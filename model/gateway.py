#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated  by generateDS.py.
# Python 3.8.5 (default, Jan 27 2021, 15:41:15)  [GCC 9.3.0]
#
# Command line options:
#   ('--user-methods', 'gateway_user_methods')
#   ('--export', 'etree literal')
#   ('--use-getter-setter', 'new')
#   ('--no-dates', '')
#   ('--no-versions', '')
#   ('-f', '')
#   ('-o', 'gateway.py')
#
# Command line arguments:
#   gateway.xsd
#
# Command line:
#   /usr/local/bin/generateDS --user-methods="gateway_user_methods" --export="etree literal" --use-getter-setter="new" --no-dates --no-versions -f -o "gateway.py" gateway.xsd
#
# Current working directory (os.getcwd()):
#   model
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class STATUSType(object):
    VERIFIED='VERIFIED'
    UNVERIFIED='UNVERIFIED'


class STOREDCREDENTIALTXTYPE(object):
    FIRST_TXN='FIRST_TXN'
    SUBSEQUENT_MERCHANT_INITIATED_TXN='SUBSEQUENT_MERCHANT_INITIATED_TXN'
    SUBSEQUENT_CARDHOLDER_INITIATED_TXN='SUBSEQUENT_CARDHOLDER_INITIATED_TXN'


class STOREDCREDENTIALUSE(object):
    UNSCHEDULED='UNSCHEDULED'
    INSTALLMENT='INSTALLMENT'
    RECURRING='RECURRING'


class TRANSACTION_TYPEType(object):
    SALE='SALE'
    REFUND='REFUND'
    PREAUTH='PREAUTH'
    COMPLETION='COMPLETION'


class TYPEType(object):
    STRING='STRING'
    NUMERIC='NUMERIC'
    BOOLEAN='BOOLEAN'


class empty(object):
    _=''


class ORDERID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ORDERID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ORDERID.subclass:
            return ORDERID.subclass(*args_, **kwargs_)
        else:
            return ORDERID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ORDERID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ORDERID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ORDERID


class TERMINALID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TERMINALID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TERMINALID.subclass:
            return TERMINALID.subclass(*args_, **kwargs_)
        else:
            return TERMINALID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TERMINALID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TERMINALID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TERMINALID


class DATETIME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATETIME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATETIME.subclass:
            return DATETIME.subclass(*args_, **kwargs_)
        else:
            return DATETIME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DATETIME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DATETIME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DATETIME


class CREATIONDATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CREATIONDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CREATIONDATE.subclass:
            return CREATIONDATE.subclass(*args_, **kwargs_)
        else:
            return CREATIONDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CREATIONDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CREATIONDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CREATIONDATE


class TRACKDATA(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRACKDATA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRACKDATA.subclass:
            return TRACKDATA.subclass(*args_, **kwargs_)
        else:
            return TRACKDATA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TRACKDATA', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TRACKDATA'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TRACKDATA


class APPLEPAYLOAD(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, APPLEPAYLOAD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if APPLEPAYLOAD.subclass:
            return APPLEPAYLOAD.subclass(*args_, **kwargs_)
        else:
            return APPLEPAYLOAD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='APPLEPAYLOAD', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='APPLEPAYLOAD'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class APPLEPAYLOAD


class ANDROIDPAYLOAD(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANDROIDPAYLOAD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANDROIDPAYLOAD.subclass:
            return ANDROIDPAYLOAD.subclass(*args_, **kwargs_)
        else:
            return ANDROIDPAYLOAD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ANDROIDPAYLOAD', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ANDROIDPAYLOAD'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ANDROIDPAYLOAD


class GOOGLEPAYLOAD(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GOOGLEPAYLOAD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GOOGLEPAYLOAD.subclass:
            return GOOGLEPAYLOAD.subclass(*args_, **kwargs_)
        else:
            return GOOGLEPAYLOAD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='GOOGLEPAYLOAD', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GOOGLEPAYLOAD'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GOOGLEPAYLOAD


class CARDNUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDNUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDNUMBER.subclass:
            return CARDNUMBER.subclass(*args_, **kwargs_)
        else:
            return CARDNUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDNUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDNUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CARDNUMBER


class MASKEDCARDNUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MASKEDCARDNUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MASKEDCARDNUMBER.subclass:
            return MASKEDCARDNUMBER.subclass(*args_, **kwargs_)
        else:
            return MASKEDCARDNUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MASKEDCARDNUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MASKEDCARDNUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MASKEDCARDNUMBER


class CREDENTIALONFILE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('BRANDTXIDENTIFIER', ['BRANDTXIDENTIFIER', 'xs:string'], 0, 1, {'name': 'BRANDTXIDENTIFIER', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('ORIGINALBRANDTXIDENTIFIER', ['BRANDTXIDENTIFIER', 'xs:string'], 0, 1, {'name': 'ORIGINALBRANDTXIDENTIFIER', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('STOREDCREDENTIALTXTYPE', ['STOREDCREDENTIALTXTYPE', 'xs:string'], 0, 1, {'name': 'STOREDCREDENTIALTXTYPE', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('STOREDCREDENTIALUSE', ['STOREDCREDENTIALUSE', 'xs:string'], 0, 1, {'name': 'STOREDCREDENTIALUSE', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, BRANDTXIDENTIFIER=None, ORIGINALBRANDTXIDENTIFIER=None, STOREDCREDENTIALTXTYPE=None, STOREDCREDENTIALUSE=None):
        self.original_tagname_ = None
        self.BRANDTXIDENTIFIER = BRANDTXIDENTIFIER
        self.validate_BRANDTXIDENTIFIER(self.BRANDTXIDENTIFIER)
        self.ORIGINALBRANDTXIDENTIFIER = ORIGINALBRANDTXIDENTIFIER
        self.validate_BRANDTXIDENTIFIER(self.ORIGINALBRANDTXIDENTIFIER)
        self.STOREDCREDENTIALTXTYPE = STOREDCREDENTIALTXTYPE
        self.validate_STOREDCREDENTIALTXTYPE(self.STOREDCREDENTIALTXTYPE)
        self.STOREDCREDENTIALUSE = STOREDCREDENTIALUSE
        self.validate_STOREDCREDENTIALUSE(self.STOREDCREDENTIALUSE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CREDENTIALONFILE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CREDENTIALONFILE.subclass:
            return CREDENTIALONFILE.subclass(*args_, **kwargs_)
        else:
            return CREDENTIALONFILE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BRANDTXIDENTIFIER(self): return self.BRANDTXIDENTIFIER
    def set_BRANDTXIDENTIFIER(self, BRANDTXIDENTIFIER): self.BRANDTXIDENTIFIER = BRANDTXIDENTIFIER
    def get_ORIGINALBRANDTXIDENTIFIER(self): return self.ORIGINALBRANDTXIDENTIFIER
    def set_ORIGINALBRANDTXIDENTIFIER(self, ORIGINALBRANDTXIDENTIFIER): self.ORIGINALBRANDTXIDENTIFIER = ORIGINALBRANDTXIDENTIFIER
    def get_STOREDCREDENTIALTXTYPE(self): return self.STOREDCREDENTIALTXTYPE
    def set_STOREDCREDENTIALTXTYPE(self, STOREDCREDENTIALTXTYPE): self.STOREDCREDENTIALTXTYPE = STOREDCREDENTIALTXTYPE
    def get_STOREDCREDENTIALUSE(self): return self.STOREDCREDENTIALUSE
    def set_STOREDCREDENTIALUSE(self, STOREDCREDENTIALUSE): self.STOREDCREDENTIALUSE = STOREDCREDENTIALUSE
    def validate_BRANDTXIDENTIFIER(self, value):
        # Validate type BRANDTXIDENTIFIER, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on BRANDTXIDENTIFIER' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BRANDTXIDENTIFIER' % {"value" : value.encode("utf-8")} )
    def validate_STOREDCREDENTIALTXTYPE(self, value):
        # Validate type STOREDCREDENTIALTXTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FIRST_TXN', 'SUBSEQUENT_MERCHANT_INITIATED_TXN', 'SUBSEQUENT_CARDHOLDER_INITIATED_TXN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on STOREDCREDENTIALTXTYPE' % {"value" : value.encode("utf-8")} )
    def validate_STOREDCREDENTIALUSE(self, value):
        # Validate type STOREDCREDENTIALUSE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['UNSCHEDULED', 'INSTALLMENT', 'RECURRING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on STOREDCREDENTIALUSE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.BRANDTXIDENTIFIER is not None or
            self.ORIGINALBRANDTXIDENTIFIER is not None or
            self.STOREDCREDENTIALTXTYPE is not None or
            self.STOREDCREDENTIALUSE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CREDENTIALONFILE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.BRANDTXIDENTIFIER is not None:
            BRANDTXIDENTIFIER_ = self.BRANDTXIDENTIFIER
            etree_.SubElement(element, '{}BRANDTXIDENTIFIER').text = self.gds_format_string(BRANDTXIDENTIFIER_)
        if self.ORIGINALBRANDTXIDENTIFIER is not None:
            ORIGINALBRANDTXIDENTIFIER_ = self.ORIGINALBRANDTXIDENTIFIER
            etree_.SubElement(element, '{}ORIGINALBRANDTXIDENTIFIER').text = self.gds_format_string(ORIGINALBRANDTXIDENTIFIER_)
        if self.STOREDCREDENTIALTXTYPE is not None:
            STOREDCREDENTIALTXTYPE_ = self.STOREDCREDENTIALTXTYPE
            etree_.SubElement(element, '{}STOREDCREDENTIALTXTYPE').text = self.gds_format_string(STOREDCREDENTIALTXTYPE_)
        if self.STOREDCREDENTIALUSE is not None:
            STOREDCREDENTIALUSE_ = self.STOREDCREDENTIALUSE
            etree_.SubElement(element, '{}STOREDCREDENTIALUSE').text = self.gds_format_string(STOREDCREDENTIALUSE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CREDENTIALONFILE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BRANDTXIDENTIFIER is not None:
            showIndent(outfile, level)
            outfile.write('BRANDTXIDENTIFIER=%s,\n' % self.gds_encode(quote_python(self.BRANDTXIDENTIFIER)))
        if self.ORIGINALBRANDTXIDENTIFIER is not None:
            showIndent(outfile, level)
            outfile.write('ORIGINALBRANDTXIDENTIFIER=%s,\n' % self.gds_encode(quote_python(self.ORIGINALBRANDTXIDENTIFIER)))
        if self.STOREDCREDENTIALTXTYPE is not None:
            showIndent(outfile, level)
            outfile.write('STOREDCREDENTIALTXTYPE=%s,\n' % self.gds_encode(quote_python(self.STOREDCREDENTIALTXTYPE)))
        if self.STOREDCREDENTIALUSE is not None:
            showIndent(outfile, level)
            outfile.write('STOREDCREDENTIALUSE=%s,\n' % self.gds_encode(quote_python(self.STOREDCREDENTIALUSE)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BRANDTXIDENTIFIER':
            BRANDTXIDENTIFIER_ = child_.text
            BRANDTXIDENTIFIER_ = self.gds_validate_string(BRANDTXIDENTIFIER_, node, 'BRANDTXIDENTIFIER')
            self.BRANDTXIDENTIFIER = BRANDTXIDENTIFIER_
            # validate type BRANDTXIDENTIFIER
            self.validate_BRANDTXIDENTIFIER(self.BRANDTXIDENTIFIER)
        elif nodeName_ == 'ORIGINALBRANDTXIDENTIFIER':
            ORIGINALBRANDTXIDENTIFIER_ = child_.text
            ORIGINALBRANDTXIDENTIFIER_ = self.gds_validate_string(ORIGINALBRANDTXIDENTIFIER_, node, 'ORIGINALBRANDTXIDENTIFIER')
            self.ORIGINALBRANDTXIDENTIFIER = ORIGINALBRANDTXIDENTIFIER_
            # validate type BRANDTXIDENTIFIER
            self.validate_BRANDTXIDENTIFIER(self.ORIGINALBRANDTXIDENTIFIER)
        elif nodeName_ == 'STOREDCREDENTIALTXTYPE':
            STOREDCREDENTIALTXTYPE_ = child_.text
            STOREDCREDENTIALTXTYPE_ = self.gds_validate_string(STOREDCREDENTIALTXTYPE_, node, 'STOREDCREDENTIALTXTYPE')
            self.STOREDCREDENTIALTXTYPE = STOREDCREDENTIALTXTYPE_
            # validate type STOREDCREDENTIALTXTYPE
            self.validate_STOREDCREDENTIALTXTYPE(self.STOREDCREDENTIALTXTYPE)
        elif nodeName_ == 'STOREDCREDENTIALUSE':
            STOREDCREDENTIALUSE_ = child_.text
            STOREDCREDENTIALUSE_ = self.gds_validate_string(STOREDCREDENTIALUSE_, node, 'STOREDCREDENTIALUSE')
            self.STOREDCREDENTIALUSE = STOREDCREDENTIALUSE_
            # validate type STOREDCREDENTIALUSE
            self.validate_STOREDCREDENTIALUSE(self.STOREDCREDENTIALUSE)
# end class CREDENTIALONFILE


class ENCRYPTEDTRACK(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENCRYPTEDTRACK)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENCRYPTEDTRACK.subclass:
            return ENCRYPTEDTRACK.subclass(*args_, **kwargs_)
        else:
            return ENCRYPTEDTRACK(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ENCRYPTEDTRACK', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ENCRYPTEDTRACK'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ENCRYPTEDTRACK


class KSN(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KSN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KSN.subclass:
            return KSN.subclass(*args_, **kwargs_)
        else:
            return KSN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='KSN', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='KSN'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class KSN


class FORMATID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FORMATID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FORMATID.subclass:
            return FORMATID.subclass(*args_, **kwargs_)
        else:
            return FORMATID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FORMATID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FORMATID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FORMATID


class PAYLOAD(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAYLOAD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAYLOAD.subclass:
            return PAYLOAD.subclass(*args_, **kwargs_)
        else:
            return PAYLOAD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAYLOAD', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAYLOAD'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PAYLOAD


class POSDEVICE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POSDEVICE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POSDEVICE.subclass:
            return POSDEVICE.subclass(*args_, **kwargs_)
        else:
            return POSDEVICE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='POSDEVICE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='POSDEVICE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class POSDEVICE


class CARDTYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDTYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDTYPE.subclass:
            return CARDTYPE.subclass(*args_, **kwargs_)
        else:
            return CARDTYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDTYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDTYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CARDTYPE


class CARDEXPIRY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDEXPIRY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDEXPIRY.subclass:
            return CARDEXPIRY.subclass(*args_, **kwargs_)
        else:
            return CARDEXPIRY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDEXPIRY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDEXPIRY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CARDEXPIRY


class CARDHOLDERNAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDHOLDERNAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDHOLDERNAME.subclass:
            return CARDHOLDERNAME.subclass(*args_, **kwargs_)
        else:
            return CARDHOLDERNAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDHOLDERNAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDHOLDERNAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CARDHOLDERNAME


class ACCOUNT_NAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACCOUNT_NAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACCOUNT_NAME.subclass:
            return ACCOUNT_NAME.subclass(*args_, **kwargs_)
        else:
            return ACCOUNT_NAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACCOUNT_NAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACCOUNT_NAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACCOUNT_NAME


class HASH(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HASH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HASH.subclass:
            return HASH.subclass(*args_, **kwargs_)
        else:
            return HASH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='HASH', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='HASH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HASH


class CURRENCY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CURRENCY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CURRENCY.subclass:
            return CURRENCY.subclass(*args_, **kwargs_)
        else:
            return CURRENCY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CURRENCY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CURRENCY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CURRENCY


class AUTOREADY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AUTOREADY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AUTOREADY.subclass:
            return AUTOREADY.subclass(*args_, **kwargs_)
        else:
            return AUTOREADY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AUTOREADY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AUTOREADY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AUTOREADY


class EMAIL(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EMAIL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EMAIL.subclass:
            return EMAIL.subclass(*args_, **kwargs_)
        else:
            return EMAIL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='EMAIL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='EMAIL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EMAIL


class CVV(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CVV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CVV.subclass:
            return CVV.subclass(*args_, **kwargs_)
        else:
            return CVV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CVV', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CVV'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CVV


class ISSUENO(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISSUENO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISSUENO.subclass:
            return ISSUENO.subclass(*args_, **kwargs_)
        else:
            return ISSUENO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ISSUENO', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ISSUENO'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ISSUENO


class ADDRESS1(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDRESS1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDRESS1.subclass:
            return ADDRESS1.subclass(*args_, **kwargs_)
        else:
            return ADDRESS1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDRESS1', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDRESS1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ADDRESS1


class ADDRESS2(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDRESS2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDRESS2.subclass:
            return ADDRESS2.subclass(*args_, **kwargs_)
        else:
            return ADDRESS2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDRESS2', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDRESS2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ADDRESS2


class POSTCODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POSTCODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POSTCODE.subclass:
            return POSTCODE.subclass(*args_, **kwargs_)
        else:
            return POSTCODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='POSTCODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='POSTCODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class POSTCODE


class BILLTOFIRSTNAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BILLTOFIRSTNAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BILLTOFIRSTNAME.subclass:
            return BILLTOFIRSTNAME.subclass(*args_, **kwargs_)
        else:
            return BILLTOFIRSTNAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BILLTOFIRSTNAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BILLTOFIRSTNAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BILLTOFIRSTNAME


class BILLTOLASTNAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BILLTOLASTNAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BILLTOLASTNAME.subclass:
            return BILLTOLASTNAME.subclass(*args_, **kwargs_)
        else:
            return BILLTOLASTNAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BILLTOLASTNAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BILLTOLASTNAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BILLTOLASTNAME


class AVSONLY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AVSONLY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AVSONLY.subclass:
            return AVSONLY.subclass(*args_, **kwargs_)
        else:
            return AVSONLY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AVSONLY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AVSONLY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AVSONLY


class DESCRIPTION(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DESCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DESCRIPTION.subclass:
            return DESCRIPTION.subclass(*args_, **kwargs_)
        else:
            return DESCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DESCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DESCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DESCRIPTION


class XID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XID.subclass:
            return XID.subclass(*args_, **kwargs_)
        else:
            return XID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='XID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='XID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class XID


class CAVV(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CAVV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CAVV.subclass:
            return CAVV.subclass(*args_, **kwargs_)
        else:
            return CAVV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CAVV', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CAVV'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CAVV


class THREEDS_PROTOCOL_VERSION(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, THREEDS_PROTOCOL_VERSION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if THREEDS_PROTOCOL_VERSION.subclass:
            return THREEDS_PROTOCOL_VERSION.subclass(*args_, **kwargs_)
        else:
            return THREEDS_PROTOCOL_VERSION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='THREEDS_PROTOCOL_VERSION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='THREEDS_PROTOCOL_VERSION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class THREEDS_PROTOCOL_VERSION


class DS_TRANS_ID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DS_TRANS_ID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DS_TRANS_ID.subclass:
            return DS_TRANS_ID.subclass(*args_, **kwargs_)
        else:
            return DS_TRANS_ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DS_TRANS_ID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DS_TRANS_ID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DS_TRANS_ID


class MPIREF(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MPIREF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MPIREF.subclass:
            return MPIREF.subclass(*args_, **kwargs_)
        else:
            return MPIREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MPIREF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MPIREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MPIREF


class MERCHANTREF(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MERCHANTREF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MERCHANTREF.subclass:
            return MERCHANTREF.subclass(*args_, **kwargs_)
        else:
            return MERCHANTREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MERCHANTREF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MERCHANTREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MERCHANTREF


class CARDREFERENCE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDREFERENCE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDREFERENCE.subclass:
            return CARDREFERENCE.subclass(*args_, **kwargs_)
        else:
            return CARDREFERENCE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDREFERENCE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDREFERENCE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CARDREFERENCE


class MOBILENUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MOBILENUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MOBILENUMBER.subclass:
            return MOBILENUMBER.subclass(*args_, **kwargs_)
        else:
            return MOBILENUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MOBILENUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MOBILENUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MOBILENUMBER


class TERMINALTYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TERMINALTYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TERMINALTYPE.subclass:
            return TERMINALTYPE.subclass(*args_, **kwargs_)
        else:
            return TERMINALTYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TERMINALTYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TERMINALTYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TERMINALTYPE


class TRANSACTIONTYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRANSACTIONTYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRANSACTIONTYPE.subclass:
            return TRANSACTIONTYPE.subclass(*args_, **kwargs_)
        else:
            return TRANSACTIONTYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TRANSACTIONTYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TRANSACTIONTYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TRANSACTIONTYPE


class DEVICEID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DEVICEID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DEVICEID.subclass:
            return DEVICEID.subclass(*args_, **kwargs_)
        else:
            return DEVICEID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DEVICEID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DEVICEID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DEVICEID


class PHONE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PHONE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PHONE.subclass:
            return PHONE.subclass(*args_, **kwargs_)
        else:
            return PHONE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PHONE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PHONE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PHONE


class COUNTRY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COUNTRY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COUNTRY.subclass:
            return COUNTRY.subclass(*args_, **kwargs_)
        else:
            return COUNTRY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='COUNTRY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='COUNTRY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class COUNTRY


class CITY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CITY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CITY.subclass:
            return CITY.subclass(*args_, **kwargs_)
        else:
            return CITY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CITY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CITY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CITY


class REGION(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REGION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REGION.subclass:
            return REGION.subclass(*args_, **kwargs_)
        else:
            return REGION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='REGION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='REGION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class REGION


class IPADDRESS(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPADDRESS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPADDRESS.subclass:
            return IPADDRESS.subclass(*args_, **kwargs_)
        else:
            return IPADDRESS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='IPADDRESS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='IPADDRESS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IPADDRESS


class DECLINEDREFUNDORDERID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DECLINEDREFUNDORDERID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DECLINEDREFUNDORDERID.subclass:
            return DECLINEDREFUNDORDERID.subclass(*args_, **kwargs_)
        else:
            return DECLINEDREFUNDORDERID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DECLINEDREFUNDORDERID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DECLINEDREFUNDORDERID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DECLINEDREFUNDORDERID


class SIGNATURE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SIGNATURE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SIGNATURE.subclass:
            return SIGNATURE.subclass(*args_, **kwargs_)
        else:
            return SIGNATURE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SIGNATURE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SIGNATURE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SIGNATURE


class CUSTOMFIELD(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('NAME', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, NAME=None, valueOf_=None):
        self.original_tagname_ = None
        self.NAME = _cast(None, NAME)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CUSTOMFIELD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CUSTOMFIELD.subclass:
            return CUSTOMFIELD.subclass(*args_, **kwargs_)
        else:
            return CUSTOMFIELD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CUSTOMFIELD', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.NAME is not None:
            element.set('NAME', self.gds_format_string(self.NAME))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CUSTOMFIELD'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            showIndent(outfile, level)
            outfile.write('NAME="%s",\n' % (self.NAME,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NAME', node)
        if value is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            self.NAME = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CUSTOMFIELD


class ADDITIONAL_FIELD(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('NAME', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, NAME=None, valueOf_=None):
        self.original_tagname_ = None
        self.NAME = _cast(None, NAME)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDITIONAL_FIELD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDITIONAL_FIELD.subclass:
            return ADDITIONAL_FIELD.subclass(*args_, **kwargs_)
        else:
            return ADDITIONAL_FIELD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDITIONAL_FIELD', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.NAME is not None:
            element.set('NAME', self.gds_format_string(self.NAME))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDITIONAL_FIELD'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            showIndent(outfile, level)
            outfile.write('NAME="%s",\n' % (self.NAME,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NAME', node)
        if value is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            self.NAME = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ADDITIONAL_FIELD


class FRAUDREVIEWSESSIONID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FRAUDREVIEWSESSIONID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FRAUDREVIEWSESSIONID.subclass:
            return FRAUDREVIEWSESSIONID.subclass(*args_, **kwargs_)
        else:
            return FRAUDREVIEWSESSIONID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FRAUDREVIEWSESSIONID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FRAUDREVIEWSESSIONID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FRAUDREVIEWSESSIONID


class FRAUDREVIEWSTATUS(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FRAUDREVIEWSTATUS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FRAUDREVIEWSTATUS.subclass:
            return FRAUDREVIEWSTATUS.subclass(*args_, **kwargs_)
        else:
            return FRAUDREVIEWSTATUS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FRAUDREVIEWSTATUS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FRAUDREVIEWSTATUS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FRAUDREVIEWSTATUS


class FRAUDREVIEWSCORE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FRAUDREVIEWSCORE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FRAUDREVIEWSCORE.subclass:
            return FRAUDREVIEWSCORE.subclass(*args_, **kwargs_)
        else:
            return FRAUDREVIEWSCORE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FRAUDREVIEWSCORE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FRAUDREVIEWSCORE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FRAUDREVIEWSCORE


class FRAUDREVIEWREASONCODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FRAUDREVIEWREASONCODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FRAUDREVIEWREASONCODE.subclass:
            return FRAUDREVIEWREASONCODE.subclass(*args_, **kwargs_)
        else:
            return FRAUDREVIEWREASONCODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FRAUDREVIEWREASONCODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FRAUDREVIEWREASONCODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FRAUDREVIEWREASONCODE


class FRAUDREVIEWRISKRATING(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FRAUDREVIEWRISKRATING)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FRAUDREVIEWRISKRATING.subclass:
            return FRAUDREVIEWRISKRATING.subclass(*args_, **kwargs_)
        else:
            return FRAUDREVIEWRISKRATING(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FRAUDREVIEWRISKRATING', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FRAUDREVIEWRISKRATING'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FRAUDREVIEWRISKRATING


class LEVEL_2_DATA(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('CUSTOMER_REF_NUMBER', ['CUSTOMER_REF_NUMBERType', 'xs:string'], 0, 1, {'name': 'CUSTOMER_REF_NUMBER', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('TAX_AMOUNT', 'emptyDecimalAllowed', 0, 1, {'name': 'TAX_AMOUNT', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('SHIPPING_ADDRESS', 'SHIPPING_ADDRESSType', 0, 1, {'name': 'SHIPPING_ADDRESS', 'minOccurs': '0', 'type': 'SHIPPING_ADDRESSType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CUSTOMER_REF_NUMBER=None, TAX_AMOUNT=None, SHIPPING_ADDRESS=None):
        self.original_tagname_ = None
        self.CUSTOMER_REF_NUMBER = CUSTOMER_REF_NUMBER
        self.validate_CUSTOMER_REF_NUMBERType(self.CUSTOMER_REF_NUMBER)
        self.TAX_AMOUNT = TAX_AMOUNT
        self.validate_emptyDecimalAllowed(self.TAX_AMOUNT)
        self.SHIPPING_ADDRESS = SHIPPING_ADDRESS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LEVEL_2_DATA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LEVEL_2_DATA.subclass:
            return LEVEL_2_DATA.subclass(*args_, **kwargs_)
        else:
            return LEVEL_2_DATA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CUSTOMER_REF_NUMBER(self): return self.CUSTOMER_REF_NUMBER
    def set_CUSTOMER_REF_NUMBER(self, CUSTOMER_REF_NUMBER): self.CUSTOMER_REF_NUMBER = CUSTOMER_REF_NUMBER
    def get_TAX_AMOUNT(self): return self.TAX_AMOUNT
    def set_TAX_AMOUNT(self, TAX_AMOUNT): self.TAX_AMOUNT = TAX_AMOUNT
    def get_SHIPPING_ADDRESS(self): return self.SHIPPING_ADDRESS
    def set_SHIPPING_ADDRESS(self, SHIPPING_ADDRESS): self.SHIPPING_ADDRESS = SHIPPING_ADDRESS
    def validate_CUSTOMER_REF_NUMBERType(self, value):
        # Validate type CUSTOMER_REF_NUMBERType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 48:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CUSTOMER_REF_NUMBERType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CUSTOMER_REF_NUMBERType' % {"value" : value.encode("utf-8")} )
    def validate_emptyDecimalAllowed(self, value):
        # Validate type emptyDecimalAllowed, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.CUSTOMER_REF_NUMBER is not None or
            self.TAX_AMOUNT is not None or
            self.SHIPPING_ADDRESS is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LEVEL_2_DATA', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.CUSTOMER_REF_NUMBER is not None:
            CUSTOMER_REF_NUMBER_ = self.CUSTOMER_REF_NUMBER
            etree_.SubElement(element, '{}CUSTOMER_REF_NUMBER').text = self.gds_format_string(CUSTOMER_REF_NUMBER_)
        if self.TAX_AMOUNT is not None:
            TAX_AMOUNT_ = self.TAX_AMOUNT
            etree_.SubElement(element, '{}TAX_AMOUNT').text = self.gds_format_string(TAX_AMOUNT_)
        if self.SHIPPING_ADDRESS is not None:
            SHIPPING_ADDRESS_ = self.SHIPPING_ADDRESS
            SHIPPING_ADDRESS_.to_etree(element, name_='SHIPPING_ADDRESS', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LEVEL_2_DATA'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CUSTOMER_REF_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CUSTOMER_REF_NUMBER=%s,\n' % self.gds_encode(quote_python(self.CUSTOMER_REF_NUMBER)))
        if self.TAX_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TAX_AMOUNT=%s,\n' % self.gds_encode(quote_python(self.TAX_AMOUNT)))
        if self.SHIPPING_ADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('SHIPPING_ADDRESS=model_.SHIPPING_ADDRESSType(\n')
            self.SHIPPING_ADDRESS.exportLiteral(outfile, level, name_='SHIPPING_ADDRESS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CUSTOMER_REF_NUMBER':
            CUSTOMER_REF_NUMBER_ = child_.text
            CUSTOMER_REF_NUMBER_ = self.gds_validate_string(CUSTOMER_REF_NUMBER_, node, 'CUSTOMER_REF_NUMBER')
            self.CUSTOMER_REF_NUMBER = CUSTOMER_REF_NUMBER_
            # validate type CUSTOMER_REF_NUMBERType
            self.validate_CUSTOMER_REF_NUMBERType(self.CUSTOMER_REF_NUMBER)
        elif nodeName_ == 'TAX_AMOUNT':
            TAX_AMOUNT_ = child_.text
            TAX_AMOUNT_ = self.gds_validate_string(TAX_AMOUNT_, node, 'TAX_AMOUNT')
            self.TAX_AMOUNT = TAX_AMOUNT_
            # validate type emptyDecimalAllowed
            self.validate_emptyDecimalAllowed(self.TAX_AMOUNT)
        elif nodeName_ == 'SHIPPING_ADDRESS':
            obj_ = SHIPPING_ADDRESSType.factory()
            obj_.build(child_)
            self.SHIPPING_ADDRESS = obj_
            obj_.original_tagname_ = 'SHIPPING_ADDRESS'


    @property
    def hash_string(self):
        hash_list = [self.CUSTOMER_REF_NUMBER, self.TAX_AMOUNT]
        if self.SHIPPING_ADDRESS:
            hash_list.append(self.SHIPPING_ADDRESS.hash_string)
        return ':'.join(hash_list)
# end class LEVEL_2_DATA


class LEVEL_3_DATA(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('SUMMARY', 'SUMMARYType', 0, 1, {'name': 'SUMMARY', 'minOccurs': '0', 'type': 'SUMMARYType'}, None),
        MemberSpec_('LINE_ITEMS', 'LINE_ITEMSType', 0, 1, {'name': 'LINE_ITEMS', 'minOccurs': '0', 'type': 'LINE_ITEMSType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, SUMMARY=None, LINE_ITEMS=None):
        self.original_tagname_ = None
        self.SUMMARY = SUMMARY
        self.LINE_ITEMS = LINE_ITEMS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LEVEL_3_DATA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LEVEL_3_DATA.subclass:
            return LEVEL_3_DATA.subclass(*args_, **kwargs_)
        else:
            return LEVEL_3_DATA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SUMMARY(self): return self.SUMMARY
    def set_SUMMARY(self, SUMMARY): self.SUMMARY = SUMMARY
    def get_LINE_ITEMS(self): return self.LINE_ITEMS
    def set_LINE_ITEMS(self, LINE_ITEMS): self.LINE_ITEMS = LINE_ITEMS
    def hasContent_(self):
        if (
            self.SUMMARY is not None or
            self.LINE_ITEMS is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LEVEL_3_DATA', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.SUMMARY is not None:
            SUMMARY_ = self.SUMMARY
            SUMMARY_.to_etree(element, name_='SUMMARY', mapping_=mapping_)
        if self.LINE_ITEMS is not None:
            LINE_ITEMS_ = self.LINE_ITEMS
            LINE_ITEMS_.to_etree(element, name_='LINE_ITEMS', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LEVEL_3_DATA'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SUMMARY is not None:
            showIndent(outfile, level)
            outfile.write('SUMMARY=model_.SUMMARYType(\n')
            self.SUMMARY.exportLiteral(outfile, level, name_='SUMMARY')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LINE_ITEMS is not None:
            showIndent(outfile, level)
            outfile.write('LINE_ITEMS=model_.LINE_ITEMSType(\n')
            self.LINE_ITEMS.exportLiteral(outfile, level, name_='LINE_ITEMS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SUMMARY':
            obj_ = SUMMARYType.factory()
            obj_.build(child_)
            self.SUMMARY = obj_
            obj_.original_tagname_ = 'SUMMARY'
        elif nodeName_ == 'LINE_ITEMS':
            obj_ = LINE_ITEMSType.factory()
            obj_.build(child_)
            self.LINE_ITEMS = obj_
            obj_.original_tagname_ = 'LINE_ITEMS'
# end class LEVEL_3_DATA


class ACCOUNT_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACCOUNT_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACCOUNT_NUMBER.subclass:
            return ACCOUNT_NUMBER.subclass(*args_, **kwargs_)
        else:
            return ACCOUNT_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACCOUNT_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACCOUNT_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACCOUNT_NUMBER


class ACCOUNT_TYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACCOUNT_TYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACCOUNT_TYPE.subclass:
            return ACCOUNT_TYPE.subclass(*args_, **kwargs_)
        else:
            return ACCOUNT_TYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACCOUNT_TYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACCOUNT_TYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACCOUNT_TYPE


class SEC_CODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SEC_CODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SEC_CODE.subclass:
            return SEC_CODE.subclass(*args_, **kwargs_)
        else:
            return SEC_CODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SEC_CODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SEC_CODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SEC_CODE


class ROUTING_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ROUTING_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ROUTING_NUMBER.subclass:
            return ROUTING_NUMBER.subclass(*args_, **kwargs_)
        else:
            return ROUTING_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ROUTING_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ROUTING_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ROUTING_NUMBER


class BSB_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BSB_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BSB_NUMBER.subclass:
            return BSB_NUMBER.subclass(*args_, **kwargs_)
        else:
            return BSB_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BSB_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BSB_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BSB_NUMBER


class DEBIT_DATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DEBIT_DATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DEBIT_DATE.subclass:
            return DEBIT_DATE.subclass(*args_, **kwargs_)
        else:
            return DEBIT_DATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DEBIT_DATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DEBIT_DATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DEBIT_DATE


class CHECK_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CHECK_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CHECK_NUMBER.subclass:
            return CHECK_NUMBER.subclass(*args_, **kwargs_)
        else:
            return CHECK_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CHECK_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CHECK_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CHECK_NUMBER


class DL_STATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DL_STATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DL_STATE.subclass:
            return DL_STATE.subclass(*args_, **kwargs_)
        else:
            return DL_STATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DL_STATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DL_STATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DL_STATE


class DL_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DL_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DL_NUMBER.subclass:
            return DL_NUMBER.subclass(*args_, **kwargs_)
        else:
            return DL_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DL_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DL_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DL_NUMBER


class ENHANCED_DATA_TEMPLATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENHANCED_DATA_TEMPLATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENHANCED_DATA_TEMPLATE.subclass:
            return ENHANCED_DATA_TEMPLATE.subclass(*args_, **kwargs_)
        else:
            return ENHANCED_DATA_TEMPLATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ENHANCED_DATA_TEMPLATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ENHANCED_DATA_TEMPLATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ENHANCED_DATA_TEMPLATE


class PAYMENT(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('TRACKDATA', ['TRACKDATA', 'xs:string'], 0, 0, {'ref': 'TRACKDATA', 'name': 'TRACKDATA', 'type': 'xs:string'}, 1),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 0, {'ref': 'CARDNUMBER', 'name': 'CARDNUMBER', 'type': 'xs:string'}, 1),
        MemberSpec_('DUKPTCARDDETAILS', 'DUKPTCARDDETAILS', 0, 0, {'ref': 'DUKPTCARDDETAILS', 'name': 'DUKPTCARDDETAILS', 'type': 'DUKPTCARDDETAILS'}, 1),
        MemberSpec_('APPLEPAYLOAD', ['APPLEPAYLOAD', 'xs:string'], 0, 0, {'ref': 'APPLEPAYLOAD', 'name': 'APPLEPAYLOAD', 'type': 'xs:string'}, 1),
        MemberSpec_('ANDROIDPAYLOAD', ['ANDROIDPAYLOAD', 'xs:string'], 0, 0, {'ref': 'ANDROIDPAYLOAD', 'name': 'ANDROIDPAYLOAD', 'type': 'xs:string'}, 1),
        MemberSpec_('GOOGLEPAYLOAD', ['GOOGLEPAYLOAD', 'xs:string'], 0, 0, {'ref': 'GOOGLEPAYLOAD', 'name': 'GOOGLEPAYLOAD', 'type': 'xs:string'}, 1),
        MemberSpec_('ENCRYPTEDPAYLOAD', 'ENCRYPTEDPAYLOAD', 0, 0, {'ref': 'ENCRYPTEDPAYLOAD', 'name': 'ENCRYPTEDPAYLOAD', 'type': 'ENCRYPTEDPAYLOAD'}, 1),
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 0, {'ref': 'CARDTYPE', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 1, {'ref': 'CARDEXPIRY', 'minOccurs': '0', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 1, {'ref': 'CARDHOLDERNAME', 'minOccurs': '0', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('FOREIGNCURRENCYINFORMATION', 'FOREIGNCURRENCYINFORMATION', 0, 1, {'ref': 'FOREIGNCURRENCYINFORMATION', 'minOccurs': '0', 'name': 'FOREIGNCURRENCYINFORMATION', 'type': 'FOREIGNCURRENCYINFORMATION'}, None),
        MemberSpec_('TERMINALTYPE', ['TERMINALTYPE', 'xs:int'], 0, 0, {'ref': 'TERMINALTYPE', 'name': 'TERMINALTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('TRANSACTIONTYPE', ['TRANSACTIONTYPE', 'xs:int'], 0, 0, {'ref': 'TRANSACTIONTYPE', 'name': 'TRANSACTIONTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('AUTOREADY', ['AUTOREADY', 'xs:string'], 0, 1, {'ref': 'AUTOREADY', 'minOccurs': '0', 'name': 'AUTOREADY', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('CVV', ['CVV', 'xs:string'], 0, 1, {'ref': 'CVV', 'minOccurs': '0', 'name': 'CVV', 'type': 'xs:string'}, None),
        MemberSpec_('ISSUENO', ['ISSUENO', 'xs:string'], 0, 1, {'ref': 'ISSUENO', 'minOccurs': '0', 'name': 'ISSUENO', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('BILLTOFIRSTNAME', ['BILLTOFIRSTNAME', 'xs:string'], 0, 1, {'ref': 'BILLTOFIRSTNAME', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'BILLTOFIRSTNAME', 'type': 'xs:string'}, None),
        MemberSpec_('BILLTOLASTNAME', ['BILLTOLASTNAME', 'xs:string'], 0, 1, {'ref': 'BILLTOLASTNAME', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'BILLTOLASTNAME', 'type': 'xs:string'}, None),
        MemberSpec_('AVSONLY', ['AVSONLY', 'xs:string'], 0, 1, {'ref': 'AVSONLY', 'minOccurs': '0', 'name': 'AVSONLY', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('XID', ['XID', 'xs:string'], 0, 1, {'ref': 'XID', 'minOccurs': '0', 'name': 'XID', 'type': 'xs:string'}, None),
        MemberSpec_('CAVV', ['CAVV', 'xs:string'], 0, 1, {'ref': 'CAVV', 'minOccurs': '0', 'name': 'CAVV', 'type': 'xs:string'}, None),
        MemberSpec_('THREEDS_PROTOCOL_VERSION', ['THREEDS_PROTOCOL_VERSION', 'xs:integer'], 0, 1, {'ref': 'THREEDS_PROTOCOL_VERSION', 'minOccurs': '0', 'name': 'THREEDS_PROTOCOL_VERSION', 'type': 'xs:integer'}, None),
        MemberSpec_('DS_TRANS_ID', ['DS_TRANS_ID', 'xs:string'], 0, 1, {'ref': 'DS_TRANS_ID', 'minOccurs': '0', 'name': 'DS_TRANS_ID', 'type': 'xs:string'}, None),
        MemberSpec_('MPIREF', ['MPIREF', 'xs:string'], 0, 1, {'ref': 'MPIREF', 'minOccurs': '0', 'name': 'MPIREF', 'type': 'xs:string'}, None),
        MemberSpec_('MOBILENUMBER', ['MOBILENUMBER', 'xs:string'], 0, 1, {'ref': 'MOBILENUMBER', 'minOccurs': '0', 'name': 'MOBILENUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('DEVICEID', ['DEVICEID', 'xs:string'], 0, 1, {'ref': 'DEVICEID', 'minOccurs': '0', 'name': 'DEVICEID', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('IPADDRESS', ['IPADDRESS', 'xs:string'], 0, 1, {'ref': 'IPADDRESS', 'minOccurs': '0', 'name': 'IPADDRESS', 'type': 'xs:string'}, None),
        MemberSpec_('SIGNATURE', ['SIGNATURE', 'xs:string'], 0, 1, {'ref': 'SIGNATURE', 'minOccurs': '0', 'name': 'SIGNATURE', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOMFIELD', 'CUSTOMFIELD', 1, 1, {'ref': 'CUSTOMFIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'CUSTOMFIELD', 'type': 'CUSTOMFIELD'}, None),
        MemberSpec_('RECURRINGTXNREF', ['UID', 'xs:string'], 0, 1, {'name': 'RECURRINGTXNREF', 'type': 'xs:string', 'minOccurs': '0', 'maxOccurs': '1'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('LEVEL_3_DATA', 'LEVEL_3_DATA', 0, 1, {'ref': 'LEVEL_3_DATA', 'minOccurs': '0', 'name': 'LEVEL_3_DATA', 'type': 'LEVEL_3_DATA'}, None),
        MemberSpec_('ENHANCED_DATA_TEMPLATE', ['ENHANCED_DATA_TEMPLATE', 'xs:string'], 0, 1, {'ref': 'ENHANCED_DATA_TEMPLATE', 'minOccurs': '0', 'name': 'ENHANCED_DATA_TEMPLATE', 'type': 'xs:string'}, None),
        MemberSpec_('FRAUDREVIEWSESSIONID', ['FRAUDREVIEWSESSIONID', 'xs:string'], 0, 1, {'ref': 'FRAUDREVIEWSESSIONID', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'FRAUDREVIEWSESSIONID', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('BYPASS_SURCHARGE', 'xs:boolean', 0, 1, {'name': 'BYPASS_SURCHARGE', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, AMOUNT=None, DATETIME=None, TRACKDATA=None, CARDNUMBER=None, DUKPTCARDDETAILS=None, APPLEPAYLOAD=None, ANDROIDPAYLOAD=None, GOOGLEPAYLOAD=None, ENCRYPTEDPAYLOAD=None, CARDTYPE=None, CARDEXPIRY=None, CARDHOLDERNAME=None, HASH=None, CURRENCY=None, FOREIGNCURRENCYINFORMATION=None, TERMINALTYPE=None, TRANSACTIONTYPE=None, AUTOREADY=None, EMAIL=None, CVV=None, ISSUENO=None, ADDRESS1=None, ADDRESS2=None, POSTCODE=None, BILLTOFIRSTNAME=None, BILLTOLASTNAME=None, AVSONLY=None, DESCRIPTION=None, XID=None, CAVV=None, THREEDS_PROTOCOL_VERSION=None, DS_TRANS_ID=None, MPIREF=None, MOBILENUMBER=None, DEVICEID=None, PHONE=None, CITY=None, REGION=None, COUNTRY=None, IPADDRESS=None, SIGNATURE=None, CUSTOMFIELD=None, RECURRINGTXNREF=None, LEVEL_2_DATA=None, LEVEL_3_DATA=None, ENHANCED_DATA_TEMPLATE=None, FRAUDREVIEWSESSIONID=None, CREDENTIALONFILE=None, BYPASS_SURCHARGE=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.TRACKDATA = TRACKDATA
        self.validate_TRACKDATA(self.TRACKDATA)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.DUKPTCARDDETAILS = DUKPTCARDDETAILS
        self.APPLEPAYLOAD = APPLEPAYLOAD
        self.validate_APPLEPAYLOAD(self.APPLEPAYLOAD)
        self.ANDROIDPAYLOAD = ANDROIDPAYLOAD
        self.validate_ANDROIDPAYLOAD(self.ANDROIDPAYLOAD)
        self.GOOGLEPAYLOAD = GOOGLEPAYLOAD
        self.validate_GOOGLEPAYLOAD(self.GOOGLEPAYLOAD)
        self.ENCRYPTEDPAYLOAD = ENCRYPTEDPAYLOAD
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
        self.TERMINALTYPE = TERMINALTYPE
        self.validate_TERMINALTYPE(self.TERMINALTYPE)
        self.TRANSACTIONTYPE = TRANSACTIONTYPE
        self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        self.AUTOREADY = AUTOREADY
        self.validate_AUTOREADY(self.AUTOREADY)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.CVV = CVV
        self.validate_CVV(self.CVV)
        self.ISSUENO = ISSUENO
        self.validate_ISSUENO(self.ISSUENO)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.BILLTOFIRSTNAME = BILLTOFIRSTNAME
        self.validate_BILLTOFIRSTNAME(self.BILLTOFIRSTNAME)
        self.BILLTOLASTNAME = BILLTOLASTNAME
        self.validate_BILLTOLASTNAME(self.BILLTOLASTNAME)
        self.AVSONLY = AVSONLY
        self.validate_AVSONLY(self.AVSONLY)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.XID = XID
        self.validate_XID(self.XID)
        self.CAVV = CAVV
        self.validate_CAVV(self.CAVV)
        self.THREEDS_PROTOCOL_VERSION = THREEDS_PROTOCOL_VERSION
        self.validate_THREEDS_PROTOCOL_VERSION(self.THREEDS_PROTOCOL_VERSION)
        self.DS_TRANS_ID = DS_TRANS_ID
        self.validate_DS_TRANS_ID(self.DS_TRANS_ID)
        self.MPIREF = MPIREF
        self.validate_MPIREF(self.MPIREF)
        self.MOBILENUMBER = MOBILENUMBER
        self.validate_MOBILENUMBER(self.MOBILENUMBER)
        self.DEVICEID = DEVICEID
        self.validate_DEVICEID(self.DEVICEID)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.IPADDRESS = IPADDRESS
        self.validate_IPADDRESS(self.IPADDRESS)
        self.SIGNATURE = SIGNATURE
        self.validate_SIGNATURE(self.SIGNATURE)
        if CUSTOMFIELD is None:
            self.CUSTOMFIELD = []
        else:
            self.CUSTOMFIELD = CUSTOMFIELD
        self.RECURRINGTXNREF = RECURRINGTXNREF
        self.validate_UID(self.RECURRINGTXNREF)
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.LEVEL_3_DATA = LEVEL_3_DATA
        self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE
        self.validate_ENHANCED_DATA_TEMPLATE(self.ENHANCED_DATA_TEMPLATE)
        self.FRAUDREVIEWSESSIONID = FRAUDREVIEWSESSIONID
        self.validate_FRAUDREVIEWSESSIONID(self.FRAUDREVIEWSESSIONID)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.BYPASS_SURCHARGE = BYPASS_SURCHARGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAYMENT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAYMENT.subclass:
            return PAYMENT.subclass(*args_, **kwargs_)
        else:
            return PAYMENT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_TRACKDATA(self): return self.TRACKDATA
    def set_TRACKDATA(self, TRACKDATA): self.TRACKDATA = TRACKDATA
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_DUKPTCARDDETAILS(self): return self.DUKPTCARDDETAILS
    def set_DUKPTCARDDETAILS(self, DUKPTCARDDETAILS): self.DUKPTCARDDETAILS = DUKPTCARDDETAILS
    def get_APPLEPAYLOAD(self): return self.APPLEPAYLOAD
    def set_APPLEPAYLOAD(self, APPLEPAYLOAD): self.APPLEPAYLOAD = APPLEPAYLOAD
    def get_ANDROIDPAYLOAD(self): return self.ANDROIDPAYLOAD
    def set_ANDROIDPAYLOAD(self, ANDROIDPAYLOAD): self.ANDROIDPAYLOAD = ANDROIDPAYLOAD
    def get_GOOGLEPAYLOAD(self): return self.GOOGLEPAYLOAD
    def set_GOOGLEPAYLOAD(self, GOOGLEPAYLOAD): self.GOOGLEPAYLOAD = GOOGLEPAYLOAD
    def get_ENCRYPTEDPAYLOAD(self): return self.ENCRYPTEDPAYLOAD
    def set_ENCRYPTEDPAYLOAD(self, ENCRYPTEDPAYLOAD): self.ENCRYPTEDPAYLOAD = ENCRYPTEDPAYLOAD
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_FOREIGNCURRENCYINFORMATION(self): return self.FOREIGNCURRENCYINFORMATION
    def set_FOREIGNCURRENCYINFORMATION(self, FOREIGNCURRENCYINFORMATION): self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
    def get_TERMINALTYPE(self): return self.TERMINALTYPE
    def set_TERMINALTYPE(self, TERMINALTYPE): self.TERMINALTYPE = TERMINALTYPE
    def get_TRANSACTIONTYPE(self): return self.TRANSACTIONTYPE
    def set_TRANSACTIONTYPE(self, TRANSACTIONTYPE): self.TRANSACTIONTYPE = TRANSACTIONTYPE
    def get_AUTOREADY(self): return self.AUTOREADY
    def set_AUTOREADY(self, AUTOREADY): self.AUTOREADY = AUTOREADY
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_CVV(self): return self.CVV
    def set_CVV(self, CVV): self.CVV = CVV
    def get_ISSUENO(self): return self.ISSUENO
    def set_ISSUENO(self, ISSUENO): self.ISSUENO = ISSUENO
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_BILLTOFIRSTNAME(self): return self.BILLTOFIRSTNAME
    def set_BILLTOFIRSTNAME(self, BILLTOFIRSTNAME): self.BILLTOFIRSTNAME = BILLTOFIRSTNAME
    def get_BILLTOLASTNAME(self): return self.BILLTOLASTNAME
    def set_BILLTOLASTNAME(self, BILLTOLASTNAME): self.BILLTOLASTNAME = BILLTOLASTNAME
    def get_AVSONLY(self): return self.AVSONLY
    def set_AVSONLY(self, AVSONLY): self.AVSONLY = AVSONLY
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_XID(self): return self.XID
    def set_XID(self, XID): self.XID = XID
    def get_CAVV(self): return self.CAVV
    def set_CAVV(self, CAVV): self.CAVV = CAVV
    def get_THREEDS_PROTOCOL_VERSION(self): return self.THREEDS_PROTOCOL_VERSION
    def set_THREEDS_PROTOCOL_VERSION(self, THREEDS_PROTOCOL_VERSION): self.THREEDS_PROTOCOL_VERSION = THREEDS_PROTOCOL_VERSION
    def get_DS_TRANS_ID(self): return self.DS_TRANS_ID
    def set_DS_TRANS_ID(self, DS_TRANS_ID): self.DS_TRANS_ID = DS_TRANS_ID
    def get_MPIREF(self): return self.MPIREF
    def set_MPIREF(self, MPIREF): self.MPIREF = MPIREF
    def get_MOBILENUMBER(self): return self.MOBILENUMBER
    def set_MOBILENUMBER(self, MOBILENUMBER): self.MOBILENUMBER = MOBILENUMBER
    def get_DEVICEID(self): return self.DEVICEID
    def set_DEVICEID(self, DEVICEID): self.DEVICEID = DEVICEID
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_IPADDRESS(self): return self.IPADDRESS
    def set_IPADDRESS(self, IPADDRESS): self.IPADDRESS = IPADDRESS
    def get_SIGNATURE(self): return self.SIGNATURE
    def set_SIGNATURE(self, SIGNATURE): self.SIGNATURE = SIGNATURE
    def get_CUSTOMFIELD(self): return self.CUSTOMFIELD
    def set_CUSTOMFIELD(self, CUSTOMFIELD): self.CUSTOMFIELD = CUSTOMFIELD
    def add_CUSTOMFIELD(self, value): self.CUSTOMFIELD.append(value)
    def insert_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD.insert(index, value)
    def replace_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD[index] = value
    def get_RECURRINGTXNREF(self): return self.RECURRINGTXNREF
    def set_RECURRINGTXNREF(self, RECURRINGTXNREF): self.RECURRINGTXNREF = RECURRINGTXNREF
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_LEVEL_3_DATA(self): return self.LEVEL_3_DATA
    def set_LEVEL_3_DATA(self, LEVEL_3_DATA): self.LEVEL_3_DATA = LEVEL_3_DATA
    def get_ENHANCED_DATA_TEMPLATE(self): return self.ENHANCED_DATA_TEMPLATE
    def set_ENHANCED_DATA_TEMPLATE(self, ENHANCED_DATA_TEMPLATE): self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE
    def get_FRAUDREVIEWSESSIONID(self): return self.FRAUDREVIEWSESSIONID
    def set_FRAUDREVIEWSESSIONID(self, FRAUDREVIEWSESSIONID): self.FRAUDREVIEWSESSIONID = FRAUDREVIEWSESSIONID
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_BYPASS_SURCHARGE(self): return self.BYPASS_SURCHARGE
    def set_BYPASS_SURCHARGE(self, BYPASS_SURCHARGE): self.BYPASS_SURCHARGE = BYPASS_SURCHARGE
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_TRACKDATA(self, value):
        # Validate type TRACKDATA, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_APPLEPAYLOAD(self, value):
        # Validate type APPLEPAYLOAD, a restriction on xs:string.
        pass
    def validate_ANDROIDPAYLOAD(self, value):
        # Validate type ANDROIDPAYLOAD, a restriction on xs:string.
        pass
    def validate_GOOGLEPAYLOAD(self, value):
        # Validate type GOOGLEPAYLOAD, a restriction on xs:string.
        pass
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_TERMINALTYPE(self, value):
        # Validate type TERMINALTYPE, a restriction on xs:int.
        pass
    def validate_TRANSACTIONTYPE(self, value):
        # Validate type TRANSACTIONTYPE, a restriction on xs:int.
        pass
    def validate_AUTOREADY(self, value):
        # Validate type AUTOREADY, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_CVV(self, value):
        # Validate type CVV, a restriction on xs:string.
        pass
    def validate_ISSUENO(self, value):
        # Validate type ISSUENO, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_BILLTOFIRSTNAME(self, value):
        # Validate type BILLTOFIRSTNAME, a restriction on xs:string.
        pass
    def validate_BILLTOLASTNAME(self, value):
        # Validate type BILLTOLASTNAME, a restriction on xs:string.
        pass
    def validate_AVSONLY(self, value):
        # Validate type AVSONLY, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_XID(self, value):
        # Validate type XID, a restriction on xs:string.
        pass
    def validate_CAVV(self, value):
        # Validate type CAVV, a restriction on xs:string.
        pass
    def validate_THREEDS_PROTOCOL_VERSION(self, value):
        # Validate type THREEDS_PROTOCOL_VERSION, a restriction on xs:integer.
        pass
    def validate_DS_TRANS_ID(self, value):
        # Validate type DS_TRANS_ID, a restriction on xs:string.
        pass
    def validate_MPIREF(self, value):
        # Validate type MPIREF, a restriction on xs:string.
        pass
    def validate_MOBILENUMBER(self, value):
        # Validate type MOBILENUMBER, a restriction on xs:string.
        pass
    def validate_DEVICEID(self, value):
        # Validate type DEVICEID, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_IPADDRESS(self, value):
        # Validate type IPADDRESS, a restriction on xs:string.
        pass
    def validate_SIGNATURE(self, value):
        # Validate type SIGNATURE, a restriction on xs:string.
        pass
    def validate_UID(self, value):
        # Validate type UID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on UID' % {"value" : value.encode("utf-8")} )
            if len(value) < 10:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on UID' % {"value" : value.encode("utf-8")} )
    def validate_ENHANCED_DATA_TEMPLATE(self, value):
        # Validate type ENHANCED_DATA_TEMPLATE, a restriction on xs:string.
        pass
    def validate_FRAUDREVIEWSESSIONID(self, value):
        # Validate type FRAUDREVIEWSESSIONID, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.DATETIME is not None or
            self.TRACKDATA is not None or
            self.CARDNUMBER is not None or
            self.DUKPTCARDDETAILS is not None or
            self.APPLEPAYLOAD is not None or
            self.ANDROIDPAYLOAD is not None or
            self.GOOGLEPAYLOAD is not None or
            self.ENCRYPTEDPAYLOAD is not None or
            self.CARDTYPE is not None or
            self.CARDEXPIRY is not None or
            self.CARDHOLDERNAME is not None or
            self.HASH is not None or
            self.CURRENCY is not None or
            self.FOREIGNCURRENCYINFORMATION is not None or
            self.TERMINALTYPE is not None or
            self.TRANSACTIONTYPE is not None or
            self.AUTOREADY is not None or
            self.EMAIL is not None or
            self.CVV is not None or
            self.ISSUENO is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.POSTCODE is not None or
            self.BILLTOFIRSTNAME is not None or
            self.BILLTOLASTNAME is not None or
            self.AVSONLY is not None or
            self.DESCRIPTION is not None or
            self.XID is not None or
            self.CAVV is not None or
            self.THREEDS_PROTOCOL_VERSION is not None or
            self.DS_TRANS_ID is not None or
            self.MPIREF is not None or
            self.MOBILENUMBER is not None or
            self.DEVICEID is not None or
            self.PHONE is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.COUNTRY is not None or
            self.IPADDRESS is not None or
            self.SIGNATURE is not None or
            self.CUSTOMFIELD or
            self.RECURRINGTXNREF is not None or
            self.LEVEL_2_DATA is not None or
            self.LEVEL_3_DATA is not None or
            self.ENHANCED_DATA_TEMPLATE is not None or
            self.FRAUDREVIEWSESSIONID is not None or
            self.CREDENTIALONFILE is not None or
            self.BYPASS_SURCHARGE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAYMENT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.TRACKDATA is not None:
            TRACKDATA_ = self.TRACKDATA
            etree_.SubElement(element, '{}TRACKDATA').text = self.gds_format_string(TRACKDATA_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.DUKPTCARDDETAILS is not None:
            DUKPTCARDDETAILS_ = self.DUKPTCARDDETAILS
            DUKPTCARDDETAILS_.to_etree(element, name_='DUKPTCARDDETAILS', mapping_=mapping_)
        if self.APPLEPAYLOAD is not None:
            APPLEPAYLOAD_ = self.APPLEPAYLOAD
            etree_.SubElement(element, '{}APPLEPAYLOAD').text = self.gds_format_string(APPLEPAYLOAD_)
        if self.ANDROIDPAYLOAD is not None:
            ANDROIDPAYLOAD_ = self.ANDROIDPAYLOAD
            etree_.SubElement(element, '{}ANDROIDPAYLOAD').text = self.gds_format_string(ANDROIDPAYLOAD_)
        if self.GOOGLEPAYLOAD is not None:
            GOOGLEPAYLOAD_ = self.GOOGLEPAYLOAD
            etree_.SubElement(element, '{}GOOGLEPAYLOAD').text = self.gds_format_string(GOOGLEPAYLOAD_)
        if self.ENCRYPTEDPAYLOAD is not None:
            ENCRYPTEDPAYLOAD_ = self.ENCRYPTEDPAYLOAD
            ENCRYPTEDPAYLOAD_.to_etree(element, name_='ENCRYPTEDPAYLOAD', mapping_=mapping_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.FOREIGNCURRENCYINFORMATION is not None:
            FOREIGNCURRENCYINFORMATION_ = self.FOREIGNCURRENCYINFORMATION
            FOREIGNCURRENCYINFORMATION_.to_etree(element, name_='FOREIGNCURRENCYINFORMATION', mapping_=mapping_)
        if self.TERMINALTYPE is not None:
            TERMINALTYPE_ = self.TERMINALTYPE
            etree_.SubElement(element, '{}TERMINALTYPE').text = self.gds_format_integer(TERMINALTYPE_)
        if self.TRANSACTIONTYPE is not None:
            TRANSACTIONTYPE_ = self.TRANSACTIONTYPE
            etree_.SubElement(element, '{}TRANSACTIONTYPE').text = self.gds_format_integer(TRANSACTIONTYPE_)
        if self.AUTOREADY is not None:
            AUTOREADY_ = self.AUTOREADY
            etree_.SubElement(element, '{}AUTOREADY').text = self.gds_format_string(AUTOREADY_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.CVV is not None:
            CVV_ = self.CVV
            etree_.SubElement(element, '{}CVV').text = self.gds_format_string(CVV_)
        if self.ISSUENO is not None:
            ISSUENO_ = self.ISSUENO
            etree_.SubElement(element, '{}ISSUENO').text = self.gds_format_string(ISSUENO_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.BILLTOFIRSTNAME is not None:
            BILLTOFIRSTNAME_ = self.BILLTOFIRSTNAME
            etree_.SubElement(element, '{}BILLTOFIRSTNAME').text = self.gds_format_string(BILLTOFIRSTNAME_)
        if self.BILLTOLASTNAME is not None:
            BILLTOLASTNAME_ = self.BILLTOLASTNAME
            etree_.SubElement(element, '{}BILLTOLASTNAME').text = self.gds_format_string(BILLTOLASTNAME_)
        if self.AVSONLY is not None:
            AVSONLY_ = self.AVSONLY
            etree_.SubElement(element, '{}AVSONLY').text = self.gds_format_string(AVSONLY_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.XID is not None:
            XID_ = self.XID
            etree_.SubElement(element, '{}XID').text = self.gds_format_string(XID_)
        if self.CAVV is not None:
            CAVV_ = self.CAVV
            etree_.SubElement(element, '{}CAVV').text = self.gds_format_string(CAVV_)
        if self.THREEDS_PROTOCOL_VERSION is not None:
            THREEDS_PROTOCOL_VERSION_ = self.THREEDS_PROTOCOL_VERSION
            etree_.SubElement(element, '{}THREEDS_PROTOCOL_VERSION').text = self.gds_format_integer(THREEDS_PROTOCOL_VERSION_)
        if self.DS_TRANS_ID is not None:
            DS_TRANS_ID_ = self.DS_TRANS_ID
            etree_.SubElement(element, '{}DS_TRANS_ID').text = self.gds_format_string(DS_TRANS_ID_)
        if self.MPIREF is not None:
            MPIREF_ = self.MPIREF
            etree_.SubElement(element, '{}MPIREF').text = self.gds_format_string(MPIREF_)
        if self.MOBILENUMBER is not None:
            MOBILENUMBER_ = self.MOBILENUMBER
            etree_.SubElement(element, '{}MOBILENUMBER').text = self.gds_format_string(MOBILENUMBER_)
        if self.DEVICEID is not None:
            DEVICEID_ = self.DEVICEID
            etree_.SubElement(element, '{}DEVICEID').text = self.gds_format_string(DEVICEID_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.IPADDRESS is not None:
            IPADDRESS_ = self.IPADDRESS
            etree_.SubElement(element, '{}IPADDRESS').text = self.gds_format_string(IPADDRESS_)
        if self.SIGNATURE is not None:
            SIGNATURE_ = self.SIGNATURE
            etree_.SubElement(element, '{}SIGNATURE').text = self.gds_format_string(SIGNATURE_)
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            CUSTOMFIELD_.to_etree(element, name_='CUSTOMFIELD', mapping_=mapping_)
        if self.RECURRINGTXNREF is not None:
            RECURRINGTXNREF_ = self.RECURRINGTXNREF
            etree_.SubElement(element, '{}RECURRINGTXNREF').text = self.gds_format_string(RECURRINGTXNREF_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.LEVEL_3_DATA is not None:
            LEVEL_3_DATA_ = self.LEVEL_3_DATA
            LEVEL_3_DATA_.to_etree(element, name_='LEVEL_3_DATA', mapping_=mapping_)
        if self.ENHANCED_DATA_TEMPLATE is not None:
            ENHANCED_DATA_TEMPLATE_ = self.ENHANCED_DATA_TEMPLATE
            etree_.SubElement(element, '{}ENHANCED_DATA_TEMPLATE').text = self.gds_format_string(ENHANCED_DATA_TEMPLATE_)
        if self.FRAUDREVIEWSESSIONID is not None:
            FRAUDREVIEWSESSIONID_ = self.FRAUDREVIEWSESSIONID
            etree_.SubElement(element, '{}FRAUDREVIEWSESSIONID').text = self.gds_format_string(FRAUDREVIEWSESSIONID_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.BYPASS_SURCHARGE is not None:
            BYPASS_SURCHARGE_ = self.BYPASS_SURCHARGE
            etree_.SubElement(element, '{}BYPASS_SURCHARGE').text = self.gds_format_boolean(BYPASS_SURCHARGE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAYMENT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.TRACKDATA is not None:
            showIndent(outfile, level)
            outfile.write('TRACKDATA=%s,\n' % self.gds_encode(quote_python(self.TRACKDATA)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.DUKPTCARDDETAILS is not None:
            showIndent(outfile, level)
            outfile.write('DUKPTCARDDETAILS=model_.DUKPTCARDDETAILS(\n')
            self.DUKPTCARDDETAILS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.APPLEPAYLOAD is not None:
            showIndent(outfile, level)
            outfile.write('APPLEPAYLOAD=%s,\n' % self.gds_encode(quote_python(self.APPLEPAYLOAD)))
        if self.ANDROIDPAYLOAD is not None:
            showIndent(outfile, level)
            outfile.write('ANDROIDPAYLOAD=%s,\n' % self.gds_encode(quote_python(self.ANDROIDPAYLOAD)))
        if self.GOOGLEPAYLOAD is not None:
            showIndent(outfile, level)
            outfile.write('GOOGLEPAYLOAD=%s,\n' % self.gds_encode(quote_python(self.GOOGLEPAYLOAD)))
        if self.ENCRYPTEDPAYLOAD is not None:
            showIndent(outfile, level)
            outfile.write('ENCRYPTEDPAYLOAD=model_.ENCRYPTEDPAYLOAD(\n')
            self.ENCRYPTEDPAYLOAD.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.FOREIGNCURRENCYINFORMATION is not None:
            showIndent(outfile, level)
            outfile.write('FOREIGNCURRENCYINFORMATION=model_.FOREIGNCURRENCYINFORMATION(\n')
            self.FOREIGNCURRENCYINFORMATION.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TERMINALTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALTYPE=%d,\n' % self.TERMINALTYPE)
        if self.TRANSACTIONTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTIONTYPE=%d,\n' % self.TRANSACTIONTYPE)
        if self.AUTOREADY is not None:
            showIndent(outfile, level)
            outfile.write('AUTOREADY=%s,\n' % self.gds_encode(quote_python(self.AUTOREADY)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.CVV is not None:
            showIndent(outfile, level)
            outfile.write('CVV=%s,\n' % self.gds_encode(quote_python(self.CVV)))
        if self.ISSUENO is not None:
            showIndent(outfile, level)
            outfile.write('ISSUENO=%s,\n' % self.gds_encode(quote_python(self.ISSUENO)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.BILLTOFIRSTNAME is not None:
            showIndent(outfile, level)
            outfile.write('BILLTOFIRSTNAME=%s,\n' % self.gds_encode(quote_python(self.BILLTOFIRSTNAME)))
        if self.BILLTOLASTNAME is not None:
            showIndent(outfile, level)
            outfile.write('BILLTOLASTNAME=%s,\n' % self.gds_encode(quote_python(self.BILLTOLASTNAME)))
        if self.AVSONLY is not None:
            showIndent(outfile, level)
            outfile.write('AVSONLY=%s,\n' % self.gds_encode(quote_python(self.AVSONLY)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.XID is not None:
            showIndent(outfile, level)
            outfile.write('XID=%s,\n' % self.gds_encode(quote_python(self.XID)))
        if self.CAVV is not None:
            showIndent(outfile, level)
            outfile.write('CAVV=%s,\n' % self.gds_encode(quote_python(self.CAVV)))
        if self.THREEDS_PROTOCOL_VERSION is not None:
            showIndent(outfile, level)
            outfile.write('THREEDS_PROTOCOL_VERSION=%d,\n' % self.THREEDS_PROTOCOL_VERSION)
        if self.DS_TRANS_ID is not None:
            showIndent(outfile, level)
            outfile.write('DS_TRANS_ID=%s,\n' % self.gds_encode(quote_python(self.DS_TRANS_ID)))
        if self.MPIREF is not None:
            showIndent(outfile, level)
            outfile.write('MPIREF=%s,\n' % self.gds_encode(quote_python(self.MPIREF)))
        if self.MOBILENUMBER is not None:
            showIndent(outfile, level)
            outfile.write('MOBILENUMBER=%s,\n' % self.gds_encode(quote_python(self.MOBILENUMBER)))
        if self.DEVICEID is not None:
            showIndent(outfile, level)
            outfile.write('DEVICEID=%s,\n' % self.gds_encode(quote_python(self.DEVICEID)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.IPADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('IPADDRESS=%s,\n' % self.gds_encode(quote_python(self.IPADDRESS)))
        if self.SIGNATURE is not None:
            showIndent(outfile, level)
            outfile.write('SIGNATURE=%s,\n' % self.gds_encode(quote_python(self.SIGNATURE)))
        showIndent(outfile, level)
        outfile.write('CUSTOMFIELD=[\n')
        level += 1
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOMFIELD(\n')
            CUSTOMFIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.RECURRINGTXNREF is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGTXNREF=%s,\n' % self.gds_encode(quote_python(self.RECURRINGTXNREF)))
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LEVEL_3_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_3_DATA=model_.LEVEL_3_DATA(\n')
            self.LEVEL_3_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ENHANCED_DATA_TEMPLATE is not None:
            showIndent(outfile, level)
            outfile.write('ENHANCED_DATA_TEMPLATE=%s,\n' % self.gds_encode(quote_python(self.ENHANCED_DATA_TEMPLATE)))
        if self.FRAUDREVIEWSESSIONID is not None:
            showIndent(outfile, level)
            outfile.write('FRAUDREVIEWSESSIONID=%s,\n' % self.gds_encode(quote_python(self.FRAUDREVIEWSESSIONID)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BYPASS_SURCHARGE is not None:
            showIndent(outfile, level)
            outfile.write('BYPASS_SURCHARGE=%s,\n' % self.BYPASS_SURCHARGE)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'TRACKDATA':
            TRACKDATA_ = child_.text
            TRACKDATA_ = self.gds_validate_string(TRACKDATA_, node, 'TRACKDATA')
            self.TRACKDATA = TRACKDATA_
            # validate type TRACKDATA
            self.validate_TRACKDATA(self.TRACKDATA)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'DUKPTCARDDETAILS':
            obj_ = DUKPTCARDDETAILS.factory()
            obj_.build(child_)
            self.DUKPTCARDDETAILS = obj_
            obj_.original_tagname_ = 'DUKPTCARDDETAILS'
        elif nodeName_ == 'APPLEPAYLOAD':
            APPLEPAYLOAD_ = child_.text
            APPLEPAYLOAD_ = self.gds_validate_string(APPLEPAYLOAD_, node, 'APPLEPAYLOAD')
            self.APPLEPAYLOAD = APPLEPAYLOAD_
            # validate type APPLEPAYLOAD
            self.validate_APPLEPAYLOAD(self.APPLEPAYLOAD)
        elif nodeName_ == 'ANDROIDPAYLOAD':
            ANDROIDPAYLOAD_ = child_.text
            ANDROIDPAYLOAD_ = self.gds_validate_string(ANDROIDPAYLOAD_, node, 'ANDROIDPAYLOAD')
            self.ANDROIDPAYLOAD = ANDROIDPAYLOAD_
            # validate type ANDROIDPAYLOAD
            self.validate_ANDROIDPAYLOAD(self.ANDROIDPAYLOAD)
        elif nodeName_ == 'GOOGLEPAYLOAD':
            GOOGLEPAYLOAD_ = child_.text
            GOOGLEPAYLOAD_ = self.gds_validate_string(GOOGLEPAYLOAD_, node, 'GOOGLEPAYLOAD')
            self.GOOGLEPAYLOAD = GOOGLEPAYLOAD_
            # validate type GOOGLEPAYLOAD
            self.validate_GOOGLEPAYLOAD(self.GOOGLEPAYLOAD)
        elif nodeName_ == 'ENCRYPTEDPAYLOAD':
            obj_ = ENCRYPTEDPAYLOAD.factory()
            obj_.build(child_)
            self.ENCRYPTEDPAYLOAD = obj_
            obj_.original_tagname_ = 'ENCRYPTEDPAYLOAD'
        elif nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'FOREIGNCURRENCYINFORMATION':
            obj_ = FOREIGNCURRENCYINFORMATION.factory()
            obj_.build(child_)
            self.FOREIGNCURRENCYINFORMATION = obj_
            obj_.original_tagname_ = 'FOREIGNCURRENCYINFORMATION'
        elif nodeName_ == 'TERMINALTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TERMINALTYPE')
            self.TERMINALTYPE = ival_
            # validate type TERMINALTYPE
            self.validate_TERMINALTYPE(self.TERMINALTYPE)
        elif nodeName_ == 'TRANSACTIONTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TRANSACTIONTYPE')
            self.TRANSACTIONTYPE = ival_
            # validate type TRANSACTIONTYPE
            self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        elif nodeName_ == 'AUTOREADY':
            AUTOREADY_ = child_.text
            AUTOREADY_ = self.gds_validate_string(AUTOREADY_, node, 'AUTOREADY')
            self.AUTOREADY = AUTOREADY_
            # validate type AUTOREADY
            self.validate_AUTOREADY(self.AUTOREADY)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'CVV':
            CVV_ = child_.text
            CVV_ = self.gds_validate_string(CVV_, node, 'CVV')
            self.CVV = CVV_
            # validate type CVV
            self.validate_CVV(self.CVV)
        elif nodeName_ == 'ISSUENO':
            ISSUENO_ = child_.text
            ISSUENO_ = self.gds_validate_string(ISSUENO_, node, 'ISSUENO')
            self.ISSUENO = ISSUENO_
            # validate type ISSUENO
            self.validate_ISSUENO(self.ISSUENO)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'BILLTOFIRSTNAME':
            BILLTOFIRSTNAME_ = child_.text
            BILLTOFIRSTNAME_ = self.gds_validate_string(BILLTOFIRSTNAME_, node, 'BILLTOFIRSTNAME')
            self.BILLTOFIRSTNAME = BILLTOFIRSTNAME_
            # validate type BILLTOFIRSTNAME
            self.validate_BILLTOFIRSTNAME(self.BILLTOFIRSTNAME)
        elif nodeName_ == 'BILLTOLASTNAME':
            BILLTOLASTNAME_ = child_.text
            BILLTOLASTNAME_ = self.gds_validate_string(BILLTOLASTNAME_, node, 'BILLTOLASTNAME')
            self.BILLTOLASTNAME = BILLTOLASTNAME_
            # validate type BILLTOLASTNAME
            self.validate_BILLTOLASTNAME(self.BILLTOLASTNAME)
        elif nodeName_ == 'AVSONLY':
            AVSONLY_ = child_.text
            AVSONLY_ = self.gds_validate_string(AVSONLY_, node, 'AVSONLY')
            self.AVSONLY = AVSONLY_
            # validate type AVSONLY
            self.validate_AVSONLY(self.AVSONLY)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'XID':
            XID_ = child_.text
            XID_ = self.gds_validate_string(XID_, node, 'XID')
            self.XID = XID_
            # validate type XID
            self.validate_XID(self.XID)
        elif nodeName_ == 'CAVV':
            CAVV_ = child_.text
            CAVV_ = self.gds_validate_string(CAVV_, node, 'CAVV')
            self.CAVV = CAVV_
            # validate type CAVV
            self.validate_CAVV(self.CAVV)
        elif nodeName_ == 'THREEDS_PROTOCOL_VERSION' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'THREEDS_PROTOCOL_VERSION')
            self.THREEDS_PROTOCOL_VERSION = ival_
            # validate type THREEDS_PROTOCOL_VERSION
            self.validate_THREEDS_PROTOCOL_VERSION(self.THREEDS_PROTOCOL_VERSION)
        elif nodeName_ == 'DS_TRANS_ID':
            DS_TRANS_ID_ = child_.text
            DS_TRANS_ID_ = self.gds_validate_string(DS_TRANS_ID_, node, 'DS_TRANS_ID')
            self.DS_TRANS_ID = DS_TRANS_ID_
            # validate type DS_TRANS_ID
            self.validate_DS_TRANS_ID(self.DS_TRANS_ID)
        elif nodeName_ == 'MPIREF':
            MPIREF_ = child_.text
            MPIREF_ = self.gds_validate_string(MPIREF_, node, 'MPIREF')
            self.MPIREF = MPIREF_
            # validate type MPIREF
            self.validate_MPIREF(self.MPIREF)
        elif nodeName_ == 'MOBILENUMBER':
            MOBILENUMBER_ = child_.text
            MOBILENUMBER_ = self.gds_validate_string(MOBILENUMBER_, node, 'MOBILENUMBER')
            self.MOBILENUMBER = MOBILENUMBER_
            # validate type MOBILENUMBER
            self.validate_MOBILENUMBER(self.MOBILENUMBER)
        elif nodeName_ == 'DEVICEID':
            DEVICEID_ = child_.text
            DEVICEID_ = self.gds_validate_string(DEVICEID_, node, 'DEVICEID')
            self.DEVICEID = DEVICEID_
            # validate type DEVICEID
            self.validate_DEVICEID(self.DEVICEID)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'IPADDRESS':
            IPADDRESS_ = child_.text
            IPADDRESS_ = self.gds_validate_string(IPADDRESS_, node, 'IPADDRESS')
            self.IPADDRESS = IPADDRESS_
            # validate type IPADDRESS
            self.validate_IPADDRESS(self.IPADDRESS)
        elif nodeName_ == 'SIGNATURE':
            SIGNATURE_ = child_.text
            SIGNATURE_ = self.gds_validate_string(SIGNATURE_, node, 'SIGNATURE')
            self.SIGNATURE = SIGNATURE_
            # validate type SIGNATURE
            self.validate_SIGNATURE(self.SIGNATURE)
        elif nodeName_ == 'CUSTOMFIELD':
            obj_ = CUSTOMFIELD.factory()
            obj_.build(child_)
            self.CUSTOMFIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOMFIELD'
        elif nodeName_ == 'RECURRINGTXNREF':
            RECURRINGTXNREF_ = child_.text
            RECURRINGTXNREF_ = self.gds_validate_string(RECURRINGTXNREF_, node, 'RECURRINGTXNREF')
            self.RECURRINGTXNREF = RECURRINGTXNREF_
            # validate type UID
            self.validate_UID(self.RECURRINGTXNREF)
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'LEVEL_3_DATA':
            obj_ = LEVEL_3_DATA.factory()
            obj_.build(child_)
            self.LEVEL_3_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_3_DATA'
        elif nodeName_ == 'ENHANCED_DATA_TEMPLATE':
            ENHANCED_DATA_TEMPLATE_ = child_.text
            ENHANCED_DATA_TEMPLATE_ = self.gds_validate_string(ENHANCED_DATA_TEMPLATE_, node, 'ENHANCED_DATA_TEMPLATE')
            self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE_
            # validate type ENHANCED_DATA_TEMPLATE
            self.validate_ENHANCED_DATA_TEMPLATE(self.ENHANCED_DATA_TEMPLATE)
        elif nodeName_ == 'FRAUDREVIEWSESSIONID':
            FRAUDREVIEWSESSIONID_ = child_.text
            FRAUDREVIEWSESSIONID_ = self.gds_validate_string(FRAUDREVIEWSESSIONID_, node, 'FRAUDREVIEWSESSIONID')
            self.FRAUDREVIEWSESSIONID = FRAUDREVIEWSESSIONID_
            # validate type FRAUDREVIEWSESSIONID
            self.validate_FRAUDREVIEWSESSIONID(self.FRAUDREVIEWSESSIONID)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'BYPASS_SURCHARGE':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'BYPASS_SURCHARGE')
            self.BYPASS_SURCHARGE = ival_


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        if self.ORDERID:
            hash_list.append(self.ORDERID)
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** -Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class PAYMENT


class OFFLINEPAYMENT(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('TRACKDATA', ['TRACKDATA', 'xs:string'], 0, 0, {'ref': 'TRACKDATA', 'name': 'TRACKDATA', 'type': 'xs:string'}, 2),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 0, {'ref': 'CARDNUMBER', 'name': 'CARDNUMBER', 'type': 'xs:string'}, 2),
        MemberSpec_('DUKPTCARDDETAILS', 'DUKPTCARDDETAILS', 0, 0, {'ref': 'DUKPTCARDDETAILS', 'name': 'DUKPTCARDDETAILS', 'type': 'DUKPTCARDDETAILS'}, 2),
        MemberSpec_('ENCRYPTEDPAYLOAD', 'ENCRYPTEDPAYLOAD', 0, 0, {'ref': 'ENCRYPTEDPAYLOAD', 'name': 'ENCRYPTEDPAYLOAD', 'type': 'ENCRYPTEDPAYLOAD'}, 2),
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 0, {'ref': 'CARDTYPE', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 1, {'ref': 'CARDEXPIRY', 'minOccurs': '0', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 1, {'ref': 'CARDHOLDERNAME', 'minOccurs': '0', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('FOREIGNCURRENCYINFORMATION', 'FOREIGNCURRENCYINFORMATION', 0, 1, {'ref': 'FOREIGNCURRENCYINFORMATION', 'minOccurs': '0', 'name': 'FOREIGNCURRENCYINFORMATION', 'type': 'FOREIGNCURRENCYINFORMATION'}, None),
        MemberSpec_('TERMINALTYPE', ['TERMINALTYPE', 'xs:int'], 0, 0, {'ref': 'TERMINALTYPE', 'name': 'TERMINALTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('TRANSACTIONTYPE', ['TRANSACTIONTYPE', 'xs:int'], 0, 0, {'ref': 'TRANSACTIONTYPE', 'name': 'TRANSACTIONTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('AUTOREADY', ['AUTOREADY', 'xs:string'], 0, 1, {'ref': 'AUTOREADY', 'minOccurs': '0', 'name': 'AUTOREADY', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('BILLTOFIRSTNAME', ['BILLTOFIRSTNAME', 'xs:string'], 0, 1, {'ref': 'BILLTOFIRSTNAME', 'minOccurs': '0', 'name': 'BILLTOFIRSTNAME', 'type': 'xs:string'}, None),
        MemberSpec_('BILLTOLASTNAME', ['BILLTOLASTNAME', 'xs:string'], 0, 1, {'ref': 'BILLTOLASTNAME', 'minOccurs': '0', 'name': 'BILLTOLASTNAME', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('MOBILENUMBER', ['MOBILENUMBER', 'xs:string'], 0, 1, {'ref': 'MOBILENUMBER', 'minOccurs': '0', 'name': 'MOBILENUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('DEVICEID', ['DEVICEID', 'xs:string'], 0, 1, {'ref': 'DEVICEID', 'minOccurs': '0', 'name': 'DEVICEID', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('IPADDRESS', ['IPADDRESS', 'xs:string'], 0, 1, {'ref': 'IPADDRESS', 'minOccurs': '0', 'name': 'IPADDRESS', 'type': 'xs:string'}, None),
        MemberSpec_('SIGNATURE', ['SIGNATURE', 'xs:string'], 0, 1, {'ref': 'SIGNATURE', 'minOccurs': '0', 'name': 'SIGNATURE', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOMFIELD', 'CUSTOMFIELD', 1, 1, {'ref': 'CUSTOMFIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'CUSTOMFIELD', 'type': 'CUSTOMFIELD'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('LEVEL_3_DATA', 'LEVEL_3_DATA', 0, 1, {'ref': 'LEVEL_3_DATA', 'minOccurs': '0', 'name': 'LEVEL_3_DATA', 'type': 'LEVEL_3_DATA'}, None),
        MemberSpec_('ENHANCED_DATA_TEMPLATE', ['ENHANCED_DATA_TEMPLATE', 'xs:string'], 0, 1, {'ref': 'ENHANCED_DATA_TEMPLATE', 'minOccurs': '0', 'name': 'ENHANCED_DATA_TEMPLATE', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, AMOUNT=None, DATETIME=None, TRACKDATA=None, CARDNUMBER=None, DUKPTCARDDETAILS=None, ENCRYPTEDPAYLOAD=None, CARDTYPE=None, CARDEXPIRY=None, CARDHOLDERNAME=None, HASH=None, CURRENCY=None, FOREIGNCURRENCYINFORMATION=None, TERMINALTYPE=None, TRANSACTIONTYPE=None, AUTOREADY=None, EMAIL=None, ADDRESS1=None, ADDRESS2=None, POSTCODE=None, BILLTOFIRSTNAME=None, BILLTOLASTNAME=None, DESCRIPTION=None, MOBILENUMBER=None, DEVICEID=None, PHONE=None, CITY=None, REGION=None, COUNTRY=None, IPADDRESS=None, SIGNATURE=None, CUSTOMFIELD=None, LEVEL_2_DATA=None, LEVEL_3_DATA=None, ENHANCED_DATA_TEMPLATE=None, APPROVALCODE=None, CREDENTIALONFILE=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.TRACKDATA = TRACKDATA
        self.validate_TRACKDATA(self.TRACKDATA)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.DUKPTCARDDETAILS = DUKPTCARDDETAILS
        self.ENCRYPTEDPAYLOAD = ENCRYPTEDPAYLOAD
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
        self.TERMINALTYPE = TERMINALTYPE
        self.validate_TERMINALTYPE(self.TERMINALTYPE)
        self.TRANSACTIONTYPE = TRANSACTIONTYPE
        self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        self.AUTOREADY = AUTOREADY
        self.validate_AUTOREADY(self.AUTOREADY)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.BILLTOFIRSTNAME = BILLTOFIRSTNAME
        self.validate_BILLTOFIRSTNAME(self.BILLTOFIRSTNAME)
        self.BILLTOLASTNAME = BILLTOLASTNAME
        self.validate_BILLTOLASTNAME(self.BILLTOLASTNAME)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.MOBILENUMBER = MOBILENUMBER
        self.validate_MOBILENUMBER(self.MOBILENUMBER)
        self.DEVICEID = DEVICEID
        self.validate_DEVICEID(self.DEVICEID)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.IPADDRESS = IPADDRESS
        self.validate_IPADDRESS(self.IPADDRESS)
        self.SIGNATURE = SIGNATURE
        self.validate_SIGNATURE(self.SIGNATURE)
        if CUSTOMFIELD is None:
            self.CUSTOMFIELD = []
        else:
            self.CUSTOMFIELD = CUSTOMFIELD
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.LEVEL_3_DATA = LEVEL_3_DATA
        self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE
        self.validate_ENHANCED_DATA_TEMPLATE(self.ENHANCED_DATA_TEMPLATE)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.CREDENTIALONFILE = CREDENTIALONFILE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OFFLINEPAYMENT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OFFLINEPAYMENT.subclass:
            return OFFLINEPAYMENT.subclass(*args_, **kwargs_)
        else:
            return OFFLINEPAYMENT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_TRACKDATA(self): return self.TRACKDATA
    def set_TRACKDATA(self, TRACKDATA): self.TRACKDATA = TRACKDATA
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_DUKPTCARDDETAILS(self): return self.DUKPTCARDDETAILS
    def set_DUKPTCARDDETAILS(self, DUKPTCARDDETAILS): self.DUKPTCARDDETAILS = DUKPTCARDDETAILS
    def get_ENCRYPTEDPAYLOAD(self): return self.ENCRYPTEDPAYLOAD
    def set_ENCRYPTEDPAYLOAD(self, ENCRYPTEDPAYLOAD): self.ENCRYPTEDPAYLOAD = ENCRYPTEDPAYLOAD
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_FOREIGNCURRENCYINFORMATION(self): return self.FOREIGNCURRENCYINFORMATION
    def set_FOREIGNCURRENCYINFORMATION(self, FOREIGNCURRENCYINFORMATION): self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
    def get_TERMINALTYPE(self): return self.TERMINALTYPE
    def set_TERMINALTYPE(self, TERMINALTYPE): self.TERMINALTYPE = TERMINALTYPE
    def get_TRANSACTIONTYPE(self): return self.TRANSACTIONTYPE
    def set_TRANSACTIONTYPE(self, TRANSACTIONTYPE): self.TRANSACTIONTYPE = TRANSACTIONTYPE
    def get_AUTOREADY(self): return self.AUTOREADY
    def set_AUTOREADY(self, AUTOREADY): self.AUTOREADY = AUTOREADY
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_BILLTOFIRSTNAME(self): return self.BILLTOFIRSTNAME
    def set_BILLTOFIRSTNAME(self, BILLTOFIRSTNAME): self.BILLTOFIRSTNAME = BILLTOFIRSTNAME
    def get_BILLTOLASTNAME(self): return self.BILLTOLASTNAME
    def set_BILLTOLASTNAME(self, BILLTOLASTNAME): self.BILLTOLASTNAME = BILLTOLASTNAME
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_MOBILENUMBER(self): return self.MOBILENUMBER
    def set_MOBILENUMBER(self, MOBILENUMBER): self.MOBILENUMBER = MOBILENUMBER
    def get_DEVICEID(self): return self.DEVICEID
    def set_DEVICEID(self, DEVICEID): self.DEVICEID = DEVICEID
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_IPADDRESS(self): return self.IPADDRESS
    def set_IPADDRESS(self, IPADDRESS): self.IPADDRESS = IPADDRESS
    def get_SIGNATURE(self): return self.SIGNATURE
    def set_SIGNATURE(self, SIGNATURE): self.SIGNATURE = SIGNATURE
    def get_CUSTOMFIELD(self): return self.CUSTOMFIELD
    def set_CUSTOMFIELD(self, CUSTOMFIELD): self.CUSTOMFIELD = CUSTOMFIELD
    def add_CUSTOMFIELD(self, value): self.CUSTOMFIELD.append(value)
    def insert_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD.insert(index, value)
    def replace_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD[index] = value
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_LEVEL_3_DATA(self): return self.LEVEL_3_DATA
    def set_LEVEL_3_DATA(self, LEVEL_3_DATA): self.LEVEL_3_DATA = LEVEL_3_DATA
    def get_ENHANCED_DATA_TEMPLATE(self): return self.ENHANCED_DATA_TEMPLATE
    def set_ENHANCED_DATA_TEMPLATE(self, ENHANCED_DATA_TEMPLATE): self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_TRACKDATA(self, value):
        # Validate type TRACKDATA, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_TERMINALTYPE(self, value):
        # Validate type TERMINALTYPE, a restriction on xs:int.
        pass
    def validate_TRANSACTIONTYPE(self, value):
        # Validate type TRANSACTIONTYPE, a restriction on xs:int.
        pass
    def validate_AUTOREADY(self, value):
        # Validate type AUTOREADY, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_BILLTOFIRSTNAME(self, value):
        # Validate type BILLTOFIRSTNAME, a restriction on xs:string.
        pass
    def validate_BILLTOLASTNAME(self, value):
        # Validate type BILLTOLASTNAME, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_MOBILENUMBER(self, value):
        # Validate type MOBILENUMBER, a restriction on xs:string.
        pass
    def validate_DEVICEID(self, value):
        # Validate type DEVICEID, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_IPADDRESS(self, value):
        # Validate type IPADDRESS, a restriction on xs:string.
        pass
    def validate_SIGNATURE(self, value):
        # Validate type SIGNATURE, a restriction on xs:string.
        pass
    def validate_ENHANCED_DATA_TEMPLATE(self, value):
        # Validate type ENHANCED_DATA_TEMPLATE, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.DATETIME is not None or
            self.TRACKDATA is not None or
            self.CARDNUMBER is not None or
            self.DUKPTCARDDETAILS is not None or
            self.ENCRYPTEDPAYLOAD is not None or
            self.CARDTYPE is not None or
            self.CARDEXPIRY is not None or
            self.CARDHOLDERNAME is not None or
            self.HASH is not None or
            self.CURRENCY is not None or
            self.FOREIGNCURRENCYINFORMATION is not None or
            self.TERMINALTYPE is not None or
            self.TRANSACTIONTYPE is not None or
            self.AUTOREADY is not None or
            self.EMAIL is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.POSTCODE is not None or
            self.BILLTOFIRSTNAME is not None or
            self.BILLTOLASTNAME is not None or
            self.DESCRIPTION is not None or
            self.MOBILENUMBER is not None or
            self.DEVICEID is not None or
            self.PHONE is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.COUNTRY is not None or
            self.IPADDRESS is not None or
            self.SIGNATURE is not None or
            self.CUSTOMFIELD or
            self.LEVEL_2_DATA is not None or
            self.LEVEL_3_DATA is not None or
            self.ENHANCED_DATA_TEMPLATE is not None or
            self.APPROVALCODE is not None or
            self.CREDENTIALONFILE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='OFFLINEPAYMENT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.TRACKDATA is not None:
            TRACKDATA_ = self.TRACKDATA
            etree_.SubElement(element, '{}TRACKDATA').text = self.gds_format_string(TRACKDATA_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.DUKPTCARDDETAILS is not None:
            DUKPTCARDDETAILS_ = self.DUKPTCARDDETAILS
            DUKPTCARDDETAILS_.to_etree(element, name_='DUKPTCARDDETAILS', mapping_=mapping_)
        if self.ENCRYPTEDPAYLOAD is not None:
            ENCRYPTEDPAYLOAD_ = self.ENCRYPTEDPAYLOAD
            ENCRYPTEDPAYLOAD_.to_etree(element, name_='ENCRYPTEDPAYLOAD', mapping_=mapping_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.FOREIGNCURRENCYINFORMATION is not None:
            FOREIGNCURRENCYINFORMATION_ = self.FOREIGNCURRENCYINFORMATION
            FOREIGNCURRENCYINFORMATION_.to_etree(element, name_='FOREIGNCURRENCYINFORMATION', mapping_=mapping_)
        if self.TERMINALTYPE is not None:
            TERMINALTYPE_ = self.TERMINALTYPE
            etree_.SubElement(element, '{}TERMINALTYPE').text = self.gds_format_integer(TERMINALTYPE_)
        if self.TRANSACTIONTYPE is not None:
            TRANSACTIONTYPE_ = self.TRANSACTIONTYPE
            etree_.SubElement(element, '{}TRANSACTIONTYPE').text = self.gds_format_integer(TRANSACTIONTYPE_)
        if self.AUTOREADY is not None:
            AUTOREADY_ = self.AUTOREADY
            etree_.SubElement(element, '{}AUTOREADY').text = self.gds_format_string(AUTOREADY_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.BILLTOFIRSTNAME is not None:
            BILLTOFIRSTNAME_ = self.BILLTOFIRSTNAME
            etree_.SubElement(element, '{}BILLTOFIRSTNAME').text = self.gds_format_string(BILLTOFIRSTNAME_)
        if self.BILLTOLASTNAME is not None:
            BILLTOLASTNAME_ = self.BILLTOLASTNAME
            etree_.SubElement(element, '{}BILLTOLASTNAME').text = self.gds_format_string(BILLTOLASTNAME_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.MOBILENUMBER is not None:
            MOBILENUMBER_ = self.MOBILENUMBER
            etree_.SubElement(element, '{}MOBILENUMBER').text = self.gds_format_string(MOBILENUMBER_)
        if self.DEVICEID is not None:
            DEVICEID_ = self.DEVICEID
            etree_.SubElement(element, '{}DEVICEID').text = self.gds_format_string(DEVICEID_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.IPADDRESS is not None:
            IPADDRESS_ = self.IPADDRESS
            etree_.SubElement(element, '{}IPADDRESS').text = self.gds_format_string(IPADDRESS_)
        if self.SIGNATURE is not None:
            SIGNATURE_ = self.SIGNATURE
            etree_.SubElement(element, '{}SIGNATURE').text = self.gds_format_string(SIGNATURE_)
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            CUSTOMFIELD_.to_etree(element, name_='CUSTOMFIELD', mapping_=mapping_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.LEVEL_3_DATA is not None:
            LEVEL_3_DATA_ = self.LEVEL_3_DATA
            LEVEL_3_DATA_.to_etree(element, name_='LEVEL_3_DATA', mapping_=mapping_)
        if self.ENHANCED_DATA_TEMPLATE is not None:
            ENHANCED_DATA_TEMPLATE_ = self.ENHANCED_DATA_TEMPLATE
            etree_.SubElement(element, '{}ENHANCED_DATA_TEMPLATE').text = self.gds_format_string(ENHANCED_DATA_TEMPLATE_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='OFFLINEPAYMENT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.TRACKDATA is not None:
            showIndent(outfile, level)
            outfile.write('TRACKDATA=%s,\n' % self.gds_encode(quote_python(self.TRACKDATA)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.DUKPTCARDDETAILS is not None:
            showIndent(outfile, level)
            outfile.write('DUKPTCARDDETAILS=model_.DUKPTCARDDETAILS(\n')
            self.DUKPTCARDDETAILS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ENCRYPTEDPAYLOAD is not None:
            showIndent(outfile, level)
            outfile.write('ENCRYPTEDPAYLOAD=model_.ENCRYPTEDPAYLOAD(\n')
            self.ENCRYPTEDPAYLOAD.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.FOREIGNCURRENCYINFORMATION is not None:
            showIndent(outfile, level)
            outfile.write('FOREIGNCURRENCYINFORMATION=model_.FOREIGNCURRENCYINFORMATION(\n')
            self.FOREIGNCURRENCYINFORMATION.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TERMINALTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALTYPE=%d,\n' % self.TERMINALTYPE)
        if self.TRANSACTIONTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTIONTYPE=%d,\n' % self.TRANSACTIONTYPE)
        if self.AUTOREADY is not None:
            showIndent(outfile, level)
            outfile.write('AUTOREADY=%s,\n' % self.gds_encode(quote_python(self.AUTOREADY)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.BILLTOFIRSTNAME is not None:
            showIndent(outfile, level)
            outfile.write('BILLTOFIRSTNAME=%s,\n' % self.gds_encode(quote_python(self.BILLTOFIRSTNAME)))
        if self.BILLTOLASTNAME is not None:
            showIndent(outfile, level)
            outfile.write('BILLTOLASTNAME=%s,\n' % self.gds_encode(quote_python(self.BILLTOLASTNAME)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.MOBILENUMBER is not None:
            showIndent(outfile, level)
            outfile.write('MOBILENUMBER=%s,\n' % self.gds_encode(quote_python(self.MOBILENUMBER)))
        if self.DEVICEID is not None:
            showIndent(outfile, level)
            outfile.write('DEVICEID=%s,\n' % self.gds_encode(quote_python(self.DEVICEID)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.IPADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('IPADDRESS=%s,\n' % self.gds_encode(quote_python(self.IPADDRESS)))
        if self.SIGNATURE is not None:
            showIndent(outfile, level)
            outfile.write('SIGNATURE=%s,\n' % self.gds_encode(quote_python(self.SIGNATURE)))
        showIndent(outfile, level)
        outfile.write('CUSTOMFIELD=[\n')
        level += 1
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOMFIELD(\n')
            CUSTOMFIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LEVEL_3_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_3_DATA=model_.LEVEL_3_DATA(\n')
            self.LEVEL_3_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ENHANCED_DATA_TEMPLATE is not None:
            showIndent(outfile, level)
            outfile.write('ENHANCED_DATA_TEMPLATE=%s,\n' % self.gds_encode(quote_python(self.ENHANCED_DATA_TEMPLATE)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'TRACKDATA':
            TRACKDATA_ = child_.text
            TRACKDATA_ = self.gds_validate_string(TRACKDATA_, node, 'TRACKDATA')
            self.TRACKDATA = TRACKDATA_
            # validate type TRACKDATA
            self.validate_TRACKDATA(self.TRACKDATA)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'DUKPTCARDDETAILS':
            obj_ = DUKPTCARDDETAILS.factory()
            obj_.build(child_)
            self.DUKPTCARDDETAILS = obj_
            obj_.original_tagname_ = 'DUKPTCARDDETAILS'
        elif nodeName_ == 'ENCRYPTEDPAYLOAD':
            obj_ = ENCRYPTEDPAYLOAD.factory()
            obj_.build(child_)
            self.ENCRYPTEDPAYLOAD = obj_
            obj_.original_tagname_ = 'ENCRYPTEDPAYLOAD'
        elif nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'FOREIGNCURRENCYINFORMATION':
            obj_ = FOREIGNCURRENCYINFORMATION.factory()
            obj_.build(child_)
            self.FOREIGNCURRENCYINFORMATION = obj_
            obj_.original_tagname_ = 'FOREIGNCURRENCYINFORMATION'
        elif nodeName_ == 'TERMINALTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TERMINALTYPE')
            self.TERMINALTYPE = ival_
            # validate type TERMINALTYPE
            self.validate_TERMINALTYPE(self.TERMINALTYPE)
        elif nodeName_ == 'TRANSACTIONTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TRANSACTIONTYPE')
            self.TRANSACTIONTYPE = ival_
            # validate type TRANSACTIONTYPE
            self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        elif nodeName_ == 'AUTOREADY':
            AUTOREADY_ = child_.text
            AUTOREADY_ = self.gds_validate_string(AUTOREADY_, node, 'AUTOREADY')
            self.AUTOREADY = AUTOREADY_
            # validate type AUTOREADY
            self.validate_AUTOREADY(self.AUTOREADY)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'BILLTOFIRSTNAME':
            BILLTOFIRSTNAME_ = child_.text
            BILLTOFIRSTNAME_ = self.gds_validate_string(BILLTOFIRSTNAME_, node, 'BILLTOFIRSTNAME')
            self.BILLTOFIRSTNAME = BILLTOFIRSTNAME_
            # validate type BILLTOFIRSTNAME
            self.validate_BILLTOFIRSTNAME(self.BILLTOFIRSTNAME)
        elif nodeName_ == 'BILLTOLASTNAME':
            BILLTOLASTNAME_ = child_.text
            BILLTOLASTNAME_ = self.gds_validate_string(BILLTOLASTNAME_, node, 'BILLTOLASTNAME')
            self.BILLTOLASTNAME = BILLTOLASTNAME_
            # validate type BILLTOLASTNAME
            self.validate_BILLTOLASTNAME(self.BILLTOLASTNAME)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'MOBILENUMBER':
            MOBILENUMBER_ = child_.text
            MOBILENUMBER_ = self.gds_validate_string(MOBILENUMBER_, node, 'MOBILENUMBER')
            self.MOBILENUMBER = MOBILENUMBER_
            # validate type MOBILENUMBER
            self.validate_MOBILENUMBER(self.MOBILENUMBER)
        elif nodeName_ == 'DEVICEID':
            DEVICEID_ = child_.text
            DEVICEID_ = self.gds_validate_string(DEVICEID_, node, 'DEVICEID')
            self.DEVICEID = DEVICEID_
            # validate type DEVICEID
            self.validate_DEVICEID(self.DEVICEID)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'IPADDRESS':
            IPADDRESS_ = child_.text
            IPADDRESS_ = self.gds_validate_string(IPADDRESS_, node, 'IPADDRESS')
            self.IPADDRESS = IPADDRESS_
            # validate type IPADDRESS
            self.validate_IPADDRESS(self.IPADDRESS)
        elif nodeName_ == 'SIGNATURE':
            SIGNATURE_ = child_.text
            SIGNATURE_ = self.gds_validate_string(SIGNATURE_, node, 'SIGNATURE')
            self.SIGNATURE = SIGNATURE_
            # validate type SIGNATURE
            self.validate_SIGNATURE(self.SIGNATURE)
        elif nodeName_ == 'CUSTOMFIELD':
            obj_ = CUSTOMFIELD.factory()
            obj_.build(child_)
            self.CUSTOMFIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOMFIELD'
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'LEVEL_3_DATA':
            obj_ = LEVEL_3_DATA.factory()
            obj_.build(child_)
            self.LEVEL_3_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_3_DATA'
        elif nodeName_ == 'ENHANCED_DATA_TEMPLATE':
            ENHANCED_DATA_TEMPLATE_ = child_.text
            ENHANCED_DATA_TEMPLATE_ = self.gds_validate_string(ENHANCED_DATA_TEMPLATE_, node, 'ENHANCED_DATA_TEMPLATE')
            self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE_
            # validate type ENHANCED_DATA_TEMPLATE
            self.validate_ENHANCED_DATA_TEMPLATE(self.ENHANCED_DATA_TEMPLATE)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        if self.ORDERID:
            hash_list.append(self.ORDERID)
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** -Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class OFFLINEPAYMENT


class PAYMENTACH(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALTYPE', ['TERMINALTYPE', 'xs:int'], 0, 0, {'ref': 'TERMINALTYPE', 'name': 'TERMINALTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('ACH_SECURE', ['ACH_SECURE', 'xs:string'], 0, 1, {'ref': 'ACH_SECURE', 'minOccurs': '0', 'name': 'ACH_SECURE', 'type': 'xs:string'}, None),
        MemberSpec_('SEC_CODE', ['SEC_CODE', 'xs:string'], 0, 0, {'ref': 'SEC_CODE', 'name': 'SEC_CODE', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_TYPE', ['ACCOUNT_TYPE', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_TYPE', 'minOccurs': '0', 'name': 'ACCOUNT_TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NUMBER', ['ACCOUNT_NUMBER', 'xs:string'], 0, 0, {'ref': 'ACCOUNT_NUMBER', 'name': 'ACCOUNT_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ROUTING_NUMBER', ['ROUTING_NUMBER', 'xs:string'], 0, 1, {'ref': 'ROUTING_NUMBER', 'minOccurs': '0', 'name': 'ROUTING_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NAME', ['ACCOUNT_NAME', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_NAME', 'minOccurs': '0', 'name': 'ACCOUNT_NAME', 'type': 'xs:string'}, None),
        MemberSpec_('CHECK_NUMBER', ['CHECK_NUMBER', 'xs:string'], 0, 1, {'ref': 'CHECK_NUMBER', 'minOccurs': '0', 'name': 'CHECK_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('IPADDRESS', ['IPADDRESS', 'xs:string'], 0, 1, {'ref': 'IPADDRESS', 'minOccurs': '0', 'name': 'IPADDRESS', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('DL_STATE', ['DL_STATE', 'xs:string'], 0, 1, {'ref': 'DL_STATE', 'minOccurs': '0', 'name': 'DL_STATE', 'type': 'xs:string'}, None),
        MemberSpec_('DL_NUMBER', ['DL_NUMBER', 'xs:string'], 0, 1, {'ref': 'DL_NUMBER', 'minOccurs': '0', 'name': 'DL_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, AMOUNT=None, CURRENCY=None, DATETIME=None, TERMINALTYPE=None, ACH_SECURE=None, SEC_CODE=None, ACCOUNT_TYPE=None, ACCOUNT_NUMBER=None, ROUTING_NUMBER=None, ACCOUNT_NAME=None, CHECK_NUMBER=None, ADDRESS1=None, ADDRESS2=None, CITY=None, REGION=None, POSTCODE=None, COUNTRY=None, PHONE=None, IPADDRESS=None, EMAIL=None, DESCRIPTION=None, DL_STATE=None, DL_NUMBER=None, HASH=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.TERMINALTYPE = TERMINALTYPE
        self.validate_TERMINALTYPE(self.TERMINALTYPE)
        self.ACH_SECURE = ACH_SECURE
        self.validate_ACH_SECURE(self.ACH_SECURE)
        self.SEC_CODE = SEC_CODE
        self.validate_SEC_CODE(self.SEC_CODE)
        self.ACCOUNT_TYPE = ACCOUNT_TYPE
        self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
        self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        self.ROUTING_NUMBER = ROUTING_NUMBER
        self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        self.ACCOUNT_NAME = ACCOUNT_NAME
        self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        self.CHECK_NUMBER = CHECK_NUMBER
        self.validate_CHECK_NUMBER(self.CHECK_NUMBER)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.IPADDRESS = IPADDRESS
        self.validate_IPADDRESS(self.IPADDRESS)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.DL_STATE = DL_STATE
        self.validate_DL_STATE(self.DL_STATE)
        self.DL_NUMBER = DL_NUMBER
        self.validate_DL_NUMBER(self.DL_NUMBER)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAYMENTACH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAYMENTACH.subclass:
            return PAYMENTACH.subclass(*args_, **kwargs_)
        else:
            return PAYMENTACH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_TERMINALTYPE(self): return self.TERMINALTYPE
    def set_TERMINALTYPE(self, TERMINALTYPE): self.TERMINALTYPE = TERMINALTYPE
    def get_ACH_SECURE(self): return self.ACH_SECURE
    def set_ACH_SECURE(self, ACH_SECURE): self.ACH_SECURE = ACH_SECURE
    def get_SEC_CODE(self): return self.SEC_CODE
    def set_SEC_CODE(self, SEC_CODE): self.SEC_CODE = SEC_CODE
    def get_ACCOUNT_TYPE(self): return self.ACCOUNT_TYPE
    def set_ACCOUNT_TYPE(self, ACCOUNT_TYPE): self.ACCOUNT_TYPE = ACCOUNT_TYPE
    def get_ACCOUNT_NUMBER(self): return self.ACCOUNT_NUMBER
    def set_ACCOUNT_NUMBER(self, ACCOUNT_NUMBER): self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
    def get_ROUTING_NUMBER(self): return self.ROUTING_NUMBER
    def set_ROUTING_NUMBER(self, ROUTING_NUMBER): self.ROUTING_NUMBER = ROUTING_NUMBER
    def get_ACCOUNT_NAME(self): return self.ACCOUNT_NAME
    def set_ACCOUNT_NAME(self, ACCOUNT_NAME): self.ACCOUNT_NAME = ACCOUNT_NAME
    def get_CHECK_NUMBER(self): return self.CHECK_NUMBER
    def set_CHECK_NUMBER(self, CHECK_NUMBER): self.CHECK_NUMBER = CHECK_NUMBER
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_IPADDRESS(self): return self.IPADDRESS
    def set_IPADDRESS(self, IPADDRESS): self.IPADDRESS = IPADDRESS
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_DL_STATE(self): return self.DL_STATE
    def set_DL_STATE(self, DL_STATE): self.DL_STATE = DL_STATE
    def get_DL_NUMBER(self): return self.DL_NUMBER
    def set_DL_NUMBER(self, DL_NUMBER): self.DL_NUMBER = DL_NUMBER
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_TERMINALTYPE(self, value):
        # Validate type TERMINALTYPE, a restriction on xs:int.
        pass
    def validate_ACH_SECURE(self, value):
        # Validate type ACH_SECURE, a restriction on xs:string.
        pass
    def validate_SEC_CODE(self, value):
        # Validate type SEC_CODE, a restriction on xs:string.
        pass
    def validate_ACCOUNT_TYPE(self, value):
        # Validate type ACCOUNT_TYPE, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NUMBER(self, value):
        # Validate type ACCOUNT_NUMBER, a restriction on xs:string.
        pass
    def validate_ROUTING_NUMBER(self, value):
        # Validate type ROUTING_NUMBER, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NAME(self, value):
        # Validate type ACCOUNT_NAME, a restriction on xs:string.
        pass
    def validate_CHECK_NUMBER(self, value):
        # Validate type CHECK_NUMBER, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_IPADDRESS(self, value):
        # Validate type IPADDRESS, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_DL_STATE(self, value):
        # Validate type DL_STATE, a restriction on xs:string.
        pass
    def validate_DL_NUMBER(self, value):
        # Validate type DL_NUMBER, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.CURRENCY is not None or
            self.DATETIME is not None or
            self.TERMINALTYPE is not None or
            self.ACH_SECURE is not None or
            self.SEC_CODE is not None or
            self.ACCOUNT_TYPE is not None or
            self.ACCOUNT_NUMBER is not None or
            self.ROUTING_NUMBER is not None or
            self.ACCOUNT_NAME is not None or
            self.CHECK_NUMBER is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.POSTCODE is not None or
            self.COUNTRY is not None or
            self.PHONE is not None or
            self.IPADDRESS is not None or
            self.EMAIL is not None or
            self.DESCRIPTION is not None or
            self.DL_STATE is not None or
            self.DL_NUMBER is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAYMENTACH', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.TERMINALTYPE is not None:
            TERMINALTYPE_ = self.TERMINALTYPE
            etree_.SubElement(element, '{}TERMINALTYPE').text = self.gds_format_integer(TERMINALTYPE_)
        if self.ACH_SECURE is not None:
            ACH_SECURE_ = self.ACH_SECURE
            etree_.SubElement(element, '{}ACH_SECURE').text = self.gds_format_string(ACH_SECURE_)
        if self.SEC_CODE is not None:
            SEC_CODE_ = self.SEC_CODE
            etree_.SubElement(element, '{}SEC_CODE').text = self.gds_format_string(SEC_CODE_)
        if self.ACCOUNT_TYPE is not None:
            ACCOUNT_TYPE_ = self.ACCOUNT_TYPE
            etree_.SubElement(element, '{}ACCOUNT_TYPE').text = self.gds_format_string(ACCOUNT_TYPE_)
        if self.ACCOUNT_NUMBER is not None:
            ACCOUNT_NUMBER_ = self.ACCOUNT_NUMBER
            etree_.SubElement(element, '{}ACCOUNT_NUMBER').text = self.gds_format_string(ACCOUNT_NUMBER_)
        if self.ROUTING_NUMBER is not None:
            ROUTING_NUMBER_ = self.ROUTING_NUMBER
            etree_.SubElement(element, '{}ROUTING_NUMBER').text = self.gds_format_string(ROUTING_NUMBER_)
        if self.ACCOUNT_NAME is not None:
            ACCOUNT_NAME_ = self.ACCOUNT_NAME
            etree_.SubElement(element, '{}ACCOUNT_NAME').text = self.gds_format_string(ACCOUNT_NAME_)
        if self.CHECK_NUMBER is not None:
            CHECK_NUMBER_ = self.CHECK_NUMBER
            etree_.SubElement(element, '{}CHECK_NUMBER').text = self.gds_format_string(CHECK_NUMBER_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.IPADDRESS is not None:
            IPADDRESS_ = self.IPADDRESS
            etree_.SubElement(element, '{}IPADDRESS').text = self.gds_format_string(IPADDRESS_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.DL_STATE is not None:
            DL_STATE_ = self.DL_STATE
            etree_.SubElement(element, '{}DL_STATE').text = self.gds_format_string(DL_STATE_)
        if self.DL_NUMBER is not None:
            DL_NUMBER_ = self.DL_NUMBER
            etree_.SubElement(element, '{}DL_NUMBER').text = self.gds_format_string(DL_NUMBER_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAYMENTACH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.TERMINALTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALTYPE=%d,\n' % self.TERMINALTYPE)
        if self.ACH_SECURE is not None:
            showIndent(outfile, level)
            outfile.write('ACH_SECURE=%s,\n' % self.gds_encode(quote_python(self.ACH_SECURE)))
        if self.SEC_CODE is not None:
            showIndent(outfile, level)
            outfile.write('SEC_CODE=%s,\n' % self.gds_encode(quote_python(self.SEC_CODE)))
        if self.ACCOUNT_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_TYPE=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_TYPE)))
        if self.ACCOUNT_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NUMBER)))
        if self.ROUTING_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ROUTING_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ROUTING_NUMBER)))
        if self.ACCOUNT_NAME is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NAME=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NAME)))
        if self.CHECK_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CHECK_NUMBER=%s,\n' % self.gds_encode(quote_python(self.CHECK_NUMBER)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.IPADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('IPADDRESS=%s,\n' % self.gds_encode(quote_python(self.IPADDRESS)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.DL_STATE is not None:
            showIndent(outfile, level)
            outfile.write('DL_STATE=%s,\n' % self.gds_encode(quote_python(self.DL_STATE)))
        if self.DL_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('DL_NUMBER=%s,\n' % self.gds_encode(quote_python(self.DL_NUMBER)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'TERMINALTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TERMINALTYPE')
            self.TERMINALTYPE = ival_
            # validate type TERMINALTYPE
            self.validate_TERMINALTYPE(self.TERMINALTYPE)
        elif nodeName_ == 'ACH_SECURE':
            ACH_SECURE_ = child_.text
            ACH_SECURE_ = self.gds_validate_string(ACH_SECURE_, node, 'ACH_SECURE')
            self.ACH_SECURE = ACH_SECURE_
            # validate type ACH_SECURE
            self.validate_ACH_SECURE(self.ACH_SECURE)
        elif nodeName_ == 'SEC_CODE':
            SEC_CODE_ = child_.text
            SEC_CODE_ = self.gds_validate_string(SEC_CODE_, node, 'SEC_CODE')
            self.SEC_CODE = SEC_CODE_
            # validate type SEC_CODE
            self.validate_SEC_CODE(self.SEC_CODE)
        elif nodeName_ == 'ACCOUNT_TYPE':
            ACCOUNT_TYPE_ = child_.text
            ACCOUNT_TYPE_ = self.gds_validate_string(ACCOUNT_TYPE_, node, 'ACCOUNT_TYPE')
            self.ACCOUNT_TYPE = ACCOUNT_TYPE_
            # validate type ACCOUNT_TYPE
            self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        elif nodeName_ == 'ACCOUNT_NUMBER':
            ACCOUNT_NUMBER_ = child_.text
            ACCOUNT_NUMBER_ = self.gds_validate_string(ACCOUNT_NUMBER_, node, 'ACCOUNT_NUMBER')
            self.ACCOUNT_NUMBER = ACCOUNT_NUMBER_
            # validate type ACCOUNT_NUMBER
            self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        elif nodeName_ == 'ROUTING_NUMBER':
            ROUTING_NUMBER_ = child_.text
            ROUTING_NUMBER_ = self.gds_validate_string(ROUTING_NUMBER_, node, 'ROUTING_NUMBER')
            self.ROUTING_NUMBER = ROUTING_NUMBER_
            # validate type ROUTING_NUMBER
            self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        elif nodeName_ == 'ACCOUNT_NAME':
            ACCOUNT_NAME_ = child_.text
            ACCOUNT_NAME_ = self.gds_validate_string(ACCOUNT_NAME_, node, 'ACCOUNT_NAME')
            self.ACCOUNT_NAME = ACCOUNT_NAME_
            # validate type ACCOUNT_NAME
            self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        elif nodeName_ == 'CHECK_NUMBER':
            CHECK_NUMBER_ = child_.text
            CHECK_NUMBER_ = self.gds_validate_string(CHECK_NUMBER_, node, 'CHECK_NUMBER')
            self.CHECK_NUMBER = CHECK_NUMBER_
            # validate type CHECK_NUMBER
            self.validate_CHECK_NUMBER(self.CHECK_NUMBER)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'IPADDRESS':
            IPADDRESS_ = child_.text
            IPADDRESS_ = self.gds_validate_string(IPADDRESS_, node, 'IPADDRESS')
            self.IPADDRESS = IPADDRESS_
            # validate type IPADDRESS
            self.validate_IPADDRESS(self.IPADDRESS)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'DL_STATE':
            DL_STATE_ = child_.text
            DL_STATE_ = self.gds_validate_string(DL_STATE_, node, 'DL_STATE')
            self.DL_STATE = DL_STATE_
            # validate type DL_STATE
            self.validate_DL_STATE(self.DL_STATE)
        elif nodeName_ == 'DL_NUMBER':
            DL_NUMBER_ = child_.text
            DL_NUMBER_ = self.gds_validate_string(DL_NUMBER_, node, 'DL_NUMBER')
            self.DL_NUMBER = DL_NUMBER_
            # validate type DL_NUMBER
            self.validate_DL_NUMBER(self.DL_NUMBER)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        if self.ORDERID:
            hash_list.append(self.ORDERID)
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** -Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class PAYMENTACH


class PAYMENTDIRECTDEBIT(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALTYPE', ['TERMINALTYPE', 'xs:int'], 0, 0, {'ref': 'TERMINALTYPE', 'name': 'TERMINALTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('DEBIT_DATE', ['DEBIT_DATE', 'xs:string'], 0, 0, {'ref': 'DEBIT_DATE', 'name': 'DEBIT_DATE', 'type': 'xs:string'}, None),
        MemberSpec_('ACH_SECURE', ['ACH_SECURE', 'xs:string'], 0, 1, {'ref': 'ACH_SECURE', 'minOccurs': '0', 'name': 'ACH_SECURE', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_TYPE', ['ACCOUNT_TYPE', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_TYPE', 'minOccurs': '0', 'name': 'ACCOUNT_TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NUMBER', ['ACCOUNT_NUMBER', 'xs:string'], 0, 0, {'ref': 'ACCOUNT_NUMBER', 'name': 'ACCOUNT_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('BSB_NUMBER', ['BSB_NUMBER', 'xs:string'], 0, 1, {'ref': 'BSB_NUMBER', 'minOccurs': '0', 'name': 'BSB_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NAME', ['ACCOUNT_NAME', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_NAME', 'minOccurs': '0', 'name': 'ACCOUNT_NAME', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('IPADDRESS', ['IPADDRESS', 'xs:string'], 0, 1, {'ref': 'IPADDRESS', 'minOccurs': '0', 'name': 'IPADDRESS', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, AMOUNT=None, CURRENCY=None, DATETIME=None, TERMINALTYPE=None, DEBIT_DATE=None, ACH_SECURE=None, ACCOUNT_TYPE=None, ACCOUNT_NUMBER=None, BSB_NUMBER=None, ACCOUNT_NAME=None, ADDRESS1=None, ADDRESS2=None, CITY=None, REGION=None, POSTCODE=None, COUNTRY=None, PHONE=None, IPADDRESS=None, EMAIL=None, DESCRIPTION=None, HASH=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.TERMINALTYPE = TERMINALTYPE
        self.validate_TERMINALTYPE(self.TERMINALTYPE)
        self.DEBIT_DATE = DEBIT_DATE
        self.validate_DEBIT_DATE(self.DEBIT_DATE)
        self.ACH_SECURE = ACH_SECURE
        self.validate_ACH_SECURE(self.ACH_SECURE)
        self.ACCOUNT_TYPE = ACCOUNT_TYPE
        self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
        self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        self.BSB_NUMBER = BSB_NUMBER
        self.validate_BSB_NUMBER(self.BSB_NUMBER)
        self.ACCOUNT_NAME = ACCOUNT_NAME
        self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.IPADDRESS = IPADDRESS
        self.validate_IPADDRESS(self.IPADDRESS)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAYMENTDIRECTDEBIT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAYMENTDIRECTDEBIT.subclass:
            return PAYMENTDIRECTDEBIT.subclass(*args_, **kwargs_)
        else:
            return PAYMENTDIRECTDEBIT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_TERMINALTYPE(self): return self.TERMINALTYPE
    def set_TERMINALTYPE(self, TERMINALTYPE): self.TERMINALTYPE = TERMINALTYPE
    def get_DEBIT_DATE(self): return self.DEBIT_DATE
    def set_DEBIT_DATE(self, DEBIT_DATE): self.DEBIT_DATE = DEBIT_DATE
    def get_ACH_SECURE(self): return self.ACH_SECURE
    def set_ACH_SECURE(self, ACH_SECURE): self.ACH_SECURE = ACH_SECURE
    def get_ACCOUNT_TYPE(self): return self.ACCOUNT_TYPE
    def set_ACCOUNT_TYPE(self, ACCOUNT_TYPE): self.ACCOUNT_TYPE = ACCOUNT_TYPE
    def get_ACCOUNT_NUMBER(self): return self.ACCOUNT_NUMBER
    def set_ACCOUNT_NUMBER(self, ACCOUNT_NUMBER): self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
    def get_BSB_NUMBER(self): return self.BSB_NUMBER
    def set_BSB_NUMBER(self, BSB_NUMBER): self.BSB_NUMBER = BSB_NUMBER
    def get_ACCOUNT_NAME(self): return self.ACCOUNT_NAME
    def set_ACCOUNT_NAME(self, ACCOUNT_NAME): self.ACCOUNT_NAME = ACCOUNT_NAME
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_IPADDRESS(self): return self.IPADDRESS
    def set_IPADDRESS(self, IPADDRESS): self.IPADDRESS = IPADDRESS
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_TERMINALTYPE(self, value):
        # Validate type TERMINALTYPE, a restriction on xs:int.
        pass
    def validate_DEBIT_DATE(self, value):
        # Validate type DEBIT_DATE, a restriction on xs:string.
        pass
    def validate_ACH_SECURE(self, value):
        # Validate type ACH_SECURE, a restriction on xs:string.
        pass
    def validate_ACCOUNT_TYPE(self, value):
        # Validate type ACCOUNT_TYPE, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NUMBER(self, value):
        # Validate type ACCOUNT_NUMBER, a restriction on xs:string.
        pass
    def validate_BSB_NUMBER(self, value):
        # Validate type BSB_NUMBER, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NAME(self, value):
        # Validate type ACCOUNT_NAME, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_IPADDRESS(self, value):
        # Validate type IPADDRESS, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.CURRENCY is not None or
            self.DATETIME is not None or
            self.TERMINALTYPE is not None or
            self.DEBIT_DATE is not None or
            self.ACH_SECURE is not None or
            self.ACCOUNT_TYPE is not None or
            self.ACCOUNT_NUMBER is not None or
            self.BSB_NUMBER is not None or
            self.ACCOUNT_NAME is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.POSTCODE is not None or
            self.COUNTRY is not None or
            self.PHONE is not None or
            self.IPADDRESS is not None or
            self.EMAIL is not None or
            self.DESCRIPTION is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAYMENTDIRECTDEBIT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.TERMINALTYPE is not None:
            TERMINALTYPE_ = self.TERMINALTYPE
            etree_.SubElement(element, '{}TERMINALTYPE').text = self.gds_format_integer(TERMINALTYPE_)
        if self.DEBIT_DATE is not None:
            DEBIT_DATE_ = self.DEBIT_DATE
            etree_.SubElement(element, '{}DEBIT_DATE').text = self.gds_format_string(DEBIT_DATE_)
        if self.ACH_SECURE is not None:
            ACH_SECURE_ = self.ACH_SECURE
            etree_.SubElement(element, '{}ACH_SECURE').text = self.gds_format_string(ACH_SECURE_)
        if self.ACCOUNT_TYPE is not None:
            ACCOUNT_TYPE_ = self.ACCOUNT_TYPE
            etree_.SubElement(element, '{}ACCOUNT_TYPE').text = self.gds_format_string(ACCOUNT_TYPE_)
        if self.ACCOUNT_NUMBER is not None:
            ACCOUNT_NUMBER_ = self.ACCOUNT_NUMBER
            etree_.SubElement(element, '{}ACCOUNT_NUMBER').text = self.gds_format_string(ACCOUNT_NUMBER_)
        if self.BSB_NUMBER is not None:
            BSB_NUMBER_ = self.BSB_NUMBER
            etree_.SubElement(element, '{}BSB_NUMBER').text = self.gds_format_string(BSB_NUMBER_)
        if self.ACCOUNT_NAME is not None:
            ACCOUNT_NAME_ = self.ACCOUNT_NAME
            etree_.SubElement(element, '{}ACCOUNT_NAME').text = self.gds_format_string(ACCOUNT_NAME_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.IPADDRESS is not None:
            IPADDRESS_ = self.IPADDRESS
            etree_.SubElement(element, '{}IPADDRESS').text = self.gds_format_string(IPADDRESS_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAYMENTDIRECTDEBIT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.TERMINALTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALTYPE=%d,\n' % self.TERMINALTYPE)
        if self.DEBIT_DATE is not None:
            showIndent(outfile, level)
            outfile.write('DEBIT_DATE=%s,\n' % self.gds_encode(quote_python(self.DEBIT_DATE)))
        if self.ACH_SECURE is not None:
            showIndent(outfile, level)
            outfile.write('ACH_SECURE=%s,\n' % self.gds_encode(quote_python(self.ACH_SECURE)))
        if self.ACCOUNT_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_TYPE=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_TYPE)))
        if self.ACCOUNT_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NUMBER)))
        if self.BSB_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('BSB_NUMBER=%s,\n' % self.gds_encode(quote_python(self.BSB_NUMBER)))
        if self.ACCOUNT_NAME is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NAME=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NAME)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.IPADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('IPADDRESS=%s,\n' % self.gds_encode(quote_python(self.IPADDRESS)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'TERMINALTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TERMINALTYPE')
            self.TERMINALTYPE = ival_
            # validate type TERMINALTYPE
            self.validate_TERMINALTYPE(self.TERMINALTYPE)
        elif nodeName_ == 'DEBIT_DATE':
            DEBIT_DATE_ = child_.text
            DEBIT_DATE_ = self.gds_validate_string(DEBIT_DATE_, node, 'DEBIT_DATE')
            self.DEBIT_DATE = DEBIT_DATE_
            # validate type DEBIT_DATE
            self.validate_DEBIT_DATE(self.DEBIT_DATE)
        elif nodeName_ == 'ACH_SECURE':
            ACH_SECURE_ = child_.text
            ACH_SECURE_ = self.gds_validate_string(ACH_SECURE_, node, 'ACH_SECURE')
            self.ACH_SECURE = ACH_SECURE_
            # validate type ACH_SECURE
            self.validate_ACH_SECURE(self.ACH_SECURE)
        elif nodeName_ == 'ACCOUNT_TYPE':
            ACCOUNT_TYPE_ = child_.text
            ACCOUNT_TYPE_ = self.gds_validate_string(ACCOUNT_TYPE_, node, 'ACCOUNT_TYPE')
            self.ACCOUNT_TYPE = ACCOUNT_TYPE_
            # validate type ACCOUNT_TYPE
            self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        elif nodeName_ == 'ACCOUNT_NUMBER':
            ACCOUNT_NUMBER_ = child_.text
            ACCOUNT_NUMBER_ = self.gds_validate_string(ACCOUNT_NUMBER_, node, 'ACCOUNT_NUMBER')
            self.ACCOUNT_NUMBER = ACCOUNT_NUMBER_
            # validate type ACCOUNT_NUMBER
            self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        elif nodeName_ == 'BSB_NUMBER':
            BSB_NUMBER_ = child_.text
            BSB_NUMBER_ = self.gds_validate_string(BSB_NUMBER_, node, 'BSB_NUMBER')
            self.BSB_NUMBER = BSB_NUMBER_
            # validate type BSB_NUMBER
            self.validate_BSB_NUMBER(self.BSB_NUMBER)
        elif nodeName_ == 'ACCOUNT_NAME':
            ACCOUNT_NAME_ = child_.text
            ACCOUNT_NAME_ = self.gds_validate_string(ACCOUNT_NAME_, node, 'ACCOUNT_NAME')
            self.ACCOUNT_NAME = ACCOUNT_NAME_
            # validate type ACCOUNT_NAME
            self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'IPADDRESS':
            IPADDRESS_ = child_.text
            IPADDRESS_ = self.gds_validate_string(IPADDRESS_, node, 'IPADDRESS')
            self.IPADDRESS = IPADDRESS_
            # validate type IPADDRESS
            self.validate_IPADDRESS(self.IPADDRESS)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        if self.ORDERID:
            hash_list.append(self.ORDERID)
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** -Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class PAYMENTDIRECTDEBIT


class RESPONSECODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RESPONSECODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RESPONSECODE.subclass:
            return RESPONSECODE.subclass(*args_, **kwargs_)
        else:
            return RESPONSECODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RESPONSECODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RESPONSECODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RESPONSECODE


class RESPONSETEXT(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RESPONSETEXT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RESPONSETEXT.subclass:
            return RESPONSETEXT.subclass(*args_, **kwargs_)
        else:
            return RESPONSETEXT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RESPONSETEXT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RESPONSETEXT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RESPONSETEXT


class APPROVALCODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, APPROVALCODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if APPROVALCODE.subclass:
            return APPROVALCODE.subclass(*args_, **kwargs_)
        else:
            return APPROVALCODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='APPROVALCODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='APPROVALCODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class APPROVALCODE


class BANKRESPONSECODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BANKRESPONSECODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BANKRESPONSECODE.subclass:
            return BANKRESPONSECODE.subclass(*args_, **kwargs_)
        else:
            return BANKRESPONSECODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BANKRESPONSECODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BANKRESPONSECODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BANKRESPONSECODE


class AVSRESPONSE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AVSRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AVSRESPONSE.subclass:
            return AVSRESPONSE.subclass(*args_, **kwargs_)
        else:
            return AVSRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AVSRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AVSRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AVSRESPONSE


class CVVRESPONSE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CVVRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CVVRESPONSE.subclass:
            return CVVRESPONSE.subclass(*args_, **kwargs_)
        else:
            return CVVRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CVVRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CVVRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CVVRESPONSE


class PAYMENTRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('BANKRESPONSECODE', ['BANKRESPONSECODE', 'xs:string'], 0, 1, {'ref': 'BANKRESPONSECODE', 'minOccurs': '0', 'name': 'BANKRESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('MASKEDCARDNUMBER', ['MASKEDCARDNUMBER', 'xs:string'], 0, 1, {'ref': 'MASKEDCARDNUMBER', 'minOccurs': '0', 'name': 'MASKEDCARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('AUTHORIZEDAMOUNT', 'xs:double', 0, 1, {'ref': 'AUTHORIZEDAMOUNT', 'minOccurs': '0', 'name': 'AUTHORIZEDAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('SURCHARGE_FEE', 'xs:double', 0, 1, {'ref': 'SURCHARGE_FEE', 'minOccurs': '0', 'name': 'SURCHARGE_FEE', 'type': 'xs:double'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('AVSRESPONSE', ['AVSRESPONSE', 'xs:string'], 0, 1, {'ref': 'AVSRESPONSE', 'minOccurs': '0', 'name': 'AVSRESPONSE', 'type': 'xs:string'}, None),
        MemberSpec_('CVVRESPONSE', ['CVVRESPONSE', 'xs:string'], 0, 1, {'ref': 'CVVRESPONSE', 'minOccurs': '0', 'name': 'CVVRESPONSE', 'type': 'xs:string'}, None),
        MemberSpec_('PROCESSINGTERMINAL', ['PROCESSINGTERMINAL', 'xs:string'], 0, 1, {'ref': 'PROCESSINGTERMINAL', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PROCESSINGTERMINAL', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', ['CARDREFERENCE', 'xs:string'], 0, 1, {'ref': 'CARDREFERENCE', 'minOccurs': '0', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 1, {'ref': 'MERCHANTREF', 'minOccurs': '0', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ADDITIONAL_FIELD', 'ADDITIONAL_FIELD', 1, 1, {'ref': 'ADDITIONAL_FIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'ADDITIONAL_FIELD', 'type': 'ADDITIONAL_FIELD'}, None),
        MemberSpec_('FRAUDREVIEWRESPONSE', 'FRAUDREVIEWRESPONSE', 0, 1, {'ref': 'FRAUDREVIEWRESPONSE', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'FRAUDREVIEWRESPONSE', 'type': 'FRAUDREVIEWRESPONSE'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, APPROVALCODE=None, BANKRESPONSECODE=None, MASKEDCARDNUMBER=None, AUTHORIZEDAMOUNT=None, SURCHARGE_FEE=None, DATETIME=None, AVSRESPONSE=None, CVVRESPONSE=None, PROCESSINGTERMINAL=None, CARDREFERENCE=None, MERCHANTREF=None, ADDITIONAL_FIELD=None, FRAUDREVIEWRESPONSE=None, CREDENTIALONFILE=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.BANKRESPONSECODE = BANKRESPONSECODE
        self.validate_BANKRESPONSECODE(self.BANKRESPONSECODE)
        self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
        self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        self.AUTHORIZEDAMOUNT = AUTHORIZEDAMOUNT
        self.SURCHARGE_FEE = SURCHARGE_FEE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.AVSRESPONSE = AVSRESPONSE
        self.validate_AVSRESPONSE(self.AVSRESPONSE)
        self.CVVRESPONSE = CVVRESPONSE
        self.validate_CVVRESPONSE(self.CVVRESPONSE)
        self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
        self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        self.CARDREFERENCE = CARDREFERENCE
        self.validate_CARDREFERENCE(self.CARDREFERENCE)
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        if ADDITIONAL_FIELD is None:
            self.ADDITIONAL_FIELD = []
        else:
            self.ADDITIONAL_FIELD = ADDITIONAL_FIELD
        self.FRAUDREVIEWRESPONSE = FRAUDREVIEWRESPONSE
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAYMENTRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAYMENTRESPONSE.subclass:
            return PAYMENTRESPONSE.subclass(*args_, **kwargs_)
        else:
            return PAYMENTRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_BANKRESPONSECODE(self): return self.BANKRESPONSECODE
    def set_BANKRESPONSECODE(self, BANKRESPONSECODE): self.BANKRESPONSECODE = BANKRESPONSECODE
    def get_MASKEDCARDNUMBER(self): return self.MASKEDCARDNUMBER
    def set_MASKEDCARDNUMBER(self, MASKEDCARDNUMBER): self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
    def get_AUTHORIZEDAMOUNT(self): return self.AUTHORIZEDAMOUNT
    def set_AUTHORIZEDAMOUNT(self, AUTHORIZEDAMOUNT): self.AUTHORIZEDAMOUNT = AUTHORIZEDAMOUNT
    def get_SURCHARGE_FEE(self): return self.SURCHARGE_FEE
    def set_SURCHARGE_FEE(self, SURCHARGE_FEE): self.SURCHARGE_FEE = SURCHARGE_FEE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_AVSRESPONSE(self): return self.AVSRESPONSE
    def set_AVSRESPONSE(self, AVSRESPONSE): self.AVSRESPONSE = AVSRESPONSE
    def get_CVVRESPONSE(self): return self.CVVRESPONSE
    def set_CVVRESPONSE(self, CVVRESPONSE): self.CVVRESPONSE = CVVRESPONSE
    def get_PROCESSINGTERMINAL(self): return self.PROCESSINGTERMINAL
    def set_PROCESSINGTERMINAL(self, PROCESSINGTERMINAL): self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_ADDITIONAL_FIELD(self): return self.ADDITIONAL_FIELD
    def set_ADDITIONAL_FIELD(self, ADDITIONAL_FIELD): self.ADDITIONAL_FIELD = ADDITIONAL_FIELD
    def add_ADDITIONAL_FIELD(self, value): self.ADDITIONAL_FIELD.append(value)
    def insert_ADDITIONAL_FIELD_at(self, index, value): self.ADDITIONAL_FIELD.insert(index, value)
    def replace_ADDITIONAL_FIELD_at(self, index, value): self.ADDITIONAL_FIELD[index] = value
    def get_FRAUDREVIEWRESPONSE(self): return self.FRAUDREVIEWRESPONSE
    def set_FRAUDREVIEWRESPONSE(self, FRAUDREVIEWRESPONSE): self.FRAUDREVIEWRESPONSE = FRAUDREVIEWRESPONSE
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_BANKRESPONSECODE(self, value):
        # Validate type BANKRESPONSECODE, a restriction on xs:string.
        pass
    def validate_MASKEDCARDNUMBER(self, value):
        # Validate type MASKEDCARDNUMBER, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_AVSRESPONSE(self, value):
        # Validate type AVSRESPONSE, a restriction on xs:string.
        pass
    def validate_CVVRESPONSE(self, value):
        # Validate type CVVRESPONSE, a restriction on xs:string.
        pass
    def validate_PROCESSINGTERMINAL(self, value):
        # Validate type PROCESSINGTERMINAL, a restriction on xs:string.
        pass
    def validate_CARDREFERENCE(self, value):
        # Validate type CARDREFERENCE, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.APPROVALCODE is not None or
            self.BANKRESPONSECODE is not None or
            self.MASKEDCARDNUMBER is not None or
            self.AUTHORIZEDAMOUNT is not None or
            self.SURCHARGE_FEE is not None or
            self.DATETIME is not None or
            self.AVSRESPONSE is not None or
            self.CVVRESPONSE is not None or
            self.PROCESSINGTERMINAL is not None or
            self.CARDREFERENCE is not None or
            self.MERCHANTREF is not None or
            self.ADDITIONAL_FIELD or
            self.FRAUDREVIEWRESPONSE is not None or
            self.CREDENTIALONFILE is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAYMENTRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.BANKRESPONSECODE is not None:
            BANKRESPONSECODE_ = self.BANKRESPONSECODE
            etree_.SubElement(element, '{}BANKRESPONSECODE').text = self.gds_format_string(BANKRESPONSECODE_)
        if self.MASKEDCARDNUMBER is not None:
            MASKEDCARDNUMBER_ = self.MASKEDCARDNUMBER
            etree_.SubElement(element, '{}MASKEDCARDNUMBER').text = self.gds_format_string(MASKEDCARDNUMBER_)
        if self.AUTHORIZEDAMOUNT is not None:
            AUTHORIZEDAMOUNT_ = self.AUTHORIZEDAMOUNT
            etree_.SubElement(element, '{}AUTHORIZEDAMOUNT').text = self.gds_format_double(AUTHORIZEDAMOUNT_)
        if self.SURCHARGE_FEE is not None:
            SURCHARGE_FEE_ = self.SURCHARGE_FEE
            etree_.SubElement(element, '{}SURCHARGE_FEE').text = self.gds_format_double(SURCHARGE_FEE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.AVSRESPONSE is not None:
            AVSRESPONSE_ = self.AVSRESPONSE
            etree_.SubElement(element, '{}AVSRESPONSE').text = self.gds_format_string(AVSRESPONSE_)
        if self.CVVRESPONSE is not None:
            CVVRESPONSE_ = self.CVVRESPONSE
            etree_.SubElement(element, '{}CVVRESPONSE').text = self.gds_format_string(CVVRESPONSE_)
        if self.PROCESSINGTERMINAL is not None:
            PROCESSINGTERMINAL_ = self.PROCESSINGTERMINAL
            etree_.SubElement(element, '{}PROCESSINGTERMINAL').text = self.gds_format_string(PROCESSINGTERMINAL_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        for ADDITIONAL_FIELD_ in self.ADDITIONAL_FIELD:
            ADDITIONAL_FIELD_.to_etree(element, name_='ADDITIONAL_FIELD', mapping_=mapping_)
        if self.FRAUDREVIEWRESPONSE is not None:
            FRAUDREVIEWRESPONSE_ = self.FRAUDREVIEWRESPONSE
            FRAUDREVIEWRESPONSE_.to_etree(element, name_='FRAUDREVIEWRESPONSE', mapping_=mapping_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAYMENTRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.BANKRESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('BANKRESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.BANKRESPONSECODE)))
        if self.MASKEDCARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('MASKEDCARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.MASKEDCARDNUMBER)))
        if self.AUTHORIZEDAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AUTHORIZEDAMOUNT=%e,\n' % self.AUTHORIZEDAMOUNT)
        if self.SURCHARGE_FEE is not None:
            showIndent(outfile, level)
            outfile.write('SURCHARGE_FEE=%e,\n' % self.SURCHARGE_FEE)
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.AVSRESPONSE is not None:
            showIndent(outfile, level)
            outfile.write('AVSRESPONSE=%s,\n' % self.gds_encode(quote_python(self.AVSRESPONSE)))
        if self.CVVRESPONSE is not None:
            showIndent(outfile, level)
            outfile.write('CVVRESPONSE=%s,\n' % self.gds_encode(quote_python(self.CVVRESPONSE)))
        if self.PROCESSINGTERMINAL is not None:
            showIndent(outfile, level)
            outfile.write('PROCESSINGTERMINAL=%s,\n' % self.gds_encode(quote_python(self.PROCESSINGTERMINAL)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        showIndent(outfile, level)
        outfile.write('ADDITIONAL_FIELD=[\n')
        level += 1
        for ADDITIONAL_FIELD_ in self.ADDITIONAL_FIELD:
            showIndent(outfile, level)
            outfile.write('model_.ADDITIONAL_FIELD(\n')
            ADDITIONAL_FIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FRAUDREVIEWRESPONSE is not None:
            showIndent(outfile, level)
            outfile.write('FRAUDREVIEWRESPONSE=model_.FRAUDREVIEWRESPONSE(\n')
            self.FRAUDREVIEWRESPONSE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'BANKRESPONSECODE':
            BANKRESPONSECODE_ = child_.text
            BANKRESPONSECODE_ = self.gds_validate_string(BANKRESPONSECODE_, node, 'BANKRESPONSECODE')
            self.BANKRESPONSECODE = BANKRESPONSECODE_
            # validate type BANKRESPONSECODE
            self.validate_BANKRESPONSECODE(self.BANKRESPONSECODE)
        elif nodeName_ == 'MASKEDCARDNUMBER':
            MASKEDCARDNUMBER_ = child_.text
            MASKEDCARDNUMBER_ = self.gds_validate_string(MASKEDCARDNUMBER_, node, 'MASKEDCARDNUMBER')
            self.MASKEDCARDNUMBER = MASKEDCARDNUMBER_
            # validate type MASKEDCARDNUMBER
            self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        elif nodeName_ == 'AUTHORIZEDAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AUTHORIZEDAMOUNT')
            self.AUTHORIZEDAMOUNT = fval_
        elif nodeName_ == 'SURCHARGE_FEE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SURCHARGE_FEE')
            self.SURCHARGE_FEE = fval_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'AVSRESPONSE':
            AVSRESPONSE_ = child_.text
            AVSRESPONSE_ = self.gds_validate_string(AVSRESPONSE_, node, 'AVSRESPONSE')
            self.AVSRESPONSE = AVSRESPONSE_
            # validate type AVSRESPONSE
            self.validate_AVSRESPONSE(self.AVSRESPONSE)
        elif nodeName_ == 'CVVRESPONSE':
            CVVRESPONSE_ = child_.text
            CVVRESPONSE_ = self.gds_validate_string(CVVRESPONSE_, node, 'CVVRESPONSE')
            self.CVVRESPONSE = CVVRESPONSE_
            # validate type CVVRESPONSE
            self.validate_CVVRESPONSE(self.CVVRESPONSE)
        elif nodeName_ == 'PROCESSINGTERMINAL':
            PROCESSINGTERMINAL_ = child_.text
            PROCESSINGTERMINAL_ = self.gds_validate_string(PROCESSINGTERMINAL_, node, 'PROCESSINGTERMINAL')
            self.PROCESSINGTERMINAL = PROCESSINGTERMINAL_
            # validate type PROCESSINGTERMINAL
            self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
            # validate type CARDREFERENCE
            self.validate_CARDREFERENCE(self.CARDREFERENCE)
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'ADDITIONAL_FIELD':
            obj_ = ADDITIONAL_FIELD.factory()
            obj_.build(child_)
            self.ADDITIONAL_FIELD.append(obj_)
            obj_.original_tagname_ = 'ADDITIONAL_FIELD'
        elif nodeName_ == 'FRAUDREVIEWRESPONSE':
            obj_ = FRAUDREVIEWRESPONSE.factory()
            obj_.build(child_)
            self.FRAUDREVIEWRESPONSE = obj_
            obj_.original_tagname_ = 'FRAUDREVIEWRESPONSE'
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.terminal_id, self.UNIQUEREF]
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        hash_list.append(self.RESPONSECODE)
        hash_list.append(self.RESPONSETEXT)
        if self.BANKRESPONSECODE:
            hash_list.append(self.BANKRESPONSECODE)
        hash_list.append(self.SECRET)
        return ':'.join(hash_list)
# end class PAYMENTRESPONSE


class OFFLINEPAYMENTRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('MASKEDCARDNUMBER', ['MASKEDCARDNUMBER', 'xs:string'], 0, 1, {'ref': 'MASKEDCARDNUMBER', 'minOccurs': '0', 'name': 'MASKEDCARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('PROCESSINGTERMINAL', ['PROCESSINGTERMINAL', 'xs:string'], 0, 1, {'ref': 'PROCESSINGTERMINAL', 'minOccurs': '0', 'name': 'PROCESSINGTERMINAL', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', ['CARDREFERENCE', 'xs:string'], 0, 1, {'ref': 'CARDREFERENCE', 'minOccurs': '0', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 1, {'ref': 'MERCHANTREF', 'minOccurs': '0', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ADDITIONAL_FIELD', 'ADDITIONAL_FIELD', 1, 1, {'ref': 'ADDITIONAL_FIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'ADDITIONAL_FIELD', 'type': 'ADDITIONAL_FIELD'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, APPROVALCODE=None, MASKEDCARDNUMBER=None, DATETIME=None, PROCESSINGTERMINAL=None, CARDREFERENCE=None, MERCHANTREF=None, ADDITIONAL_FIELD=None, CREDENTIALONFILE=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
        self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
        self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        self.CARDREFERENCE = CARDREFERENCE
        self.validate_CARDREFERENCE(self.CARDREFERENCE)
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        if ADDITIONAL_FIELD is None:
            self.ADDITIONAL_FIELD = []
        else:
            self.ADDITIONAL_FIELD = ADDITIONAL_FIELD
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OFFLINEPAYMENTRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OFFLINEPAYMENTRESPONSE.subclass:
            return OFFLINEPAYMENTRESPONSE.subclass(*args_, **kwargs_)
        else:
            return OFFLINEPAYMENTRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_MASKEDCARDNUMBER(self): return self.MASKEDCARDNUMBER
    def set_MASKEDCARDNUMBER(self, MASKEDCARDNUMBER): self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_PROCESSINGTERMINAL(self): return self.PROCESSINGTERMINAL
    def set_PROCESSINGTERMINAL(self, PROCESSINGTERMINAL): self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_ADDITIONAL_FIELD(self): return self.ADDITIONAL_FIELD
    def set_ADDITIONAL_FIELD(self, ADDITIONAL_FIELD): self.ADDITIONAL_FIELD = ADDITIONAL_FIELD
    def add_ADDITIONAL_FIELD(self, value): self.ADDITIONAL_FIELD.append(value)
    def insert_ADDITIONAL_FIELD_at(self, index, value): self.ADDITIONAL_FIELD.insert(index, value)
    def replace_ADDITIONAL_FIELD_at(self, index, value): self.ADDITIONAL_FIELD[index] = value
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_MASKEDCARDNUMBER(self, value):
        # Validate type MASKEDCARDNUMBER, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_PROCESSINGTERMINAL(self, value):
        # Validate type PROCESSINGTERMINAL, a restriction on xs:string.
        pass
    def validate_CARDREFERENCE(self, value):
        # Validate type CARDREFERENCE, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.APPROVALCODE is not None or
            self.MASKEDCARDNUMBER is not None or
            self.DATETIME is not None or
            self.PROCESSINGTERMINAL is not None or
            self.CARDREFERENCE is not None or
            self.MERCHANTREF is not None or
            self.ADDITIONAL_FIELD or
            self.CREDENTIALONFILE is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='OFFLINEPAYMENTRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.MASKEDCARDNUMBER is not None:
            MASKEDCARDNUMBER_ = self.MASKEDCARDNUMBER
            etree_.SubElement(element, '{}MASKEDCARDNUMBER').text = self.gds_format_string(MASKEDCARDNUMBER_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.PROCESSINGTERMINAL is not None:
            PROCESSINGTERMINAL_ = self.PROCESSINGTERMINAL
            etree_.SubElement(element, '{}PROCESSINGTERMINAL').text = self.gds_format_string(PROCESSINGTERMINAL_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        for ADDITIONAL_FIELD_ in self.ADDITIONAL_FIELD:
            ADDITIONAL_FIELD_.to_etree(element, name_='ADDITIONAL_FIELD', mapping_=mapping_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='OFFLINEPAYMENTRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.MASKEDCARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('MASKEDCARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.MASKEDCARDNUMBER)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.PROCESSINGTERMINAL is not None:
            showIndent(outfile, level)
            outfile.write('PROCESSINGTERMINAL=%s,\n' % self.gds_encode(quote_python(self.PROCESSINGTERMINAL)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        showIndent(outfile, level)
        outfile.write('ADDITIONAL_FIELD=[\n')
        level += 1
        for ADDITIONAL_FIELD_ in self.ADDITIONAL_FIELD:
            showIndent(outfile, level)
            outfile.write('model_.ADDITIONAL_FIELD(\n')
            ADDITIONAL_FIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'MASKEDCARDNUMBER':
            MASKEDCARDNUMBER_ = child_.text
            MASKEDCARDNUMBER_ = self.gds_validate_string(MASKEDCARDNUMBER_, node, 'MASKEDCARDNUMBER')
            self.MASKEDCARDNUMBER = MASKEDCARDNUMBER_
            # validate type MASKEDCARDNUMBER
            self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'PROCESSINGTERMINAL':
            PROCESSINGTERMINAL_ = child_.text
            PROCESSINGTERMINAL_ = self.gds_validate_string(PROCESSINGTERMINAL_, node, 'PROCESSINGTERMINAL')
            self.PROCESSINGTERMINAL = PROCESSINGTERMINAL_
            # validate type PROCESSINGTERMINAL
            self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
            # validate type CARDREFERENCE
            self.validate_CARDREFERENCE(self.CARDREFERENCE)
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'ADDITIONAL_FIELD':
            obj_ = ADDITIONAL_FIELD.factory()
            obj_.build(child_)
            self.ADDITIONAL_FIELD.append(obj_)
            obj_.original_tagname_ = 'ADDITIONAL_FIELD'
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.terminal_id, self.UNIQUEREF]
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        hash_list.append(self.RESPONSECODE)
        hash_list.append(self.RESPONSETEXT)
        if self.BANKRESPONSECODE:
            hash_list.append(self.BANKRESPONSECODE)
        hash_list.append(self.SECRET)
        return ':'.join(hash_list)
# end class OFFLINEPAYMENTRESPONSE


class PAYMENTACHRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, APPROVALCODE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAYMENTACHRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAYMENTACHRESPONSE.subclass:
            return PAYMENTACHRESPONSE.subclass(*args_, **kwargs_)
        else:
            return PAYMENTACHRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.APPROVALCODE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAYMENTACHRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAYMENTACHRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.terminal_id, self.UNIQUEREF]
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        hash_list.append(self.RESPONSECODE)
        hash_list.append(self.RESPONSETEXT)
        if self.BANKRESPONSECODE:
            hash_list.append(self.BANKRESPONSECODE)
        hash_list.append(self.SECRET)
        return ':'.join(hash_list)
# end class PAYMENTACHRESPONSE


class ERRORSTRING(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ERRORSTRING)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ERRORSTRING.subclass:
            return ERRORSTRING.subclass(*args_, **kwargs_)
        else:
            return ERRORSTRING(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ERRORSTRING', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ERRORSTRING'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ERRORSTRING


class ERRORCODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ERRORCODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ERRORCODE.subclass:
            return ERRORCODE.subclass(*args_, **kwargs_)
        else:
            return ERRORCODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ERRORCODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ERRORCODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ERRORCODE


class ERROR(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ERRORCODE', ['ERRORCODE', 'xs:string'], 0, 1, {'ref': 'ERRORCODE', 'minOccurs': '0', 'name': 'ERRORCODE', 'type': 'xs:string'}, None),
        MemberSpec_('ERRORSTRING', ['ERRORSTRING', 'xs:string'], 0, 0, {'ref': 'ERRORSTRING', 'name': 'ERRORSTRING', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ERRORCODE=None, ERRORSTRING=None):
        self.original_tagname_ = None
        self.ERRORCODE = ERRORCODE
        self.validate_ERRORCODE(self.ERRORCODE)
        self.ERRORSTRING = ERRORSTRING
        self.validate_ERRORSTRING(self.ERRORSTRING)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ERROR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ERROR.subclass:
            return ERROR.subclass(*args_, **kwargs_)
        else:
            return ERROR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ERRORCODE(self): return self.ERRORCODE
    def set_ERRORCODE(self, ERRORCODE): self.ERRORCODE = ERRORCODE
    def get_ERRORSTRING(self): return self.ERRORSTRING
    def set_ERRORSTRING(self, ERRORSTRING): self.ERRORSTRING = ERRORSTRING
    def validate_ERRORCODE(self, value):
        # Validate type ERRORCODE, a restriction on xs:string.
        pass
    def validate_ERRORSTRING(self, value):
        # Validate type ERRORSTRING, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ERRORCODE is not None or
            self.ERRORSTRING is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ERROR', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ERRORCODE is not None:
            ERRORCODE_ = self.ERRORCODE
            etree_.SubElement(element, '{}ERRORCODE').text = self.gds_format_string(ERRORCODE_)
        if self.ERRORSTRING is not None:
            ERRORSTRING_ = self.ERRORSTRING
            etree_.SubElement(element, '{}ERRORSTRING').text = self.gds_format_string(ERRORSTRING_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ERROR'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ERRORCODE is not None:
            showIndent(outfile, level)
            outfile.write('ERRORCODE=%s,\n' % self.gds_encode(quote_python(self.ERRORCODE)))
        if self.ERRORSTRING is not None:
            showIndent(outfile, level)
            outfile.write('ERRORSTRING=%s,\n' % self.gds_encode(quote_python(self.ERRORSTRING)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ERRORCODE':
            ERRORCODE_ = child_.text
            ERRORCODE_ = self.gds_validate_string(ERRORCODE_, node, 'ERRORCODE')
            self.ERRORCODE = ERRORCODE_
            # validate type ERRORCODE
            self.validate_ERRORCODE(self.ERRORCODE)
        elif nodeName_ == 'ERRORSTRING':
            ERRORSTRING_ = child_.text
            ERRORSTRING_ = self.gds_validate_string(ERRORSTRING_, node, 'ERRORSTRING')
            self.ERRORSTRING = ERRORSTRING_
            # validate type ERRORSTRING
            self.validate_ERRORSTRING(self.ERRORSTRING)
# end class ERROR


class OPERATOR(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPERATOR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPERATOR.subclass:
            return OPERATOR.subclass(*args_, **kwargs_)
        else:
            return OPERATOR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='OPERATOR', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='OPERATOR'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPERATOR


class REASON(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REASON)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REASON.subclass:
            return REASON.subclass(*args_, **kwargs_)
        else:
            return REASON(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='REASON', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='REASON'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class REASON


class PAREFERENCENUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAREFERENCENUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAREFERENCENUMBER.subclass:
            return PAREFERENCENUMBER.subclass(*args_, **kwargs_)
        else:
            return PAREFERENCENUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAREFERENCENUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAREFERENCENUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PAREFERENCENUMBER


class REFUND(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, 3),
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, 3),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('OPERATOR', ['OPERATOR', 'xs:string'], 0, 0, {'ref': 'OPERATOR', 'name': 'OPERATOR', 'type': 'xs:string'}, None),
        MemberSpec_('REASON', ['REASON', 'xs:string'], 0, 0, {'ref': 'REASON', 'name': 'REASON', 'type': 'xs:string'}, None),
        MemberSpec_('AUTOREADY', ['AUTOREADY', 'xs:string'], 0, 1, {'ref': 'AUTOREADY', 'minOccurs': '0', 'name': 'AUTOREADY', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, ORDERID=None, TERMINALID=None, AMOUNT=None, DATETIME=None, HASH=None, OPERATOR=None, REASON=None, AUTOREADY=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.OPERATOR = OPERATOR
        self.validate_OPERATOR(self.OPERATOR)
        self.REASON = REASON
        self.validate_REASON(self.REASON)
        self.AUTOREADY = AUTOREADY
        self.validate_AUTOREADY(self.AUTOREADY)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REFUND)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REFUND.subclass:
            return REFUND.subclass(*args_, **kwargs_)
        else:
            return REFUND(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_OPERATOR(self): return self.OPERATOR
    def set_OPERATOR(self, OPERATOR): self.OPERATOR = OPERATOR
    def get_REASON(self): return self.REASON
    def set_REASON(self, REASON): self.REASON = REASON
    def get_AUTOREADY(self): return self.AUTOREADY
    def set_AUTOREADY(self, AUTOREADY): self.AUTOREADY = AUTOREADY
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_OPERATOR(self, value):
        # Validate type OPERATOR, a restriction on xs:string.
        pass
    def validate_REASON(self, value):
        # Validate type REASON, a restriction on xs:string.
        pass
    def validate_AUTOREADY(self, value):
        # Validate type AUTOREADY, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.DATETIME is not None or
            self.HASH is not None or
            self.OPERATOR is not None or
            self.REASON is not None or
            self.AUTOREADY is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='REFUND', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.OPERATOR is not None:
            OPERATOR_ = self.OPERATOR
            etree_.SubElement(element, '{}OPERATOR').text = self.gds_format_string(OPERATOR_)
        if self.REASON is not None:
            REASON_ = self.REASON
            etree_.SubElement(element, '{}REASON').text = self.gds_format_string(REASON_)
        if self.AUTOREADY is not None:
            AUTOREADY_ = self.AUTOREADY
            etree_.SubElement(element, '{}AUTOREADY').text = self.gds_format_string(AUTOREADY_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='REFUND'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.OPERATOR is not None:
            showIndent(outfile, level)
            outfile.write('OPERATOR=%s,\n' % self.gds_encode(quote_python(self.OPERATOR)))
        if self.REASON is not None:
            showIndent(outfile, level)
            outfile.write('REASON=%s,\n' % self.gds_encode(quote_python(self.REASON)))
        if self.AUTOREADY is not None:
            showIndent(outfile, level)
            outfile.write('AUTOREADY=%s,\n' % self.gds_encode(quote_python(self.AUTOREADY)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'OPERATOR':
            OPERATOR_ = child_.text
            OPERATOR_ = self.gds_validate_string(OPERATOR_, node, 'OPERATOR')
            self.OPERATOR = OPERATOR_
            # validate type OPERATOR
            self.validate_OPERATOR(self.OPERATOR)
        elif nodeName_ == 'REASON':
            REASON_ = child_.text
            REASON_ = self.gds_validate_string(REASON_, node, 'REASON')
            self.REASON = REASON_
            # validate type REASON
            self.validate_REASON(self.REASON)
        elif nodeName_ == 'AUTOREADY':
            AUTOREADY_ = child_.text
            AUTOREADY_ = self.gds_validate_string(AUTOREADY_, node, 'AUTOREADY')
            self.AUTOREADY = AUTOREADY_
            # validate type AUTOREADY
            self.validate_AUTOREADY(self.AUTOREADY)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        hash_list.append(self.UNIQUEREF)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class REFUND


class REFUNDRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, 4),
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, 4),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('PROCESSINGTERMINAL', ['PROCESSINGTERMINAL', 'xs:string'], 0, 1, {'ref': 'PROCESSINGTERMINAL', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PROCESSINGTERMINAL', 'type': 'xs:string'}, None),
        MemberSpec_('ADDITIONAL_FIELD', 'ADDITIONAL_FIELD', 1, 1, {'ref': 'ADDITIONAL_FIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'ADDITIONAL_FIELD', 'type': 'ADDITIONAL_FIELD'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, RESPONSECODE=None, RESPONSETEXT=None, UNIQUEREF=None, ORDERID=None, DATETIME=None, PROCESSINGTERMINAL=None, ADDITIONAL_FIELD=None, HASH=None):
        self.original_tagname_ = None
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.UNIQUEREF = UNIQUEREF
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
        self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        if ADDITIONAL_FIELD is None:
            self.ADDITIONAL_FIELD = []
        else:
            self.ADDITIONAL_FIELD = ADDITIONAL_FIELD
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REFUNDRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REFUNDRESPONSE.subclass:
            return REFUNDRESPONSE.subclass(*args_, **kwargs_)
        else:
            return REFUNDRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_PROCESSINGTERMINAL(self): return self.PROCESSINGTERMINAL
    def set_PROCESSINGTERMINAL(self, PROCESSINGTERMINAL): self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
    def get_ADDITIONAL_FIELD(self): return self.ADDITIONAL_FIELD
    def set_ADDITIONAL_FIELD(self, ADDITIONAL_FIELD): self.ADDITIONAL_FIELD = ADDITIONAL_FIELD
    def add_ADDITIONAL_FIELD(self, value): self.ADDITIONAL_FIELD.append(value)
    def insert_ADDITIONAL_FIELD_at(self, index, value): self.ADDITIONAL_FIELD.insert(index, value)
    def replace_ADDITIONAL_FIELD_at(self, index, value): self.ADDITIONAL_FIELD[index] = value
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_PROCESSINGTERMINAL(self, value):
        # Validate type PROCESSINGTERMINAL, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.UNIQUEREF is not None or
            self.ORDERID is not None or
            self.DATETIME is not None or
            self.PROCESSINGTERMINAL is not None or
            self.ADDITIONAL_FIELD or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='REFUNDRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.PROCESSINGTERMINAL is not None:
            PROCESSINGTERMINAL_ = self.PROCESSINGTERMINAL
            etree_.SubElement(element, '{}PROCESSINGTERMINAL').text = self.gds_format_string(PROCESSINGTERMINAL_)
        for ADDITIONAL_FIELD_ in self.ADDITIONAL_FIELD:
            ADDITIONAL_FIELD_.to_etree(element, name_='ADDITIONAL_FIELD', mapping_=mapping_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='REFUNDRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.PROCESSINGTERMINAL is not None:
            showIndent(outfile, level)
            outfile.write('PROCESSINGTERMINAL=%s,\n' % self.gds_encode(quote_python(self.PROCESSINGTERMINAL)))
        showIndent(outfile, level)
        outfile.write('ADDITIONAL_FIELD=[\n')
        level += 1
        for ADDITIONAL_FIELD_ in self.ADDITIONAL_FIELD:
            showIndent(outfile, level)
            outfile.write('model_.ADDITIONAL_FIELD(\n')
            ADDITIONAL_FIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'PROCESSINGTERMINAL':
            PROCESSINGTERMINAL_ = child_.text
            PROCESSINGTERMINAL_ = self.gds_validate_string(PROCESSINGTERMINAL_, node, 'PROCESSINGTERMINAL')
            self.PROCESSINGTERMINAL = PROCESSINGTERMINAL_
            # validate type PROCESSINGTERMINAL
            self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        elif nodeName_ == 'ADDITIONAL_FIELD':
            obj_ = ADDITIONAL_FIELD.factory()
            obj_.build(child_)
            self.ADDITIONAL_FIELD.append(obj_)
            obj_.original_tagname_ = 'ADDITIONAL_FIELD'
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        hash_list.append(self.UNIQUEREF)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class REFUNDRESPONSE


class CARDBIN(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDBIN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDBIN.subclass:
            return CARDBIN.subclass(*args_, **kwargs_)
        else:
            return CARDBIN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDBIN', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDBIN'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CARDBIN


class GETCARDCURRENCYRATE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('CARDBIN', ['CARDBIN', 'xs:string'], 0, 0, {'ref': 'CARDBIN', 'name': 'CARDBIN', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('BASEAMOUNT', 'xs:double', 0, 1, {'ref': 'BASEAMOUNT', 'minOccurs': '0', 'name': 'BASEAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, CARDBIN=None, DATETIME=None, BASEAMOUNT=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.CARDBIN = CARDBIN
        self.validate_CARDBIN(self.CARDBIN)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.BASEAMOUNT = BASEAMOUNT
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GETCARDCURRENCYRATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GETCARDCURRENCYRATE.subclass:
            return GETCARDCURRENCYRATE.subclass(*args_, **kwargs_)
        else:
            return GETCARDCURRENCYRATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_CARDBIN(self): return self.CARDBIN
    def set_CARDBIN(self, CARDBIN): self.CARDBIN = CARDBIN
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_BASEAMOUNT(self): return self.BASEAMOUNT
    def set_BASEAMOUNT(self, BASEAMOUNT): self.BASEAMOUNT = BASEAMOUNT
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_CARDBIN(self, value):
        # Validate type CARDBIN, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.CARDBIN is not None or
            self.DATETIME is not None or
            self.BASEAMOUNT is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='GETCARDCURRENCYRATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.CARDBIN is not None:
            CARDBIN_ = self.CARDBIN
            etree_.SubElement(element, '{}CARDBIN').text = self.gds_format_string(CARDBIN_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.BASEAMOUNT is not None:
            BASEAMOUNT_ = self.BASEAMOUNT
            etree_.SubElement(element, '{}BASEAMOUNT').text = self.gds_format_double(BASEAMOUNT_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GETCARDCURRENCYRATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.CARDBIN is not None:
            showIndent(outfile, level)
            outfile.write('CARDBIN=%s,\n' % self.gds_encode(quote_python(self.CARDBIN)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.BASEAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('BASEAMOUNT=%e,\n' % self.BASEAMOUNT)
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'CARDBIN':
            CARDBIN_ = child_.text
            CARDBIN_ = self.gds_validate_string(CARDBIN_, node, 'CARDBIN')
            self.CARDBIN = CARDBIN_
            # validate type CARDBIN
            self.validate_CARDBIN(self.CARDBIN)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'BASEAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'BASEAMOUNT')
            self.BASEAMOUNT = fval_
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID]
        hash_list.append(self.CARDBIN)
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class GETCARDCURRENCYRATE


class TERMINALCURRENCY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TERMINALCURRENCY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TERMINALCURRENCY.subclass:
            return TERMINALCURRENCY.subclass(*args_, **kwargs_)
        else:
            return TERMINALCURRENCY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TERMINALCURRENCY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TERMINALCURRENCY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TERMINALCURRENCY


class CARDCURRENCY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDCURRENCY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDCURRENCY.subclass:
            return CARDCURRENCY.subclass(*args_, **kwargs_)
        else:
            return CARDCURRENCY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDCURRENCY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDCURRENCY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CARDCURRENCY


class EXCHANGERATESOURCENAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EXCHANGERATESOURCENAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EXCHANGERATESOURCENAME.subclass:
            return EXCHANGERATESOURCENAME.subclass(*args_, **kwargs_)
        else:
            return EXCHANGERATESOURCENAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='EXCHANGERATESOURCENAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='EXCHANGERATESOURCENAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EXCHANGERATESOURCENAME


class CARDCURRENCYRATERESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALCURRENCY', ['TERMINALCURRENCY', 'xs:string'], 0, 0, {'ref': 'TERMINALCURRENCY', 'name': 'TERMINALCURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDCURRENCY', ['CARDCURRENCY', 'xs:string'], 0, 0, {'ref': 'CARDCURRENCY', 'name': 'CARDCURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('CONVERSIONRATE', 'xs:double', 0, 0, {'ref': 'CONVERSIONRATE', 'name': 'CONVERSIONRATE', 'type': 'xs:double'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('EXCHANGERATESOURCENAME', ['EXCHANGERATESOURCENAME', 'xs:string'], 0, 0, {'ref': 'EXCHANGERATESOURCENAME', 'name': 'EXCHANGERATESOURCENAME', 'type': 'xs:string'}, None),
        MemberSpec_('MARGINRATEPERCENTAGE', 'xs:double', 0, 0, {'ref': 'MARGINRATEPERCENTAGE', 'name': 'MARGINRATEPERCENTAGE', 'type': 'xs:double'}, None),
        MemberSpec_('COMMISSIONPERCENTAGE', 'xs:double', 0, 0, {'ref': 'COMMISSIONPERCENTAGE', 'name': 'COMMISSIONPERCENTAGE', 'type': 'xs:double'}, None),
        MemberSpec_('FOREIGNAMOUNT', 'xs:double', 0, 1, {'ref': 'FOREIGNAMOUNT', 'minOccurs': '0', 'name': 'FOREIGNAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALCURRENCY=None, CARDCURRENCY=None, CONVERSIONRATE=None, DATETIME=None, EXCHANGERATESOURCENAME=None, MARGINRATEPERCENTAGE=None, COMMISSIONPERCENTAGE=None, FOREIGNAMOUNT=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALCURRENCY = TERMINALCURRENCY
        self.validate_TERMINALCURRENCY(self.TERMINALCURRENCY)
        self.CARDCURRENCY = CARDCURRENCY
        self.validate_CARDCURRENCY(self.CARDCURRENCY)
        self.CONVERSIONRATE = CONVERSIONRATE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.EXCHANGERATESOURCENAME = EXCHANGERATESOURCENAME
        self.validate_EXCHANGERATESOURCENAME(self.EXCHANGERATESOURCENAME)
        self.MARGINRATEPERCENTAGE = MARGINRATEPERCENTAGE
        self.COMMISSIONPERCENTAGE = COMMISSIONPERCENTAGE
        self.FOREIGNAMOUNT = FOREIGNAMOUNT
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDCURRENCYRATERESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDCURRENCYRATERESPONSE.subclass:
            return CARDCURRENCYRATERESPONSE.subclass(*args_, **kwargs_)
        else:
            return CARDCURRENCYRATERESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALCURRENCY(self): return self.TERMINALCURRENCY
    def set_TERMINALCURRENCY(self, TERMINALCURRENCY): self.TERMINALCURRENCY = TERMINALCURRENCY
    def get_CARDCURRENCY(self): return self.CARDCURRENCY
    def set_CARDCURRENCY(self, CARDCURRENCY): self.CARDCURRENCY = CARDCURRENCY
    def get_CONVERSIONRATE(self): return self.CONVERSIONRATE
    def set_CONVERSIONRATE(self, CONVERSIONRATE): self.CONVERSIONRATE = CONVERSIONRATE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_EXCHANGERATESOURCENAME(self): return self.EXCHANGERATESOURCENAME
    def set_EXCHANGERATESOURCENAME(self, EXCHANGERATESOURCENAME): self.EXCHANGERATESOURCENAME = EXCHANGERATESOURCENAME
    def get_MARGINRATEPERCENTAGE(self): return self.MARGINRATEPERCENTAGE
    def set_MARGINRATEPERCENTAGE(self, MARGINRATEPERCENTAGE): self.MARGINRATEPERCENTAGE = MARGINRATEPERCENTAGE
    def get_COMMISSIONPERCENTAGE(self): return self.COMMISSIONPERCENTAGE
    def set_COMMISSIONPERCENTAGE(self, COMMISSIONPERCENTAGE): self.COMMISSIONPERCENTAGE = COMMISSIONPERCENTAGE
    def get_FOREIGNAMOUNT(self): return self.FOREIGNAMOUNT
    def set_FOREIGNAMOUNT(self, FOREIGNAMOUNT): self.FOREIGNAMOUNT = FOREIGNAMOUNT
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALCURRENCY(self, value):
        # Validate type TERMINALCURRENCY, a restriction on xs:string.
        pass
    def validate_CARDCURRENCY(self, value):
        # Validate type CARDCURRENCY, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_EXCHANGERATESOURCENAME(self, value):
        # Validate type EXCHANGERATESOURCENAME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALCURRENCY is not None or
            self.CARDCURRENCY is not None or
            self.CONVERSIONRATE is not None or
            self.DATETIME is not None or
            self.EXCHANGERATESOURCENAME is not None or
            self.MARGINRATEPERCENTAGE is not None or
            self.COMMISSIONPERCENTAGE is not None or
            self.FOREIGNAMOUNT is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDCURRENCYRATERESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALCURRENCY is not None:
            TERMINALCURRENCY_ = self.TERMINALCURRENCY
            etree_.SubElement(element, '{}TERMINALCURRENCY').text = self.gds_format_string(TERMINALCURRENCY_)
        if self.CARDCURRENCY is not None:
            CARDCURRENCY_ = self.CARDCURRENCY
            etree_.SubElement(element, '{}CARDCURRENCY').text = self.gds_format_string(CARDCURRENCY_)
        if self.CONVERSIONRATE is not None:
            CONVERSIONRATE_ = self.CONVERSIONRATE
            etree_.SubElement(element, '{}CONVERSIONRATE').text = self.gds_format_double(CONVERSIONRATE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.EXCHANGERATESOURCENAME is not None:
            EXCHANGERATESOURCENAME_ = self.EXCHANGERATESOURCENAME
            etree_.SubElement(element, '{}EXCHANGERATESOURCENAME').text = self.gds_format_string(EXCHANGERATESOURCENAME_)
        if self.MARGINRATEPERCENTAGE is not None:
            MARGINRATEPERCENTAGE_ = self.MARGINRATEPERCENTAGE
            etree_.SubElement(element, '{}MARGINRATEPERCENTAGE').text = self.gds_format_double(MARGINRATEPERCENTAGE_)
        if self.COMMISSIONPERCENTAGE is not None:
            COMMISSIONPERCENTAGE_ = self.COMMISSIONPERCENTAGE
            etree_.SubElement(element, '{}COMMISSIONPERCENTAGE').text = self.gds_format_double(COMMISSIONPERCENTAGE_)
        if self.FOREIGNAMOUNT is not None:
            FOREIGNAMOUNT_ = self.FOREIGNAMOUNT
            etree_.SubElement(element, '{}FOREIGNAMOUNT').text = self.gds_format_double(FOREIGNAMOUNT_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDCURRENCYRATERESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALCURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALCURRENCY=%s,\n' % self.gds_encode(quote_python(self.TERMINALCURRENCY)))
        if self.CARDCURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CARDCURRENCY=%s,\n' % self.gds_encode(quote_python(self.CARDCURRENCY)))
        if self.CONVERSIONRATE is not None:
            showIndent(outfile, level)
            outfile.write('CONVERSIONRATE=%e,\n' % self.CONVERSIONRATE)
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.EXCHANGERATESOURCENAME is not None:
            showIndent(outfile, level)
            outfile.write('EXCHANGERATESOURCENAME=%s,\n' % self.gds_encode(quote_python(self.EXCHANGERATESOURCENAME)))
        if self.MARGINRATEPERCENTAGE is not None:
            showIndent(outfile, level)
            outfile.write('MARGINRATEPERCENTAGE=%e,\n' % self.MARGINRATEPERCENTAGE)
        if self.COMMISSIONPERCENTAGE is not None:
            showIndent(outfile, level)
            outfile.write('COMMISSIONPERCENTAGE=%e,\n' % self.COMMISSIONPERCENTAGE)
        if self.FOREIGNAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('FOREIGNAMOUNT=%e,\n' % self.FOREIGNAMOUNT)
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALCURRENCY':
            TERMINALCURRENCY_ = child_.text
            TERMINALCURRENCY_ = self.gds_validate_string(TERMINALCURRENCY_, node, 'TERMINALCURRENCY')
            self.TERMINALCURRENCY = TERMINALCURRENCY_
            # validate type TERMINALCURRENCY
            self.validate_TERMINALCURRENCY(self.TERMINALCURRENCY)
        elif nodeName_ == 'CARDCURRENCY':
            CARDCURRENCY_ = child_.text
            CARDCURRENCY_ = self.gds_validate_string(CARDCURRENCY_, node, 'CARDCURRENCY')
            self.CARDCURRENCY = CARDCURRENCY_
            # validate type CARDCURRENCY
            self.validate_CARDCURRENCY(self.CARDCURRENCY)
        elif nodeName_ == 'CONVERSIONRATE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CONVERSIONRATE')
            self.CONVERSIONRATE = fval_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'EXCHANGERATESOURCENAME':
            EXCHANGERATESOURCENAME_ = child_.text
            EXCHANGERATESOURCENAME_ = self.gds_validate_string(EXCHANGERATESOURCENAME_, node, 'EXCHANGERATESOURCENAME')
            self.EXCHANGERATESOURCENAME = EXCHANGERATESOURCENAME_
            # validate type EXCHANGERATESOURCENAME
            self.validate_EXCHANGERATESOURCENAME(self.EXCHANGERATESOURCENAME)
        elif nodeName_ == 'MARGINRATEPERCENTAGE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MARGINRATEPERCENTAGE')
            self.MARGINRATEPERCENTAGE = fval_
        elif nodeName_ == 'COMMISSIONPERCENTAGE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'COMMISSIONPERCENTAGE')
            self.COMMISSIONPERCENTAGE = fval_
        elif nodeName_ == 'FOREIGNAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'FOREIGNAMOUNT')
            self.FOREIGNAMOUNT = fval_
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class CARDCURRENCYRATERESPONSE


class FOREIGNCURRENCYINFORMATION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('CARDCURRENCY', ['CARDCURRENCY', 'xs:string'], 0, 0, {'ref': 'CARDCURRENCY', 'name': 'CARDCURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDAMOUNT', 'xs:double', 0, 0, {'ref': 'CARDAMOUNT', 'name': 'CARDAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('CONVERSIONRATE', 'xs:double', 0, 0, {'ref': 'CONVERSIONRATE', 'name': 'CONVERSIONRATE', 'type': 'xs:double'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CARDCURRENCY=None, CARDAMOUNT=None, CONVERSIONRATE=None):
        self.original_tagname_ = None
        self.CARDCURRENCY = CARDCURRENCY
        self.validate_CARDCURRENCY(self.CARDCURRENCY)
        self.CARDAMOUNT = CARDAMOUNT
        self.CONVERSIONRATE = CONVERSIONRATE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FOREIGNCURRENCYINFORMATION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FOREIGNCURRENCYINFORMATION.subclass:
            return FOREIGNCURRENCYINFORMATION.subclass(*args_, **kwargs_)
        else:
            return FOREIGNCURRENCYINFORMATION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CARDCURRENCY(self): return self.CARDCURRENCY
    def set_CARDCURRENCY(self, CARDCURRENCY): self.CARDCURRENCY = CARDCURRENCY
    def get_CARDAMOUNT(self): return self.CARDAMOUNT
    def set_CARDAMOUNT(self, CARDAMOUNT): self.CARDAMOUNT = CARDAMOUNT
    def get_CONVERSIONRATE(self): return self.CONVERSIONRATE
    def set_CONVERSIONRATE(self, CONVERSIONRATE): self.CONVERSIONRATE = CONVERSIONRATE
    def validate_CARDCURRENCY(self, value):
        # Validate type CARDCURRENCY, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.CARDCURRENCY is not None or
            self.CARDAMOUNT is not None or
            self.CONVERSIONRATE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FOREIGNCURRENCYINFORMATION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.CARDCURRENCY is not None:
            CARDCURRENCY_ = self.CARDCURRENCY
            etree_.SubElement(element, '{}CARDCURRENCY').text = self.gds_format_string(CARDCURRENCY_)
        if self.CARDAMOUNT is not None:
            CARDAMOUNT_ = self.CARDAMOUNT
            etree_.SubElement(element, '{}CARDAMOUNT').text = self.gds_format_double(CARDAMOUNT_)
        if self.CONVERSIONRATE is not None:
            CONVERSIONRATE_ = self.CONVERSIONRATE
            etree_.SubElement(element, '{}CONVERSIONRATE').text = self.gds_format_double(CONVERSIONRATE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FOREIGNCURRENCYINFORMATION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CARDCURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CARDCURRENCY=%s,\n' % self.gds_encode(quote_python(self.CARDCURRENCY)))
        if self.CARDAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('CARDAMOUNT=%e,\n' % self.CARDAMOUNT)
        if self.CONVERSIONRATE is not None:
            showIndent(outfile, level)
            outfile.write('CONVERSIONRATE=%e,\n' % self.CONVERSIONRATE)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CARDCURRENCY':
            CARDCURRENCY_ = child_.text
            CARDCURRENCY_ = self.gds_validate_string(CARDCURRENCY_, node, 'CARDCURRENCY')
            self.CARDCURRENCY = CARDCURRENCY_
            # validate type CARDCURRENCY
            self.validate_CARDCURRENCY(self.CARDCURRENCY)
        elif nodeName_ == 'CARDAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CARDAMOUNT')
            self.CARDAMOUNT = fval_
        elif nodeName_ == 'CONVERSIONRATE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CONVERSIONRATE')
            self.CONVERSIONRATE = fval_
# end class FOREIGNCURRENCYINFORMATION


class DUKPTCARDDETAILS(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ENCRYPTEDTRACK', ['ENCRYPTEDTRACK', 'xs:string'], 0, 0, {'ref': 'ENCRYPTEDTRACK', 'name': 'ENCRYPTEDTRACK', 'type': 'xs:string'}, None),
        MemberSpec_('KSN', ['KSN', 'xs:string'], 0, 0, {'ref': 'KSN', 'name': 'KSN', 'type': 'xs:string'}, None),
        MemberSpec_('FORMATID', ['FORMATID', 'xs:integer'], 0, 0, {'ref': 'FORMATID', 'name': 'FORMATID', 'type': 'xs:integer'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ENCRYPTEDTRACK=None, KSN=None, FORMATID=None):
        self.original_tagname_ = None
        self.ENCRYPTEDTRACK = ENCRYPTEDTRACK
        self.validate_ENCRYPTEDTRACK(self.ENCRYPTEDTRACK)
        self.KSN = KSN
        self.validate_KSN(self.KSN)
        self.FORMATID = FORMATID
        self.validate_FORMATID(self.FORMATID)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DUKPTCARDDETAILS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DUKPTCARDDETAILS.subclass:
            return DUKPTCARDDETAILS.subclass(*args_, **kwargs_)
        else:
            return DUKPTCARDDETAILS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ENCRYPTEDTRACK(self): return self.ENCRYPTEDTRACK
    def set_ENCRYPTEDTRACK(self, ENCRYPTEDTRACK): self.ENCRYPTEDTRACK = ENCRYPTEDTRACK
    def get_KSN(self): return self.KSN
    def set_KSN(self, KSN): self.KSN = KSN
    def get_FORMATID(self): return self.FORMATID
    def set_FORMATID(self, FORMATID): self.FORMATID = FORMATID
    def validate_ENCRYPTEDTRACK(self, value):
        # Validate type ENCRYPTEDTRACK, a restriction on xs:string.
        pass
    def validate_KSN(self, value):
        # Validate type KSN, a restriction on xs:string.
        pass
    def validate_FORMATID(self, value):
        # Validate type FORMATID, a restriction on xs:integer.
        pass
    def hasContent_(self):
        if (
            self.ENCRYPTEDTRACK is not None or
            self.KSN is not None or
            self.FORMATID is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DUKPTCARDDETAILS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ENCRYPTEDTRACK is not None:
            ENCRYPTEDTRACK_ = self.ENCRYPTEDTRACK
            etree_.SubElement(element, '{}ENCRYPTEDTRACK').text = self.gds_format_string(ENCRYPTEDTRACK_)
        if self.KSN is not None:
            KSN_ = self.KSN
            etree_.SubElement(element, '{}KSN').text = self.gds_format_string(KSN_)
        if self.FORMATID is not None:
            FORMATID_ = self.FORMATID
            etree_.SubElement(element, '{}FORMATID').text = self.gds_format_integer(FORMATID_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DUKPTCARDDETAILS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ENCRYPTEDTRACK is not None:
            showIndent(outfile, level)
            outfile.write('ENCRYPTEDTRACK=%s,\n' % self.gds_encode(quote_python(self.ENCRYPTEDTRACK)))
        if self.KSN is not None:
            showIndent(outfile, level)
            outfile.write('KSN=%s,\n' % self.gds_encode(quote_python(self.KSN)))
        if self.FORMATID is not None:
            showIndent(outfile, level)
            outfile.write('FORMATID=%d,\n' % self.FORMATID)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ENCRYPTEDTRACK':
            ENCRYPTEDTRACK_ = child_.text
            ENCRYPTEDTRACK_ = self.gds_validate_string(ENCRYPTEDTRACK_, node, 'ENCRYPTEDTRACK')
            self.ENCRYPTEDTRACK = ENCRYPTEDTRACK_
            # validate type ENCRYPTEDTRACK
            self.validate_ENCRYPTEDTRACK(self.ENCRYPTEDTRACK)
        elif nodeName_ == 'KSN':
            KSN_ = child_.text
            KSN_ = self.gds_validate_string(KSN_, node, 'KSN')
            self.KSN = KSN_
            # validate type KSN
            self.validate_KSN(self.KSN)
        elif nodeName_ == 'FORMATID' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FORMATID')
            self.FORMATID = ival_
            # validate type FORMATID
            self.validate_FORMATID(self.FORMATID)
# end class DUKPTCARDDETAILS


class ENCRYPTEDPAYLOAD(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('PAYLOAD', ['PAYLOAD', 'xs:string'], 0, 0, {'ref': 'PAYLOAD', 'name': 'PAYLOAD', 'type': 'xs:string'}, None),
        MemberSpec_('POSDEVICE', ['POSDEVICE', 'xs:string'], 0, 0, {'ref': 'POSDEVICE', 'name': 'POSDEVICE', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, PAYLOAD=None, POSDEVICE=None):
        self.original_tagname_ = None
        self.PAYLOAD = PAYLOAD
        self.validate_PAYLOAD(self.PAYLOAD)
        self.POSDEVICE = POSDEVICE
        self.validate_POSDEVICE(self.POSDEVICE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENCRYPTEDPAYLOAD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENCRYPTEDPAYLOAD.subclass:
            return ENCRYPTEDPAYLOAD.subclass(*args_, **kwargs_)
        else:
            return ENCRYPTEDPAYLOAD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PAYLOAD(self): return self.PAYLOAD
    def set_PAYLOAD(self, PAYLOAD): self.PAYLOAD = PAYLOAD
    def get_POSDEVICE(self): return self.POSDEVICE
    def set_POSDEVICE(self, POSDEVICE): self.POSDEVICE = POSDEVICE
    def validate_PAYLOAD(self, value):
        # Validate type PAYLOAD, a restriction on xs:string.
        pass
    def validate_POSDEVICE(self, value):
        # Validate type POSDEVICE, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.PAYLOAD is not None or
            self.POSDEVICE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ENCRYPTEDPAYLOAD', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.PAYLOAD is not None:
            PAYLOAD_ = self.PAYLOAD
            etree_.SubElement(element, '{}PAYLOAD').text = self.gds_format_string(PAYLOAD_)
        if self.POSDEVICE is not None:
            POSDEVICE_ = self.POSDEVICE
            etree_.SubElement(element, '{}POSDEVICE').text = self.gds_format_string(POSDEVICE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ENCRYPTEDPAYLOAD'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PAYLOAD is not None:
            showIndent(outfile, level)
            outfile.write('PAYLOAD=%s,\n' % self.gds_encode(quote_python(self.PAYLOAD)))
        if self.POSDEVICE is not None:
            showIndent(outfile, level)
            outfile.write('POSDEVICE=%s,\n' % self.gds_encode(quote_python(self.POSDEVICE)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PAYLOAD':
            PAYLOAD_ = child_.text
            PAYLOAD_ = self.gds_validate_string(PAYLOAD_, node, 'PAYLOAD')
            self.PAYLOAD = PAYLOAD_
            # validate type PAYLOAD
            self.validate_PAYLOAD(self.PAYLOAD)
        elif nodeName_ == 'POSDEVICE':
            POSDEVICE_ = child_.text
            POSDEVICE_ = self.gds_validate_string(POSDEVICE_, node, 'POSDEVICE')
            self.POSDEVICE = POSDEVICE_
            # validate type POSDEVICE
            self.validate_POSDEVICE(self.POSDEVICE)
# end class ENCRYPTEDPAYLOAD


class FRAUDREVIEWRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('FRAUDREVIEWSTATUS', ['FRAUDREVIEWSTATUS', 'xs:string'], 0, 1, {'ref': 'FRAUDREVIEWSTATUS', 'minOccurs': '0', 'name': 'FRAUDREVIEWSTATUS', 'type': 'xs:string'}, None),
        MemberSpec_('FRAUDREVIEWRISKRATING', ['FRAUDREVIEWRISKRATING', 'xs:string'], 0, 1, {'ref': 'FRAUDREVIEWRISKRATING', 'minOccurs': '0', 'name': 'FRAUDREVIEWRISKRATING', 'type': 'xs:string'}, None),
        MemberSpec_('FRAUDREVIEWSCORE', ['FRAUDREVIEWSCORE', 'xs:integer'], 0, 1, {'ref': 'FRAUDREVIEWSCORE', 'minOccurs': '0', 'name': 'FRAUDREVIEWSCORE', 'type': 'xs:integer'}, None),
        MemberSpec_('FRAUDREVIEWREASONCODE', ['FRAUDREVIEWREASONCODE', 'xs:string'], 0, 1, {'ref': 'FRAUDREVIEWREASONCODE', 'minOccurs': '0', 'name': 'FRAUDREVIEWREASONCODE', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, FRAUDREVIEWSTATUS=None, FRAUDREVIEWRISKRATING=None, FRAUDREVIEWSCORE=None, FRAUDREVIEWREASONCODE=None):
        self.original_tagname_ = None
        self.FRAUDREVIEWSTATUS = FRAUDREVIEWSTATUS
        self.validate_FRAUDREVIEWSTATUS(self.FRAUDREVIEWSTATUS)
        self.FRAUDREVIEWRISKRATING = FRAUDREVIEWRISKRATING
        self.validate_FRAUDREVIEWRISKRATING(self.FRAUDREVIEWRISKRATING)
        self.FRAUDREVIEWSCORE = FRAUDREVIEWSCORE
        self.validate_FRAUDREVIEWSCORE(self.FRAUDREVIEWSCORE)
        self.FRAUDREVIEWREASONCODE = FRAUDREVIEWREASONCODE
        self.validate_FRAUDREVIEWREASONCODE(self.FRAUDREVIEWREASONCODE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FRAUDREVIEWRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FRAUDREVIEWRESPONSE.subclass:
            return FRAUDREVIEWRESPONSE.subclass(*args_, **kwargs_)
        else:
            return FRAUDREVIEWRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FRAUDREVIEWSTATUS(self): return self.FRAUDREVIEWSTATUS
    def set_FRAUDREVIEWSTATUS(self, FRAUDREVIEWSTATUS): self.FRAUDREVIEWSTATUS = FRAUDREVIEWSTATUS
    def get_FRAUDREVIEWRISKRATING(self): return self.FRAUDREVIEWRISKRATING
    def set_FRAUDREVIEWRISKRATING(self, FRAUDREVIEWRISKRATING): self.FRAUDREVIEWRISKRATING = FRAUDREVIEWRISKRATING
    def get_FRAUDREVIEWSCORE(self): return self.FRAUDREVIEWSCORE
    def set_FRAUDREVIEWSCORE(self, FRAUDREVIEWSCORE): self.FRAUDREVIEWSCORE = FRAUDREVIEWSCORE
    def get_FRAUDREVIEWREASONCODE(self): return self.FRAUDREVIEWREASONCODE
    def set_FRAUDREVIEWREASONCODE(self, FRAUDREVIEWREASONCODE): self.FRAUDREVIEWREASONCODE = FRAUDREVIEWREASONCODE
    def validate_FRAUDREVIEWSTATUS(self, value):
        # Validate type FRAUDREVIEWSTATUS, a restriction on xs:string.
        pass
    def validate_FRAUDREVIEWRISKRATING(self, value):
        # Validate type FRAUDREVIEWRISKRATING, a restriction on xs:string.
        pass
    def validate_FRAUDREVIEWSCORE(self, value):
        # Validate type FRAUDREVIEWSCORE, a restriction on xs:integer.
        pass
    def validate_FRAUDREVIEWREASONCODE(self, value):
        # Validate type FRAUDREVIEWREASONCODE, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.FRAUDREVIEWSTATUS is not None or
            self.FRAUDREVIEWRISKRATING is not None or
            self.FRAUDREVIEWSCORE is not None or
            self.FRAUDREVIEWREASONCODE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FRAUDREVIEWRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.FRAUDREVIEWSTATUS is not None:
            FRAUDREVIEWSTATUS_ = self.FRAUDREVIEWSTATUS
            etree_.SubElement(element, '{}FRAUDREVIEWSTATUS').text = self.gds_format_string(FRAUDREVIEWSTATUS_)
        if self.FRAUDREVIEWRISKRATING is not None:
            FRAUDREVIEWRISKRATING_ = self.FRAUDREVIEWRISKRATING
            etree_.SubElement(element, '{}FRAUDREVIEWRISKRATING').text = self.gds_format_string(FRAUDREVIEWRISKRATING_)
        if self.FRAUDREVIEWSCORE is not None:
            FRAUDREVIEWSCORE_ = self.FRAUDREVIEWSCORE
            etree_.SubElement(element, '{}FRAUDREVIEWSCORE').text = self.gds_format_integer(FRAUDREVIEWSCORE_)
        if self.FRAUDREVIEWREASONCODE is not None:
            FRAUDREVIEWREASONCODE_ = self.FRAUDREVIEWREASONCODE
            etree_.SubElement(element, '{}FRAUDREVIEWREASONCODE').text = self.gds_format_string(FRAUDREVIEWREASONCODE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FRAUDREVIEWRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FRAUDREVIEWSTATUS is not None:
            showIndent(outfile, level)
            outfile.write('FRAUDREVIEWSTATUS=%s,\n' % self.gds_encode(quote_python(self.FRAUDREVIEWSTATUS)))
        if self.FRAUDREVIEWRISKRATING is not None:
            showIndent(outfile, level)
            outfile.write('FRAUDREVIEWRISKRATING=%s,\n' % self.gds_encode(quote_python(self.FRAUDREVIEWRISKRATING)))
        if self.FRAUDREVIEWSCORE is not None:
            showIndent(outfile, level)
            outfile.write('FRAUDREVIEWSCORE=%d,\n' % self.FRAUDREVIEWSCORE)
        if self.FRAUDREVIEWREASONCODE is not None:
            showIndent(outfile, level)
            outfile.write('FRAUDREVIEWREASONCODE=%s,\n' % self.gds_encode(quote_python(self.FRAUDREVIEWREASONCODE)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FRAUDREVIEWSTATUS':
            FRAUDREVIEWSTATUS_ = child_.text
            FRAUDREVIEWSTATUS_ = self.gds_validate_string(FRAUDREVIEWSTATUS_, node, 'FRAUDREVIEWSTATUS')
            self.FRAUDREVIEWSTATUS = FRAUDREVIEWSTATUS_
            # validate type FRAUDREVIEWSTATUS
            self.validate_FRAUDREVIEWSTATUS(self.FRAUDREVIEWSTATUS)
        elif nodeName_ == 'FRAUDREVIEWRISKRATING':
            FRAUDREVIEWRISKRATING_ = child_.text
            FRAUDREVIEWRISKRATING_ = self.gds_validate_string(FRAUDREVIEWRISKRATING_, node, 'FRAUDREVIEWRISKRATING')
            self.FRAUDREVIEWRISKRATING = FRAUDREVIEWRISKRATING_
            # validate type FRAUDREVIEWRISKRATING
            self.validate_FRAUDREVIEWRISKRATING(self.FRAUDREVIEWRISKRATING)
        elif nodeName_ == 'FRAUDREVIEWSCORE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FRAUDREVIEWSCORE')
            self.FRAUDREVIEWSCORE = ival_
            # validate type FRAUDREVIEWSCORE
            self.validate_FRAUDREVIEWSCORE(self.FRAUDREVIEWSCORE)
        elif nodeName_ == 'FRAUDREVIEWREASONCODE':
            FRAUDREVIEWREASONCODE_ = child_.text
            FRAUDREVIEWREASONCODE_ = self.gds_validate_string(FRAUDREVIEWREASONCODE_, node, 'FRAUDREVIEWREASONCODE')
            self.FRAUDREVIEWREASONCODE = FRAUDREVIEWREASONCODE_
            # validate type FRAUDREVIEWREASONCODE
            self.validate_FRAUDREVIEWREASONCODE(self.FRAUDREVIEWREASONCODE)
# end class FRAUDREVIEWRESPONSE


class PREAUTH(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 0, {'ref': 'CARDNUMBER', 'name': 'CARDNUMBER', 'type': 'xs:string'}, 5),
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 0, {'ref': 'CARDTYPE', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 1, {'ref': 'CARDEXPIRY', 'minOccurs': '0', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 1, {'ref': 'CARDHOLDERNAME', 'minOccurs': '0', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('FOREIGNCURRENCYINFORMATION', 'FOREIGNCURRENCYINFORMATION', 0, 1, {'ref': 'FOREIGNCURRENCYINFORMATION', 'minOccurs': '0', 'name': 'FOREIGNCURRENCYINFORMATION', 'type': 'FOREIGNCURRENCYINFORMATION'}, None),
        MemberSpec_('TERMINALTYPE', ['TERMINALTYPE', 'xs:int'], 0, 0, {'ref': 'TERMINALTYPE', 'name': 'TERMINALTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('TRANSACTIONTYPE', ['TRANSACTIONTYPE', 'xs:int'], 0, 0, {'ref': 'TRANSACTIONTYPE', 'name': 'TRANSACTIONTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('CVV', ['CVV', 'xs:string'], 0, 1, {'ref': 'CVV', 'minOccurs': '0', 'name': 'CVV', 'type': 'xs:string'}, None),
        MemberSpec_('ISSUENO', ['ISSUENO', 'xs:string'], 0, 1, {'ref': 'ISSUENO', 'minOccurs': '0', 'name': 'ISSUENO', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('XID', ['XID', 'xs:string'], 0, 1, {'ref': 'XID', 'minOccurs': '0', 'name': 'XID', 'type': 'xs:string'}, None),
        MemberSpec_('CAVV', ['CAVV', 'xs:string'], 0, 1, {'ref': 'CAVV', 'minOccurs': '0', 'name': 'CAVV', 'type': 'xs:string'}, None),
        MemberSpec_('THREEDS_PROTOCOL_VERSION', ['THREEDS_PROTOCOL_VERSION', 'xs:integer'], 0, 1, {'ref': 'THREEDS_PROTOCOL_VERSION', 'minOccurs': '0', 'name': 'THREEDS_PROTOCOL_VERSION', 'type': 'xs:integer'}, None),
        MemberSpec_('DS_TRANS_ID', ['DS_TRANS_ID', 'xs:string'], 0, 1, {'ref': 'DS_TRANS_ID', 'minOccurs': '0', 'name': 'DS_TRANS_ID', 'type': 'xs:string'}, None),
        MemberSpec_('MPIREF', ['MPIREF', 'xs:string'], 0, 1, {'ref': 'MPIREF', 'minOccurs': '0', 'name': 'MPIREF', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('IPADDRESS', ['IPADDRESS', 'xs:string'], 0, 1, {'ref': 'IPADDRESS', 'minOccurs': '0', 'name': 'IPADDRESS', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOMFIELD', 'CUSTOMFIELD', 1, 1, {'ref': 'CUSTOMFIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'CUSTOMFIELD', 'type': 'CUSTOMFIELD'}, None),
        MemberSpec_('RECURRINGTXNREF', ['UID', 'xs:string'], 0, 1, {'name': 'RECURRINGTXNREF', 'type': 'xs:string', 'minOccurs': '0', 'maxOccurs': '1'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('LEVEL_3_DATA', 'LEVEL_3_DATA', 0, 1, {'ref': 'LEVEL_3_DATA', 'minOccurs': '0', 'name': 'LEVEL_3_DATA', 'type': 'LEVEL_3_DATA'}, None),
        MemberSpec_('ENHANCED_DATA_TEMPLATE', ['ENHANCED_DATA_TEMPLATE', 'xs:string'], 0, 1, {'ref': 'ENHANCED_DATA_TEMPLATE', 'minOccurs': '0', 'name': 'ENHANCED_DATA_TEMPLATE', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('BYPASS_SURCHARGE', 'xs:boolean', 0, 1, {'name': 'BYPASS_SURCHARGE', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, AMOUNT=None, DATETIME=None, CARDNUMBER=None, CARDTYPE=None, CARDEXPIRY=None, CARDHOLDERNAME=None, HASH=None, CURRENCY=None, FOREIGNCURRENCYINFORMATION=None, TERMINALTYPE=None, TRANSACTIONTYPE=None, EMAIL=None, CVV=None, ISSUENO=None, ADDRESS1=None, ADDRESS2=None, POSTCODE=None, DESCRIPTION=None, XID=None, CAVV=None, THREEDS_PROTOCOL_VERSION=None, DS_TRANS_ID=None, MPIREF=None, CITY=None, REGION=None, COUNTRY=None, IPADDRESS=None, CUSTOMFIELD=None, RECURRINGTXNREF=None, LEVEL_2_DATA=None, LEVEL_3_DATA=None, ENHANCED_DATA_TEMPLATE=None, CREDENTIALONFILE=None, BYPASS_SURCHARGE=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
        self.TERMINALTYPE = TERMINALTYPE
        self.validate_TERMINALTYPE(self.TERMINALTYPE)
        self.TRANSACTIONTYPE = TRANSACTIONTYPE
        self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.CVV = CVV
        self.validate_CVV(self.CVV)
        self.ISSUENO = ISSUENO
        self.validate_ISSUENO(self.ISSUENO)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.XID = XID
        self.validate_XID(self.XID)
        self.CAVV = CAVV
        self.validate_CAVV(self.CAVV)
        self.THREEDS_PROTOCOL_VERSION = THREEDS_PROTOCOL_VERSION
        self.validate_THREEDS_PROTOCOL_VERSION(self.THREEDS_PROTOCOL_VERSION)
        self.DS_TRANS_ID = DS_TRANS_ID
        self.validate_DS_TRANS_ID(self.DS_TRANS_ID)
        self.MPIREF = MPIREF
        self.validate_MPIREF(self.MPIREF)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.IPADDRESS = IPADDRESS
        self.validate_IPADDRESS(self.IPADDRESS)
        if CUSTOMFIELD is None:
            self.CUSTOMFIELD = []
        else:
            self.CUSTOMFIELD = CUSTOMFIELD
        self.RECURRINGTXNREF = RECURRINGTXNREF
        self.validate_UID(self.RECURRINGTXNREF)
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.LEVEL_3_DATA = LEVEL_3_DATA
        self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE
        self.validate_ENHANCED_DATA_TEMPLATE(self.ENHANCED_DATA_TEMPLATE)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.BYPASS_SURCHARGE = BYPASS_SURCHARGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PREAUTH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PREAUTH.subclass:
            return PREAUTH.subclass(*args_, **kwargs_)
        else:
            return PREAUTH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_FOREIGNCURRENCYINFORMATION(self): return self.FOREIGNCURRENCYINFORMATION
    def set_FOREIGNCURRENCYINFORMATION(self, FOREIGNCURRENCYINFORMATION): self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
    def get_TERMINALTYPE(self): return self.TERMINALTYPE
    def set_TERMINALTYPE(self, TERMINALTYPE): self.TERMINALTYPE = TERMINALTYPE
    def get_TRANSACTIONTYPE(self): return self.TRANSACTIONTYPE
    def set_TRANSACTIONTYPE(self, TRANSACTIONTYPE): self.TRANSACTIONTYPE = TRANSACTIONTYPE
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_CVV(self): return self.CVV
    def set_CVV(self, CVV): self.CVV = CVV
    def get_ISSUENO(self): return self.ISSUENO
    def set_ISSUENO(self, ISSUENO): self.ISSUENO = ISSUENO
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_XID(self): return self.XID
    def set_XID(self, XID): self.XID = XID
    def get_CAVV(self): return self.CAVV
    def set_CAVV(self, CAVV): self.CAVV = CAVV
    def get_THREEDS_PROTOCOL_VERSION(self): return self.THREEDS_PROTOCOL_VERSION
    def set_THREEDS_PROTOCOL_VERSION(self, THREEDS_PROTOCOL_VERSION): self.THREEDS_PROTOCOL_VERSION = THREEDS_PROTOCOL_VERSION
    def get_DS_TRANS_ID(self): return self.DS_TRANS_ID
    def set_DS_TRANS_ID(self, DS_TRANS_ID): self.DS_TRANS_ID = DS_TRANS_ID
    def get_MPIREF(self): return self.MPIREF
    def set_MPIREF(self, MPIREF): self.MPIREF = MPIREF
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_IPADDRESS(self): return self.IPADDRESS
    def set_IPADDRESS(self, IPADDRESS): self.IPADDRESS = IPADDRESS
    def get_CUSTOMFIELD(self): return self.CUSTOMFIELD
    def set_CUSTOMFIELD(self, CUSTOMFIELD): self.CUSTOMFIELD = CUSTOMFIELD
    def add_CUSTOMFIELD(self, value): self.CUSTOMFIELD.append(value)
    def insert_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD.insert(index, value)
    def replace_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD[index] = value
    def get_RECURRINGTXNREF(self): return self.RECURRINGTXNREF
    def set_RECURRINGTXNREF(self, RECURRINGTXNREF): self.RECURRINGTXNREF = RECURRINGTXNREF
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_LEVEL_3_DATA(self): return self.LEVEL_3_DATA
    def set_LEVEL_3_DATA(self, LEVEL_3_DATA): self.LEVEL_3_DATA = LEVEL_3_DATA
    def get_ENHANCED_DATA_TEMPLATE(self): return self.ENHANCED_DATA_TEMPLATE
    def set_ENHANCED_DATA_TEMPLATE(self, ENHANCED_DATA_TEMPLATE): self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_BYPASS_SURCHARGE(self): return self.BYPASS_SURCHARGE
    def set_BYPASS_SURCHARGE(self, BYPASS_SURCHARGE): self.BYPASS_SURCHARGE = BYPASS_SURCHARGE
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_TERMINALTYPE(self, value):
        # Validate type TERMINALTYPE, a restriction on xs:int.
        pass
    def validate_TRANSACTIONTYPE(self, value):
        # Validate type TRANSACTIONTYPE, a restriction on xs:int.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_CVV(self, value):
        # Validate type CVV, a restriction on xs:string.
        pass
    def validate_ISSUENO(self, value):
        # Validate type ISSUENO, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_XID(self, value):
        # Validate type XID, a restriction on xs:string.
        pass
    def validate_CAVV(self, value):
        # Validate type CAVV, a restriction on xs:string.
        pass
    def validate_THREEDS_PROTOCOL_VERSION(self, value):
        # Validate type THREEDS_PROTOCOL_VERSION, a restriction on xs:integer.
        pass
    def validate_DS_TRANS_ID(self, value):
        # Validate type DS_TRANS_ID, a restriction on xs:string.
        pass
    def validate_MPIREF(self, value):
        # Validate type MPIREF, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_IPADDRESS(self, value):
        # Validate type IPADDRESS, a restriction on xs:string.
        pass
    def validate_UID(self, value):
        # Validate type UID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on UID' % {"value" : value.encode("utf-8")} )
            if len(value) < 10:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on UID' % {"value" : value.encode("utf-8")} )
    def validate_ENHANCED_DATA_TEMPLATE(self, value):
        # Validate type ENHANCED_DATA_TEMPLATE, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.DATETIME is not None or
            self.CARDNUMBER is not None or
            self.CARDTYPE is not None or
            self.CARDEXPIRY is not None or
            self.CARDHOLDERNAME is not None or
            self.HASH is not None or
            self.CURRENCY is not None or
            self.FOREIGNCURRENCYINFORMATION is not None or
            self.TERMINALTYPE is not None or
            self.TRANSACTIONTYPE is not None or
            self.EMAIL is not None or
            self.CVV is not None or
            self.ISSUENO is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.POSTCODE is not None or
            self.DESCRIPTION is not None or
            self.XID is not None or
            self.CAVV is not None or
            self.THREEDS_PROTOCOL_VERSION is not None or
            self.DS_TRANS_ID is not None or
            self.MPIREF is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.COUNTRY is not None or
            self.IPADDRESS is not None or
            self.CUSTOMFIELD or
            self.RECURRINGTXNREF is not None or
            self.LEVEL_2_DATA is not None or
            self.LEVEL_3_DATA is not None or
            self.ENHANCED_DATA_TEMPLATE is not None or
            self.CREDENTIALONFILE is not None or
            self.BYPASS_SURCHARGE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PREAUTH', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.FOREIGNCURRENCYINFORMATION is not None:
            FOREIGNCURRENCYINFORMATION_ = self.FOREIGNCURRENCYINFORMATION
            FOREIGNCURRENCYINFORMATION_.to_etree(element, name_='FOREIGNCURRENCYINFORMATION', mapping_=mapping_)
        if self.TERMINALTYPE is not None:
            TERMINALTYPE_ = self.TERMINALTYPE
            etree_.SubElement(element, '{}TERMINALTYPE').text = self.gds_format_integer(TERMINALTYPE_)
        if self.TRANSACTIONTYPE is not None:
            TRANSACTIONTYPE_ = self.TRANSACTIONTYPE
            etree_.SubElement(element, '{}TRANSACTIONTYPE').text = self.gds_format_integer(TRANSACTIONTYPE_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.CVV is not None:
            CVV_ = self.CVV
            etree_.SubElement(element, '{}CVV').text = self.gds_format_string(CVV_)
        if self.ISSUENO is not None:
            ISSUENO_ = self.ISSUENO
            etree_.SubElement(element, '{}ISSUENO').text = self.gds_format_string(ISSUENO_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.XID is not None:
            XID_ = self.XID
            etree_.SubElement(element, '{}XID').text = self.gds_format_string(XID_)
        if self.CAVV is not None:
            CAVV_ = self.CAVV
            etree_.SubElement(element, '{}CAVV').text = self.gds_format_string(CAVV_)
        if self.THREEDS_PROTOCOL_VERSION is not None:
            THREEDS_PROTOCOL_VERSION_ = self.THREEDS_PROTOCOL_VERSION
            etree_.SubElement(element, '{}THREEDS_PROTOCOL_VERSION').text = self.gds_format_integer(THREEDS_PROTOCOL_VERSION_)
        if self.DS_TRANS_ID is not None:
            DS_TRANS_ID_ = self.DS_TRANS_ID
            etree_.SubElement(element, '{}DS_TRANS_ID').text = self.gds_format_string(DS_TRANS_ID_)
        if self.MPIREF is not None:
            MPIREF_ = self.MPIREF
            etree_.SubElement(element, '{}MPIREF').text = self.gds_format_string(MPIREF_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.IPADDRESS is not None:
            IPADDRESS_ = self.IPADDRESS
            etree_.SubElement(element, '{}IPADDRESS').text = self.gds_format_string(IPADDRESS_)
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            CUSTOMFIELD_.to_etree(element, name_='CUSTOMFIELD', mapping_=mapping_)
        if self.RECURRINGTXNREF is not None:
            RECURRINGTXNREF_ = self.RECURRINGTXNREF
            etree_.SubElement(element, '{}RECURRINGTXNREF').text = self.gds_format_string(RECURRINGTXNREF_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.LEVEL_3_DATA is not None:
            LEVEL_3_DATA_ = self.LEVEL_3_DATA
            LEVEL_3_DATA_.to_etree(element, name_='LEVEL_3_DATA', mapping_=mapping_)
        if self.ENHANCED_DATA_TEMPLATE is not None:
            ENHANCED_DATA_TEMPLATE_ = self.ENHANCED_DATA_TEMPLATE
            etree_.SubElement(element, '{}ENHANCED_DATA_TEMPLATE').text = self.gds_format_string(ENHANCED_DATA_TEMPLATE_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.BYPASS_SURCHARGE is not None:
            BYPASS_SURCHARGE_ = self.BYPASS_SURCHARGE
            etree_.SubElement(element, '{}BYPASS_SURCHARGE').text = self.gds_format_boolean(BYPASS_SURCHARGE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PREAUTH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.FOREIGNCURRENCYINFORMATION is not None:
            showIndent(outfile, level)
            outfile.write('FOREIGNCURRENCYINFORMATION=model_.FOREIGNCURRENCYINFORMATION(\n')
            self.FOREIGNCURRENCYINFORMATION.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TERMINALTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALTYPE=%d,\n' % self.TERMINALTYPE)
        if self.TRANSACTIONTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTIONTYPE=%d,\n' % self.TRANSACTIONTYPE)
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.CVV is not None:
            showIndent(outfile, level)
            outfile.write('CVV=%s,\n' % self.gds_encode(quote_python(self.CVV)))
        if self.ISSUENO is not None:
            showIndent(outfile, level)
            outfile.write('ISSUENO=%s,\n' % self.gds_encode(quote_python(self.ISSUENO)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.XID is not None:
            showIndent(outfile, level)
            outfile.write('XID=%s,\n' % self.gds_encode(quote_python(self.XID)))
        if self.CAVV is not None:
            showIndent(outfile, level)
            outfile.write('CAVV=%s,\n' % self.gds_encode(quote_python(self.CAVV)))
        if self.THREEDS_PROTOCOL_VERSION is not None:
            showIndent(outfile, level)
            outfile.write('THREEDS_PROTOCOL_VERSION=%d,\n' % self.THREEDS_PROTOCOL_VERSION)
        if self.DS_TRANS_ID is not None:
            showIndent(outfile, level)
            outfile.write('DS_TRANS_ID=%s,\n' % self.gds_encode(quote_python(self.DS_TRANS_ID)))
        if self.MPIREF is not None:
            showIndent(outfile, level)
            outfile.write('MPIREF=%s,\n' % self.gds_encode(quote_python(self.MPIREF)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.IPADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('IPADDRESS=%s,\n' % self.gds_encode(quote_python(self.IPADDRESS)))
        showIndent(outfile, level)
        outfile.write('CUSTOMFIELD=[\n')
        level += 1
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOMFIELD(\n')
            CUSTOMFIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.RECURRINGTXNREF is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGTXNREF=%s,\n' % self.gds_encode(quote_python(self.RECURRINGTXNREF)))
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LEVEL_3_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_3_DATA=model_.LEVEL_3_DATA(\n')
            self.LEVEL_3_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ENHANCED_DATA_TEMPLATE is not None:
            showIndent(outfile, level)
            outfile.write('ENHANCED_DATA_TEMPLATE=%s,\n' % self.gds_encode(quote_python(self.ENHANCED_DATA_TEMPLATE)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BYPASS_SURCHARGE is not None:
            showIndent(outfile, level)
            outfile.write('BYPASS_SURCHARGE=%s,\n' % self.BYPASS_SURCHARGE)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'FOREIGNCURRENCYINFORMATION':
            obj_ = FOREIGNCURRENCYINFORMATION.factory()
            obj_.build(child_)
            self.FOREIGNCURRENCYINFORMATION = obj_
            obj_.original_tagname_ = 'FOREIGNCURRENCYINFORMATION'
        elif nodeName_ == 'TERMINALTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TERMINALTYPE')
            self.TERMINALTYPE = ival_
            # validate type TERMINALTYPE
            self.validate_TERMINALTYPE(self.TERMINALTYPE)
        elif nodeName_ == 'TRANSACTIONTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TRANSACTIONTYPE')
            self.TRANSACTIONTYPE = ival_
            # validate type TRANSACTIONTYPE
            self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'CVV':
            CVV_ = child_.text
            CVV_ = self.gds_validate_string(CVV_, node, 'CVV')
            self.CVV = CVV_
            # validate type CVV
            self.validate_CVV(self.CVV)
        elif nodeName_ == 'ISSUENO':
            ISSUENO_ = child_.text
            ISSUENO_ = self.gds_validate_string(ISSUENO_, node, 'ISSUENO')
            self.ISSUENO = ISSUENO_
            # validate type ISSUENO
            self.validate_ISSUENO(self.ISSUENO)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'XID':
            XID_ = child_.text
            XID_ = self.gds_validate_string(XID_, node, 'XID')
            self.XID = XID_
            # validate type XID
            self.validate_XID(self.XID)
        elif nodeName_ == 'CAVV':
            CAVV_ = child_.text
            CAVV_ = self.gds_validate_string(CAVV_, node, 'CAVV')
            self.CAVV = CAVV_
            # validate type CAVV
            self.validate_CAVV(self.CAVV)
        elif nodeName_ == 'THREEDS_PROTOCOL_VERSION' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'THREEDS_PROTOCOL_VERSION')
            self.THREEDS_PROTOCOL_VERSION = ival_
            # validate type THREEDS_PROTOCOL_VERSION
            self.validate_THREEDS_PROTOCOL_VERSION(self.THREEDS_PROTOCOL_VERSION)
        elif nodeName_ == 'DS_TRANS_ID':
            DS_TRANS_ID_ = child_.text
            DS_TRANS_ID_ = self.gds_validate_string(DS_TRANS_ID_, node, 'DS_TRANS_ID')
            self.DS_TRANS_ID = DS_TRANS_ID_
            # validate type DS_TRANS_ID
            self.validate_DS_TRANS_ID(self.DS_TRANS_ID)
        elif nodeName_ == 'MPIREF':
            MPIREF_ = child_.text
            MPIREF_ = self.gds_validate_string(MPIREF_, node, 'MPIREF')
            self.MPIREF = MPIREF_
            # validate type MPIREF
            self.validate_MPIREF(self.MPIREF)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'IPADDRESS':
            IPADDRESS_ = child_.text
            IPADDRESS_ = self.gds_validate_string(IPADDRESS_, node, 'IPADDRESS')
            self.IPADDRESS = IPADDRESS_
            # validate type IPADDRESS
            self.validate_IPADDRESS(self.IPADDRESS)
        elif nodeName_ == 'CUSTOMFIELD':
            obj_ = CUSTOMFIELD.factory()
            obj_.build(child_)
            self.CUSTOMFIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOMFIELD'
        elif nodeName_ == 'RECURRINGTXNREF':
            RECURRINGTXNREF_ = child_.text
            RECURRINGTXNREF_ = self.gds_validate_string(RECURRINGTXNREF_, node, 'RECURRINGTXNREF')
            self.RECURRINGTXNREF = RECURRINGTXNREF_
            # validate type UID
            self.validate_UID(self.RECURRINGTXNREF)
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'LEVEL_3_DATA':
            obj_ = LEVEL_3_DATA.factory()
            obj_.build(child_)
            self.LEVEL_3_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_3_DATA'
        elif nodeName_ == 'ENHANCED_DATA_TEMPLATE':
            ENHANCED_DATA_TEMPLATE_ = child_.text
            ENHANCED_DATA_TEMPLATE_ = self.gds_validate_string(ENHANCED_DATA_TEMPLATE_, node, 'ENHANCED_DATA_TEMPLATE')
            self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE_
            # validate type ENHANCED_DATA_TEMPLATE
            self.validate_ENHANCED_DATA_TEMPLATE(self.ENHANCED_DATA_TEMPLATE)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'BYPASS_SURCHARGE':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'BYPASS_SURCHARGE')
            self.BYPASS_SURCHARGE = ival_


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        if self.ORDERID:
            hash_list.append(self.ORDERID)
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** -Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class PREAUTH


class PREAUTHRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('BANKRESPONSECODE', ['BANKRESPONSECODE', 'xs:string'], 0, 1, {'ref': 'BANKRESPONSECODE', 'minOccurs': '0', 'name': 'BANKRESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('MASKEDCARDNUMBER', ['MASKEDCARDNUMBER', 'xs:string'], 0, 1, {'ref': 'MASKEDCARDNUMBER', 'minOccurs': '0', 'name': 'MASKEDCARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('SURCHARGE_FEE', 'xs:double', 0, 1, {'ref': 'SURCHARGE_FEE', 'minOccurs': '0', 'name': 'SURCHARGE_FEE', 'type': 'xs:double'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('AVSRESPONSE', ['AVSRESPONSE', 'xs:string'], 0, 1, {'ref': 'AVSRESPONSE', 'minOccurs': '0', 'name': 'AVSRESPONSE', 'type': 'xs:string'}, None),
        MemberSpec_('CVVRESPONSE', ['CVVRESPONSE', 'xs:string'], 0, 1, {'ref': 'CVVRESPONSE', 'minOccurs': '0', 'name': 'CVVRESPONSE', 'type': 'xs:string'}, None),
        MemberSpec_('PROCESSINGTERMINAL', ['PROCESSINGTERMINAL', 'xs:string'], 0, 1, {'ref': 'PROCESSINGTERMINAL', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PROCESSINGTERMINAL', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', ['CARDREFERENCE', 'xs:string'], 0, 1, {'ref': 'CARDREFERENCE', 'minOccurs': '0', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 1, {'ref': 'MERCHANTREF', 'minOccurs': '0', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ADDITIONAL_FIELD', 'ADDITIONAL_FIELD', 1, 1, {'ref': 'ADDITIONAL_FIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'ADDITIONAL_FIELD', 'type': 'ADDITIONAL_FIELD'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, BANKRESPONSECODE=None, MASKEDCARDNUMBER=None, APPROVALCODE=None, SURCHARGE_FEE=None, DATETIME=None, AVSRESPONSE=None, CVVRESPONSE=None, PROCESSINGTERMINAL=None, CARDREFERENCE=None, MERCHANTREF=None, ADDITIONAL_FIELD=None, CREDENTIALONFILE=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.BANKRESPONSECODE = BANKRESPONSECODE
        self.validate_BANKRESPONSECODE(self.BANKRESPONSECODE)
        self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
        self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.SURCHARGE_FEE = SURCHARGE_FEE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.AVSRESPONSE = AVSRESPONSE
        self.validate_AVSRESPONSE(self.AVSRESPONSE)
        self.CVVRESPONSE = CVVRESPONSE
        self.validate_CVVRESPONSE(self.CVVRESPONSE)
        self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
        self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        self.CARDREFERENCE = CARDREFERENCE
        self.validate_CARDREFERENCE(self.CARDREFERENCE)
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        if ADDITIONAL_FIELD is None:
            self.ADDITIONAL_FIELD = []
        else:
            self.ADDITIONAL_FIELD = ADDITIONAL_FIELD
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PREAUTHRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PREAUTHRESPONSE.subclass:
            return PREAUTHRESPONSE.subclass(*args_, **kwargs_)
        else:
            return PREAUTHRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_BANKRESPONSECODE(self): return self.BANKRESPONSECODE
    def set_BANKRESPONSECODE(self, BANKRESPONSECODE): self.BANKRESPONSECODE = BANKRESPONSECODE
    def get_MASKEDCARDNUMBER(self): return self.MASKEDCARDNUMBER
    def set_MASKEDCARDNUMBER(self, MASKEDCARDNUMBER): self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_SURCHARGE_FEE(self): return self.SURCHARGE_FEE
    def set_SURCHARGE_FEE(self, SURCHARGE_FEE): self.SURCHARGE_FEE = SURCHARGE_FEE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_AVSRESPONSE(self): return self.AVSRESPONSE
    def set_AVSRESPONSE(self, AVSRESPONSE): self.AVSRESPONSE = AVSRESPONSE
    def get_CVVRESPONSE(self): return self.CVVRESPONSE
    def set_CVVRESPONSE(self, CVVRESPONSE): self.CVVRESPONSE = CVVRESPONSE
    def get_PROCESSINGTERMINAL(self): return self.PROCESSINGTERMINAL
    def set_PROCESSINGTERMINAL(self, PROCESSINGTERMINAL): self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_ADDITIONAL_FIELD(self): return self.ADDITIONAL_FIELD
    def set_ADDITIONAL_FIELD(self, ADDITIONAL_FIELD): self.ADDITIONAL_FIELD = ADDITIONAL_FIELD
    def add_ADDITIONAL_FIELD(self, value): self.ADDITIONAL_FIELD.append(value)
    def insert_ADDITIONAL_FIELD_at(self, index, value): self.ADDITIONAL_FIELD.insert(index, value)
    def replace_ADDITIONAL_FIELD_at(self, index, value): self.ADDITIONAL_FIELD[index] = value
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_BANKRESPONSECODE(self, value):
        # Validate type BANKRESPONSECODE, a restriction on xs:string.
        pass
    def validate_MASKEDCARDNUMBER(self, value):
        # Validate type MASKEDCARDNUMBER, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_AVSRESPONSE(self, value):
        # Validate type AVSRESPONSE, a restriction on xs:string.
        pass
    def validate_CVVRESPONSE(self, value):
        # Validate type CVVRESPONSE, a restriction on xs:string.
        pass
    def validate_PROCESSINGTERMINAL(self, value):
        # Validate type PROCESSINGTERMINAL, a restriction on xs:string.
        pass
    def validate_CARDREFERENCE(self, value):
        # Validate type CARDREFERENCE, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.BANKRESPONSECODE is not None or
            self.MASKEDCARDNUMBER is not None or
            self.APPROVALCODE is not None or
            self.SURCHARGE_FEE is not None or
            self.DATETIME is not None or
            self.AVSRESPONSE is not None or
            self.CVVRESPONSE is not None or
            self.PROCESSINGTERMINAL is not None or
            self.CARDREFERENCE is not None or
            self.MERCHANTREF is not None or
            self.ADDITIONAL_FIELD or
            self.CREDENTIALONFILE is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PREAUTHRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.BANKRESPONSECODE is not None:
            BANKRESPONSECODE_ = self.BANKRESPONSECODE
            etree_.SubElement(element, '{}BANKRESPONSECODE').text = self.gds_format_string(BANKRESPONSECODE_)
        if self.MASKEDCARDNUMBER is not None:
            MASKEDCARDNUMBER_ = self.MASKEDCARDNUMBER
            etree_.SubElement(element, '{}MASKEDCARDNUMBER').text = self.gds_format_string(MASKEDCARDNUMBER_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.SURCHARGE_FEE is not None:
            SURCHARGE_FEE_ = self.SURCHARGE_FEE
            etree_.SubElement(element, '{}SURCHARGE_FEE').text = self.gds_format_double(SURCHARGE_FEE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.AVSRESPONSE is not None:
            AVSRESPONSE_ = self.AVSRESPONSE
            etree_.SubElement(element, '{}AVSRESPONSE').text = self.gds_format_string(AVSRESPONSE_)
        if self.CVVRESPONSE is not None:
            CVVRESPONSE_ = self.CVVRESPONSE
            etree_.SubElement(element, '{}CVVRESPONSE').text = self.gds_format_string(CVVRESPONSE_)
        if self.PROCESSINGTERMINAL is not None:
            PROCESSINGTERMINAL_ = self.PROCESSINGTERMINAL
            etree_.SubElement(element, '{}PROCESSINGTERMINAL').text = self.gds_format_string(PROCESSINGTERMINAL_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        for ADDITIONAL_FIELD_ in self.ADDITIONAL_FIELD:
            ADDITIONAL_FIELD_.to_etree(element, name_='ADDITIONAL_FIELD', mapping_=mapping_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PREAUTHRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.BANKRESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('BANKRESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.BANKRESPONSECODE)))
        if self.MASKEDCARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('MASKEDCARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.MASKEDCARDNUMBER)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.SURCHARGE_FEE is not None:
            showIndent(outfile, level)
            outfile.write('SURCHARGE_FEE=%e,\n' % self.SURCHARGE_FEE)
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.AVSRESPONSE is not None:
            showIndent(outfile, level)
            outfile.write('AVSRESPONSE=%s,\n' % self.gds_encode(quote_python(self.AVSRESPONSE)))
        if self.CVVRESPONSE is not None:
            showIndent(outfile, level)
            outfile.write('CVVRESPONSE=%s,\n' % self.gds_encode(quote_python(self.CVVRESPONSE)))
        if self.PROCESSINGTERMINAL is not None:
            showIndent(outfile, level)
            outfile.write('PROCESSINGTERMINAL=%s,\n' % self.gds_encode(quote_python(self.PROCESSINGTERMINAL)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        showIndent(outfile, level)
        outfile.write('ADDITIONAL_FIELD=[\n')
        level += 1
        for ADDITIONAL_FIELD_ in self.ADDITIONAL_FIELD:
            showIndent(outfile, level)
            outfile.write('model_.ADDITIONAL_FIELD(\n')
            ADDITIONAL_FIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'BANKRESPONSECODE':
            BANKRESPONSECODE_ = child_.text
            BANKRESPONSECODE_ = self.gds_validate_string(BANKRESPONSECODE_, node, 'BANKRESPONSECODE')
            self.BANKRESPONSECODE = BANKRESPONSECODE_
            # validate type BANKRESPONSECODE
            self.validate_BANKRESPONSECODE(self.BANKRESPONSECODE)
        elif nodeName_ == 'MASKEDCARDNUMBER':
            MASKEDCARDNUMBER_ = child_.text
            MASKEDCARDNUMBER_ = self.gds_validate_string(MASKEDCARDNUMBER_, node, 'MASKEDCARDNUMBER')
            self.MASKEDCARDNUMBER = MASKEDCARDNUMBER_
            # validate type MASKEDCARDNUMBER
            self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'SURCHARGE_FEE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SURCHARGE_FEE')
            self.SURCHARGE_FEE = fval_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'AVSRESPONSE':
            AVSRESPONSE_ = child_.text
            AVSRESPONSE_ = self.gds_validate_string(AVSRESPONSE_, node, 'AVSRESPONSE')
            self.AVSRESPONSE = AVSRESPONSE_
            # validate type AVSRESPONSE
            self.validate_AVSRESPONSE(self.AVSRESPONSE)
        elif nodeName_ == 'CVVRESPONSE':
            CVVRESPONSE_ = child_.text
            CVVRESPONSE_ = self.gds_validate_string(CVVRESPONSE_, node, 'CVVRESPONSE')
            self.CVVRESPONSE = CVVRESPONSE_
            # validate type CVVRESPONSE
            self.validate_CVVRESPONSE(self.CVVRESPONSE)
        elif nodeName_ == 'PROCESSINGTERMINAL':
            PROCESSINGTERMINAL_ = child_.text
            PROCESSINGTERMINAL_ = self.gds_validate_string(PROCESSINGTERMINAL_, node, 'PROCESSINGTERMINAL')
            self.PROCESSINGTERMINAL = PROCESSINGTERMINAL_
            # validate type PROCESSINGTERMINAL
            self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
            # validate type CARDREFERENCE
            self.validate_CARDREFERENCE(self.CARDREFERENCE)
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'ADDITIONAL_FIELD':
            obj_ = ADDITIONAL_FIELD.factory()
            obj_.build(child_)
            self.ADDITIONAL_FIELD.append(obj_)
            obj_.original_tagname_ = 'ADDITIONAL_FIELD'
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.terminal_id, self.UNIQUEREF]
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        hash_list.append(self.RESPONSECODE)
        hash_list.append(self.RESPONSETEXT)
        if self.BANKRESPONSECODE:
            hash_list.append(self.BANKRESPONSECODE)
        hash_list.append(self.SECRET)
        return ':'.join(hash_list)
# end class PREAUTHRESPONSE


class PREAUTHCOMPLETION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, 6),
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, 6),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('FOREIGNCURRENCYINFORMATION', 'FOREIGNCURRENCYINFORMATION', 0, 1, {'ref': 'FOREIGNCURRENCYINFORMATION', 'minOccurs': '0', 'name': 'FOREIGNCURRENCYINFORMATION', 'type': 'FOREIGNCURRENCYINFORMATION'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('CVV', ['CVV', 'xs:string'], 0, 1, {'ref': 'CVV', 'minOccurs': '0', 'name': 'CVV', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, ORDERID=None, TERMINALID=None, AMOUNT=None, FOREIGNCURRENCYINFORMATION=None, DESCRIPTION=None, DATETIME=None, CVV=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.CVV = CVV
        self.validate_CVV(self.CVV)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PREAUTHCOMPLETION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PREAUTHCOMPLETION.subclass:
            return PREAUTHCOMPLETION.subclass(*args_, **kwargs_)
        else:
            return PREAUTHCOMPLETION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_FOREIGNCURRENCYINFORMATION(self): return self.FOREIGNCURRENCYINFORMATION
    def set_FOREIGNCURRENCYINFORMATION(self, FOREIGNCURRENCYINFORMATION): self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_CVV(self): return self.CVV
    def set_CVV(self, CVV): self.CVV = CVV
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_CVV(self, value):
        # Validate type CVV, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.FOREIGNCURRENCYINFORMATION is not None or
            self.DESCRIPTION is not None or
            self.DATETIME is not None or
            self.CVV is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PREAUTHCOMPLETION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.FOREIGNCURRENCYINFORMATION is not None:
            FOREIGNCURRENCYINFORMATION_ = self.FOREIGNCURRENCYINFORMATION
            FOREIGNCURRENCYINFORMATION_.to_etree(element, name_='FOREIGNCURRENCYINFORMATION', mapping_=mapping_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.CVV is not None:
            CVV_ = self.CVV
            etree_.SubElement(element, '{}CVV').text = self.gds_format_string(CVV_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PREAUTHCOMPLETION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.FOREIGNCURRENCYINFORMATION is not None:
            showIndent(outfile, level)
            outfile.write('FOREIGNCURRENCYINFORMATION=model_.FOREIGNCURRENCYINFORMATION(\n')
            self.FOREIGNCURRENCYINFORMATION.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.CVV is not None:
            showIndent(outfile, level)
            outfile.write('CVV=%s,\n' % self.gds_encode(quote_python(self.CVV)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'FOREIGNCURRENCYINFORMATION':
            obj_ = FOREIGNCURRENCYINFORMATION.factory()
            obj_.build(child_)
            self.FOREIGNCURRENCYINFORMATION = obj_
            obj_.original_tagname_ = 'FOREIGNCURRENCYINFORMATION'
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'CVV':
            CVV_ = child_.text
            CVV_ = self.gds_validate_string(CVV_, node, 'CVV')
            self.CVV = CVV_
            # validate type CVV
            self.validate_CVV(self.CVV)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID, self.UNIQUEREF]
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** -Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class PREAUTHCOMPLETION


class PREAUTHCOMPLETIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('AVSRESPONSE', ['AVSRESPONSE', 'xs:string'], 0, 1, {'ref': 'AVSRESPONSE', 'minOccurs': '0', 'name': 'AVSRESPONSE', 'type': 'xs:string'}, None),
        MemberSpec_('CVVRESPONSE', ['CVVRESPONSE', 'xs:string'], 0, 1, {'ref': 'CVVRESPONSE', 'minOccurs': '0', 'name': 'CVVRESPONSE', 'type': 'xs:string'}, None),
        MemberSpec_('PROCESSINGTERMINAL', ['PROCESSINGTERMINAL', 'xs:string'], 0, 1, {'ref': 'PROCESSINGTERMINAL', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PROCESSINGTERMINAL', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, APPROVALCODE=None, DATETIME=None, AVSRESPONSE=None, CVVRESPONSE=None, PROCESSINGTERMINAL=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.AVSRESPONSE = AVSRESPONSE
        self.validate_AVSRESPONSE(self.AVSRESPONSE)
        self.CVVRESPONSE = CVVRESPONSE
        self.validate_CVVRESPONSE(self.CVVRESPONSE)
        self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
        self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PREAUTHCOMPLETIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PREAUTHCOMPLETIONRESPONSE.subclass:
            return PREAUTHCOMPLETIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return PREAUTHCOMPLETIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_AVSRESPONSE(self): return self.AVSRESPONSE
    def set_AVSRESPONSE(self, AVSRESPONSE): self.AVSRESPONSE = AVSRESPONSE
    def get_CVVRESPONSE(self): return self.CVVRESPONSE
    def set_CVVRESPONSE(self, CVVRESPONSE): self.CVVRESPONSE = CVVRESPONSE
    def get_PROCESSINGTERMINAL(self): return self.PROCESSINGTERMINAL
    def set_PROCESSINGTERMINAL(self, PROCESSINGTERMINAL): self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_AVSRESPONSE(self, value):
        # Validate type AVSRESPONSE, a restriction on xs:string.
        pass
    def validate_CVVRESPONSE(self, value):
        # Validate type CVVRESPONSE, a restriction on xs:string.
        pass
    def validate_PROCESSINGTERMINAL(self, value):
        # Validate type PROCESSINGTERMINAL, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.APPROVALCODE is not None or
            self.DATETIME is not None or
            self.AVSRESPONSE is not None or
            self.CVVRESPONSE is not None or
            self.PROCESSINGTERMINAL is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PREAUTHCOMPLETIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.AVSRESPONSE is not None:
            AVSRESPONSE_ = self.AVSRESPONSE
            etree_.SubElement(element, '{}AVSRESPONSE').text = self.gds_format_string(AVSRESPONSE_)
        if self.CVVRESPONSE is not None:
            CVVRESPONSE_ = self.CVVRESPONSE
            etree_.SubElement(element, '{}CVVRESPONSE').text = self.gds_format_string(CVVRESPONSE_)
        if self.PROCESSINGTERMINAL is not None:
            PROCESSINGTERMINAL_ = self.PROCESSINGTERMINAL
            etree_.SubElement(element, '{}PROCESSINGTERMINAL').text = self.gds_format_string(PROCESSINGTERMINAL_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PREAUTHCOMPLETIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.AVSRESPONSE is not None:
            showIndent(outfile, level)
            outfile.write('AVSRESPONSE=%s,\n' % self.gds_encode(quote_python(self.AVSRESPONSE)))
        if self.CVVRESPONSE is not None:
            showIndent(outfile, level)
            outfile.write('CVVRESPONSE=%s,\n' % self.gds_encode(quote_python(self.CVVRESPONSE)))
        if self.PROCESSINGTERMINAL is not None:
            showIndent(outfile, level)
            outfile.write('PROCESSINGTERMINAL=%s,\n' % self.gds_encode(quote_python(self.PROCESSINGTERMINAL)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'AVSRESPONSE':
            AVSRESPONSE_ = child_.text
            AVSRESPONSE_ = self.gds_validate_string(AVSRESPONSE_, node, 'AVSRESPONSE')
            self.AVSRESPONSE = AVSRESPONSE_
            # validate type AVSRESPONSE
            self.validate_AVSRESPONSE(self.AVSRESPONSE)
        elif nodeName_ == 'CVVRESPONSE':
            CVVRESPONSE_ = child_.text
            CVVRESPONSE_ = self.gds_validate_string(CVVRESPONSE_, node, 'CVVRESPONSE')
            self.CVVRESPONSE = CVVRESPONSE_
            # validate type CVVRESPONSE
            self.validate_CVVRESPONSE(self.CVVRESPONSE)
        elif nodeName_ == 'PROCESSINGTERMINAL':
            PROCESSINGTERMINAL_ = child_.text
            PROCESSINGTERMINAL_ = self.gds_validate_string(PROCESSINGTERMINAL_, node, 'PROCESSINGTERMINAL')
            self.PROCESSINGTERMINAL = PROCESSINGTERMINAL_
            # validate type PROCESSINGTERMINAL
            self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.terminal_id, self.UNIQUEREF]
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** -Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        hash_list.append(self.RESPONSECODE)
        hash_list.append(self.RESPONSETEXT)
        hash_list.append(str(self.SECRET))
        return ':'.join(hash_list)
# end class PREAUTHCOMPLETIONRESPONSE


class DONTCHECKSECURITY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DONTCHECKSECURITY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DONTCHECKSECURITY.subclass:
            return DONTCHECKSECURITY.subclass(*args_, **kwargs_)
        else:
            return DONTCHECKSECURITY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DONTCHECKSECURITY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DONTCHECKSECURITY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DONTCHECKSECURITY


class SECURECARDREGISTRATION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 0, {'ref': 'CARDNUMBER', 'name': 'CARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 0, {'ref': 'CARDEXPIRY', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 0, {'ref': 'CARDTYPE', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 1, {'ref': 'CARDHOLDERNAME', 'minOccurs': '0', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('DONTCHECKSECURITY', ['DONTCHECKSECURITY', 'xs:string'], 0, 1, {'ref': 'DONTCHECKSECURITY', 'minOccurs': '0', 'name': 'DONTCHECKSECURITY', 'type': 'xs:string'}, None),
        MemberSpec_('CVV', ['CVV', 'xs:string'], 0, 1, {'ref': 'CVV', 'minOccurs': '0', 'name': 'CVV', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('ISSUENO', ['ISSUENO', 'xs:string'], 0, 1, {'ref': 'ISSUENO', 'minOccurs': '0', 'name': 'ISSUENO', 'type': 'xs:string'}, None),
        MemberSpec_('PERMITTEDTERMINALS', 'PERMITTEDTERMINALS', 0, 1, {'ref': 'PERMITTEDTERMINALS', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PERMITTEDTERMINALS', 'type': 'PERMITTEDTERMINALS'}, None),
        MemberSpec_('CUSTOMFIELD', 'CUSTOMFIELD', 1, 1, {'ref': 'CUSTOMFIELD', 'minOccurs': '0', 'maxOccurs': '3', 'name': 'CUSTOMFIELD', 'type': 'CUSTOMFIELD'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('XID', ['XID', 'xs:string'], 0, 1, {'ref': 'XID', 'minOccurs': '0', 'name': 'XID', 'type': 'xs:string'}, None),
        MemberSpec_('CAVV', ['CAVV', 'xs:string'], 0, 1, {'ref': 'CAVV', 'minOccurs': '0', 'name': 'CAVV', 'type': 'xs:string'}, None),
        MemberSpec_('THREEDS_PROTOCOL_VERSION', ['THREEDS_PROTOCOL_VERSION', 'xs:integer'], 0, 1, {'ref': 'THREEDS_PROTOCOL_VERSION', 'minOccurs': '0', 'name': 'THREEDS_PROTOCOL_VERSION', 'type': 'xs:integer'}, None),
        MemberSpec_('DS_TRANS_ID', ['DS_TRANS_ID', 'xs:string'], 0, 1, {'ref': 'DS_TRANS_ID', 'minOccurs': '0', 'name': 'DS_TRANS_ID', 'type': 'xs:string'}, None),
        MemberSpec_('TRANSACTIONTYPE', ['TRANSACTIONTYPE', 'xs:int'], 0, 1, {'ref': 'TRANSACTIONTYPE', 'minOccurs': '0', 'name': 'TRANSACTIONTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('MPIREF', ['MPIREF', 'xs:string'], 0, 1, {'ref': 'MPIREF', 'minOccurs': '0', 'name': 'MPIREF', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, CARDNUMBER=None, CARDEXPIRY=None, CARDTYPE=None, CARDHOLDERNAME=None, HASH=None, DONTCHECKSECURITY=None, CVV=None, ADDRESS1=None, POSTCODE=None, ISSUENO=None, PERMITTEDTERMINALS=None, CUSTOMFIELD=None, EMAIL=None, PHONE=None, CREDENTIALONFILE=None, XID=None, CAVV=None, THREEDS_PROTOCOL_VERSION=None, DS_TRANS_ID=None, TRANSACTIONTYPE=None, MPIREF=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.DONTCHECKSECURITY = DONTCHECKSECURITY
        self.validate_DONTCHECKSECURITY(self.DONTCHECKSECURITY)
        self.CVV = CVV
        self.validate_CVV(self.CVV)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.ISSUENO = ISSUENO
        self.validate_ISSUENO(self.ISSUENO)
        self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
        if CUSTOMFIELD is None:
            self.CUSTOMFIELD = []
        else:
            self.CUSTOMFIELD = CUSTOMFIELD
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.XID = XID
        self.validate_XID(self.XID)
        self.CAVV = CAVV
        self.validate_CAVV(self.CAVV)
        self.THREEDS_PROTOCOL_VERSION = THREEDS_PROTOCOL_VERSION
        self.validate_THREEDS_PROTOCOL_VERSION(self.THREEDS_PROTOCOL_VERSION)
        self.DS_TRANS_ID = DS_TRANS_ID
        self.validate_DS_TRANS_ID(self.DS_TRANS_ID)
        self.TRANSACTIONTYPE = TRANSACTIONTYPE
        self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        self.MPIREF = MPIREF
        self.validate_MPIREF(self.MPIREF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDREGISTRATION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDREGISTRATION.subclass:
            return SECURECARDREGISTRATION.subclass(*args_, **kwargs_)
        else:
            return SECURECARDREGISTRATION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_DONTCHECKSECURITY(self): return self.DONTCHECKSECURITY
    def set_DONTCHECKSECURITY(self, DONTCHECKSECURITY): self.DONTCHECKSECURITY = DONTCHECKSECURITY
    def get_CVV(self): return self.CVV
    def set_CVV(self, CVV): self.CVV = CVV
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_ISSUENO(self): return self.ISSUENO
    def set_ISSUENO(self, ISSUENO): self.ISSUENO = ISSUENO
    def get_PERMITTEDTERMINALS(self): return self.PERMITTEDTERMINALS
    def set_PERMITTEDTERMINALS(self, PERMITTEDTERMINALS): self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
    def get_CUSTOMFIELD(self): return self.CUSTOMFIELD
    def set_CUSTOMFIELD(self, CUSTOMFIELD): self.CUSTOMFIELD = CUSTOMFIELD
    def add_CUSTOMFIELD(self, value): self.CUSTOMFIELD.append(value)
    def insert_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD.insert(index, value)
    def replace_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD[index] = value
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_XID(self): return self.XID
    def set_XID(self, XID): self.XID = XID
    def get_CAVV(self): return self.CAVV
    def set_CAVV(self, CAVV): self.CAVV = CAVV
    def get_THREEDS_PROTOCOL_VERSION(self): return self.THREEDS_PROTOCOL_VERSION
    def set_THREEDS_PROTOCOL_VERSION(self, THREEDS_PROTOCOL_VERSION): self.THREEDS_PROTOCOL_VERSION = THREEDS_PROTOCOL_VERSION
    def get_DS_TRANS_ID(self): return self.DS_TRANS_ID
    def set_DS_TRANS_ID(self, DS_TRANS_ID): self.DS_TRANS_ID = DS_TRANS_ID
    def get_TRANSACTIONTYPE(self): return self.TRANSACTIONTYPE
    def set_TRANSACTIONTYPE(self, TRANSACTIONTYPE): self.TRANSACTIONTYPE = TRANSACTIONTYPE
    def get_MPIREF(self): return self.MPIREF
    def set_MPIREF(self, MPIREF): self.MPIREF = MPIREF
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_DONTCHECKSECURITY(self, value):
        # Validate type DONTCHECKSECURITY, a restriction on xs:string.
        pass
    def validate_CVV(self, value):
        # Validate type CVV, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_ISSUENO(self, value):
        # Validate type ISSUENO, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_XID(self, value):
        # Validate type XID, a restriction on xs:string.
        pass
    def validate_CAVV(self, value):
        # Validate type CAVV, a restriction on xs:string.
        pass
    def validate_THREEDS_PROTOCOL_VERSION(self, value):
        # Validate type THREEDS_PROTOCOL_VERSION, a restriction on xs:integer.
        pass
    def validate_DS_TRANS_ID(self, value):
        # Validate type DS_TRANS_ID, a restriction on xs:string.
        pass
    def validate_TRANSACTIONTYPE(self, value):
        # Validate type TRANSACTIONTYPE, a restriction on xs:int.
        pass
    def validate_MPIREF(self, value):
        # Validate type MPIREF, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.CARDNUMBER is not None or
            self.CARDEXPIRY is not None or
            self.CARDTYPE is not None or
            self.CARDHOLDERNAME is not None or
            self.HASH is not None or
            self.DONTCHECKSECURITY is not None or
            self.CVV is not None or
            self.ADDRESS1 is not None or
            self.POSTCODE is not None or
            self.ISSUENO is not None or
            self.PERMITTEDTERMINALS is not None or
            self.CUSTOMFIELD or
            self.EMAIL is not None or
            self.PHONE is not None or
            self.CREDENTIALONFILE is not None or
            self.XID is not None or
            self.CAVV is not None or
            self.THREEDS_PROTOCOL_VERSION is not None or
            self.DS_TRANS_ID is not None or
            self.TRANSACTIONTYPE is not None or
            self.MPIREF is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDREGISTRATION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.DONTCHECKSECURITY is not None:
            DONTCHECKSECURITY_ = self.DONTCHECKSECURITY
            etree_.SubElement(element, '{}DONTCHECKSECURITY').text = self.gds_format_string(DONTCHECKSECURITY_)
        if self.CVV is not None:
            CVV_ = self.CVV
            etree_.SubElement(element, '{}CVV').text = self.gds_format_string(CVV_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.ISSUENO is not None:
            ISSUENO_ = self.ISSUENO
            etree_.SubElement(element, '{}ISSUENO').text = self.gds_format_string(ISSUENO_)
        if self.PERMITTEDTERMINALS is not None:
            PERMITTEDTERMINALS_ = self.PERMITTEDTERMINALS
            PERMITTEDTERMINALS_.to_etree(element, name_='PERMITTEDTERMINALS', mapping_=mapping_)
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            CUSTOMFIELD_.to_etree(element, name_='CUSTOMFIELD', mapping_=mapping_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.XID is not None:
            XID_ = self.XID
            etree_.SubElement(element, '{}XID').text = self.gds_format_string(XID_)
        if self.CAVV is not None:
            CAVV_ = self.CAVV
            etree_.SubElement(element, '{}CAVV').text = self.gds_format_string(CAVV_)
        if self.THREEDS_PROTOCOL_VERSION is not None:
            THREEDS_PROTOCOL_VERSION_ = self.THREEDS_PROTOCOL_VERSION
            etree_.SubElement(element, '{}THREEDS_PROTOCOL_VERSION').text = self.gds_format_integer(THREEDS_PROTOCOL_VERSION_)
        if self.DS_TRANS_ID is not None:
            DS_TRANS_ID_ = self.DS_TRANS_ID
            etree_.SubElement(element, '{}DS_TRANS_ID').text = self.gds_format_string(DS_TRANS_ID_)
        if self.TRANSACTIONTYPE is not None:
            TRANSACTIONTYPE_ = self.TRANSACTIONTYPE
            etree_.SubElement(element, '{}TRANSACTIONTYPE').text = self.gds_format_integer(TRANSACTIONTYPE_)
        if self.MPIREF is not None:
            MPIREF_ = self.MPIREF
            etree_.SubElement(element, '{}MPIREF').text = self.gds_format_string(MPIREF_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDREGISTRATION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.DONTCHECKSECURITY is not None:
            showIndent(outfile, level)
            outfile.write('DONTCHECKSECURITY=%s,\n' % self.gds_encode(quote_python(self.DONTCHECKSECURITY)))
        if self.CVV is not None:
            showIndent(outfile, level)
            outfile.write('CVV=%s,\n' % self.gds_encode(quote_python(self.CVV)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.ISSUENO is not None:
            showIndent(outfile, level)
            outfile.write('ISSUENO=%s,\n' % self.gds_encode(quote_python(self.ISSUENO)))
        if self.PERMITTEDTERMINALS is not None:
            showIndent(outfile, level)
            outfile.write('PERMITTEDTERMINALS=model_.PERMITTEDTERMINALS(\n')
            self.PERMITTEDTERMINALS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CUSTOMFIELD=[\n')
        level += 1
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOMFIELD(\n')
            CUSTOMFIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.XID is not None:
            showIndent(outfile, level)
            outfile.write('XID=%s,\n' % self.gds_encode(quote_python(self.XID)))
        if self.CAVV is not None:
            showIndent(outfile, level)
            outfile.write('CAVV=%s,\n' % self.gds_encode(quote_python(self.CAVV)))
        if self.THREEDS_PROTOCOL_VERSION is not None:
            showIndent(outfile, level)
            outfile.write('THREEDS_PROTOCOL_VERSION=%d,\n' % self.THREEDS_PROTOCOL_VERSION)
        if self.DS_TRANS_ID is not None:
            showIndent(outfile, level)
            outfile.write('DS_TRANS_ID=%s,\n' % self.gds_encode(quote_python(self.DS_TRANS_ID)))
        if self.TRANSACTIONTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTIONTYPE=%d,\n' % self.TRANSACTIONTYPE)
        if self.MPIREF is not None:
            showIndent(outfile, level)
            outfile.write('MPIREF=%s,\n' % self.gds_encode(quote_python(self.MPIREF)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'DONTCHECKSECURITY':
            DONTCHECKSECURITY_ = child_.text
            DONTCHECKSECURITY_ = self.gds_validate_string(DONTCHECKSECURITY_, node, 'DONTCHECKSECURITY')
            self.DONTCHECKSECURITY = DONTCHECKSECURITY_
            # validate type DONTCHECKSECURITY
            self.validate_DONTCHECKSECURITY(self.DONTCHECKSECURITY)
        elif nodeName_ == 'CVV':
            CVV_ = child_.text
            CVV_ = self.gds_validate_string(CVV_, node, 'CVV')
            self.CVV = CVV_
            # validate type CVV
            self.validate_CVV(self.CVV)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'ISSUENO':
            ISSUENO_ = child_.text
            ISSUENO_ = self.gds_validate_string(ISSUENO_, node, 'ISSUENO')
            self.ISSUENO = ISSUENO_
            # validate type ISSUENO
            self.validate_ISSUENO(self.ISSUENO)
        elif nodeName_ == 'PERMITTEDTERMINALS':
            obj_ = PERMITTEDTERMINALS.factory()
            obj_.build(child_)
            self.PERMITTEDTERMINALS = obj_
            obj_.original_tagname_ = 'PERMITTEDTERMINALS'
        elif nodeName_ == 'CUSTOMFIELD':
            obj_ = CUSTOMFIELD.factory()
            obj_.build(child_)
            self.CUSTOMFIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOMFIELD'
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'XID':
            XID_ = child_.text
            XID_ = self.gds_validate_string(XID_, node, 'XID')
            self.XID = XID_
            # validate type XID
            self.validate_XID(self.XID)
        elif nodeName_ == 'CAVV':
            CAVV_ = child_.text
            CAVV_ = self.gds_validate_string(CAVV_, node, 'CAVV')
            self.CAVV = CAVV_
            # validate type CAVV
            self.validate_CAVV(self.CAVV)
        elif nodeName_ == 'THREEDS_PROTOCOL_VERSION' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'THREEDS_PROTOCOL_VERSION')
            self.THREEDS_PROTOCOL_VERSION = ival_
            # validate type THREEDS_PROTOCOL_VERSION
            self.validate_THREEDS_PROTOCOL_VERSION(self.THREEDS_PROTOCOL_VERSION)
        elif nodeName_ == 'DS_TRANS_ID':
            DS_TRANS_ID_ = child_.text
            DS_TRANS_ID_ = self.gds_validate_string(DS_TRANS_ID_, node, 'DS_TRANS_ID')
            self.DS_TRANS_ID = DS_TRANS_ID_
            # validate type DS_TRANS_ID
            self.validate_DS_TRANS_ID(self.DS_TRANS_ID)
        elif nodeName_ == 'TRANSACTIONTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TRANSACTIONTYPE')
            self.TRANSACTIONTYPE = ival_
            # validate type TRANSACTIONTYPE
            self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        elif nodeName_ == 'MPIREF':
            MPIREF_ = child_.text
            MPIREF_ = self.gds_validate_string(MPIREF_, node, 'MPIREF')
            self.MPIREF = MPIREF_
            # validate type MPIREF
            self.validate_MPIREF(self.MPIREF)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID, self.MERCHANTREF, self.DATETIME, self.CARDNUMBER, self.CARDEXPIRY, self.CARDTYPE,
        self.CARDHOLDERNAME]
        return ':'.join(hash_list)
# end class SECURECARDREGISTRATION


class SECURECARDREGISTRATIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', ['CARDREFERENCE', 'xs:string'], 0, 0, {'ref': 'CARDREFERENCE', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('MASKEDCARDNUMBER', ['MASKEDCARDNUMBER', 'xs:string'], 0, 1, {'ref': 'MASKEDCARDNUMBER', 'minOccurs': '0', 'name': 'MASKEDCARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, CARDREFERENCE=None, MASKEDCARDNUMBER=None, CREDENTIALONFILE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.CARDREFERENCE = CARDREFERENCE
        self.validate_CARDREFERENCE(self.CARDREFERENCE)
        self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
        self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDREGISTRATIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDREGISTRATIONRESPONSE.subclass:
            return SECURECARDREGISTRATIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return SECURECARDREGISTRATIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_MASKEDCARDNUMBER(self): return self.MASKEDCARDNUMBER
    def set_MASKEDCARDNUMBER(self, MASKEDCARDNUMBER): self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_CARDREFERENCE(self, value):
        # Validate type CARDREFERENCE, a restriction on xs:string.
        pass
    def validate_MASKEDCARDNUMBER(self, value):
        # Validate type MASKEDCARDNUMBER, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.CARDREFERENCE is not None or
            self.MASKEDCARDNUMBER is not None or
            self.CREDENTIALONFILE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDREGISTRATIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.MASKEDCARDNUMBER is not None:
            MASKEDCARDNUMBER_ = self.MASKEDCARDNUMBER
            etree_.SubElement(element, '{}MASKEDCARDNUMBER').text = self.gds_format_string(MASKEDCARDNUMBER_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDREGISTRATIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.MASKEDCARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('MASKEDCARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.MASKEDCARDNUMBER)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
            # validate type CARDREFERENCE
            self.validate_CARDREFERENCE(self.CARDREFERENCE)
        elif nodeName_ == 'MASKEDCARDNUMBER':
            MASKEDCARDNUMBER_ = child_.text
            MASKEDCARDNUMBER_ = self.gds_validate_string(MASKEDCARDNUMBER_, node, 'MASKEDCARDNUMBER')
            self.MASKEDCARDNUMBER = MASKEDCARDNUMBER_
            # validate type MASKEDCARDNUMBER
            self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.terminal_id]
        hash_list.append(self.MERCHANTREF)
        hash_list.append(self.CARDREFERENCE)
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class SECURECARDREGISTRATIONRESPONSE


class SECURECARDREMOVAL(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', ['CARDREFERENCE', 'xs:string'], 0, 0, {'ref': 'CARDREFERENCE', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, CARDREFERENCE=None, TERMINALID=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.CARDREFERENCE = CARDREFERENCE
        self.validate_CARDREFERENCE(self.CARDREFERENCE)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDREMOVAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDREMOVAL.subclass:
            return SECURECARDREMOVAL.subclass(*args_, **kwargs_)
        else:
            return SECURECARDREMOVAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_CARDREFERENCE(self, value):
        # Validate type CARDREFERENCE, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.CARDREFERENCE is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDREMOVAL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDREMOVAL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
            # validate type CARDREFERENCE
            self.validate_CARDREFERENCE(self.CARDREFERENCE)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID, self.MERCHANTREF, self.DATETIME, self.CARDREFERENCE]
        return ':'.join(hash_list)
# end class SECURECARDREMOVAL


class SECURECARDREMOVALRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDREMOVALRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDREMOVALRESPONSE.subclass:
            return SECURECARDREMOVALRESPONSE.subclass(*args_, **kwargs_)
        else:
            return SECURECARDREMOVALRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDREMOVALRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDREMOVALRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.terminal_id, self.MERCHANTREF, self.DATETIME]
        return ':'.join(hash_list)
# end class SECURECARDREMOVALRESPONSE


class SECURECARDUPDATE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 1, {'ref': 'CARDNUMBER', 'minOccurs': '0', 'name': 'CARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 1, {'ref': 'CARDEXPIRY', 'minOccurs': '0', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 1, {'ref': 'CARDTYPE', 'minOccurs': '0', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 1, {'ref': 'CARDHOLDERNAME', 'minOccurs': '0', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('DONTCHECKSECURITY', ['DONTCHECKSECURITY', 'xs:string'], 0, 1, {'ref': 'DONTCHECKSECURITY', 'minOccurs': '0', 'name': 'DONTCHECKSECURITY', 'type': 'xs:string'}, None),
        MemberSpec_('CVV', ['CVV', 'xs:string'], 0, 1, {'ref': 'CVV', 'minOccurs': '0', 'name': 'CVV', 'type': 'xs:string'}, None),
        MemberSpec_('ISSUENO', ['ISSUENO', 'xs:string'], 0, 1, {'ref': 'ISSUENO', 'minOccurs': '0', 'name': 'ISSUENO', 'type': 'xs:string'}, None),
        MemberSpec_('PERMITTEDTERMINALS', 'PERMITTEDTERMINALS', 0, 1, {'ref': 'PERMITTEDTERMINALS', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PERMITTEDTERMINALS', 'type': 'PERMITTEDTERMINALS'}, None),
        MemberSpec_('CUSTOMFIELD', 'CUSTOMFIELD', 1, 1, {'ref': 'CUSTOMFIELD', 'minOccurs': '0', 'maxOccurs': '3', 'name': 'CUSTOMFIELD', 'type': 'CUSTOMFIELD'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('XID', ['XID', 'xs:string'], 0, 1, {'ref': 'XID', 'minOccurs': '0', 'name': 'XID', 'type': 'xs:string'}, None),
        MemberSpec_('CAVV', ['CAVV', 'xs:string'], 0, 1, {'ref': 'CAVV', 'minOccurs': '0', 'name': 'CAVV', 'type': 'xs:string'}, None),
        MemberSpec_('THREEDS_PROTOCOL_VERSION', ['THREEDS_PROTOCOL_VERSION', 'xs:integer'], 0, 1, {'ref': 'THREEDS_PROTOCOL_VERSION', 'minOccurs': '0', 'name': 'THREEDS_PROTOCOL_VERSION', 'type': 'xs:integer'}, None),
        MemberSpec_('DS_TRANS_ID', ['DS_TRANS_ID', 'xs:string'], 0, 1, {'ref': 'DS_TRANS_ID', 'minOccurs': '0', 'name': 'DS_TRANS_ID', 'type': 'xs:string'}, None),
        MemberSpec_('TRANSACTIONTYPE', ['TRANSACTIONTYPE', 'xs:int'], 0, 1, {'ref': 'TRANSACTIONTYPE', 'minOccurs': '0', 'name': 'TRANSACTIONTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('MPIREF', ['MPIREF', 'xs:string'], 0, 1, {'ref': 'MPIREF', 'minOccurs': '0', 'name': 'MPIREF', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, CARDNUMBER=None, CARDEXPIRY=None, CARDTYPE=None, CARDHOLDERNAME=None, HASH=None, DONTCHECKSECURITY=None, CVV=None, ISSUENO=None, PERMITTEDTERMINALS=None, CUSTOMFIELD=None, EMAIL=None, PHONE=None, CREDENTIALONFILE=None, XID=None, CAVV=None, THREEDS_PROTOCOL_VERSION=None, DS_TRANS_ID=None, TRANSACTIONTYPE=None, MPIREF=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.DONTCHECKSECURITY = DONTCHECKSECURITY
        self.validate_DONTCHECKSECURITY(self.DONTCHECKSECURITY)
        self.CVV = CVV
        self.validate_CVV(self.CVV)
        self.ISSUENO = ISSUENO
        self.validate_ISSUENO(self.ISSUENO)
        self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
        if CUSTOMFIELD is None:
            self.CUSTOMFIELD = []
        else:
            self.CUSTOMFIELD = CUSTOMFIELD
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.XID = XID
        self.validate_XID(self.XID)
        self.CAVV = CAVV
        self.validate_CAVV(self.CAVV)
        self.THREEDS_PROTOCOL_VERSION = THREEDS_PROTOCOL_VERSION
        self.validate_THREEDS_PROTOCOL_VERSION(self.THREEDS_PROTOCOL_VERSION)
        self.DS_TRANS_ID = DS_TRANS_ID
        self.validate_DS_TRANS_ID(self.DS_TRANS_ID)
        self.TRANSACTIONTYPE = TRANSACTIONTYPE
        self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        self.MPIREF = MPIREF
        self.validate_MPIREF(self.MPIREF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDUPDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDUPDATE.subclass:
            return SECURECARDUPDATE.subclass(*args_, **kwargs_)
        else:
            return SECURECARDUPDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_DONTCHECKSECURITY(self): return self.DONTCHECKSECURITY
    def set_DONTCHECKSECURITY(self, DONTCHECKSECURITY): self.DONTCHECKSECURITY = DONTCHECKSECURITY
    def get_CVV(self): return self.CVV
    def set_CVV(self, CVV): self.CVV = CVV
    def get_ISSUENO(self): return self.ISSUENO
    def set_ISSUENO(self, ISSUENO): self.ISSUENO = ISSUENO
    def get_PERMITTEDTERMINALS(self): return self.PERMITTEDTERMINALS
    def set_PERMITTEDTERMINALS(self, PERMITTEDTERMINALS): self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
    def get_CUSTOMFIELD(self): return self.CUSTOMFIELD
    def set_CUSTOMFIELD(self, CUSTOMFIELD): self.CUSTOMFIELD = CUSTOMFIELD
    def add_CUSTOMFIELD(self, value): self.CUSTOMFIELD.append(value)
    def insert_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD.insert(index, value)
    def replace_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD[index] = value
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_XID(self): return self.XID
    def set_XID(self, XID): self.XID = XID
    def get_CAVV(self): return self.CAVV
    def set_CAVV(self, CAVV): self.CAVV = CAVV
    def get_THREEDS_PROTOCOL_VERSION(self): return self.THREEDS_PROTOCOL_VERSION
    def set_THREEDS_PROTOCOL_VERSION(self, THREEDS_PROTOCOL_VERSION): self.THREEDS_PROTOCOL_VERSION = THREEDS_PROTOCOL_VERSION
    def get_DS_TRANS_ID(self): return self.DS_TRANS_ID
    def set_DS_TRANS_ID(self, DS_TRANS_ID): self.DS_TRANS_ID = DS_TRANS_ID
    def get_TRANSACTIONTYPE(self): return self.TRANSACTIONTYPE
    def set_TRANSACTIONTYPE(self, TRANSACTIONTYPE): self.TRANSACTIONTYPE = TRANSACTIONTYPE
    def get_MPIREF(self): return self.MPIREF
    def set_MPIREF(self, MPIREF): self.MPIREF = MPIREF
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_DONTCHECKSECURITY(self, value):
        # Validate type DONTCHECKSECURITY, a restriction on xs:string.
        pass
    def validate_CVV(self, value):
        # Validate type CVV, a restriction on xs:string.
        pass
    def validate_ISSUENO(self, value):
        # Validate type ISSUENO, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_XID(self, value):
        # Validate type XID, a restriction on xs:string.
        pass
    def validate_CAVV(self, value):
        # Validate type CAVV, a restriction on xs:string.
        pass
    def validate_THREEDS_PROTOCOL_VERSION(self, value):
        # Validate type THREEDS_PROTOCOL_VERSION, a restriction on xs:integer.
        pass
    def validate_DS_TRANS_ID(self, value):
        # Validate type DS_TRANS_ID, a restriction on xs:string.
        pass
    def validate_TRANSACTIONTYPE(self, value):
        # Validate type TRANSACTIONTYPE, a restriction on xs:int.
        pass
    def validate_MPIREF(self, value):
        # Validate type MPIREF, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.CARDNUMBER is not None or
            self.CARDEXPIRY is not None or
            self.CARDTYPE is not None or
            self.CARDHOLDERNAME is not None or
            self.HASH is not None or
            self.DONTCHECKSECURITY is not None or
            self.CVV is not None or
            self.ISSUENO is not None or
            self.PERMITTEDTERMINALS is not None or
            self.CUSTOMFIELD or
            self.EMAIL is not None or
            self.PHONE is not None or
            self.CREDENTIALONFILE is not None or
            self.XID is not None or
            self.CAVV is not None or
            self.THREEDS_PROTOCOL_VERSION is not None or
            self.DS_TRANS_ID is not None or
            self.TRANSACTIONTYPE is not None or
            self.MPIREF is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDUPDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.DONTCHECKSECURITY is not None:
            DONTCHECKSECURITY_ = self.DONTCHECKSECURITY
            etree_.SubElement(element, '{}DONTCHECKSECURITY').text = self.gds_format_string(DONTCHECKSECURITY_)
        if self.CVV is not None:
            CVV_ = self.CVV
            etree_.SubElement(element, '{}CVV').text = self.gds_format_string(CVV_)
        if self.ISSUENO is not None:
            ISSUENO_ = self.ISSUENO
            etree_.SubElement(element, '{}ISSUENO').text = self.gds_format_string(ISSUENO_)
        if self.PERMITTEDTERMINALS is not None:
            PERMITTEDTERMINALS_ = self.PERMITTEDTERMINALS
            PERMITTEDTERMINALS_.to_etree(element, name_='PERMITTEDTERMINALS', mapping_=mapping_)
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            CUSTOMFIELD_.to_etree(element, name_='CUSTOMFIELD', mapping_=mapping_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.XID is not None:
            XID_ = self.XID
            etree_.SubElement(element, '{}XID').text = self.gds_format_string(XID_)
        if self.CAVV is not None:
            CAVV_ = self.CAVV
            etree_.SubElement(element, '{}CAVV').text = self.gds_format_string(CAVV_)
        if self.THREEDS_PROTOCOL_VERSION is not None:
            THREEDS_PROTOCOL_VERSION_ = self.THREEDS_PROTOCOL_VERSION
            etree_.SubElement(element, '{}THREEDS_PROTOCOL_VERSION').text = self.gds_format_integer(THREEDS_PROTOCOL_VERSION_)
        if self.DS_TRANS_ID is not None:
            DS_TRANS_ID_ = self.DS_TRANS_ID
            etree_.SubElement(element, '{}DS_TRANS_ID').text = self.gds_format_string(DS_TRANS_ID_)
        if self.TRANSACTIONTYPE is not None:
            TRANSACTIONTYPE_ = self.TRANSACTIONTYPE
            etree_.SubElement(element, '{}TRANSACTIONTYPE').text = self.gds_format_integer(TRANSACTIONTYPE_)
        if self.MPIREF is not None:
            MPIREF_ = self.MPIREF
            etree_.SubElement(element, '{}MPIREF').text = self.gds_format_string(MPIREF_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDUPDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.DONTCHECKSECURITY is not None:
            showIndent(outfile, level)
            outfile.write('DONTCHECKSECURITY=%s,\n' % self.gds_encode(quote_python(self.DONTCHECKSECURITY)))
        if self.CVV is not None:
            showIndent(outfile, level)
            outfile.write('CVV=%s,\n' % self.gds_encode(quote_python(self.CVV)))
        if self.ISSUENO is not None:
            showIndent(outfile, level)
            outfile.write('ISSUENO=%s,\n' % self.gds_encode(quote_python(self.ISSUENO)))
        if self.PERMITTEDTERMINALS is not None:
            showIndent(outfile, level)
            outfile.write('PERMITTEDTERMINALS=model_.PERMITTEDTERMINALS(\n')
            self.PERMITTEDTERMINALS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CUSTOMFIELD=[\n')
        level += 1
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOMFIELD(\n')
            CUSTOMFIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.XID is not None:
            showIndent(outfile, level)
            outfile.write('XID=%s,\n' % self.gds_encode(quote_python(self.XID)))
        if self.CAVV is not None:
            showIndent(outfile, level)
            outfile.write('CAVV=%s,\n' % self.gds_encode(quote_python(self.CAVV)))
        if self.THREEDS_PROTOCOL_VERSION is not None:
            showIndent(outfile, level)
            outfile.write('THREEDS_PROTOCOL_VERSION=%d,\n' % self.THREEDS_PROTOCOL_VERSION)
        if self.DS_TRANS_ID is not None:
            showIndent(outfile, level)
            outfile.write('DS_TRANS_ID=%s,\n' % self.gds_encode(quote_python(self.DS_TRANS_ID)))
        if self.TRANSACTIONTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTIONTYPE=%d,\n' % self.TRANSACTIONTYPE)
        if self.MPIREF is not None:
            showIndent(outfile, level)
            outfile.write('MPIREF=%s,\n' % self.gds_encode(quote_python(self.MPIREF)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'DONTCHECKSECURITY':
            DONTCHECKSECURITY_ = child_.text
            DONTCHECKSECURITY_ = self.gds_validate_string(DONTCHECKSECURITY_, node, 'DONTCHECKSECURITY')
            self.DONTCHECKSECURITY = DONTCHECKSECURITY_
            # validate type DONTCHECKSECURITY
            self.validate_DONTCHECKSECURITY(self.DONTCHECKSECURITY)
        elif nodeName_ == 'CVV':
            CVV_ = child_.text
            CVV_ = self.gds_validate_string(CVV_, node, 'CVV')
            self.CVV = CVV_
            # validate type CVV
            self.validate_CVV(self.CVV)
        elif nodeName_ == 'ISSUENO':
            ISSUENO_ = child_.text
            ISSUENO_ = self.gds_validate_string(ISSUENO_, node, 'ISSUENO')
            self.ISSUENO = ISSUENO_
            # validate type ISSUENO
            self.validate_ISSUENO(self.ISSUENO)
        elif nodeName_ == 'PERMITTEDTERMINALS':
            obj_ = PERMITTEDTERMINALS.factory()
            obj_.build(child_)
            self.PERMITTEDTERMINALS = obj_
            obj_.original_tagname_ = 'PERMITTEDTERMINALS'
        elif nodeName_ == 'CUSTOMFIELD':
            obj_ = CUSTOMFIELD.factory()
            obj_.build(child_)
            self.CUSTOMFIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOMFIELD'
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'XID':
            XID_ = child_.text
            XID_ = self.gds_validate_string(XID_, node, 'XID')
            self.XID = XID_
            # validate type XID
            self.validate_XID(self.XID)
        elif nodeName_ == 'CAVV':
            CAVV_ = child_.text
            CAVV_ = self.gds_validate_string(CAVV_, node, 'CAVV')
            self.CAVV = CAVV_
            # validate type CAVV
            self.validate_CAVV(self.CAVV)
        elif nodeName_ == 'THREEDS_PROTOCOL_VERSION' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'THREEDS_PROTOCOL_VERSION')
            self.THREEDS_PROTOCOL_VERSION = ival_
            # validate type THREEDS_PROTOCOL_VERSION
            self.validate_THREEDS_PROTOCOL_VERSION(self.THREEDS_PROTOCOL_VERSION)
        elif nodeName_ == 'DS_TRANS_ID':
            DS_TRANS_ID_ = child_.text
            DS_TRANS_ID_ = self.gds_validate_string(DS_TRANS_ID_, node, 'DS_TRANS_ID')
            self.DS_TRANS_ID = DS_TRANS_ID_
            # validate type DS_TRANS_ID
            self.validate_DS_TRANS_ID(self.DS_TRANS_ID)
        elif nodeName_ == 'TRANSACTIONTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TRANSACTIONTYPE')
            self.TRANSACTIONTYPE = ival_
            # validate type TRANSACTIONTYPE
            self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        elif nodeName_ == 'MPIREF':
            MPIREF_ = child_.text
            MPIREF_ = self.gds_validate_string(MPIREF_, node, 'MPIREF')
            self.MPIREF = MPIREF_
            # validate type MPIREF
            self.validate_MPIREF(self.MPIREF)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID, self.MERCHANTREF, self.DATETIME, self.CARDNUMBER, self.CARDEXPIRY, self.CARDTYPE,
        self.CARDHOLDERNAME]
        return ':'.join(hash_list)
# end class SECURECARDUPDATE


class SECURECARDUPDATERESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', ['CARDREFERENCE', 'xs:string'], 0, 0, {'ref': 'CARDREFERENCE', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('MASKEDCARDNUMBER', ['MASKEDCARDNUMBER', 'xs:string'], 0, 1, {'ref': 'MASKEDCARDNUMBER', 'minOccurs': '0', 'name': 'MASKEDCARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, CARDREFERENCE=None, MASKEDCARDNUMBER=None, CREDENTIALONFILE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.CARDREFERENCE = CARDREFERENCE
        self.validate_CARDREFERENCE(self.CARDREFERENCE)
        self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
        self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDUPDATERESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDUPDATERESPONSE.subclass:
            return SECURECARDUPDATERESPONSE.subclass(*args_, **kwargs_)
        else:
            return SECURECARDUPDATERESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_MASKEDCARDNUMBER(self): return self.MASKEDCARDNUMBER
    def set_MASKEDCARDNUMBER(self, MASKEDCARDNUMBER): self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_CARDREFERENCE(self, value):
        # Validate type CARDREFERENCE, a restriction on xs:string.
        pass
    def validate_MASKEDCARDNUMBER(self, value):
        # Validate type MASKEDCARDNUMBER, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.CARDREFERENCE is not None or
            self.MASKEDCARDNUMBER is not None or
            self.CREDENTIALONFILE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDUPDATERESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.MASKEDCARDNUMBER is not None:
            MASKEDCARDNUMBER_ = self.MASKEDCARDNUMBER
            etree_.SubElement(element, '{}MASKEDCARDNUMBER').text = self.gds_format_string(MASKEDCARDNUMBER_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDUPDATERESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.MASKEDCARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('MASKEDCARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.MASKEDCARDNUMBER)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
            # validate type CARDREFERENCE
            self.validate_CARDREFERENCE(self.CARDREFERENCE)
        elif nodeName_ == 'MASKEDCARDNUMBER':
            MASKEDCARDNUMBER_ = child_.text
            MASKEDCARDNUMBER_ = self.gds_validate_string(MASKEDCARDNUMBER_, node, 'MASKEDCARDNUMBER')
            self.MASKEDCARDNUMBER = MASKEDCARDNUMBER_
            # validate type MASKEDCARDNUMBER
            self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class SECURECARDUPDATERESPONSE


class SECURECARDSEARCH(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('PERMITTEDTERMINALSREQUIRED', ['PERMITTEDTERMINALSREQUIRED', 'xs:string'], 0, 1, {'ref': 'PERMITTEDTERMINALSREQUIRED', 'minOccurs': '0', 'name': 'PERMITTEDTERMINALSREQUIRED', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, PERMITTEDTERMINALSREQUIRED=None, CREDENTIALONFILE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.PERMITTEDTERMINALSREQUIRED = PERMITTEDTERMINALSREQUIRED
        self.validate_PERMITTEDTERMINALSREQUIRED(self.PERMITTEDTERMINALSREQUIRED)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDSEARCH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDSEARCH.subclass:
            return SECURECARDSEARCH.subclass(*args_, **kwargs_)
        else:
            return SECURECARDSEARCH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_PERMITTEDTERMINALSREQUIRED(self): return self.PERMITTEDTERMINALSREQUIRED
    def set_PERMITTEDTERMINALSREQUIRED(self, PERMITTEDTERMINALSREQUIRED): self.PERMITTEDTERMINALSREQUIRED = PERMITTEDTERMINALSREQUIRED
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_PERMITTEDTERMINALSREQUIRED(self, value):
        # Validate type PERMITTEDTERMINALSREQUIRED, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.PERMITTEDTERMINALSREQUIRED is not None or
            self.CREDENTIALONFILE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDSEARCH', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.PERMITTEDTERMINALSREQUIRED is not None:
            PERMITTEDTERMINALSREQUIRED_ = self.PERMITTEDTERMINALSREQUIRED
            etree_.SubElement(element, '{}PERMITTEDTERMINALSREQUIRED').text = self.gds_format_string(PERMITTEDTERMINALSREQUIRED_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDSEARCH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.PERMITTEDTERMINALSREQUIRED is not None:
            showIndent(outfile, level)
            outfile.write('PERMITTEDTERMINALSREQUIRED=%s,\n' % self.gds_encode(quote_python(self.PERMITTEDTERMINALSREQUIRED)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'PERMITTEDTERMINALSREQUIRED':
            PERMITTEDTERMINALSREQUIRED_ = child_.text
            PERMITTEDTERMINALSREQUIRED_ = self.gds_validate_string(PERMITTEDTERMINALSREQUIRED_, node, 'PERMITTEDTERMINALSREQUIRED')
            self.PERMITTEDTERMINALSREQUIRED = PERMITTEDTERMINALSREQUIRED_
            # validate type PERMITTEDTERMINALSREQUIRED
            self.validate_PERMITTEDTERMINALSREQUIRED(self.PERMITTEDTERMINALSREQUIRED)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID, self.MERCHANTREF, self.DATETIME]
        return ':'.join(hash_list)
# end class SECURECARDSEARCH


class SECURECARDSEARCHRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', ['CARDREFERENCE', 'xs:string'], 0, 0, {'ref': 'CARDREFERENCE', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 0, {'ref': 'CARDTYPE', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 0, {'ref': 'CARDEXPIRY', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 0, {'ref': 'CARDHOLDERNAME', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('PERMITTEDTERMINALS', 'PERMITTEDTERMINALS', 0, 1, {'ref': 'PERMITTEDTERMINALS', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PERMITTEDTERMINALS', 'type': 'PERMITTEDTERMINALS'}, None),
        MemberSpec_('MASKEDCARDNUMBER', ['MASKEDCARDNUMBER', 'xs:string'], 0, 1, {'ref': 'MASKEDCARDNUMBER', 'minOccurs': '0', 'name': 'MASKEDCARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, CARDREFERENCE=None, CARDTYPE=None, CARDEXPIRY=None, CARDHOLDERNAME=None, PERMITTEDTERMINALS=None, MASKEDCARDNUMBER=None, CREDENTIALONFILE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.CARDREFERENCE = CARDREFERENCE
        self.validate_CARDREFERENCE(self.CARDREFERENCE)
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
        self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
        self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDSEARCHRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDSEARCHRESPONSE.subclass:
            return SECURECARDSEARCHRESPONSE.subclass(*args_, **kwargs_)
        else:
            return SECURECARDSEARCHRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_PERMITTEDTERMINALS(self): return self.PERMITTEDTERMINALS
    def set_PERMITTEDTERMINALS(self, PERMITTEDTERMINALS): self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
    def get_MASKEDCARDNUMBER(self): return self.MASKEDCARDNUMBER
    def set_MASKEDCARDNUMBER(self, MASKEDCARDNUMBER): self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_CARDREFERENCE(self, value):
        # Validate type CARDREFERENCE, a restriction on xs:string.
        pass
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_MASKEDCARDNUMBER(self, value):
        # Validate type MASKEDCARDNUMBER, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.CARDREFERENCE is not None or
            self.CARDTYPE is not None or
            self.CARDEXPIRY is not None or
            self.CARDHOLDERNAME is not None or
            self.PERMITTEDTERMINALS is not None or
            self.MASKEDCARDNUMBER is not None or
            self.CREDENTIALONFILE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDSEARCHRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.PERMITTEDTERMINALS is not None:
            PERMITTEDTERMINALS_ = self.PERMITTEDTERMINALS
            PERMITTEDTERMINALS_.to_etree(element, name_='PERMITTEDTERMINALS', mapping_=mapping_)
        if self.MASKEDCARDNUMBER is not None:
            MASKEDCARDNUMBER_ = self.MASKEDCARDNUMBER
            etree_.SubElement(element, '{}MASKEDCARDNUMBER').text = self.gds_format_string(MASKEDCARDNUMBER_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDSEARCHRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.PERMITTEDTERMINALS is not None:
            showIndent(outfile, level)
            outfile.write('PERMITTEDTERMINALS=model_.PERMITTEDTERMINALS(\n')
            self.PERMITTEDTERMINALS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MASKEDCARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('MASKEDCARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.MASKEDCARDNUMBER)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
            # validate type CARDREFERENCE
            self.validate_CARDREFERENCE(self.CARDREFERENCE)
        elif nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'PERMITTEDTERMINALS':
            obj_ = PERMITTEDTERMINALS.factory()
            obj_.build(child_)
            self.PERMITTEDTERMINALS = obj_
            obj_.original_tagname_ = 'PERMITTEDTERMINALS'
        elif nodeName_ == 'MASKEDCARDNUMBER':
            MASKEDCARDNUMBER_ = child_.text
            MASKEDCARDNUMBER_ = self.gds_validate_string(MASKEDCARDNUMBER_, node, 'MASKEDCARDNUMBER')
            self.MASKEDCARDNUMBER = MASKEDCARDNUMBER_
            # validate type MASKEDCARDNUMBER
            self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class SECURECARDSEARCHRESPONSE


class SECURE_CARD_ADVANCED_SEARCH(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 1, {'ref': 'MERCHANTREF', 'minOccurs': '0', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('NAME', ['NAME', 'xs:string'], 0, 1, {'ref': 'NAME', 'minOccurs': '0', 'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('CREATIONDATE', ['CREATIONDATE', 'xs:string'], 0, 1, {'ref': 'CREATIONDATE', 'minOccurs': '0', 'name': 'CREATIONDATE', 'type': 'xs:string'}, None),
        MemberSpec_('PERMITTEDTERMINALSREQUIRED', ['PERMITTEDTERMINALSREQUIRED', 'xs:string'], 0, 1, {'ref': 'PERMITTEDTERMINALSREQUIRED', 'minOccurs': '0', 'name': 'PERMITTEDTERMINALSREQUIRED', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOMFIELD', 'CUSTOMFIELD', 1, 1, {'ref': 'CUSTOMFIELD', 'minOccurs': '0', 'maxOccurs': '3', 'name': 'CUSTOMFIELD', 'type': 'CUSTOMFIELD'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, NAME=None, EMAIL=None, PHONE=None, CREATIONDATE=None, PERMITTEDTERMINALSREQUIRED=None, CREDENTIALONFILE=None, DATETIME=None, CUSTOMFIELD=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.NAME = NAME
        self.validate_NAME(self.NAME)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.CREATIONDATE = CREATIONDATE
        self.validate_CREATIONDATE(self.CREATIONDATE)
        self.PERMITTEDTERMINALSREQUIRED = PERMITTEDTERMINALSREQUIRED
        self.validate_PERMITTEDTERMINALSREQUIRED(self.PERMITTEDTERMINALSREQUIRED)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        if CUSTOMFIELD is None:
            self.CUSTOMFIELD = []
        else:
            self.CUSTOMFIELD = CUSTOMFIELD
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURE_CARD_ADVANCED_SEARCH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURE_CARD_ADVANCED_SEARCH.subclass:
            return SECURE_CARD_ADVANCED_SEARCH.subclass(*args_, **kwargs_)
        else:
            return SECURE_CARD_ADVANCED_SEARCH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_CREATIONDATE(self): return self.CREATIONDATE
    def set_CREATIONDATE(self, CREATIONDATE): self.CREATIONDATE = CREATIONDATE
    def get_PERMITTEDTERMINALSREQUIRED(self): return self.PERMITTEDTERMINALSREQUIRED
    def set_PERMITTEDTERMINALSREQUIRED(self, PERMITTEDTERMINALSREQUIRED): self.PERMITTEDTERMINALSREQUIRED = PERMITTEDTERMINALSREQUIRED
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_CUSTOMFIELD(self): return self.CUSTOMFIELD
    def set_CUSTOMFIELD(self, CUSTOMFIELD): self.CUSTOMFIELD = CUSTOMFIELD
    def add_CUSTOMFIELD(self, value): self.CUSTOMFIELD.append(value)
    def insert_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD.insert(index, value)
    def replace_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD[index] = value
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_NAME(self, value):
        # Validate type NAME, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_CREATIONDATE(self, value):
        # Validate type CREATIONDATE, a restriction on xs:string.
        pass
    def validate_PERMITTEDTERMINALSREQUIRED(self, value):
        # Validate type PERMITTEDTERMINALSREQUIRED, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.NAME is not None or
            self.EMAIL is not None or
            self.PHONE is not None or
            self.CREATIONDATE is not None or
            self.PERMITTEDTERMINALSREQUIRED is not None or
            self.CREDENTIALONFILE is not None or
            self.DATETIME is not None or
            self.CUSTOMFIELD or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURE_CARD_ADVANCED_SEARCH', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.CREATIONDATE is not None:
            CREATIONDATE_ = self.CREATIONDATE
            etree_.SubElement(element, '{}CREATIONDATE').text = self.gds_format_string(CREATIONDATE_)
        if self.PERMITTEDTERMINALSREQUIRED is not None:
            PERMITTEDTERMINALSREQUIRED_ = self.PERMITTEDTERMINALSREQUIRED
            etree_.SubElement(element, '{}PERMITTEDTERMINALSREQUIRED').text = self.gds_format_string(PERMITTEDTERMINALSREQUIRED_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            CUSTOMFIELD_.to_etree(element, name_='CUSTOMFIELD', mapping_=mapping_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURE_CARD_ADVANCED_SEARCH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.CREATIONDATE is not None:
            showIndent(outfile, level)
            outfile.write('CREATIONDATE=%s,\n' % self.gds_encode(quote_python(self.CREATIONDATE)))
        if self.PERMITTEDTERMINALSREQUIRED is not None:
            showIndent(outfile, level)
            outfile.write('PERMITTEDTERMINALSREQUIRED=%s,\n' % self.gds_encode(quote_python(self.PERMITTEDTERMINALSREQUIRED)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        showIndent(outfile, level)
        outfile.write('CUSTOMFIELD=[\n')
        level += 1
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOMFIELD(\n')
            CUSTOMFIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
            # validate type NAME
            self.validate_NAME(self.NAME)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'CREATIONDATE':
            CREATIONDATE_ = child_.text
            CREATIONDATE_ = self.gds_validate_string(CREATIONDATE_, node, 'CREATIONDATE')
            self.CREATIONDATE = CREATIONDATE_
            # validate type CREATIONDATE
            self.validate_CREATIONDATE(self.CREATIONDATE)
        elif nodeName_ == 'PERMITTEDTERMINALSREQUIRED':
            PERMITTEDTERMINALSREQUIRED_ = child_.text
            PERMITTEDTERMINALSREQUIRED_ = self.gds_validate_string(PERMITTEDTERMINALSREQUIRED_, node, 'PERMITTEDTERMINALSREQUIRED')
            self.PERMITTEDTERMINALSREQUIRED = PERMITTEDTERMINALSREQUIRED_
            # validate type PERMITTEDTERMINALSREQUIRED
            self.validate_PERMITTEDTERMINALSREQUIRED(self.PERMITTEDTERMINALSREQUIRED)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'CUSTOMFIELD':
            obj_ = CUSTOMFIELD.factory()
            obj_.build(child_)
            self.CUSTOMFIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOMFIELD'
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID]
        if self.MERCHANTREF:
            hash_list.append(self.MERCHANTREF)
        if self.NAME:
            hash_list.append(self.NAME)
        if self.EMAIL:
            hash_list.append(self.EMAIL)
        if self.PHONE:
            hash_list.append(self.PHONE)
        if self.CREATIONDATE:
            hash_list.append(self.CREATIONDATE)
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class SECURE_CARD_ADVANCED_SEARCH


class SECURE_CARD_ADVANCED_SEARCH_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('SECURECARD', 'SECURECARD', 1, 0, {'ref': 'SECURECARD', 'minOccurs': '1', 'maxOccurs': 'unbounded', 'name': 'SECURECARD', 'type': 'SECURECARD'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, SECURECARD=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        if SECURECARD is None:
            self.SECURECARD = []
        else:
            self.SECURECARD = SECURECARD
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURE_CARD_ADVANCED_SEARCH_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURE_CARD_ADVANCED_SEARCH_RESPONSE.subclass:
            return SECURE_CARD_ADVANCED_SEARCH_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return SECURE_CARD_ADVANCED_SEARCH_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SECURECARD(self): return self.SECURECARD
    def set_SECURECARD(self, SECURECARD): self.SECURECARD = SECURECARD
    def add_SECURECARD(self, value): self.SECURECARD.append(value)
    def insert_SECURECARD_at(self, index, value): self.SECURECARD.insert(index, value)
    def replace_SECURECARD_at(self, index, value): self.SECURECARD[index] = value
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.SECURECARD or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURE_CARD_ADVANCED_SEARCH_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for SECURECARD_ in self.SECURECARD:
            SECURECARD_.to_etree(element, name_='SECURECARD', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURE_CARD_ADVANCED_SEARCH_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SECURECARD=[\n')
        level += 1
        for SECURECARD_ in self.SECURECARD:
            showIndent(outfile, level)
            outfile.write('model_.SECURECARD(\n')
            SECURECARD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SECURECARD':
            obj_ = SECURECARD.factory()
            obj_.build(child_)
            self.SECURECARD.append(obj_)
            obj_.original_tagname_ = 'SECURECARD'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class SECURE_CARD_ADVANCED_SEARCH_RESPONSE


class SECURECARD(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', ['CARDREFERENCE', 'xs:string'], 0, 0, {'ref': 'CARDREFERENCE', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 0, {'ref': 'CARDTYPE', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 0, {'ref': 'CARDEXPIRY', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 0, {'ref': 'CARDHOLDERNAME', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('PERMITTEDTERMINALS', 'PERMITTEDTERMINALS', 0, 1, {'ref': 'PERMITTEDTERMINALS', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PERMITTEDTERMINALS', 'type': 'PERMITTEDTERMINALS'}, None),
        MemberSpec_('MASKEDCARDNUMBER', ['MASKEDCARDNUMBER', 'xs:string'], 0, 1, {'ref': 'MASKEDCARDNUMBER', 'minOccurs': '0', 'name': 'MASKEDCARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, CARDREFERENCE=None, CARDTYPE=None, CARDEXPIRY=None, CARDHOLDERNAME=None, PERMITTEDTERMINALS=None, MASKEDCARDNUMBER=None, CREDENTIALONFILE=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.CARDREFERENCE = CARDREFERENCE
        self.validate_CARDREFERENCE(self.CARDREFERENCE)
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
        self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
        self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        self.CREDENTIALONFILE = CREDENTIALONFILE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARD.subclass:
            return SECURECARD.subclass(*args_, **kwargs_)
        else:
            return SECURECARD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_PERMITTEDTERMINALS(self): return self.PERMITTEDTERMINALS
    def set_PERMITTEDTERMINALS(self, PERMITTEDTERMINALS): self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
    def get_MASKEDCARDNUMBER(self): return self.MASKEDCARDNUMBER
    def set_MASKEDCARDNUMBER(self, MASKEDCARDNUMBER): self.MASKEDCARDNUMBER = MASKEDCARDNUMBER
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_CARDREFERENCE(self, value):
        # Validate type CARDREFERENCE, a restriction on xs:string.
        pass
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_MASKEDCARDNUMBER(self, value):
        # Validate type MASKEDCARDNUMBER, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.CARDREFERENCE is not None or
            self.CARDTYPE is not None or
            self.CARDEXPIRY is not None or
            self.CARDHOLDERNAME is not None or
            self.PERMITTEDTERMINALS is not None or
            self.MASKEDCARDNUMBER is not None or
            self.CREDENTIALONFILE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARD', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.PERMITTEDTERMINALS is not None:
            PERMITTEDTERMINALS_ = self.PERMITTEDTERMINALS
            PERMITTEDTERMINALS_.to_etree(element, name_='PERMITTEDTERMINALS', mapping_=mapping_)
        if self.MASKEDCARDNUMBER is not None:
            MASKEDCARDNUMBER_ = self.MASKEDCARDNUMBER
            etree_.SubElement(element, '{}MASKEDCARDNUMBER').text = self.gds_format_string(MASKEDCARDNUMBER_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARD'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.PERMITTEDTERMINALS is not None:
            showIndent(outfile, level)
            outfile.write('PERMITTEDTERMINALS=model_.PERMITTEDTERMINALS(\n')
            self.PERMITTEDTERMINALS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MASKEDCARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('MASKEDCARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.MASKEDCARDNUMBER)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
            # validate type CARDREFERENCE
            self.validate_CARDREFERENCE(self.CARDREFERENCE)
        elif nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'PERMITTEDTERMINALS':
            obj_ = PERMITTEDTERMINALS.factory()
            obj_.build(child_)
            self.PERMITTEDTERMINALS = obj_
            obj_.original_tagname_ = 'PERMITTEDTERMINALS'
        elif nodeName_ == 'MASKEDCARDNUMBER':
            MASKEDCARDNUMBER_ = child_.text
            MASKEDCARDNUMBER_ = self.gds_validate_string(MASKEDCARDNUMBER_, node, 'MASKEDCARDNUMBER')
            self.MASKEDCARDNUMBER = MASKEDCARDNUMBER_
            # validate type MASKEDCARDNUMBER
            self.validate_MASKEDCARDNUMBER(self.MASKEDCARDNUMBER)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
# end class SECURECARD


class NAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NAME.subclass:
            return NAME.subclass(*args_, **kwargs_)
        else:
            return NAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='NAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NAME


class PERIODTYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERIODTYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERIODTYPE.subclass:
            return PERIODTYPE.subclass(*args_, **kwargs_)
        else:
            return PERIODTYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PERIODTYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PERIODTYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PERIODTYPE


class TYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TYPE.subclass:
            return TYPE.subclass(*args_, **kwargs_)
        else:
            return TYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TYPE


class ONUPDATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ONUPDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ONUPDATE.subclass:
            return ONUPDATE.subclass(*args_, **kwargs_)
        else:
            return ONUPDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ONUPDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ONUPDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ONUPDATE


class ONDELETE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ONDELETE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ONDELETE.subclass:
            return ONDELETE.subclass(*args_, **kwargs_)
        else:
            return ONDELETE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ONDELETE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ONDELETE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ONDELETE


class ADDSTOREDSUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('NAME', ['NAME', 'xs:string'], 0, 0, {'ref': 'NAME', 'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('PERIODTYPE', ['PERIODTYPE', 'xs:string'], 0, 0, {'ref': 'PERIODTYPE', 'name': 'PERIODTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('LENGTH', 'xs:unsignedInt', 0, 0, {'ref': 'LENGTH', 'name': 'LENGTH', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('INITIALAMOUNT', 'xs:double', 0, 1, {'ref': 'INITIALAMOUNT', 'minOccurs': '0', 'name': 'INITIALAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('TYPE', ['TYPE', 'xs:string'], 0, 0, {'ref': 'TYPE', 'name': 'TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ONUPDATE', ['ONUPDATE', 'xs:string'], 0, 0, {'ref': 'ONUPDATE', 'name': 'ONUPDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ONDELETE', ['ONDELETE', 'xs:string'], 0, 0, {'ref': 'ONDELETE', 'name': 'ONDELETE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOMFIELD', 'CUSTOMFIELD', 1, 1, {'ref': 'CUSTOMFIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'CUSTOMFIELD', 'type': 'CUSTOMFIELD'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, NAME=None, DESCRIPTION=None, PERIODTYPE=None, LENGTH=None, CURRENCY=None, RECURRINGAMOUNT=None, INITIALAMOUNT=None, TYPE=None, ONUPDATE=None, ONDELETE=None, HASH=None, CUSTOMFIELD=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.NAME = NAME
        self.validate_NAME(self.NAME)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.PERIODTYPE = PERIODTYPE
        self.validate_PERIODTYPE(self.PERIODTYPE)
        self.LENGTH = LENGTH
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.INITIALAMOUNT = INITIALAMOUNT
        self.TYPE = TYPE
        self.validate_TYPE(self.TYPE)
        self.ONUPDATE = ONUPDATE
        self.validate_ONUPDATE(self.ONUPDATE)
        self.ONDELETE = ONDELETE
        self.validate_ONDELETE(self.ONDELETE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        if CUSTOMFIELD is None:
            self.CUSTOMFIELD = []
        else:
            self.CUSTOMFIELD = CUSTOMFIELD
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDSTOREDSUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDSTOREDSUBSCRIPTION.subclass:
            return ADDSTOREDSUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return ADDSTOREDSUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_PERIODTYPE(self): return self.PERIODTYPE
    def set_PERIODTYPE(self, PERIODTYPE): self.PERIODTYPE = PERIODTYPE
    def get_LENGTH(self): return self.LENGTH
    def set_LENGTH(self, LENGTH): self.LENGTH = LENGTH
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_INITIALAMOUNT(self): return self.INITIALAMOUNT
    def set_INITIALAMOUNT(self, INITIALAMOUNT): self.INITIALAMOUNT = INITIALAMOUNT
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ONUPDATE(self): return self.ONUPDATE
    def set_ONUPDATE(self, ONUPDATE): self.ONUPDATE = ONUPDATE
    def get_ONDELETE(self): return self.ONDELETE
    def set_ONDELETE(self, ONDELETE): self.ONDELETE = ONDELETE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CUSTOMFIELD(self): return self.CUSTOMFIELD
    def set_CUSTOMFIELD(self, CUSTOMFIELD): self.CUSTOMFIELD = CUSTOMFIELD
    def add_CUSTOMFIELD(self, value): self.CUSTOMFIELD.append(value)
    def insert_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD.insert(index, value)
    def replace_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD[index] = value
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_NAME(self, value):
        # Validate type NAME, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_PERIODTYPE(self, value):
        # Validate type PERIODTYPE, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_TYPE(self, value):
        # Validate type TYPE, a restriction on xs:string.
        pass
    def validate_ONUPDATE(self, value):
        # Validate type ONUPDATE, a restriction on xs:string.
        pass
    def validate_ONDELETE(self, value):
        # Validate type ONDELETE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.PERIODTYPE is not None or
            self.LENGTH is not None or
            self.CURRENCY is not None or
            self.RECURRINGAMOUNT is not None or
            self.INITIALAMOUNT is not None or
            self.TYPE is not None or
            self.ONUPDATE is not None or
            self.ONDELETE is not None or
            self.HASH is not None or
            self.CUSTOMFIELD
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDSTOREDSUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.PERIODTYPE is not None:
            PERIODTYPE_ = self.PERIODTYPE
            etree_.SubElement(element, '{}PERIODTYPE').text = self.gds_format_string(PERIODTYPE_)
        if self.LENGTH is not None:
            LENGTH_ = self.LENGTH
            etree_.SubElement(element, '{}LENGTH').text = self.gds_format_integer(LENGTH_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.INITIALAMOUNT is not None:
            INITIALAMOUNT_ = self.INITIALAMOUNT
            etree_.SubElement(element, '{}INITIALAMOUNT').text = self.gds_format_double(INITIALAMOUNT_)
        if self.TYPE is not None:
            TYPE_ = self.TYPE
            etree_.SubElement(element, '{}TYPE').text = self.gds_format_string(TYPE_)
        if self.ONUPDATE is not None:
            ONUPDATE_ = self.ONUPDATE
            etree_.SubElement(element, '{}ONUPDATE').text = self.gds_format_string(ONUPDATE_)
        if self.ONDELETE is not None:
            ONDELETE_ = self.ONDELETE
            etree_.SubElement(element, '{}ONDELETE').text = self.gds_format_string(ONDELETE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            CUSTOMFIELD_.to_etree(element, name_='CUSTOMFIELD', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDSTOREDSUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.PERIODTYPE is not None:
            showIndent(outfile, level)
            outfile.write('PERIODTYPE=%s,\n' % self.gds_encode(quote_python(self.PERIODTYPE)))
        if self.LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('LENGTH=%d,\n' % self.LENGTH)
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.INITIALAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('INITIALAMOUNT=%e,\n' % self.INITIALAMOUNT)
        if self.TYPE is not None:
            showIndent(outfile, level)
            outfile.write('TYPE=%s,\n' % self.gds_encode(quote_python(self.TYPE)))
        if self.ONUPDATE is not None:
            showIndent(outfile, level)
            outfile.write('ONUPDATE=%s,\n' % self.gds_encode(quote_python(self.ONUPDATE)))
        if self.ONDELETE is not None:
            showIndent(outfile, level)
            outfile.write('ONDELETE=%s,\n' % self.gds_encode(quote_python(self.ONDELETE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        showIndent(outfile, level)
        outfile.write('CUSTOMFIELD=[\n')
        level += 1
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOMFIELD(\n')
            CUSTOMFIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
            # validate type NAME
            self.validate_NAME(self.NAME)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'PERIODTYPE':
            PERIODTYPE_ = child_.text
            PERIODTYPE_ = self.gds_validate_string(PERIODTYPE_, node, 'PERIODTYPE')
            self.PERIODTYPE = PERIODTYPE_
            # validate type PERIODTYPE
            self.validate_PERIODTYPE(self.PERIODTYPE)
        elif nodeName_ == 'LENGTH' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LENGTH')
            self.LENGTH = ival_
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'INITIALAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'INITIALAMOUNT')
            self.INITIALAMOUNT = fval_
        elif nodeName_ == 'TYPE':
            TYPE_ = child_.text
            TYPE_ = self.gds_validate_string(TYPE_, node, 'TYPE')
            self.TYPE = TYPE_
            # validate type TYPE
            self.validate_TYPE(self.TYPE)
        elif nodeName_ == 'ONUPDATE':
            ONUPDATE_ = child_.text
            ONUPDATE_ = self.gds_validate_string(ONUPDATE_, node, 'ONUPDATE')
            self.ONUPDATE = ONUPDATE_
            # validate type ONUPDATE
            self.validate_ONUPDATE(self.ONUPDATE)
        elif nodeName_ == 'ONDELETE':
            ONDELETE_ = child_.text
            ONDELETE_ = self.gds_validate_string(ONDELETE_, node, 'ONDELETE')
            self.ONDELETE = ONDELETE_
            # validate type ONDELETE
            self.validate_ONDELETE(self.ONDELETE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CUSTOMFIELD':
            obj_ = CUSTOMFIELD.factory()
            obj_.build(child_)
            self.CUSTOMFIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOMFIELD'


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        hash_list.append(self.MERCHANTREF)
        hash_list.append(self.DATETIME)
        hash_list.append(self.TYPE)
        hash_list.append(self.NAME)
        hash_list.append(self.PERIODTYPE)
        hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.RECURRINGAMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(str(Decimal(self.INITIALAMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(str(self.LENGTH))
        return ':'.join(hash_list)
# end class ADDSTOREDSUBSCRIPTION


class ADDSTOREDSUBSCRIPTIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDSTOREDSUBSCRIPTIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDSTOREDSUBSCRIPTIONRESPONSE.subclass:
            return ADDSTOREDSUBSCRIPTIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return ADDSTOREDSUBSCRIPTIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDSTOREDSUBSCRIPTIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDSTOREDSUBSCRIPTIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.terminal_id, self.MERCHANTREF, self.DATETIME]
        return ':'.join(hash_list)
# end class ADDSTOREDSUBSCRIPTIONRESPONSE


class UPDATESTOREDSUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('NAME', ['NAME', 'xs:string'], 0, 0, {'ref': 'NAME', 'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('LENGTH', 'xs:unsignedInt', 0, 0, {'ref': 'LENGTH', 'name': 'LENGTH', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('INITIALAMOUNT', 'xs:double', 0, 1, {'ref': 'INITIALAMOUNT', 'minOccurs': '0', 'name': 'INITIALAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('TYPE', ['TYPE', 'xs:string'], 0, 0, {'ref': 'TYPE', 'name': 'TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ONUPDATE', ['ONUPDATE', 'xs:string'], 0, 0, {'ref': 'ONUPDATE', 'name': 'ONUPDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ONDELETE', ['ONDELETE', 'xs:string'], 0, 0, {'ref': 'ONDELETE', 'name': 'ONDELETE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOMFIELD', 'CUSTOMFIELD', 1, 1, {'ref': 'CUSTOMFIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'CUSTOMFIELD', 'type': 'CUSTOMFIELD'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, NAME=None, DESCRIPTION=None, LENGTH=None, CURRENCY=None, RECURRINGAMOUNT=None, INITIALAMOUNT=None, TYPE=None, ONUPDATE=None, ONDELETE=None, HASH=None, CUSTOMFIELD=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.NAME = NAME
        self.validate_NAME(self.NAME)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.LENGTH = LENGTH
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.INITIALAMOUNT = INITIALAMOUNT
        self.TYPE = TYPE
        self.validate_TYPE(self.TYPE)
        self.ONUPDATE = ONUPDATE
        self.validate_ONUPDATE(self.ONUPDATE)
        self.ONDELETE = ONDELETE
        self.validate_ONDELETE(self.ONDELETE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        if CUSTOMFIELD is None:
            self.CUSTOMFIELD = []
        else:
            self.CUSTOMFIELD = CUSTOMFIELD
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATESTOREDSUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATESTOREDSUBSCRIPTION.subclass:
            return UPDATESTOREDSUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return UPDATESTOREDSUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_LENGTH(self): return self.LENGTH
    def set_LENGTH(self, LENGTH): self.LENGTH = LENGTH
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_INITIALAMOUNT(self): return self.INITIALAMOUNT
    def set_INITIALAMOUNT(self, INITIALAMOUNT): self.INITIALAMOUNT = INITIALAMOUNT
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ONUPDATE(self): return self.ONUPDATE
    def set_ONUPDATE(self, ONUPDATE): self.ONUPDATE = ONUPDATE
    def get_ONDELETE(self): return self.ONDELETE
    def set_ONDELETE(self, ONDELETE): self.ONDELETE = ONDELETE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CUSTOMFIELD(self): return self.CUSTOMFIELD
    def set_CUSTOMFIELD(self, CUSTOMFIELD): self.CUSTOMFIELD = CUSTOMFIELD
    def add_CUSTOMFIELD(self, value): self.CUSTOMFIELD.append(value)
    def insert_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD.insert(index, value)
    def replace_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD[index] = value
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_NAME(self, value):
        # Validate type NAME, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_TYPE(self, value):
        # Validate type TYPE, a restriction on xs:string.
        pass
    def validate_ONUPDATE(self, value):
        # Validate type ONUPDATE, a restriction on xs:string.
        pass
    def validate_ONDELETE(self, value):
        # Validate type ONDELETE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.LENGTH is not None or
            self.CURRENCY is not None or
            self.RECURRINGAMOUNT is not None or
            self.INITIALAMOUNT is not None or
            self.TYPE is not None or
            self.ONUPDATE is not None or
            self.ONDELETE is not None or
            self.HASH is not None or
            self.CUSTOMFIELD
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATESTOREDSUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.LENGTH is not None:
            LENGTH_ = self.LENGTH
            etree_.SubElement(element, '{}LENGTH').text = self.gds_format_integer(LENGTH_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.INITIALAMOUNT is not None:
            INITIALAMOUNT_ = self.INITIALAMOUNT
            etree_.SubElement(element, '{}INITIALAMOUNT').text = self.gds_format_double(INITIALAMOUNT_)
        if self.TYPE is not None:
            TYPE_ = self.TYPE
            etree_.SubElement(element, '{}TYPE').text = self.gds_format_string(TYPE_)
        if self.ONUPDATE is not None:
            ONUPDATE_ = self.ONUPDATE
            etree_.SubElement(element, '{}ONUPDATE').text = self.gds_format_string(ONUPDATE_)
        if self.ONDELETE is not None:
            ONDELETE_ = self.ONDELETE
            etree_.SubElement(element, '{}ONDELETE').text = self.gds_format_string(ONDELETE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            CUSTOMFIELD_.to_etree(element, name_='CUSTOMFIELD', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATESTOREDSUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('LENGTH=%d,\n' % self.LENGTH)
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.INITIALAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('INITIALAMOUNT=%e,\n' % self.INITIALAMOUNT)
        if self.TYPE is not None:
            showIndent(outfile, level)
            outfile.write('TYPE=%s,\n' % self.gds_encode(quote_python(self.TYPE)))
        if self.ONUPDATE is not None:
            showIndent(outfile, level)
            outfile.write('ONUPDATE=%s,\n' % self.gds_encode(quote_python(self.ONUPDATE)))
        if self.ONDELETE is not None:
            showIndent(outfile, level)
            outfile.write('ONDELETE=%s,\n' % self.gds_encode(quote_python(self.ONDELETE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        showIndent(outfile, level)
        outfile.write('CUSTOMFIELD=[\n')
        level += 1
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOMFIELD(\n')
            CUSTOMFIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
            # validate type NAME
            self.validate_NAME(self.NAME)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'LENGTH' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LENGTH')
            self.LENGTH = ival_
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'INITIALAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'INITIALAMOUNT')
            self.INITIALAMOUNT = fval_
        elif nodeName_ == 'TYPE':
            TYPE_ = child_.text
            TYPE_ = self.gds_validate_string(TYPE_, node, 'TYPE')
            self.TYPE = TYPE_
            # validate type TYPE
            self.validate_TYPE(self.TYPE)
        elif nodeName_ == 'ONUPDATE':
            ONUPDATE_ = child_.text
            ONUPDATE_ = self.gds_validate_string(ONUPDATE_, node, 'ONUPDATE')
            self.ONUPDATE = ONUPDATE_
            # validate type ONUPDATE
            self.validate_ONUPDATE(self.ONUPDATE)
        elif nodeName_ == 'ONDELETE':
            ONDELETE_ = child_.text
            ONDELETE_ = self.gds_validate_string(ONDELETE_, node, 'ONDELETE')
            self.ONDELETE = ONDELETE_
            # validate type ONDELETE
            self.validate_ONDELETE(self.ONDELETE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CUSTOMFIELD':
            obj_ = CUSTOMFIELD.factory()
            obj_.build(child_)
            self.CUSTOMFIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOMFIELD'


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        hash_list.append(self.MERCHANTREF)
        hash_list.append(self.DATETIME)
        hash_list.append(self.TYPE)
        hash_list.append(self.NAME)
        hash_list.append(self.PERIODTYPE)
        hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.RECURRINGAMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(str(Decimal(self.INITIALAMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(str(self.LENGTH))
        return ':'.join(hash_list)
# end class UPDATESTOREDSUBSCRIPTION


class UPDATESTOREDSUBSCRIPTIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATESTOREDSUBSCRIPTIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATESTOREDSUBSCRIPTIONRESPONSE.subclass:
            return UPDATESTOREDSUBSCRIPTIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return UPDATESTOREDSUBSCRIPTIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATESTOREDSUBSCRIPTIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATESTOREDSUBSCRIPTIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class UPDATESTOREDSUBSCRIPTIONRESPONSE


class DELETESTOREDSUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DELETESTOREDSUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DELETESTOREDSUBSCRIPTION.subclass:
            return DELETESTOREDSUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return DELETESTOREDSUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DELETESTOREDSUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DELETESTOREDSUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID, self.MERCHANTREF, self.DATETIME]
        return ':'.join(hash_list)
# end class DELETESTOREDSUBSCRIPTION


class DELETESTOREDSUBSCRIPTIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DELETESTOREDSUBSCRIPTIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DELETESTOREDSUBSCRIPTIONRESPONSE.subclass:
            return DELETESTOREDSUBSCRIPTIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return DELETESTOREDSUBSCRIPTIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DELETESTOREDSUBSCRIPTIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DELETESTOREDSUBSCRIPTIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.terminal_id, self.MERCHANTREF, self.DATETIME]
        return ':'.join(hash_list)
# end class DELETESTOREDSUBSCRIPTIONRESPONSE


class STOREDSUBSCRIPTIONREF(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STOREDSUBSCRIPTIONREF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STOREDSUBSCRIPTIONREF.subclass:
            return STOREDSUBSCRIPTIONREF.subclass(*args_, **kwargs_)
        else:
            return STOREDSUBSCRIPTIONREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='STOREDSUBSCRIPTIONREF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='STOREDSUBSCRIPTIONREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class STOREDSUBSCRIPTIONREF


class SECURECARDMERCHANTREF(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDMERCHANTREF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDMERCHANTREF.subclass:
            return SECURECARDMERCHANTREF.subclass(*args_, **kwargs_)
        else:
            return SECURECARDMERCHANTREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDMERCHANTREF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDMERCHANTREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SECURECARDMERCHANTREF


class SECUREACHACCOUNTMERCHANTREF(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECUREACHACCOUNTMERCHANTREF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECUREACHACCOUNTMERCHANTREF.subclass:
            return SECUREACHACCOUNTMERCHANTREF.subclass(*args_, **kwargs_)
        else:
            return SECUREACHACCOUNTMERCHANTREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECUREACHACCOUNTMERCHANTREF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECUREACHACCOUNTMERCHANTREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SECUREACHACCOUNTMERCHANTREF


class STARTDATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STARTDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STARTDATE.subclass:
            return STARTDATE.subclass(*args_, **kwargs_)
        else:
            return STARTDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='STARTDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='STARTDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class STARTDATE


class ENDDATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENDDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENDDATE.subclass:
            return ENDDATE.subclass(*args_, **kwargs_)
        else:
            return ENDDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ENDDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ENDDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ENDDATE


class EDCCDECISION(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EDCCDECISION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EDCCDECISION.subclass:
            return EDCCDECISION.subclass(*args_, **kwargs_)
        else:
            return EDCCDECISION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='EDCCDECISION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='EDCCDECISION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EDCCDECISION


class NEWSTOREDSUBSCRIPTIONINFO(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('NAME', ['NAME', 'xs:string'], 0, 0, {'ref': 'NAME', 'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 0, {'ref': 'DESCRIPTION', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('PERIODTYPE', ['PERIODTYPE', 'xs:string'], 0, 0, {'ref': 'PERIODTYPE', 'name': 'PERIODTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('LENGTH', 'xs:unsignedInt', 0, 0, {'ref': 'LENGTH', 'name': 'LENGTH', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('INITIALAMOUNT', 'xs:double', 0, 1, {'ref': 'INITIALAMOUNT', 'minOccurs': '0', 'name': 'INITIALAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('TYPE', ['TYPE', 'xs:string'], 0, 0, {'ref': 'TYPE', 'name': 'TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ONUPDATE', ['ONUPDATE', 'xs:string'], 0, 0, {'ref': 'ONUPDATE', 'name': 'ONUPDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ONDELETE', ['ONDELETE', 'xs:string'], 0, 0, {'ref': 'ONDELETE', 'name': 'ONDELETE', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, NAME=None, DESCRIPTION=None, PERIODTYPE=None, LENGTH=None, CURRENCY=None, RECURRINGAMOUNT=None, INITIALAMOUNT=None, TYPE=None, ONUPDATE=None, ONDELETE=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.NAME = NAME
        self.validate_NAME(self.NAME)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.PERIODTYPE = PERIODTYPE
        self.validate_PERIODTYPE(self.PERIODTYPE)
        self.LENGTH = LENGTH
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.INITIALAMOUNT = INITIALAMOUNT
        self.TYPE = TYPE
        self.validate_TYPE(self.TYPE)
        self.ONUPDATE = ONUPDATE
        self.validate_ONUPDATE(self.ONUPDATE)
        self.ONDELETE = ONDELETE
        self.validate_ONDELETE(self.ONDELETE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NEWSTOREDSUBSCRIPTIONINFO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NEWSTOREDSUBSCRIPTIONINFO.subclass:
            return NEWSTOREDSUBSCRIPTIONINFO.subclass(*args_, **kwargs_)
        else:
            return NEWSTOREDSUBSCRIPTIONINFO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_PERIODTYPE(self): return self.PERIODTYPE
    def set_PERIODTYPE(self, PERIODTYPE): self.PERIODTYPE = PERIODTYPE
    def get_LENGTH(self): return self.LENGTH
    def set_LENGTH(self, LENGTH): self.LENGTH = LENGTH
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_INITIALAMOUNT(self): return self.INITIALAMOUNT
    def set_INITIALAMOUNT(self, INITIALAMOUNT): self.INITIALAMOUNT = INITIALAMOUNT
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ONUPDATE(self): return self.ONUPDATE
    def set_ONUPDATE(self, ONUPDATE): self.ONUPDATE = ONUPDATE
    def get_ONDELETE(self): return self.ONDELETE
    def set_ONDELETE(self, ONDELETE): self.ONDELETE = ONDELETE
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_NAME(self, value):
        # Validate type NAME, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_PERIODTYPE(self, value):
        # Validate type PERIODTYPE, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_TYPE(self, value):
        # Validate type TYPE, a restriction on xs:string.
        pass
    def validate_ONUPDATE(self, value):
        # Validate type ONUPDATE, a restriction on xs:string.
        pass
    def validate_ONDELETE(self, value):
        # Validate type ONDELETE, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.PERIODTYPE is not None or
            self.LENGTH is not None or
            self.CURRENCY is not None or
            self.RECURRINGAMOUNT is not None or
            self.INITIALAMOUNT is not None or
            self.TYPE is not None or
            self.ONUPDATE is not None or
            self.ONDELETE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='NEWSTOREDSUBSCRIPTIONINFO', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.PERIODTYPE is not None:
            PERIODTYPE_ = self.PERIODTYPE
            etree_.SubElement(element, '{}PERIODTYPE').text = self.gds_format_string(PERIODTYPE_)
        if self.LENGTH is not None:
            LENGTH_ = self.LENGTH
            etree_.SubElement(element, '{}LENGTH').text = self.gds_format_integer(LENGTH_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.INITIALAMOUNT is not None:
            INITIALAMOUNT_ = self.INITIALAMOUNT
            etree_.SubElement(element, '{}INITIALAMOUNT').text = self.gds_format_double(INITIALAMOUNT_)
        if self.TYPE is not None:
            TYPE_ = self.TYPE
            etree_.SubElement(element, '{}TYPE').text = self.gds_format_string(TYPE_)
        if self.ONUPDATE is not None:
            ONUPDATE_ = self.ONUPDATE
            etree_.SubElement(element, '{}ONUPDATE').text = self.gds_format_string(ONUPDATE_)
        if self.ONDELETE is not None:
            ONDELETE_ = self.ONDELETE
            etree_.SubElement(element, '{}ONDELETE').text = self.gds_format_string(ONDELETE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NEWSTOREDSUBSCRIPTIONINFO'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.PERIODTYPE is not None:
            showIndent(outfile, level)
            outfile.write('PERIODTYPE=%s,\n' % self.gds_encode(quote_python(self.PERIODTYPE)))
        if self.LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('LENGTH=%d,\n' % self.LENGTH)
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.INITIALAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('INITIALAMOUNT=%e,\n' % self.INITIALAMOUNT)
        if self.TYPE is not None:
            showIndent(outfile, level)
            outfile.write('TYPE=%s,\n' % self.gds_encode(quote_python(self.TYPE)))
        if self.ONUPDATE is not None:
            showIndent(outfile, level)
            outfile.write('ONUPDATE=%s,\n' % self.gds_encode(quote_python(self.ONUPDATE)))
        if self.ONDELETE is not None:
            showIndent(outfile, level)
            outfile.write('ONDELETE=%s,\n' % self.gds_encode(quote_python(self.ONDELETE)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
            # validate type NAME
            self.validate_NAME(self.NAME)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'PERIODTYPE':
            PERIODTYPE_ = child_.text
            PERIODTYPE_ = self.gds_validate_string(PERIODTYPE_, node, 'PERIODTYPE')
            self.PERIODTYPE = PERIODTYPE_
            # validate type PERIODTYPE
            self.validate_PERIODTYPE(self.PERIODTYPE)
        elif nodeName_ == 'LENGTH' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LENGTH')
            self.LENGTH = ival_
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'INITIALAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'INITIALAMOUNT')
            self.INITIALAMOUNT = fval_
        elif nodeName_ == 'TYPE':
            TYPE_ = child_.text
            TYPE_ = self.gds_validate_string(TYPE_, node, 'TYPE')
            self.TYPE = TYPE_
            # validate type TYPE
            self.validate_TYPE(self.TYPE)
        elif nodeName_ == 'ONUPDATE':
            ONUPDATE_ = child_.text
            ONUPDATE_ = self.gds_validate_string(ONUPDATE_, node, 'ONUPDATE')
            self.ONUPDATE = ONUPDATE_
            # validate type ONUPDATE
            self.validate_ONUPDATE(self.ONUPDATE)
        elif nodeName_ == 'ONDELETE':
            ONDELETE_ = child_.text
            ONDELETE_ = self.gds_validate_string(ONDELETE_, node, 'ONDELETE')
            self.ONDELETE = ONDELETE_
            # validate type ONDELETE
            self.validate_ONDELETE(self.ONDELETE)
# end class NEWSTOREDSUBSCRIPTIONINFO


class ADDSUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('STOREDSUBSCRIPTIONREF', ['STOREDSUBSCRIPTIONREF', 'xs:string'], 0, 1, {'ref': 'STOREDSUBSCRIPTIONREF', 'minOccurs': '0', 'name': 'STOREDSUBSCRIPTIONREF', 'type': 'xs:string'}, None),
        MemberSpec_('SECURECARDMERCHANTREF', ['SECURECARDMERCHANTREF', 'xs:string'], 0, 1, {'ref': 'SECURECARDMERCHANTREF', 'minOccurs': '0', 'name': 'SECURECARDMERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', ['CARDREFERENCE', 'xs:string'], 0, 1, {'ref': 'CARDREFERENCE', 'minOccurs': '0', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('INITIALAMOUNT', 'xs:double', 0, 1, {'ref': 'INITIALAMOUNT', 'minOccurs': '0', 'name': 'INITIALAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('STARTDATE', ['STARTDATE', 'xs:string'], 0, 0, {'ref': 'STARTDATE', 'name': 'STARTDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ENDDATE', ['ENDDATE', 'xs:string'], 0, 1, {'ref': 'ENDDATE', 'minOccurs': '0', 'name': 'ENDDATE', 'type': 'xs:string'}, None),
        MemberSpec_('EDCCDECISION', ['EDCCDECISION', 'xs:string'], 0, 1, {'ref': 'EDCCDECISION', 'minOccurs': '0', 'name': 'EDCCDECISION', 'type': 'xs:string'}, None),
        MemberSpec_('NEWSTOREDSUBSCRIPTIONINFO', 'NEWSTOREDSUBSCRIPTIONINFO', 0, 1, {'ref': 'NEWSTOREDSUBSCRIPTIONINFO', 'minOccurs': '0', 'name': 'NEWSTOREDSUBSCRIPTIONINFO', 'type': 'NEWSTOREDSUBSCRIPTIONINFO'}, None),
        MemberSpec_('NOTIFICATIONLANGUAGE', ['NOTIFICATIONLANGUAGE', 'xs:string'], 0, 1, {'ref': 'NOTIFICATIONLANGUAGE', 'minOccurs': '0', 'name': 'NOTIFICATIONLANGUAGE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOMFIELD', 'CUSTOMFIELD', 1, 1, {'ref': 'CUSTOMFIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'CUSTOMFIELD', 'type': 'CUSTOMFIELD'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('LEVEL_3_DATA', 'LEVEL_3_DATA', 0, 1, {'ref': 'LEVEL_3_DATA', 'minOccurs': '0', 'name': 'LEVEL_3_DATA', 'type': 'LEVEL_3_DATA'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, STOREDSUBSCRIPTIONREF=None, SECURECARDMERCHANTREF=None, CARDREFERENCE=None, DATETIME=None, RECURRINGAMOUNT=None, INITIALAMOUNT=None, STARTDATE=None, ENDDATE=None, EDCCDECISION=None, NEWSTOREDSUBSCRIPTIONINFO=None, NOTIFICATIONLANGUAGE=None, HASH=None, CUSTOMFIELD=None, LEVEL_2_DATA=None, LEVEL_3_DATA=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF
        self.validate_STOREDSUBSCRIPTIONREF(self.STOREDSUBSCRIPTIONREF)
        self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF
        self.validate_SECURECARDMERCHANTREF(self.SECURECARDMERCHANTREF)
        self.CARDREFERENCE = CARDREFERENCE
        self.validate_CARDREFERENCE(self.CARDREFERENCE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.INITIALAMOUNT = INITIALAMOUNT
        self.STARTDATE = STARTDATE
        self.validate_STARTDATE(self.STARTDATE)
        self.ENDDATE = ENDDATE
        self.validate_ENDDATE(self.ENDDATE)
        self.EDCCDECISION = EDCCDECISION
        self.validate_EDCCDECISION(self.EDCCDECISION)
        self.NEWSTOREDSUBSCRIPTIONINFO = NEWSTOREDSUBSCRIPTIONINFO
        self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
        self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        if CUSTOMFIELD is None:
            self.CUSTOMFIELD = []
        else:
            self.CUSTOMFIELD = CUSTOMFIELD
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.LEVEL_3_DATA = LEVEL_3_DATA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDSUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDSUBSCRIPTION.subclass:
            return ADDSUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return ADDSUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_STOREDSUBSCRIPTIONREF(self): return self.STOREDSUBSCRIPTIONREF
    def set_STOREDSUBSCRIPTIONREF(self, STOREDSUBSCRIPTIONREF): self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF
    def get_SECURECARDMERCHANTREF(self): return self.SECURECARDMERCHANTREF
    def set_SECURECARDMERCHANTREF(self, SECURECARDMERCHANTREF): self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_INITIALAMOUNT(self): return self.INITIALAMOUNT
    def set_INITIALAMOUNT(self, INITIALAMOUNT): self.INITIALAMOUNT = INITIALAMOUNT
    def get_STARTDATE(self): return self.STARTDATE
    def set_STARTDATE(self, STARTDATE): self.STARTDATE = STARTDATE
    def get_ENDDATE(self): return self.ENDDATE
    def set_ENDDATE(self, ENDDATE): self.ENDDATE = ENDDATE
    def get_EDCCDECISION(self): return self.EDCCDECISION
    def set_EDCCDECISION(self, EDCCDECISION): self.EDCCDECISION = EDCCDECISION
    def get_NEWSTOREDSUBSCRIPTIONINFO(self): return self.NEWSTOREDSUBSCRIPTIONINFO
    def set_NEWSTOREDSUBSCRIPTIONINFO(self, NEWSTOREDSUBSCRIPTIONINFO): self.NEWSTOREDSUBSCRIPTIONINFO = NEWSTOREDSUBSCRIPTIONINFO
    def get_NOTIFICATIONLANGUAGE(self): return self.NOTIFICATIONLANGUAGE
    def set_NOTIFICATIONLANGUAGE(self, NOTIFICATIONLANGUAGE): self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CUSTOMFIELD(self): return self.CUSTOMFIELD
    def set_CUSTOMFIELD(self, CUSTOMFIELD): self.CUSTOMFIELD = CUSTOMFIELD
    def add_CUSTOMFIELD(self, value): self.CUSTOMFIELD.append(value)
    def insert_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD.insert(index, value)
    def replace_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD[index] = value
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_LEVEL_3_DATA(self): return self.LEVEL_3_DATA
    def set_LEVEL_3_DATA(self, LEVEL_3_DATA): self.LEVEL_3_DATA = LEVEL_3_DATA
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_STOREDSUBSCRIPTIONREF(self, value):
        # Validate type STOREDSUBSCRIPTIONREF, a restriction on xs:string.
        pass
    def validate_SECURECARDMERCHANTREF(self, value):
        # Validate type SECURECARDMERCHANTREF, a restriction on xs:string.
        pass
    def validate_CARDREFERENCE(self, value):
        # Validate type CARDREFERENCE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_STARTDATE(self, value):
        # Validate type STARTDATE, a restriction on xs:string.
        pass
    def validate_ENDDATE(self, value):
        # Validate type ENDDATE, a restriction on xs:string.
        pass
    def validate_EDCCDECISION(self, value):
        # Validate type EDCCDECISION, a restriction on xs:string.
        pass
    def validate_NOTIFICATIONLANGUAGE(self, value):
        # Validate type NOTIFICATIONLANGUAGE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.STOREDSUBSCRIPTIONREF is not None or
            self.SECURECARDMERCHANTREF is not None or
            self.CARDREFERENCE is not None or
            self.DATETIME is not None or
            self.RECURRINGAMOUNT is not None or
            self.INITIALAMOUNT is not None or
            self.STARTDATE is not None or
            self.ENDDATE is not None or
            self.EDCCDECISION is not None or
            self.NEWSTOREDSUBSCRIPTIONINFO is not None or
            self.NOTIFICATIONLANGUAGE is not None or
            self.HASH is not None or
            self.CUSTOMFIELD or
            self.LEVEL_2_DATA is not None or
            self.LEVEL_3_DATA is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDSUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.STOREDSUBSCRIPTIONREF is not None:
            STOREDSUBSCRIPTIONREF_ = self.STOREDSUBSCRIPTIONREF
            etree_.SubElement(element, '{}STOREDSUBSCRIPTIONREF').text = self.gds_format_string(STOREDSUBSCRIPTIONREF_)
        if self.SECURECARDMERCHANTREF is not None:
            SECURECARDMERCHANTREF_ = self.SECURECARDMERCHANTREF
            etree_.SubElement(element, '{}SECURECARDMERCHANTREF').text = self.gds_format_string(SECURECARDMERCHANTREF_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.INITIALAMOUNT is not None:
            INITIALAMOUNT_ = self.INITIALAMOUNT
            etree_.SubElement(element, '{}INITIALAMOUNT').text = self.gds_format_double(INITIALAMOUNT_)
        if self.STARTDATE is not None:
            STARTDATE_ = self.STARTDATE
            etree_.SubElement(element, '{}STARTDATE').text = self.gds_format_string(STARTDATE_)
        if self.ENDDATE is not None:
            ENDDATE_ = self.ENDDATE
            etree_.SubElement(element, '{}ENDDATE').text = self.gds_format_string(ENDDATE_)
        if self.EDCCDECISION is not None:
            EDCCDECISION_ = self.EDCCDECISION
            etree_.SubElement(element, '{}EDCCDECISION').text = self.gds_format_string(EDCCDECISION_)
        if self.NEWSTOREDSUBSCRIPTIONINFO is not None:
            NEWSTOREDSUBSCRIPTIONINFO_ = self.NEWSTOREDSUBSCRIPTIONINFO
            NEWSTOREDSUBSCRIPTIONINFO_.to_etree(element, name_='NEWSTOREDSUBSCRIPTIONINFO', mapping_=mapping_)
        if self.NOTIFICATIONLANGUAGE is not None:
            NOTIFICATIONLANGUAGE_ = self.NOTIFICATIONLANGUAGE
            etree_.SubElement(element, '{}NOTIFICATIONLANGUAGE').text = self.gds_format_string(NOTIFICATIONLANGUAGE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            CUSTOMFIELD_.to_etree(element, name_='CUSTOMFIELD', mapping_=mapping_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.LEVEL_3_DATA is not None:
            LEVEL_3_DATA_ = self.LEVEL_3_DATA
            LEVEL_3_DATA_.to_etree(element, name_='LEVEL_3_DATA', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDSUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.STOREDSUBSCRIPTIONREF is not None:
            showIndent(outfile, level)
            outfile.write('STOREDSUBSCRIPTIONREF=%s,\n' % self.gds_encode(quote_python(self.STOREDSUBSCRIPTIONREF)))
        if self.SECURECARDMERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('SECURECARDMERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.SECURECARDMERCHANTREF)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.INITIALAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('INITIALAMOUNT=%e,\n' % self.INITIALAMOUNT)
        if self.STARTDATE is not None:
            showIndent(outfile, level)
            outfile.write('STARTDATE=%s,\n' % self.gds_encode(quote_python(self.STARTDATE)))
        if self.ENDDATE is not None:
            showIndent(outfile, level)
            outfile.write('ENDDATE=%s,\n' % self.gds_encode(quote_python(self.ENDDATE)))
        if self.EDCCDECISION is not None:
            showIndent(outfile, level)
            outfile.write('EDCCDECISION=%s,\n' % self.gds_encode(quote_python(self.EDCCDECISION)))
        if self.NEWSTOREDSUBSCRIPTIONINFO is not None:
            showIndent(outfile, level)
            outfile.write('NEWSTOREDSUBSCRIPTIONINFO=model_.NEWSTOREDSUBSCRIPTIONINFO(\n')
            self.NEWSTOREDSUBSCRIPTIONINFO.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NOTIFICATIONLANGUAGE is not None:
            showIndent(outfile, level)
            outfile.write('NOTIFICATIONLANGUAGE=%s,\n' % self.gds_encode(quote_python(self.NOTIFICATIONLANGUAGE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        showIndent(outfile, level)
        outfile.write('CUSTOMFIELD=[\n')
        level += 1
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOMFIELD(\n')
            CUSTOMFIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LEVEL_3_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_3_DATA=model_.LEVEL_3_DATA(\n')
            self.LEVEL_3_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'STOREDSUBSCRIPTIONREF':
            STOREDSUBSCRIPTIONREF_ = child_.text
            STOREDSUBSCRIPTIONREF_ = self.gds_validate_string(STOREDSUBSCRIPTIONREF_, node, 'STOREDSUBSCRIPTIONREF')
            self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF_
            # validate type STOREDSUBSCRIPTIONREF
            self.validate_STOREDSUBSCRIPTIONREF(self.STOREDSUBSCRIPTIONREF)
        elif nodeName_ == 'SECURECARDMERCHANTREF':
            SECURECARDMERCHANTREF_ = child_.text
            SECURECARDMERCHANTREF_ = self.gds_validate_string(SECURECARDMERCHANTREF_, node, 'SECURECARDMERCHANTREF')
            self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF_
            # validate type SECURECARDMERCHANTREF
            self.validate_SECURECARDMERCHANTREF(self.SECURECARDMERCHANTREF)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
            # validate type CARDREFERENCE
            self.validate_CARDREFERENCE(self.CARDREFERENCE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'INITIALAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'INITIALAMOUNT')
            self.INITIALAMOUNT = fval_
        elif nodeName_ == 'STARTDATE':
            STARTDATE_ = child_.text
            STARTDATE_ = self.gds_validate_string(STARTDATE_, node, 'STARTDATE')
            self.STARTDATE = STARTDATE_
            # validate type STARTDATE
            self.validate_STARTDATE(self.STARTDATE)
        elif nodeName_ == 'ENDDATE':
            ENDDATE_ = child_.text
            ENDDATE_ = self.gds_validate_string(ENDDATE_, node, 'ENDDATE')
            self.ENDDATE = ENDDATE_
            # validate type ENDDATE
            self.validate_ENDDATE(self.ENDDATE)
        elif nodeName_ == 'EDCCDECISION':
            EDCCDECISION_ = child_.text
            EDCCDECISION_ = self.gds_validate_string(EDCCDECISION_, node, 'EDCCDECISION')
            self.EDCCDECISION = EDCCDECISION_
            # validate type EDCCDECISION
            self.validate_EDCCDECISION(self.EDCCDECISION)
        elif nodeName_ == 'NEWSTOREDSUBSCRIPTIONINFO':
            obj_ = NEWSTOREDSUBSCRIPTIONINFO.factory()
            obj_.build(child_)
            self.NEWSTOREDSUBSCRIPTIONINFO = obj_
            obj_.original_tagname_ = 'NEWSTOREDSUBSCRIPTIONINFO'
        elif nodeName_ == 'NOTIFICATIONLANGUAGE':
            NOTIFICATIONLANGUAGE_ = child_.text
            NOTIFICATIONLANGUAGE_ = self.gds_validate_string(NOTIFICATIONLANGUAGE_, node, 'NOTIFICATIONLANGUAGE')
            self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE_
            # validate type NOTIFICATIONLANGUAGE
            self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CUSTOMFIELD':
            obj_ = CUSTOMFIELD.factory()
            obj_.build(child_)
            self.CUSTOMFIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOMFIELD'
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'LEVEL_3_DATA':
            obj_ = LEVEL_3_DATA.factory()
            obj_.build(child_)
            self.LEVEL_3_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_3_DATA'


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID]
        hash_list.append(self.MERCHANTREF)
        hash_list.append(self.STOREDSUBSCRIPTIONREF)
        if self.SECURECARDMERCHANTREF:
            hash_list.append(self.SECURECARDMERCHANTREF)
        if self.CARDREFERENCE:
            hash_list.append(self.CARDREFERENCE)
        hash_list.append(self.DATETIME)
        hash_list.append(self.STARTDATE)
        return ':'.join(hash_list)
# end class ADDSUBSCRIPTION


class ADDSUBSCRIPTIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDSUBSCRIPTIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDSUBSCRIPTIONRESPONSE.subclass:
            return ADDSUBSCRIPTIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return ADDSUBSCRIPTIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDSUBSCRIPTIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDSUBSCRIPTIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID]
        hash_list.append(self.MERCHANTREF)
        hash_list.append(self.STOREDSUBSCRIPTIONREF)
        if self.SECURECARDMERCHANTREF:
            hash_list.append(self.SECURECARDMERCHANTREF)
        if self.CARDREFERENCE:
            hash_list.append(self.CARDREFERENCE)
        hash_list.append(self.DATETIME)
        hash_list.append(self.STARTDATE)
        return ':'.join(hash_list)
# end class ADDSUBSCRIPTIONRESPONSE


class UPDATESUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('SECURECARDMERCHANTREF', ['SECURECARDMERCHANTREF', 'xs:string'], 0, 1, {'ref': 'SECURECARDMERCHANTREF', 'minOccurs': '0', 'name': 'SECURECARDMERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', ['CARDREFERENCE', 'xs:string'], 0, 1, {'ref': 'CARDREFERENCE', 'minOccurs': '0', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('NAME', ['NAME', 'xs:string'], 0, 1, {'ref': 'NAME', 'minOccurs': '0', 'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('LENGTH', 'xs:unsignedInt', 0, 1, {'ref': 'LENGTH', 'minOccurs': '0', 'name': 'LENGTH', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('SKIPPERIODCOUNT', 'xs:unsignedInt', 0, 1, {'ref': 'SKIPPERIODCOUNT', 'minOccurs': '0', 'name': 'SKIPPERIODCOUNT', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('STARTDATE', ['STARTDATE', 'xs:string'], 0, 1, {'ref': 'STARTDATE', 'minOccurs': '0', 'name': 'STARTDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ENDDATE', ['ENDDATE', 'xs:string'], 0, 1, {'ref': 'ENDDATE', 'minOccurs': '0', 'name': 'ENDDATE', 'type': 'xs:string'}, None),
        MemberSpec_('EDCCDECISION', ['EDCCDECISION', 'xs:string'], 0, 1, {'ref': 'EDCCDECISION', 'minOccurs': '0', 'name': 'EDCCDECISION', 'type': 'xs:string'}, None),
        MemberSpec_('NOTIFICATIONLANGUAGE', ['NOTIFICATIONLANGUAGE', 'xs:string'], 0, 1, {'ref': 'NOTIFICATIONLANGUAGE', 'minOccurs': '0', 'name': 'NOTIFICATIONLANGUAGE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOMFIELD', 'CUSTOMFIELD', 1, 1, {'ref': 'CUSTOMFIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'CUSTOMFIELD', 'type': 'CUSTOMFIELD'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('LEVEL_3_DATA', 'LEVEL_3_DATA', 0, 1, {'ref': 'LEVEL_3_DATA', 'minOccurs': '0', 'name': 'LEVEL_3_DATA', 'type': 'LEVEL_3_DATA'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, SECURECARDMERCHANTREF=None, CARDREFERENCE=None, DATETIME=None, NAME=None, DESCRIPTION=None, LENGTH=None, SKIPPERIODCOUNT=None, RECURRINGAMOUNT=None, STARTDATE=None, ENDDATE=None, EDCCDECISION=None, NOTIFICATIONLANGUAGE=None, HASH=None, CUSTOMFIELD=None, LEVEL_2_DATA=None, LEVEL_3_DATA=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF
        self.validate_SECURECARDMERCHANTREF(self.SECURECARDMERCHANTREF)
        self.CARDREFERENCE = CARDREFERENCE
        self.validate_CARDREFERENCE(self.CARDREFERENCE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.NAME = NAME
        self.validate_NAME(self.NAME)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.LENGTH = LENGTH
        self.SKIPPERIODCOUNT = SKIPPERIODCOUNT
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.STARTDATE = STARTDATE
        self.validate_STARTDATE(self.STARTDATE)
        self.ENDDATE = ENDDATE
        self.validate_ENDDATE(self.ENDDATE)
        self.EDCCDECISION = EDCCDECISION
        self.validate_EDCCDECISION(self.EDCCDECISION)
        self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
        self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        if CUSTOMFIELD is None:
            self.CUSTOMFIELD = []
        else:
            self.CUSTOMFIELD = CUSTOMFIELD
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.LEVEL_3_DATA = LEVEL_3_DATA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATESUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATESUBSCRIPTION.subclass:
            return UPDATESUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return UPDATESUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_SECURECARDMERCHANTREF(self): return self.SECURECARDMERCHANTREF
    def set_SECURECARDMERCHANTREF(self, SECURECARDMERCHANTREF): self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_LENGTH(self): return self.LENGTH
    def set_LENGTH(self, LENGTH): self.LENGTH = LENGTH
    def get_SKIPPERIODCOUNT(self): return self.SKIPPERIODCOUNT
    def set_SKIPPERIODCOUNT(self, SKIPPERIODCOUNT): self.SKIPPERIODCOUNT = SKIPPERIODCOUNT
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_STARTDATE(self): return self.STARTDATE
    def set_STARTDATE(self, STARTDATE): self.STARTDATE = STARTDATE
    def get_ENDDATE(self): return self.ENDDATE
    def set_ENDDATE(self, ENDDATE): self.ENDDATE = ENDDATE
    def get_EDCCDECISION(self): return self.EDCCDECISION
    def set_EDCCDECISION(self, EDCCDECISION): self.EDCCDECISION = EDCCDECISION
    def get_NOTIFICATIONLANGUAGE(self): return self.NOTIFICATIONLANGUAGE
    def set_NOTIFICATIONLANGUAGE(self, NOTIFICATIONLANGUAGE): self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CUSTOMFIELD(self): return self.CUSTOMFIELD
    def set_CUSTOMFIELD(self, CUSTOMFIELD): self.CUSTOMFIELD = CUSTOMFIELD
    def add_CUSTOMFIELD(self, value): self.CUSTOMFIELD.append(value)
    def insert_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD.insert(index, value)
    def replace_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD[index] = value
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_LEVEL_3_DATA(self): return self.LEVEL_3_DATA
    def set_LEVEL_3_DATA(self, LEVEL_3_DATA): self.LEVEL_3_DATA = LEVEL_3_DATA
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_SECURECARDMERCHANTREF(self, value):
        # Validate type SECURECARDMERCHANTREF, a restriction on xs:string.
        pass
    def validate_CARDREFERENCE(self, value):
        # Validate type CARDREFERENCE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_NAME(self, value):
        # Validate type NAME, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_STARTDATE(self, value):
        # Validate type STARTDATE, a restriction on xs:string.
        pass
    def validate_ENDDATE(self, value):
        # Validate type ENDDATE, a restriction on xs:string.
        pass
    def validate_EDCCDECISION(self, value):
        # Validate type EDCCDECISION, a restriction on xs:string.
        pass
    def validate_NOTIFICATIONLANGUAGE(self, value):
        # Validate type NOTIFICATIONLANGUAGE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.SECURECARDMERCHANTREF is not None or
            self.CARDREFERENCE is not None or
            self.DATETIME is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.LENGTH is not None or
            self.SKIPPERIODCOUNT is not None or
            self.RECURRINGAMOUNT is not None or
            self.STARTDATE is not None or
            self.ENDDATE is not None or
            self.EDCCDECISION is not None or
            self.NOTIFICATIONLANGUAGE is not None or
            self.HASH is not None or
            self.CUSTOMFIELD or
            self.LEVEL_2_DATA is not None or
            self.LEVEL_3_DATA is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATESUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.SECURECARDMERCHANTREF is not None:
            SECURECARDMERCHANTREF_ = self.SECURECARDMERCHANTREF
            etree_.SubElement(element, '{}SECURECARDMERCHANTREF').text = self.gds_format_string(SECURECARDMERCHANTREF_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.LENGTH is not None:
            LENGTH_ = self.LENGTH
            etree_.SubElement(element, '{}LENGTH').text = self.gds_format_integer(LENGTH_)
        if self.SKIPPERIODCOUNT is not None:
            SKIPPERIODCOUNT_ = self.SKIPPERIODCOUNT
            etree_.SubElement(element, '{}SKIPPERIODCOUNT').text = self.gds_format_integer(SKIPPERIODCOUNT_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.STARTDATE is not None:
            STARTDATE_ = self.STARTDATE
            etree_.SubElement(element, '{}STARTDATE').text = self.gds_format_string(STARTDATE_)
        if self.ENDDATE is not None:
            ENDDATE_ = self.ENDDATE
            etree_.SubElement(element, '{}ENDDATE').text = self.gds_format_string(ENDDATE_)
        if self.EDCCDECISION is not None:
            EDCCDECISION_ = self.EDCCDECISION
            etree_.SubElement(element, '{}EDCCDECISION').text = self.gds_format_string(EDCCDECISION_)
        if self.NOTIFICATIONLANGUAGE is not None:
            NOTIFICATIONLANGUAGE_ = self.NOTIFICATIONLANGUAGE
            etree_.SubElement(element, '{}NOTIFICATIONLANGUAGE').text = self.gds_format_string(NOTIFICATIONLANGUAGE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            CUSTOMFIELD_.to_etree(element, name_='CUSTOMFIELD', mapping_=mapping_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.LEVEL_3_DATA is not None:
            LEVEL_3_DATA_ = self.LEVEL_3_DATA
            LEVEL_3_DATA_.to_etree(element, name_='LEVEL_3_DATA', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATESUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.SECURECARDMERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('SECURECARDMERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.SECURECARDMERCHANTREF)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('LENGTH=%d,\n' % self.LENGTH)
        if self.SKIPPERIODCOUNT is not None:
            showIndent(outfile, level)
            outfile.write('SKIPPERIODCOUNT=%d,\n' % self.SKIPPERIODCOUNT)
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.STARTDATE is not None:
            showIndent(outfile, level)
            outfile.write('STARTDATE=%s,\n' % self.gds_encode(quote_python(self.STARTDATE)))
        if self.ENDDATE is not None:
            showIndent(outfile, level)
            outfile.write('ENDDATE=%s,\n' % self.gds_encode(quote_python(self.ENDDATE)))
        if self.EDCCDECISION is not None:
            showIndent(outfile, level)
            outfile.write('EDCCDECISION=%s,\n' % self.gds_encode(quote_python(self.EDCCDECISION)))
        if self.NOTIFICATIONLANGUAGE is not None:
            showIndent(outfile, level)
            outfile.write('NOTIFICATIONLANGUAGE=%s,\n' % self.gds_encode(quote_python(self.NOTIFICATIONLANGUAGE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        showIndent(outfile, level)
        outfile.write('CUSTOMFIELD=[\n')
        level += 1
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOMFIELD(\n')
            CUSTOMFIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LEVEL_3_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_3_DATA=model_.LEVEL_3_DATA(\n')
            self.LEVEL_3_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'SECURECARDMERCHANTREF':
            SECURECARDMERCHANTREF_ = child_.text
            SECURECARDMERCHANTREF_ = self.gds_validate_string(SECURECARDMERCHANTREF_, node, 'SECURECARDMERCHANTREF')
            self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF_
            # validate type SECURECARDMERCHANTREF
            self.validate_SECURECARDMERCHANTREF(self.SECURECARDMERCHANTREF)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
            # validate type CARDREFERENCE
            self.validate_CARDREFERENCE(self.CARDREFERENCE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
            # validate type NAME
            self.validate_NAME(self.NAME)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'LENGTH' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LENGTH')
            self.LENGTH = ival_
        elif nodeName_ == 'SKIPPERIODCOUNT' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SKIPPERIODCOUNT')
            self.SKIPPERIODCOUNT = ival_
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'STARTDATE':
            STARTDATE_ = child_.text
            STARTDATE_ = self.gds_validate_string(STARTDATE_, node, 'STARTDATE')
            self.STARTDATE = STARTDATE_
            # validate type STARTDATE
            self.validate_STARTDATE(self.STARTDATE)
        elif nodeName_ == 'ENDDATE':
            ENDDATE_ = child_.text
            ENDDATE_ = self.gds_validate_string(ENDDATE_, node, 'ENDDATE')
            self.ENDDATE = ENDDATE_
            # validate type ENDDATE
            self.validate_ENDDATE(self.ENDDATE)
        elif nodeName_ == 'EDCCDECISION':
            EDCCDECISION_ = child_.text
            EDCCDECISION_ = self.gds_validate_string(EDCCDECISION_, node, 'EDCCDECISION')
            self.EDCCDECISION = EDCCDECISION_
            # validate type EDCCDECISION
            self.validate_EDCCDECISION(self.EDCCDECISION)
        elif nodeName_ == 'NOTIFICATIONLANGUAGE':
            NOTIFICATIONLANGUAGE_ = child_.text
            NOTIFICATIONLANGUAGE_ = self.gds_validate_string(NOTIFICATIONLANGUAGE_, node, 'NOTIFICATIONLANGUAGE')
            self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE_
            # validate type NOTIFICATIONLANGUAGE
            self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CUSTOMFIELD':
            obj_ = CUSTOMFIELD.factory()
            obj_.build(child_)
            self.CUSTOMFIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOMFIELD'
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'LEVEL_3_DATA':
            obj_ = LEVEL_3_DATA.factory()
            obj_.build(child_)
            self.LEVEL_3_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_3_DATA'


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID, self.MERCHANTREF]
        if self.SECURECARDMERCHANTREF:
            hash_list.append(self.SECURECARDMERCHANTREF)
        hash_list.append(self.DATETIME)
        hash_list.append(self.STARTDATE)
        return ':'.join(hash_list)
# end class UPDATESUBSCRIPTION


class UPDATESUBSCRIPTIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATESUBSCRIPTIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATESUBSCRIPTIONRESPONSE.subclass:
            return UPDATESUBSCRIPTIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return UPDATESUBSCRIPTIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATESUBSCRIPTIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATESUBSCRIPTIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID, self.MERCHANTREF]
        if self.SECURECARDMERCHANTREF:
            hash_list.append(self.SECURECARDMERCHANTREF)
        hash_list.append(self.DATETIME)
        hash_list.append(self.STARTDATE)
        return ':'.join(hash_list)
# end class UPDATESUBSCRIPTIONRESPONSE


class DELETESUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DELETESUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DELETESUBSCRIPTION.subclass:
            return DELETESUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return DELETESUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DELETESUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DELETESUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class DELETESUBSCRIPTION


class DELETESUBSCRIPTIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DELETESUBSCRIPTIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DELETESUBSCRIPTIONRESPONSE.subclass:
            return DELETESUBSCRIPTIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return DELETESUBSCRIPTIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DELETESUBSCRIPTIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DELETESUBSCRIPTIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class DELETESUBSCRIPTIONRESPONSE


class CANCELSUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CANCELSUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CANCELSUBSCRIPTION.subclass:
            return CANCELSUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return CANCELSUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CANCELSUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CANCELSUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class CANCELSUBSCRIPTION


class CANCELSUBSCRIPTIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CANCELSUBSCRIPTIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CANCELSUBSCRIPTIONRESPONSE.subclass:
            return CANCELSUBSCRIPTIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return CANCELSUBSCRIPTIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CANCELSUBSCRIPTIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CANCELSUBSCRIPTIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class CANCELSUBSCRIPTIONRESPONSE


class SUBSCRIPTIONREF(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUBSCRIPTIONREF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUBSCRIPTIONREF.subclass:
            return SUBSCRIPTIONREF.subclass(*args_, **kwargs_)
        else:
            return SUBSCRIPTIONREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SUBSCRIPTIONREF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SUBSCRIPTIONREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SUBSCRIPTIONREF


class NOTIFICATIONLANGUAGE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NOTIFICATIONLANGUAGE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NOTIFICATIONLANGUAGE.subclass:
            return NOTIFICATIONLANGUAGE.subclass(*args_, **kwargs_)
        else:
            return NOTIFICATIONLANGUAGE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='NOTIFICATIONLANGUAGE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NOTIFICATIONLANGUAGE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NOTIFICATIONLANGUAGE


class SUBSCRIPTIONPAYMENT(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('SUBSCRIPTIONREF', ['SUBSCRIPTIONREF', 'xs:string'], 0, 0, {'ref': 'SUBSCRIPTIONREF', 'name': 'SUBSCRIPTIONREF', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('FOREIGNCURRENCYINFORMATION', 'FOREIGNCURRENCYINFORMATION', 0, 1, {'ref': 'FOREIGNCURRENCYINFORMATION', 'minOccurs': '0', 'name': 'FOREIGNCURRENCYINFORMATION', 'type': 'FOREIGNCURRENCYINFORMATION'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOMFIELD', 'CUSTOMFIELD', 1, 1, {'ref': 'CUSTOMFIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'CUSTOMFIELD', 'type': 'CUSTOMFIELD'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, AMOUNT=None, SUBSCRIPTIONREF=None, DESCRIPTION=None, FOREIGNCURRENCYINFORMATION=None, EMAIL=None, DATETIME=None, HASH=None, CUSTOMFIELD=None, CREDENTIALONFILE=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.SUBSCRIPTIONREF = SUBSCRIPTIONREF
        self.validate_SUBSCRIPTIONREF(self.SUBSCRIPTIONREF)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        if CUSTOMFIELD is None:
            self.CUSTOMFIELD = []
        else:
            self.CUSTOMFIELD = CUSTOMFIELD
        self.CREDENTIALONFILE = CREDENTIALONFILE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUBSCRIPTIONPAYMENT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUBSCRIPTIONPAYMENT.subclass:
            return SUBSCRIPTIONPAYMENT.subclass(*args_, **kwargs_)
        else:
            return SUBSCRIPTIONPAYMENT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_SUBSCRIPTIONREF(self): return self.SUBSCRIPTIONREF
    def set_SUBSCRIPTIONREF(self, SUBSCRIPTIONREF): self.SUBSCRIPTIONREF = SUBSCRIPTIONREF
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_FOREIGNCURRENCYINFORMATION(self): return self.FOREIGNCURRENCYINFORMATION
    def set_FOREIGNCURRENCYINFORMATION(self, FOREIGNCURRENCYINFORMATION): self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CUSTOMFIELD(self): return self.CUSTOMFIELD
    def set_CUSTOMFIELD(self, CUSTOMFIELD): self.CUSTOMFIELD = CUSTOMFIELD
    def add_CUSTOMFIELD(self, value): self.CUSTOMFIELD.append(value)
    def insert_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD.insert(index, value)
    def replace_CUSTOMFIELD_at(self, index, value): self.CUSTOMFIELD[index] = value
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_SUBSCRIPTIONREF(self, value):
        # Validate type SUBSCRIPTIONREF, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.SUBSCRIPTIONREF is not None or
            self.DESCRIPTION is not None or
            self.FOREIGNCURRENCYINFORMATION is not None or
            self.EMAIL is not None or
            self.DATETIME is not None or
            self.HASH is not None or
            self.CUSTOMFIELD or
            self.CREDENTIALONFILE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SUBSCRIPTIONPAYMENT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.SUBSCRIPTIONREF is not None:
            SUBSCRIPTIONREF_ = self.SUBSCRIPTIONREF
            etree_.SubElement(element, '{}SUBSCRIPTIONREF').text = self.gds_format_string(SUBSCRIPTIONREF_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.FOREIGNCURRENCYINFORMATION is not None:
            FOREIGNCURRENCYINFORMATION_ = self.FOREIGNCURRENCYINFORMATION
            FOREIGNCURRENCYINFORMATION_.to_etree(element, name_='FOREIGNCURRENCYINFORMATION', mapping_=mapping_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            CUSTOMFIELD_.to_etree(element, name_='CUSTOMFIELD', mapping_=mapping_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SUBSCRIPTIONPAYMENT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.SUBSCRIPTIONREF is not None:
            showIndent(outfile, level)
            outfile.write('SUBSCRIPTIONREF=%s,\n' % self.gds_encode(quote_python(self.SUBSCRIPTIONREF)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.FOREIGNCURRENCYINFORMATION is not None:
            showIndent(outfile, level)
            outfile.write('FOREIGNCURRENCYINFORMATION=model_.FOREIGNCURRENCYINFORMATION(\n')
            self.FOREIGNCURRENCYINFORMATION.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        showIndent(outfile, level)
        outfile.write('CUSTOMFIELD=[\n')
        level += 1
        for CUSTOMFIELD_ in self.CUSTOMFIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOMFIELD(\n')
            CUSTOMFIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'SUBSCRIPTIONREF':
            SUBSCRIPTIONREF_ = child_.text
            SUBSCRIPTIONREF_ = self.gds_validate_string(SUBSCRIPTIONREF_, node, 'SUBSCRIPTIONREF')
            self.SUBSCRIPTIONREF = SUBSCRIPTIONREF_
            # validate type SUBSCRIPTIONREF
            self.validate_SUBSCRIPTIONREF(self.SUBSCRIPTIONREF)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'FOREIGNCURRENCYINFORMATION':
            obj_ = FOREIGNCURRENCYINFORMATION.factory()
            obj_.build(child_)
            self.FOREIGNCURRENCYINFORMATION = obj_
            obj_.original_tagname_ = 'FOREIGNCURRENCYINFORMATION'
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CUSTOMFIELD':
            obj_ = CUSTOMFIELD.factory()
            obj_.build(child_)
            self.CUSTOMFIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOMFIELD'
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        hash_list.append(self.ORDERID)
        hash_list.append(self.SUBSCRIPTIONREF)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** -Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class SUBSCRIPTIONPAYMENT


class SUBSCRIPTIONPAYMENTRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, APPROVALCODE=None, CREDENTIALONFILE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUBSCRIPTIONPAYMENTRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUBSCRIPTIONPAYMENTRESPONSE.subclass:
            return SUBSCRIPTIONPAYMENTRESPONSE.subclass(*args_, **kwargs_)
        else:
            return SUBSCRIPTIONPAYMENTRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.APPROVALCODE is not None or
            self.CREDENTIALONFILE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SUBSCRIPTIONPAYMENTRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SUBSCRIPTIONPAYMENTRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class SUBSCRIPTIONPAYMENTRESPONSE


class CARDDETAILS(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 0, {'ref': 'CARDTYPE', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 0, {'ref': 'CARDNUMBER', 'name': 'CARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 0, {'ref': 'CARDEXPIRY', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 1, {'ref': 'CARDHOLDERNAME', 'minOccurs': '0', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CARDTYPE=None, CARDNUMBER=None, CARDEXPIRY=None, CARDHOLDERNAME=None):
        self.original_tagname_ = None
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDDETAILS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDDETAILS.subclass:
            return CARDDETAILS.subclass(*args_, **kwargs_)
        else:
            return CARDDETAILS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.CARDTYPE is not None or
            self.CARDNUMBER is not None or
            self.CARDEXPIRY is not None or
            self.CARDHOLDERNAME is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDDETAILS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDDETAILS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)


    @property
    def hash_string(self):
        return ':'.join([self.CARDTYPE, self.CARDNUMBER, self.CARDEXPIRY, self.CARDHOLDERNAME])
# end class CARDDETAILS


class UNREFERENCEDREFUND(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', ['CARDREFERENCE', 'xs:string'], 0, 0, {'ref': 'CARDREFERENCE', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, 7),
        MemberSpec_('CARDDETAILS', 'CARDDETAILS', 0, 0, {'ref': 'CARDDETAILS', 'name': 'CARDDETAILS', 'type': 'CARDDETAILS'}, 7),
        MemberSpec_('DECLINEDREFUNDUNIQUEREF', 'xs:string', 0, 1, {'ref': 'DECLINEDREFUNDUNIQUEREF', 'name': 'DECLINEDREFUNDUNIQUEREF', 'type': 'xs:string'}, 8),
        MemberSpec_('DECLINEDREFUNDORDERID', ['DECLINEDREFUNDORDERID', 'xs:string'], 0, 1, {'ref': 'DECLINEDREFUNDORDERID', 'name': 'DECLINEDREFUNDORDERID', 'type': 'xs:string'}, 8),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 1, {'ref': 'CURRENCY', 'minOccurs': '0', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('AUTOREADY', ['AUTOREADY', 'xs:string'], 0, 1, {'ref': 'AUTOREADY', 'minOccurs': '0', 'name': 'AUTOREADY', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('OPERATOR', ['OPERATOR', 'xs:string'], 0, 0, {'ref': 'OPERATOR', 'name': 'OPERATOR', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('BILLTOFIRSTNAME', ['BILLTOFIRSTNAME', 'xs:string'], 0, 1, {'ref': 'BILLTOFIRSTNAME', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'BILLTOFIRSTNAME', 'type': 'xs:string'}, None),
        MemberSpec_('BILLTOLASTNAME', ['BILLTOLASTNAME', 'xs:string'], 0, 1, {'ref': 'BILLTOLASTNAME', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'BILLTOLASTNAME', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, CARDREFERENCE=None, CARDDETAILS=None, DECLINEDREFUNDUNIQUEREF=None, DECLINEDREFUNDORDERID=None, CURRENCY=None, AMOUNT=None, EMAIL=None, AUTOREADY=None, DATETIME=None, HASH=None, OPERATOR=None, DESCRIPTION=None, ADDRESS1=None, CITY=None, REGION=None, POSTCODE=None, COUNTRY=None, BILLTOFIRSTNAME=None, BILLTOLASTNAME=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.CARDREFERENCE = CARDREFERENCE
        self.validate_CARDREFERENCE(self.CARDREFERENCE)
        self.CARDDETAILS = CARDDETAILS
        self.DECLINEDREFUNDUNIQUEREF = DECLINEDREFUNDUNIQUEREF
        self.DECLINEDREFUNDORDERID = DECLINEDREFUNDORDERID
        self.validate_DECLINEDREFUNDORDERID(self.DECLINEDREFUNDORDERID)
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.AMOUNT = AMOUNT
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.AUTOREADY = AUTOREADY
        self.validate_AUTOREADY(self.AUTOREADY)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.OPERATOR = OPERATOR
        self.validate_OPERATOR(self.OPERATOR)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.BILLTOFIRSTNAME = BILLTOFIRSTNAME
        self.validate_BILLTOFIRSTNAME(self.BILLTOFIRSTNAME)
        self.BILLTOLASTNAME = BILLTOLASTNAME
        self.validate_BILLTOLASTNAME(self.BILLTOLASTNAME)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UNREFERENCEDREFUND)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UNREFERENCEDREFUND.subclass:
            return UNREFERENCEDREFUND.subclass(*args_, **kwargs_)
        else:
            return UNREFERENCEDREFUND(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_CARDDETAILS(self): return self.CARDDETAILS
    def set_CARDDETAILS(self, CARDDETAILS): self.CARDDETAILS = CARDDETAILS
    def get_DECLINEDREFUNDUNIQUEREF(self): return self.DECLINEDREFUNDUNIQUEREF
    def set_DECLINEDREFUNDUNIQUEREF(self, DECLINEDREFUNDUNIQUEREF): self.DECLINEDREFUNDUNIQUEREF = DECLINEDREFUNDUNIQUEREF
    def get_DECLINEDREFUNDORDERID(self): return self.DECLINEDREFUNDORDERID
    def set_DECLINEDREFUNDORDERID(self, DECLINEDREFUNDORDERID): self.DECLINEDREFUNDORDERID = DECLINEDREFUNDORDERID
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_AUTOREADY(self): return self.AUTOREADY
    def set_AUTOREADY(self, AUTOREADY): self.AUTOREADY = AUTOREADY
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_OPERATOR(self): return self.OPERATOR
    def set_OPERATOR(self, OPERATOR): self.OPERATOR = OPERATOR
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_BILLTOFIRSTNAME(self): return self.BILLTOFIRSTNAME
    def set_BILLTOFIRSTNAME(self, BILLTOFIRSTNAME): self.BILLTOFIRSTNAME = BILLTOFIRSTNAME
    def get_BILLTOLASTNAME(self): return self.BILLTOLASTNAME
    def set_BILLTOLASTNAME(self, BILLTOLASTNAME): self.BILLTOLASTNAME = BILLTOLASTNAME
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_CARDREFERENCE(self, value):
        # Validate type CARDREFERENCE, a restriction on xs:string.
        pass
    def validate_DECLINEDREFUNDORDERID(self, value):
        # Validate type DECLINEDREFUNDORDERID, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_AUTOREADY(self, value):
        # Validate type AUTOREADY, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_OPERATOR(self, value):
        # Validate type OPERATOR, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_BILLTOFIRSTNAME(self, value):
        # Validate type BILLTOFIRSTNAME, a restriction on xs:string.
        pass
    def validate_BILLTOLASTNAME(self, value):
        # Validate type BILLTOLASTNAME, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.CARDREFERENCE is not None or
            self.CARDDETAILS is not None or
            self.DECLINEDREFUNDUNIQUEREF is not None or
            self.DECLINEDREFUNDORDERID is not None or
            self.CURRENCY is not None or
            self.AMOUNT is not None or
            self.EMAIL is not None or
            self.AUTOREADY is not None or
            self.DATETIME is not None or
            self.HASH is not None or
            self.OPERATOR is not None or
            self.DESCRIPTION is not None or
            self.ADDRESS1 is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.POSTCODE is not None or
            self.COUNTRY is not None or
            self.BILLTOFIRSTNAME is not None or
            self.BILLTOLASTNAME is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UNREFERENCEDREFUND', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.CARDDETAILS is not None:
            CARDDETAILS_ = self.CARDDETAILS
            CARDDETAILS_.to_etree(element, name_='CARDDETAILS', mapping_=mapping_)
        if self.DECLINEDREFUNDUNIQUEREF is not None:
            DECLINEDREFUNDUNIQUEREF_ = self.DECLINEDREFUNDUNIQUEREF
            etree_.SubElement(element, '{}DECLINEDREFUNDUNIQUEREF').text = self.gds_format_string(DECLINEDREFUNDUNIQUEREF_)
        if self.DECLINEDREFUNDORDERID is not None:
            DECLINEDREFUNDORDERID_ = self.DECLINEDREFUNDORDERID
            etree_.SubElement(element, '{}DECLINEDREFUNDORDERID').text = self.gds_format_string(DECLINEDREFUNDORDERID_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.AUTOREADY is not None:
            AUTOREADY_ = self.AUTOREADY
            etree_.SubElement(element, '{}AUTOREADY').text = self.gds_format_string(AUTOREADY_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.OPERATOR is not None:
            OPERATOR_ = self.OPERATOR
            etree_.SubElement(element, '{}OPERATOR').text = self.gds_format_string(OPERATOR_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.BILLTOFIRSTNAME is not None:
            BILLTOFIRSTNAME_ = self.BILLTOFIRSTNAME
            etree_.SubElement(element, '{}BILLTOFIRSTNAME').text = self.gds_format_string(BILLTOFIRSTNAME_)
        if self.BILLTOLASTNAME is not None:
            BILLTOLASTNAME_ = self.BILLTOLASTNAME
            etree_.SubElement(element, '{}BILLTOLASTNAME').text = self.gds_format_string(BILLTOLASTNAME_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UNREFERENCEDREFUND'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.CARDDETAILS is not None:
            showIndent(outfile, level)
            outfile.write('CARDDETAILS=model_.CARDDETAILS(\n')
            self.CARDDETAILS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DECLINEDREFUNDUNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('DECLINEDREFUNDUNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.DECLINEDREFUNDUNIQUEREF)))
        if self.DECLINEDREFUNDORDERID is not None:
            showIndent(outfile, level)
            outfile.write('DECLINEDREFUNDORDERID=%s,\n' % self.gds_encode(quote_python(self.DECLINEDREFUNDORDERID)))
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.AUTOREADY is not None:
            showIndent(outfile, level)
            outfile.write('AUTOREADY=%s,\n' % self.gds_encode(quote_python(self.AUTOREADY)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.OPERATOR is not None:
            showIndent(outfile, level)
            outfile.write('OPERATOR=%s,\n' % self.gds_encode(quote_python(self.OPERATOR)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.BILLTOFIRSTNAME is not None:
            showIndent(outfile, level)
            outfile.write('BILLTOFIRSTNAME=%s,\n' % self.gds_encode(quote_python(self.BILLTOFIRSTNAME)))
        if self.BILLTOLASTNAME is not None:
            showIndent(outfile, level)
            outfile.write('BILLTOLASTNAME=%s,\n' % self.gds_encode(quote_python(self.BILLTOLASTNAME)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
            # validate type CARDREFERENCE
            self.validate_CARDREFERENCE(self.CARDREFERENCE)
        elif nodeName_ == 'CARDDETAILS':
            obj_ = CARDDETAILS.factory()
            obj_.build(child_)
            self.CARDDETAILS = obj_
            obj_.original_tagname_ = 'CARDDETAILS'
        elif nodeName_ == 'DECLINEDREFUNDUNIQUEREF':
            DECLINEDREFUNDUNIQUEREF_ = child_.text
            DECLINEDREFUNDUNIQUEREF_ = self.gds_validate_string(DECLINEDREFUNDUNIQUEREF_, node, 'DECLINEDREFUNDUNIQUEREF')
            self.DECLINEDREFUNDUNIQUEREF = DECLINEDREFUNDUNIQUEREF_
        elif nodeName_ == 'DECLINEDREFUNDORDERID':
            DECLINEDREFUNDORDERID_ = child_.text
            DECLINEDREFUNDORDERID_ = self.gds_validate_string(DECLINEDREFUNDORDERID_, node, 'DECLINEDREFUNDORDERID')
            self.DECLINEDREFUNDORDERID = DECLINEDREFUNDORDERID_
            # validate type DECLINEDREFUNDORDERID
            self.validate_DECLINEDREFUNDORDERID(self.DECLINEDREFUNDORDERID)
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'AUTOREADY':
            AUTOREADY_ = child_.text
            AUTOREADY_ = self.gds_validate_string(AUTOREADY_, node, 'AUTOREADY')
            self.AUTOREADY = AUTOREADY_
            # validate type AUTOREADY
            self.validate_AUTOREADY(self.AUTOREADY)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'OPERATOR':
            OPERATOR_ = child_.text
            OPERATOR_ = self.gds_validate_string(OPERATOR_, node, 'OPERATOR')
            self.OPERATOR = OPERATOR_
            # validate type OPERATOR
            self.validate_OPERATOR(self.OPERATOR)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'BILLTOFIRSTNAME':
            BILLTOFIRSTNAME_ = child_.text
            BILLTOFIRSTNAME_ = self.gds_validate_string(BILLTOFIRSTNAME_, node, 'BILLTOFIRSTNAME')
            self.BILLTOFIRSTNAME = BILLTOFIRSTNAME_
            # validate type BILLTOFIRSTNAME
            self.validate_BILLTOFIRSTNAME(self.BILLTOFIRSTNAME)
        elif nodeName_ == 'BILLTOLASTNAME':
            BILLTOLASTNAME_ = child_.text
            BILLTOLASTNAME_ = self.gds_validate_string(BILLTOLASTNAME_, node, 'BILLTOLASTNAME')
            self.BILLTOLASTNAME = BILLTOLASTNAME_
            # validate type BILLTOLASTNAME
            self.validate_BILLTOLASTNAME(self.BILLTOLASTNAME)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        if self.ORDERID:
            hash_list.append(self.ORDERID)
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** -Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID, self.ORDERID, self.CARDDETAILS.hash_string]
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class UNREFERENCEDREFUND


class UNREFERENCEDREFUNDRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, 9),
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, 9),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('PROCESSINGTERMINAL', ['PROCESSINGTERMINAL', 'xs:string'], 0, 1, {'ref': 'PROCESSINGTERMINAL', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PROCESSINGTERMINAL', 'type': 'xs:string'}, None),
        MemberSpec_('ADDITIONAL_FIELD', 'ADDITIONAL_FIELD', 1, 1, {'ref': 'ADDITIONAL_FIELD', 'minOccurs': '0', 'maxOccurs': '30', 'name': 'ADDITIONAL_FIELD', 'type': 'ADDITIONAL_FIELD'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, RESPONSECODE=None, RESPONSETEXT=None, UNIQUEREF=None, ORDERID=None, DATETIME=None, PROCESSINGTERMINAL=None, ADDITIONAL_FIELD=None, HASH=None):
        self.original_tagname_ = None
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.UNIQUEREF = UNIQUEREF
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
        self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        if ADDITIONAL_FIELD is None:
            self.ADDITIONAL_FIELD = []
        else:
            self.ADDITIONAL_FIELD = ADDITIONAL_FIELD
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UNREFERENCEDREFUNDRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UNREFERENCEDREFUNDRESPONSE.subclass:
            return UNREFERENCEDREFUNDRESPONSE.subclass(*args_, **kwargs_)
        else:
            return UNREFERENCEDREFUNDRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_PROCESSINGTERMINAL(self): return self.PROCESSINGTERMINAL
    def set_PROCESSINGTERMINAL(self, PROCESSINGTERMINAL): self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
    def get_ADDITIONAL_FIELD(self): return self.ADDITIONAL_FIELD
    def set_ADDITIONAL_FIELD(self, ADDITIONAL_FIELD): self.ADDITIONAL_FIELD = ADDITIONAL_FIELD
    def add_ADDITIONAL_FIELD(self, value): self.ADDITIONAL_FIELD.append(value)
    def insert_ADDITIONAL_FIELD_at(self, index, value): self.ADDITIONAL_FIELD.insert(index, value)
    def replace_ADDITIONAL_FIELD_at(self, index, value): self.ADDITIONAL_FIELD[index] = value
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_PROCESSINGTERMINAL(self, value):
        # Validate type PROCESSINGTERMINAL, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.UNIQUEREF is not None or
            self.ORDERID is not None or
            self.DATETIME is not None or
            self.PROCESSINGTERMINAL is not None or
            self.ADDITIONAL_FIELD or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UNREFERENCEDREFUNDRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.PROCESSINGTERMINAL is not None:
            PROCESSINGTERMINAL_ = self.PROCESSINGTERMINAL
            etree_.SubElement(element, '{}PROCESSINGTERMINAL').text = self.gds_format_string(PROCESSINGTERMINAL_)
        for ADDITIONAL_FIELD_ in self.ADDITIONAL_FIELD:
            ADDITIONAL_FIELD_.to_etree(element, name_='ADDITIONAL_FIELD', mapping_=mapping_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UNREFERENCEDREFUNDRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.PROCESSINGTERMINAL is not None:
            showIndent(outfile, level)
            outfile.write('PROCESSINGTERMINAL=%s,\n' % self.gds_encode(quote_python(self.PROCESSINGTERMINAL)))
        showIndent(outfile, level)
        outfile.write('ADDITIONAL_FIELD=[\n')
        level += 1
        for ADDITIONAL_FIELD_ in self.ADDITIONAL_FIELD:
            showIndent(outfile, level)
            outfile.write('model_.ADDITIONAL_FIELD(\n')
            ADDITIONAL_FIELD_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'PROCESSINGTERMINAL':
            PROCESSINGTERMINAL_ = child_.text
            PROCESSINGTERMINAL_ = self.gds_validate_string(PROCESSINGTERMINAL_, node, 'PROCESSINGTERMINAL')
            self.PROCESSINGTERMINAL = PROCESSINGTERMINAL_
            # validate type PROCESSINGTERMINAL
            self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        elif nodeName_ == 'ADDITIONAL_FIELD':
            obj_ = ADDITIONAL_FIELD.factory()
            obj_.build(child_)
            self.ADDITIONAL_FIELD.append(obj_)
            obj_.original_tagname_ = 'ADDITIONAL_FIELD'
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID, self.ORDERID, self.CARDDETAILS.hash_string]
        if self.multicurrency:
            hash_list.append(self.CURRENCY)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** - Currency[self.CURRENCY].minorunits)))
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class UNREFERENCEDREFUNDRESPONSE


class VOICEIDREQUEST(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('MOBILENUMBER', ['MOBILENUMBER', 'xs:string'], 0, 0, {'ref': 'MOBILENUMBER', 'name': 'MOBILENUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 0, {'ref': 'EMAIL', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('VOICEIDPAYMENT', 'VOICEIDPAYMENT', 0, 1, {'ref': 'VOICEIDPAYMENT', 'minOccurs': '0', 'name': 'VOICEIDPAYMENT', 'type': 'VOICEIDPAYMENT'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, DATETIME=None, MOBILENUMBER=None, EMAIL=None, VOICEIDPAYMENT=None, HASH=None, DESCRIPTION=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.MOBILENUMBER = MOBILENUMBER
        self.validate_MOBILENUMBER(self.MOBILENUMBER)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.VOICEIDPAYMENT = VOICEIDPAYMENT
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VOICEIDREQUEST)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VOICEIDREQUEST.subclass:
            return VOICEIDREQUEST.subclass(*args_, **kwargs_)
        else:
            return VOICEIDREQUEST(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_MOBILENUMBER(self): return self.MOBILENUMBER
    def set_MOBILENUMBER(self, MOBILENUMBER): self.MOBILENUMBER = MOBILENUMBER
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_VOICEIDPAYMENT(self): return self.VOICEIDPAYMENT
    def set_VOICEIDPAYMENT(self, VOICEIDPAYMENT): self.VOICEIDPAYMENT = VOICEIDPAYMENT
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_MOBILENUMBER(self, value):
        # Validate type MOBILENUMBER, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.MOBILENUMBER is not None or
            self.EMAIL is not None or
            self.VOICEIDPAYMENT is not None or
            self.HASH is not None or
            self.DESCRIPTION is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VOICEIDREQUEST', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.MOBILENUMBER is not None:
            MOBILENUMBER_ = self.MOBILENUMBER
            etree_.SubElement(element, '{}MOBILENUMBER').text = self.gds_format_string(MOBILENUMBER_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.VOICEIDPAYMENT is not None:
            VOICEIDPAYMENT_ = self.VOICEIDPAYMENT
            VOICEIDPAYMENT_.to_etree(element, name_='VOICEIDPAYMENT', mapping_=mapping_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='VOICEIDREQUEST'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.MOBILENUMBER is not None:
            showIndent(outfile, level)
            outfile.write('MOBILENUMBER=%s,\n' % self.gds_encode(quote_python(self.MOBILENUMBER)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.VOICEIDPAYMENT is not None:
            showIndent(outfile, level)
            outfile.write('VOICEIDPAYMENT=model_.VOICEIDPAYMENT(\n')
            self.VOICEIDPAYMENT.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'MOBILENUMBER':
            MOBILENUMBER_ = child_.text
            MOBILENUMBER_ = self.gds_validate_string(MOBILENUMBER_, node, 'MOBILENUMBER')
            self.MOBILENUMBER = MOBILENUMBER_
            # validate type MOBILENUMBER
            self.validate_MOBILENUMBER(self.MOBILENUMBER)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'VOICEIDPAYMENT':
            obj_ = VOICEIDPAYMENT.factory()
            obj_.build(child_)
            self.VOICEIDPAYMENT = obj_
            obj_.original_tagname_ = 'VOICEIDPAYMENT'
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
# end class VOICEIDREQUEST


class VOICEIDRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, RESPONSECODE=None, RESPONSETEXT=None, ORDERID=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VOICEIDRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VOICEIDRESPONSE.subclass:
            return VOICEIDRESPONSE.subclass(*args_, **kwargs_)
        else:
            return VOICEIDRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.ORDERID is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VOICEIDRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='VOICEIDRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class VOICEIDRESPONSE


class VOICEIDPAYMENT(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, AMOUNT=None, CURRENCY=None):
        self.original_tagname_ = None
        self.AMOUNT = AMOUNT
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VOICEIDPAYMENT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VOICEIDPAYMENT.subclass:
            return VOICEIDPAYMENT.subclass(*args_, **kwargs_)
        else:
            return VOICEIDPAYMENT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.AMOUNT is not None or
            self.CURRENCY is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VOICEIDPAYMENT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='VOICEIDPAYMENT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
# end class VOICEIDPAYMENT


class FXCURRENCY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FXCURRENCY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FXCURRENCY.subclass:
            return FXCURRENCY.subclass(*args_, **kwargs_)
        else:
            return FXCURRENCY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FXCURRENCY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FXCURRENCY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FXCURRENCY


class GETFXCURRENCYRATE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('FXCURRENCY', ['FXCURRENCY', 'xs:string'], 0, 0, {'ref': 'FXCURRENCY', 'name': 'FXCURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('BASEAMOUNT', 'xs:double', 0, 1, {'ref': 'BASEAMOUNT', 'minOccurs': '0', 'name': 'BASEAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, FXCURRENCY=None, BASEAMOUNT=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.FXCURRENCY = FXCURRENCY
        self.validate_FXCURRENCY(self.FXCURRENCY)
        self.BASEAMOUNT = BASEAMOUNT
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GETFXCURRENCYRATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GETFXCURRENCYRATE.subclass:
            return GETFXCURRENCYRATE.subclass(*args_, **kwargs_)
        else:
            return GETFXCURRENCYRATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_FXCURRENCY(self): return self.FXCURRENCY
    def set_FXCURRENCY(self, FXCURRENCY): self.FXCURRENCY = FXCURRENCY
    def get_BASEAMOUNT(self): return self.BASEAMOUNT
    def set_BASEAMOUNT(self, BASEAMOUNT): self.BASEAMOUNT = BASEAMOUNT
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_FXCURRENCY(self, value):
        # Validate type FXCURRENCY, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.FXCURRENCY is not None or
            self.BASEAMOUNT is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='GETFXCURRENCYRATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.FXCURRENCY is not None:
            FXCURRENCY_ = self.FXCURRENCY
            etree_.SubElement(element, '{}FXCURRENCY').text = self.gds_format_string(FXCURRENCY_)
        if self.BASEAMOUNT is not None:
            BASEAMOUNT_ = self.BASEAMOUNT
            etree_.SubElement(element, '{}BASEAMOUNT').text = self.gds_format_double(BASEAMOUNT_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GETFXCURRENCYRATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.FXCURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('FXCURRENCY=%s,\n' % self.gds_encode(quote_python(self.FXCURRENCY)))
        if self.BASEAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('BASEAMOUNT=%e,\n' % self.BASEAMOUNT)
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'FXCURRENCY':
            FXCURRENCY_ = child_.text
            FXCURRENCY_ = self.gds_validate_string(FXCURRENCY_, node, 'FXCURRENCY')
            self.FXCURRENCY = FXCURRENCY_
            # validate type FXCURRENCY
            self.validate_FXCURRENCY(self.FXCURRENCY)
        elif nodeName_ == 'BASEAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'BASEAMOUNT')
            self.BASEAMOUNT = fval_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class GETFXCURRENCYRATE


class FXCURRENCYRATERESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALCURRENCY', ['TERMINALCURRENCY', 'xs:string'], 0, 0, {'ref': 'TERMINALCURRENCY', 'name': 'TERMINALCURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('FXCURRENCY', ['FXCURRENCY', 'xs:string'], 0, 0, {'ref': 'FXCURRENCY', 'name': 'FXCURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('CONVERSIONRATE', 'xs:double', 0, 0, {'ref': 'CONVERSIONRATE', 'name': 'CONVERSIONRATE', 'type': 'xs:double'}, None),
        MemberSpec_('FOREIGNAMOUNT', 'xs:double', 0, 1, {'ref': 'FOREIGNAMOUNT', 'minOccurs': '0', 'name': 'FOREIGNAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALCURRENCY=None, FXCURRENCY=None, CONVERSIONRATE=None, FOREIGNAMOUNT=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALCURRENCY = TERMINALCURRENCY
        self.validate_TERMINALCURRENCY(self.TERMINALCURRENCY)
        self.FXCURRENCY = FXCURRENCY
        self.validate_FXCURRENCY(self.FXCURRENCY)
        self.CONVERSIONRATE = CONVERSIONRATE
        self.FOREIGNAMOUNT = FOREIGNAMOUNT
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FXCURRENCYRATERESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FXCURRENCYRATERESPONSE.subclass:
            return FXCURRENCYRATERESPONSE.subclass(*args_, **kwargs_)
        else:
            return FXCURRENCYRATERESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALCURRENCY(self): return self.TERMINALCURRENCY
    def set_TERMINALCURRENCY(self, TERMINALCURRENCY): self.TERMINALCURRENCY = TERMINALCURRENCY
    def get_FXCURRENCY(self): return self.FXCURRENCY
    def set_FXCURRENCY(self, FXCURRENCY): self.FXCURRENCY = FXCURRENCY
    def get_CONVERSIONRATE(self): return self.CONVERSIONRATE
    def set_CONVERSIONRATE(self, CONVERSIONRATE): self.CONVERSIONRATE = CONVERSIONRATE
    def get_FOREIGNAMOUNT(self): return self.FOREIGNAMOUNT
    def set_FOREIGNAMOUNT(self, FOREIGNAMOUNT): self.FOREIGNAMOUNT = FOREIGNAMOUNT
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALCURRENCY(self, value):
        # Validate type TERMINALCURRENCY, a restriction on xs:string.
        pass
    def validate_FXCURRENCY(self, value):
        # Validate type FXCURRENCY, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALCURRENCY is not None or
            self.FXCURRENCY is not None or
            self.CONVERSIONRATE is not None or
            self.FOREIGNAMOUNT is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FXCURRENCYRATERESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALCURRENCY is not None:
            TERMINALCURRENCY_ = self.TERMINALCURRENCY
            etree_.SubElement(element, '{}TERMINALCURRENCY').text = self.gds_format_string(TERMINALCURRENCY_)
        if self.FXCURRENCY is not None:
            FXCURRENCY_ = self.FXCURRENCY
            etree_.SubElement(element, '{}FXCURRENCY').text = self.gds_format_string(FXCURRENCY_)
        if self.CONVERSIONRATE is not None:
            CONVERSIONRATE_ = self.CONVERSIONRATE
            etree_.SubElement(element, '{}CONVERSIONRATE').text = self.gds_format_double(CONVERSIONRATE_)
        if self.FOREIGNAMOUNT is not None:
            FOREIGNAMOUNT_ = self.FOREIGNAMOUNT
            etree_.SubElement(element, '{}FOREIGNAMOUNT').text = self.gds_format_double(FOREIGNAMOUNT_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FXCURRENCYRATERESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALCURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALCURRENCY=%s,\n' % self.gds_encode(quote_python(self.TERMINALCURRENCY)))
        if self.FXCURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('FXCURRENCY=%s,\n' % self.gds_encode(quote_python(self.FXCURRENCY)))
        if self.CONVERSIONRATE is not None:
            showIndent(outfile, level)
            outfile.write('CONVERSIONRATE=%e,\n' % self.CONVERSIONRATE)
        if self.FOREIGNAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('FOREIGNAMOUNT=%e,\n' % self.FOREIGNAMOUNT)
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALCURRENCY':
            TERMINALCURRENCY_ = child_.text
            TERMINALCURRENCY_ = self.gds_validate_string(TERMINALCURRENCY_, node, 'TERMINALCURRENCY')
            self.TERMINALCURRENCY = TERMINALCURRENCY_
            # validate type TERMINALCURRENCY
            self.validate_TERMINALCURRENCY(self.TERMINALCURRENCY)
        elif nodeName_ == 'FXCURRENCY':
            FXCURRENCY_ = child_.text
            FXCURRENCY_ = self.gds_validate_string(FXCURRENCY_, node, 'FXCURRENCY')
            self.FXCURRENCY = FXCURRENCY_
            # validate type FXCURRENCY
            self.validate_FXCURRENCY(self.FXCURRENCY)
        elif nodeName_ == 'CONVERSIONRATE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CONVERSIONRATE')
            self.CONVERSIONRATE = fval_
        elif nodeName_ == 'FOREIGNAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'FOREIGNAMOUNT')
            self.FOREIGNAMOUNT = fval_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class FXCURRENCYRATERESPONSE


class FROMSTATUS(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FROMSTATUS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FROMSTATUS.subclass:
            return FROMSTATUS.subclass(*args_, **kwargs_)
        else:
            return FROMSTATUS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FROMSTATUS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FROMSTATUS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FROMSTATUS


class TOSTATUS(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TOSTATUS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TOSTATUS.subclass:
            return TOSTATUS.subclass(*args_, **kwargs_)
        else:
            return TOSTATUS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TOSTATUS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TOSTATUS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TOSTATUS


class TRANSACTIONUPDATE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('OPERATOR', ['OPERATOR', 'xs:string'], 0, 0, {'ref': 'OPERATOR', 'name': 'OPERATOR', 'type': 'xs:string'}, None),
        MemberSpec_('FROMSTATUS', ['FROMSTATUS', 'xs:string'], 0, 0, {'ref': 'FROMSTATUS', 'name': 'FROMSTATUS', 'type': 'xs:string'}, None),
        MemberSpec_('TOSTATUS', ['TOSTATUS', 'xs:string'], 0, 0, {'ref': 'TOSTATUS', 'name': 'TOSTATUS', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 1, {'ref': 'APPROVALCODE', 'minOccurs': '0', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, TERMINALID=None, OPERATOR=None, FROMSTATUS=None, TOSTATUS=None, APPROVALCODE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.OPERATOR = OPERATOR
        self.validate_OPERATOR(self.OPERATOR)
        self.FROMSTATUS = FROMSTATUS
        self.validate_FROMSTATUS(self.FROMSTATUS)
        self.TOSTATUS = TOSTATUS
        self.validate_TOSTATUS(self.TOSTATUS)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRANSACTIONUPDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRANSACTIONUPDATE.subclass:
            return TRANSACTIONUPDATE.subclass(*args_, **kwargs_)
        else:
            return TRANSACTIONUPDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_OPERATOR(self): return self.OPERATOR
    def set_OPERATOR(self, OPERATOR): self.OPERATOR = OPERATOR
    def get_FROMSTATUS(self): return self.FROMSTATUS
    def set_FROMSTATUS(self, FROMSTATUS): self.FROMSTATUS = FROMSTATUS
    def get_TOSTATUS(self): return self.TOSTATUS
    def set_TOSTATUS(self, TOSTATUS): self.TOSTATUS = TOSTATUS
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_OPERATOR(self, value):
        # Validate type OPERATOR, a restriction on xs:string.
        pass
    def validate_FROMSTATUS(self, value):
        # Validate type FROMSTATUS, a restriction on xs:string.
        pass
    def validate_TOSTATUS(self, value):
        # Validate type TOSTATUS, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.TERMINALID is not None or
            self.OPERATOR is not None or
            self.FROMSTATUS is not None or
            self.TOSTATUS is not None or
            self.APPROVALCODE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TRANSACTIONUPDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.OPERATOR is not None:
            OPERATOR_ = self.OPERATOR
            etree_.SubElement(element, '{}OPERATOR').text = self.gds_format_string(OPERATOR_)
        if self.FROMSTATUS is not None:
            FROMSTATUS_ = self.FROMSTATUS
            etree_.SubElement(element, '{}FROMSTATUS').text = self.gds_format_string(FROMSTATUS_)
        if self.TOSTATUS is not None:
            TOSTATUS_ = self.TOSTATUS
            etree_.SubElement(element, '{}TOSTATUS').text = self.gds_format_string(TOSTATUS_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TRANSACTIONUPDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.OPERATOR is not None:
            showIndent(outfile, level)
            outfile.write('OPERATOR=%s,\n' % self.gds_encode(quote_python(self.OPERATOR)))
        if self.FROMSTATUS is not None:
            showIndent(outfile, level)
            outfile.write('FROMSTATUS=%s,\n' % self.gds_encode(quote_python(self.FROMSTATUS)))
        if self.TOSTATUS is not None:
            showIndent(outfile, level)
            outfile.write('TOSTATUS=%s,\n' % self.gds_encode(quote_python(self.TOSTATUS)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'OPERATOR':
            OPERATOR_ = child_.text
            OPERATOR_ = self.gds_validate_string(OPERATOR_, node, 'OPERATOR')
            self.OPERATOR = OPERATOR_
            # validate type OPERATOR
            self.validate_OPERATOR(self.OPERATOR)
        elif nodeName_ == 'FROMSTATUS':
            FROMSTATUS_ = child_.text
            FROMSTATUS_ = self.gds_validate_string(FROMSTATUS_, node, 'FROMSTATUS')
            self.FROMSTATUS = FROMSTATUS_
            # validate type FROMSTATUS
            self.validate_FROMSTATUS(self.FROMSTATUS)
        elif nodeName_ == 'TOSTATUS':
            TOSTATUS_ = child_.text
            TOSTATUS_ = self.gds_validate_string(TOSTATUS_, node, 'TOSTATUS')
            self.TOSTATUS = TOSTATUS_
            # validate type TOSTATUS
            self.validate_TOSTATUS(self.TOSTATUS)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class TRANSACTIONUPDATE


class TRANSACTIONUPDATERESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, RESPONSECODE=None, RESPONSETEXT=None, UNIQUEREF=None, TERMINALID=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.UNIQUEREF = UNIQUEREF
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRANSACTIONUPDATERESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRANSACTIONUPDATERESPONSE.subclass:
            return TRANSACTIONUPDATERESPONSE.subclass(*args_, **kwargs_)
        else:
            return TRANSACTIONUPDATERESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.UNIQUEREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TRANSACTIONUPDATERESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TRANSACTIONUPDATERESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class TRANSACTIONUPDATERESPONSE


class UPDATE_TRANSACTION_ENHANCED_DATA(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('OPERATOR', ['OPERATOR', 'xs:string'], 0, 0, {'ref': 'OPERATOR', 'name': 'OPERATOR', 'type': 'xs:string'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('LEVEL_3_DATA', 'LEVEL_3_DATA', 0, 1, {'ref': 'LEVEL_3_DATA', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'LEVEL_3_DATA', 'type': 'LEVEL_3_DATA'}, None),
        MemberSpec_('ENHANCED_DATA_TEMPLATE', ['ENHANCED_DATA_TEMPLATE', 'xs:string'], 0, 1, {'ref': 'ENHANCED_DATA_TEMPLATE', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'ENHANCED_DATA_TEMPLATE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, UNIQUEREF=None, OPERATOR=None, LEVEL_2_DATA=None, LEVEL_3_DATA=None, ENHANCED_DATA_TEMPLATE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.UNIQUEREF = UNIQUEREF
        self.OPERATOR = OPERATOR
        self.validate_OPERATOR(self.OPERATOR)
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.LEVEL_3_DATA = LEVEL_3_DATA
        self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE
        self.validate_ENHANCED_DATA_TEMPLATE(self.ENHANCED_DATA_TEMPLATE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATE_TRANSACTION_ENHANCED_DATA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATE_TRANSACTION_ENHANCED_DATA.subclass:
            return UPDATE_TRANSACTION_ENHANCED_DATA.subclass(*args_, **kwargs_)
        else:
            return UPDATE_TRANSACTION_ENHANCED_DATA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_OPERATOR(self): return self.OPERATOR
    def set_OPERATOR(self, OPERATOR): self.OPERATOR = OPERATOR
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_LEVEL_3_DATA(self): return self.LEVEL_3_DATA
    def set_LEVEL_3_DATA(self, LEVEL_3_DATA): self.LEVEL_3_DATA = LEVEL_3_DATA
    def get_ENHANCED_DATA_TEMPLATE(self): return self.ENHANCED_DATA_TEMPLATE
    def set_ENHANCED_DATA_TEMPLATE(self, ENHANCED_DATA_TEMPLATE): self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_OPERATOR(self, value):
        # Validate type OPERATOR, a restriction on xs:string.
        pass
    def validate_ENHANCED_DATA_TEMPLATE(self, value):
        # Validate type ENHANCED_DATA_TEMPLATE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.UNIQUEREF is not None or
            self.OPERATOR is not None or
            self.LEVEL_2_DATA is not None or
            self.LEVEL_3_DATA is not None or
            self.ENHANCED_DATA_TEMPLATE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATE_TRANSACTION_ENHANCED_DATA', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.OPERATOR is not None:
            OPERATOR_ = self.OPERATOR
            etree_.SubElement(element, '{}OPERATOR').text = self.gds_format_string(OPERATOR_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.LEVEL_3_DATA is not None:
            LEVEL_3_DATA_ = self.LEVEL_3_DATA
            LEVEL_3_DATA_.to_etree(element, name_='LEVEL_3_DATA', mapping_=mapping_)
        if self.ENHANCED_DATA_TEMPLATE is not None:
            ENHANCED_DATA_TEMPLATE_ = self.ENHANCED_DATA_TEMPLATE
            etree_.SubElement(element, '{}ENHANCED_DATA_TEMPLATE').text = self.gds_format_string(ENHANCED_DATA_TEMPLATE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATE_TRANSACTION_ENHANCED_DATA'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.OPERATOR is not None:
            showIndent(outfile, level)
            outfile.write('OPERATOR=%s,\n' % self.gds_encode(quote_python(self.OPERATOR)))
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LEVEL_3_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_3_DATA=model_.LEVEL_3_DATA(\n')
            self.LEVEL_3_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ENHANCED_DATA_TEMPLATE is not None:
            showIndent(outfile, level)
            outfile.write('ENHANCED_DATA_TEMPLATE=%s,\n' % self.gds_encode(quote_python(self.ENHANCED_DATA_TEMPLATE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'OPERATOR':
            OPERATOR_ = child_.text
            OPERATOR_ = self.gds_validate_string(OPERATOR_, node, 'OPERATOR')
            self.OPERATOR = OPERATOR_
            # validate type OPERATOR
            self.validate_OPERATOR(self.OPERATOR)
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'LEVEL_3_DATA':
            obj_ = LEVEL_3_DATA.factory()
            obj_.build(child_)
            self.LEVEL_3_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_3_DATA'
        elif nodeName_ == 'ENHANCED_DATA_TEMPLATE':
            ENHANCED_DATA_TEMPLATE_ = child_.text
            ENHANCED_DATA_TEMPLATE_ = self.gds_validate_string(ENHANCED_DATA_TEMPLATE_, node, 'ENHANCED_DATA_TEMPLATE')
            self.ENHANCED_DATA_TEMPLATE = ENHANCED_DATA_TEMPLATE_
            # validate type ENHANCED_DATA_TEMPLATE
            self.validate_ENHANCED_DATA_TEMPLATE(self.ENHANCED_DATA_TEMPLATE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class UPDATE_TRANSACTION_ENHANCED_DATA


class UPDATE_TRANSACTION_ENHANCED_DATA_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('LEVEL_3_DATA', 'LEVEL_3_DATA', 0, 1, {'ref': 'LEVEL_3_DATA', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'LEVEL_3_DATA', 'type': 'LEVEL_3_DATA'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, UNIQUEREF=None, LEVEL_2_DATA=None, LEVEL_3_DATA=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.UNIQUEREF = UNIQUEREF
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.LEVEL_3_DATA = LEVEL_3_DATA
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATE_TRANSACTION_ENHANCED_DATA_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATE_TRANSACTION_ENHANCED_DATA_RESPONSE.subclass:
            return UPDATE_TRANSACTION_ENHANCED_DATA_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return UPDATE_TRANSACTION_ENHANCED_DATA_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_LEVEL_3_DATA(self): return self.LEVEL_3_DATA
    def set_LEVEL_3_DATA(self, LEVEL_3_DATA): self.LEVEL_3_DATA = LEVEL_3_DATA
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.UNIQUEREF is not None or
            self.LEVEL_2_DATA is not None or
            self.LEVEL_3_DATA is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATE_TRANSACTION_ENHANCED_DATA_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.LEVEL_3_DATA is not None:
            LEVEL_3_DATA_ = self.LEVEL_3_DATA
            LEVEL_3_DATA_.to_etree(element, name_='LEVEL_3_DATA', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATE_TRANSACTION_ENHANCED_DATA_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LEVEL_3_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_3_DATA=model_.LEVEL_3_DATA(\n')
            self.LEVEL_3_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'LEVEL_3_DATA':
            obj_ = LEVEL_3_DATA.factory()
            obj_.build(child_)
            self.LEVEL_3_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_3_DATA'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class UPDATE_TRANSACTION_ENHANCED_DATA_RESPONSE


class PROCESSINGTERMINAL(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PROCESSINGTERMINAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PROCESSINGTERMINAL.subclass:
            return PROCESSINGTERMINAL.subclass(*args_, **kwargs_)
        else:
            return PROCESSINGTERMINAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PROCESSINGTERMINAL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PROCESSINGTERMINAL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PROCESSINGTERMINAL


class ACH_ACCOUNT(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_ACCOUNT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_ACCOUNT.subclass:
            return ACH_ACCOUNT.subclass(*args_, **kwargs_)
        else:
            return ACH_ACCOUNT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_ACCOUNT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_ACCOUNT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_ACCOUNT


class ACH_ACCOUNT_TYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_ACCOUNT_TYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_ACCOUNT_TYPE.subclass:
            return ACH_ACCOUNT_TYPE.subclass(*args_, **kwargs_)
        else:
            return ACH_ACCOUNT_TYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_ACCOUNT_TYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_ACCOUNT_TYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_ACCOUNT_TYPE


class ACH_FIRST_NAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_FIRST_NAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_FIRST_NAME.subclass:
            return ACH_FIRST_NAME.subclass(*args_, **kwargs_)
        else:
            return ACH_FIRST_NAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_FIRST_NAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_FIRST_NAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_FIRST_NAME


class ACH_LAST_NAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_LAST_NAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_LAST_NAME.subclass:
            return ACH_LAST_NAME.subclass(*args_, **kwargs_)
        else:
            return ACH_LAST_NAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_LAST_NAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_LAST_NAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_LAST_NAME


class ACH_ADDRESS1(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_ADDRESS1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_ADDRESS1.subclass:
            return ACH_ADDRESS1.subclass(*args_, **kwargs_)
        else:
            return ACH_ADDRESS1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_ADDRESS1', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_ADDRESS1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_ADDRESS1


class ACH_ADDRESS2(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_ADDRESS2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_ADDRESS2.subclass:
            return ACH_ADDRESS2.subclass(*args_, **kwargs_)
        else:
            return ACH_ADDRESS2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_ADDRESS2', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_ADDRESS2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_ADDRESS2


class ACH_CITY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_CITY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_CITY.subclass:
            return ACH_CITY.subclass(*args_, **kwargs_)
        else:
            return ACH_CITY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_CITY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_CITY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_CITY


class ACH_STATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_STATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_STATE.subclass:
            return ACH_STATE.subclass(*args_, **kwargs_)
        else:
            return ACH_STATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_STATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_STATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_STATE


class ACH_ZIP(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_ZIP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_ZIP.subclass:
            return ACH_ZIP.subclass(*args_, **kwargs_)
        else:
            return ACH_ZIP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_ZIP', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_ZIP'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_ZIP


class ACH_PHONE_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_PHONE_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_PHONE_NUMBER.subclass:
            return ACH_PHONE_NUMBER.subclass(*args_, **kwargs_)
        else:
            return ACH_PHONE_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_PHONE_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_PHONE_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_PHONE_NUMBER


class ACHREFERENCE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHREFERENCE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHREFERENCE.subclass:
            return ACHREFERENCE.subclass(*args_, **kwargs_)
        else:
            return ACHREFERENCE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHREFERENCE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHREFERENCE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACHREFERENCE


class ACH_SECURE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_SECURE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_SECURE.subclass:
            return ACH_SECURE.subclass(*args_, **kwargs_)
        else:
            return ACH_SECURE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_SECURE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_SECURE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_SECURE


class ACH_SEC_CODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_SEC_CODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_SEC_CODE.subclass:
            return ACH_SEC_CODE.subclass(*args_, **kwargs_)
        else:
            return ACH_SEC_CODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_SEC_CODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_SEC_CODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_SEC_CODE


class ACH_TERMINALID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_TERMINALID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_TERMINALID.subclass:
            return ACH_TERMINALID.subclass(*args_, **kwargs_)
        else:
            return ACH_TERMINALID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_TERMINALID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_TERMINALID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_TERMINALID


class ACH_CHECK_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_CHECK_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_CHECK_NUMBER.subclass:
            return ACH_CHECK_NUMBER.subclass(*args_, **kwargs_)
        else:
            return ACH_CHECK_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_CHECK_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_CHECK_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_CHECK_NUMBER


class ACH_NOTIFICATION_URL(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_NOTIFICATION_URL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_NOTIFICATION_URL.subclass:
            return ACH_NOTIFICATION_URL.subclass(*args_, **kwargs_)
        else:
            return ACH_NOTIFICATION_URL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_NOTIFICATION_URL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_NOTIFICATION_URL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ACH_NOTIFICATION_URL


class PERMITTEDTERMINALS(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 1, 1, {'ref': 'TERMINALID', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None):
        self.original_tagname_ = None
        if TERMINALID is None:
            self.TERMINALID = []
        else:
            self.TERMINALID = TERMINALID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMITTEDTERMINALS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMITTEDTERMINALS.subclass:
            return PERMITTEDTERMINALS.subclass(*args_, **kwargs_)
        else:
            return PERMITTEDTERMINALS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def add_TERMINALID(self, value): self.TERMINALID.append(value)
    def insert_TERMINALID_at(self, index, value): self.TERMINALID.insert(index, value)
    def replace_TERMINALID_at(self, index, value): self.TERMINALID[index] = value
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PERMITTEDTERMINALS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for TERMINALID_ in self.TERMINALID:
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PERMITTEDTERMINALS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TERMINALID=[\n')
        level += 1
        for TERMINALID_ in self.TERMINALID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(TERMINALID_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID.append(TERMINALID_)
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID[-1])
# end class PERMITTEDTERMINALS


class PERMITTEDTERMINALSREQUIRED(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMITTEDTERMINALSREQUIRED)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMITTEDTERMINALSREQUIRED.subclass:
            return PERMITTEDTERMINALSREQUIRED.subclass(*args_, **kwargs_)
        else:
            return PERMITTEDTERMINALSREQUIRED(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PERMITTEDTERMINALSREQUIRED', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PERMITTEDTERMINALSREQUIRED'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PERMITTEDTERMINALSREQUIRED


class ACHREINITIATION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, TERMINALID=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHREINITIATION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHREINITIATION.subclass:
            return ACHREINITIATION.subclass(*args_, **kwargs_)
        else:
            return ACHREINITIATION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHREINITIATION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHREINITIATION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ACHREINITIATION


class ACHREINITIATIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, RESPONSECODE=None, RESPONSETEXT=None, UNIQUEREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.UNIQUEREF = UNIQUEREF
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHREINITIATIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHREINITIATIONRESPONSE.subclass:
            return ACHREINITIATIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return ACHREINITIATIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.UNIQUEREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHREINITIATIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHREINITIATIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ACHREINITIATIONRESPONSE


class ACHSECUREREGISTRATION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_TYPE', ['ACCOUNT_TYPE', 'xs:string'], 0, 0, {'ref': 'ACCOUNT_TYPE', 'name': 'ACCOUNT_TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NUMBER', ['ACCOUNT_NUMBER', 'xs:string'], 0, 0, {'ref': 'ACCOUNT_NUMBER', 'name': 'ACCOUNT_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ROUTING_NUMBER', ['ROUTING_NUMBER', 'xs:string'], 0, 0, {'ref': 'ROUTING_NUMBER', 'name': 'ROUTING_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NAME', ['ACCOUNT_NAME', 'xs:string'], 0, 0, {'ref': 'ACCOUNT_NAME', 'name': 'ACCOUNT_NAME', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('IPADDRESS', ['IPADDRESS', 'xs:string'], 0, 1, {'ref': 'IPADDRESS', 'minOccurs': '0', 'name': 'IPADDRESS', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('DL_STATE', ['DL_STATE', 'xs:string'], 0, 1, {'ref': 'DL_STATE', 'minOccurs': '0', 'name': 'DL_STATE', 'type': 'xs:string'}, None),
        MemberSpec_('DL_NUMBER', ['DL_NUMBER', 'xs:string'], 0, 1, {'ref': 'DL_NUMBER', 'minOccurs': '0', 'name': 'DL_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('PERMITTEDTERMINALS', 'PERMITTEDTERMINALS', 0, 1, {'ref': 'PERMITTEDTERMINALS', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PERMITTEDTERMINALS', 'type': 'PERMITTEDTERMINALS'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, ACCOUNT_TYPE=None, ACCOUNT_NUMBER=None, ROUTING_NUMBER=None, ACCOUNT_NAME=None, ADDRESS1=None, ADDRESS2=None, CITY=None, REGION=None, POSTCODE=None, COUNTRY=None, PHONE=None, IPADDRESS=None, EMAIL=None, DL_STATE=None, DL_NUMBER=None, PERMITTEDTERMINALS=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.ACCOUNT_TYPE = ACCOUNT_TYPE
        self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
        self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        self.ROUTING_NUMBER = ROUTING_NUMBER
        self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        self.ACCOUNT_NAME = ACCOUNT_NAME
        self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.IPADDRESS = IPADDRESS
        self.validate_IPADDRESS(self.IPADDRESS)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.DL_STATE = DL_STATE
        self.validate_DL_STATE(self.DL_STATE)
        self.DL_NUMBER = DL_NUMBER
        self.validate_DL_NUMBER(self.DL_NUMBER)
        self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECUREREGISTRATION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECUREREGISTRATION.subclass:
            return ACHSECUREREGISTRATION.subclass(*args_, **kwargs_)
        else:
            return ACHSECUREREGISTRATION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_ACCOUNT_TYPE(self): return self.ACCOUNT_TYPE
    def set_ACCOUNT_TYPE(self, ACCOUNT_TYPE): self.ACCOUNT_TYPE = ACCOUNT_TYPE
    def get_ACCOUNT_NUMBER(self): return self.ACCOUNT_NUMBER
    def set_ACCOUNT_NUMBER(self, ACCOUNT_NUMBER): self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
    def get_ROUTING_NUMBER(self): return self.ROUTING_NUMBER
    def set_ROUTING_NUMBER(self, ROUTING_NUMBER): self.ROUTING_NUMBER = ROUTING_NUMBER
    def get_ACCOUNT_NAME(self): return self.ACCOUNT_NAME
    def set_ACCOUNT_NAME(self, ACCOUNT_NAME): self.ACCOUNT_NAME = ACCOUNT_NAME
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_IPADDRESS(self): return self.IPADDRESS
    def set_IPADDRESS(self, IPADDRESS): self.IPADDRESS = IPADDRESS
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_DL_STATE(self): return self.DL_STATE
    def set_DL_STATE(self, DL_STATE): self.DL_STATE = DL_STATE
    def get_DL_NUMBER(self): return self.DL_NUMBER
    def set_DL_NUMBER(self, DL_NUMBER): self.DL_NUMBER = DL_NUMBER
    def get_PERMITTEDTERMINALS(self): return self.PERMITTEDTERMINALS
    def set_PERMITTEDTERMINALS(self, PERMITTEDTERMINALS): self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_ACCOUNT_TYPE(self, value):
        # Validate type ACCOUNT_TYPE, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NUMBER(self, value):
        # Validate type ACCOUNT_NUMBER, a restriction on xs:string.
        pass
    def validate_ROUTING_NUMBER(self, value):
        # Validate type ROUTING_NUMBER, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NAME(self, value):
        # Validate type ACCOUNT_NAME, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_IPADDRESS(self, value):
        # Validate type IPADDRESS, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_DL_STATE(self, value):
        # Validate type DL_STATE, a restriction on xs:string.
        pass
    def validate_DL_NUMBER(self, value):
        # Validate type DL_NUMBER, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.ACCOUNT_TYPE is not None or
            self.ACCOUNT_NUMBER is not None or
            self.ROUTING_NUMBER is not None or
            self.ACCOUNT_NAME is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.POSTCODE is not None or
            self.COUNTRY is not None or
            self.PHONE is not None or
            self.IPADDRESS is not None or
            self.EMAIL is not None or
            self.DL_STATE is not None or
            self.DL_NUMBER is not None or
            self.PERMITTEDTERMINALS is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECUREREGISTRATION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.ACCOUNT_TYPE is not None:
            ACCOUNT_TYPE_ = self.ACCOUNT_TYPE
            etree_.SubElement(element, '{}ACCOUNT_TYPE').text = self.gds_format_string(ACCOUNT_TYPE_)
        if self.ACCOUNT_NUMBER is not None:
            ACCOUNT_NUMBER_ = self.ACCOUNT_NUMBER
            etree_.SubElement(element, '{}ACCOUNT_NUMBER').text = self.gds_format_string(ACCOUNT_NUMBER_)
        if self.ROUTING_NUMBER is not None:
            ROUTING_NUMBER_ = self.ROUTING_NUMBER
            etree_.SubElement(element, '{}ROUTING_NUMBER').text = self.gds_format_string(ROUTING_NUMBER_)
        if self.ACCOUNT_NAME is not None:
            ACCOUNT_NAME_ = self.ACCOUNT_NAME
            etree_.SubElement(element, '{}ACCOUNT_NAME').text = self.gds_format_string(ACCOUNT_NAME_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.IPADDRESS is not None:
            IPADDRESS_ = self.IPADDRESS
            etree_.SubElement(element, '{}IPADDRESS').text = self.gds_format_string(IPADDRESS_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.DL_STATE is not None:
            DL_STATE_ = self.DL_STATE
            etree_.SubElement(element, '{}DL_STATE').text = self.gds_format_string(DL_STATE_)
        if self.DL_NUMBER is not None:
            DL_NUMBER_ = self.DL_NUMBER
            etree_.SubElement(element, '{}DL_NUMBER').text = self.gds_format_string(DL_NUMBER_)
        if self.PERMITTEDTERMINALS is not None:
            PERMITTEDTERMINALS_ = self.PERMITTEDTERMINALS
            PERMITTEDTERMINALS_.to_etree(element, name_='PERMITTEDTERMINALS', mapping_=mapping_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECUREREGISTRATION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.ACCOUNT_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_TYPE=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_TYPE)))
        if self.ACCOUNT_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NUMBER)))
        if self.ROUTING_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ROUTING_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ROUTING_NUMBER)))
        if self.ACCOUNT_NAME is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NAME=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NAME)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.IPADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('IPADDRESS=%s,\n' % self.gds_encode(quote_python(self.IPADDRESS)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.DL_STATE is not None:
            showIndent(outfile, level)
            outfile.write('DL_STATE=%s,\n' % self.gds_encode(quote_python(self.DL_STATE)))
        if self.DL_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('DL_NUMBER=%s,\n' % self.gds_encode(quote_python(self.DL_NUMBER)))
        if self.PERMITTEDTERMINALS is not None:
            showIndent(outfile, level)
            outfile.write('PERMITTEDTERMINALS=model_.PERMITTEDTERMINALS(\n')
            self.PERMITTEDTERMINALS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'ACCOUNT_TYPE':
            ACCOUNT_TYPE_ = child_.text
            ACCOUNT_TYPE_ = self.gds_validate_string(ACCOUNT_TYPE_, node, 'ACCOUNT_TYPE')
            self.ACCOUNT_TYPE = ACCOUNT_TYPE_
            # validate type ACCOUNT_TYPE
            self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        elif nodeName_ == 'ACCOUNT_NUMBER':
            ACCOUNT_NUMBER_ = child_.text
            ACCOUNT_NUMBER_ = self.gds_validate_string(ACCOUNT_NUMBER_, node, 'ACCOUNT_NUMBER')
            self.ACCOUNT_NUMBER = ACCOUNT_NUMBER_
            # validate type ACCOUNT_NUMBER
            self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        elif nodeName_ == 'ROUTING_NUMBER':
            ROUTING_NUMBER_ = child_.text
            ROUTING_NUMBER_ = self.gds_validate_string(ROUTING_NUMBER_, node, 'ROUTING_NUMBER')
            self.ROUTING_NUMBER = ROUTING_NUMBER_
            # validate type ROUTING_NUMBER
            self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        elif nodeName_ == 'ACCOUNT_NAME':
            ACCOUNT_NAME_ = child_.text
            ACCOUNT_NAME_ = self.gds_validate_string(ACCOUNT_NAME_, node, 'ACCOUNT_NAME')
            self.ACCOUNT_NAME = ACCOUNT_NAME_
            # validate type ACCOUNT_NAME
            self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'IPADDRESS':
            IPADDRESS_ = child_.text
            IPADDRESS_ = self.gds_validate_string(IPADDRESS_, node, 'IPADDRESS')
            self.IPADDRESS = IPADDRESS_
            # validate type IPADDRESS
            self.validate_IPADDRESS(self.IPADDRESS)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'DL_STATE':
            DL_STATE_ = child_.text
            DL_STATE_ = self.gds_validate_string(DL_STATE_, node, 'DL_STATE')
            self.DL_STATE = DL_STATE_
            # validate type DL_STATE
            self.validate_DL_STATE(self.DL_STATE)
        elif nodeName_ == 'DL_NUMBER':
            DL_NUMBER_ = child_.text
            DL_NUMBER_ = self.gds_validate_string(DL_NUMBER_, node, 'DL_NUMBER')
            self.DL_NUMBER = DL_NUMBER_
            # validate type DL_NUMBER
            self.validate_DL_NUMBER(self.DL_NUMBER)
        elif nodeName_ == 'PERMITTEDTERMINALS':
            obj_ = PERMITTEDTERMINALS.factory()
            obj_.build(child_)
            self.PERMITTEDTERMINALS = obj_
            obj_.original_tagname_ = 'PERMITTEDTERMINALS'
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID]
        hash_list.append(self.MERCHANTREF)
        hash_list.append(self.DATETIME)
        hash_list.append(self.ACCOUNT_NUMBER)
        hash_list.append(self.ACCOUNT_NAME)
        hash_list.append(self.ACCOUNT_TYPE)
        hash_list.append(self.ROUTING_NUMBER)
        return ':'.join(hash_list)
# end class ACHSECUREREGISTRATION


class ACHSECUREREGISTRATIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ACHREFERENCE', ['ACHREFERENCE', 'xs:string'], 0, 0, {'ref': 'ACHREFERENCE', 'name': 'ACHREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, ACHREFERENCE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.ACHREFERENCE = ACHREFERENCE
        self.validate_ACHREFERENCE(self.ACHREFERENCE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECUREREGISTRATIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECUREREGISTRATIONRESPONSE.subclass:
            return ACHSECUREREGISTRATIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return ACHSECUREREGISTRATIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_ACHREFERENCE(self): return self.ACHREFERENCE
    def set_ACHREFERENCE(self, ACHREFERENCE): self.ACHREFERENCE = ACHREFERENCE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_ACHREFERENCE(self, value):
        # Validate type ACHREFERENCE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.ACHREFERENCE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECUREREGISTRATIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.ACHREFERENCE is not None:
            ACHREFERENCE_ = self.ACHREFERENCE
            etree_.SubElement(element, '{}ACHREFERENCE').text = self.gds_format_string(ACHREFERENCE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECUREREGISTRATIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.ACHREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('ACHREFERENCE=%s,\n' % self.gds_encode(quote_python(self.ACHREFERENCE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'ACHREFERENCE':
            ACHREFERENCE_ = child_.text
            ACHREFERENCE_ = self.gds_validate_string(ACHREFERENCE_, node, 'ACHREFERENCE')
            self.ACHREFERENCE = ACHREFERENCE_
            # validate type ACHREFERENCE
            self.validate_ACHREFERENCE(self.ACHREFERENCE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ACHSECUREREGISTRATIONRESPONSE


class ACHSECUREUPDATE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_TYPE', ['ACCOUNT_TYPE', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_TYPE', 'minOccurs': '0', 'name': 'ACCOUNT_TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NUMBER', ['ACCOUNT_NUMBER', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_NUMBER', 'minOccurs': '0', 'name': 'ACCOUNT_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ROUTING_NUMBER', ['ROUTING_NUMBER', 'xs:string'], 0, 1, {'ref': 'ROUTING_NUMBER', 'minOccurs': '0', 'name': 'ROUTING_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NAME', ['ACCOUNT_NAME', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_NAME', 'minOccurs': '0', 'name': 'ACCOUNT_NAME', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('IPADDRESS', ['IPADDRESS', 'xs:string'], 0, 1, {'ref': 'IPADDRESS', 'minOccurs': '0', 'name': 'IPADDRESS', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('DL_STATE', ['DL_STATE', 'xs:string'], 0, 1, {'ref': 'DL_STATE', 'minOccurs': '0', 'name': 'DL_STATE', 'type': 'xs:string'}, None),
        MemberSpec_('DL_NUMBER', ['DL_NUMBER', 'xs:string'], 0, 1, {'ref': 'DL_NUMBER', 'minOccurs': '0', 'name': 'DL_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('PERMITTEDTERMINALS', 'PERMITTEDTERMINALS', 0, 1, {'ref': 'PERMITTEDTERMINALS', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PERMITTEDTERMINALS', 'type': 'PERMITTEDTERMINALS'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, ACCOUNT_TYPE=None, ACCOUNT_NUMBER=None, ROUTING_NUMBER=None, ACCOUNT_NAME=None, ADDRESS1=None, ADDRESS2=None, CITY=None, REGION=None, POSTCODE=None, COUNTRY=None, PHONE=None, IPADDRESS=None, EMAIL=None, DL_STATE=None, DL_NUMBER=None, PERMITTEDTERMINALS=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.ACCOUNT_TYPE = ACCOUNT_TYPE
        self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
        self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        self.ROUTING_NUMBER = ROUTING_NUMBER
        self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        self.ACCOUNT_NAME = ACCOUNT_NAME
        self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.IPADDRESS = IPADDRESS
        self.validate_IPADDRESS(self.IPADDRESS)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.DL_STATE = DL_STATE
        self.validate_DL_STATE(self.DL_STATE)
        self.DL_NUMBER = DL_NUMBER
        self.validate_DL_NUMBER(self.DL_NUMBER)
        self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECUREUPDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECUREUPDATE.subclass:
            return ACHSECUREUPDATE.subclass(*args_, **kwargs_)
        else:
            return ACHSECUREUPDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_ACCOUNT_TYPE(self): return self.ACCOUNT_TYPE
    def set_ACCOUNT_TYPE(self, ACCOUNT_TYPE): self.ACCOUNT_TYPE = ACCOUNT_TYPE
    def get_ACCOUNT_NUMBER(self): return self.ACCOUNT_NUMBER
    def set_ACCOUNT_NUMBER(self, ACCOUNT_NUMBER): self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
    def get_ROUTING_NUMBER(self): return self.ROUTING_NUMBER
    def set_ROUTING_NUMBER(self, ROUTING_NUMBER): self.ROUTING_NUMBER = ROUTING_NUMBER
    def get_ACCOUNT_NAME(self): return self.ACCOUNT_NAME
    def set_ACCOUNT_NAME(self, ACCOUNT_NAME): self.ACCOUNT_NAME = ACCOUNT_NAME
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_IPADDRESS(self): return self.IPADDRESS
    def set_IPADDRESS(self, IPADDRESS): self.IPADDRESS = IPADDRESS
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_DL_STATE(self): return self.DL_STATE
    def set_DL_STATE(self, DL_STATE): self.DL_STATE = DL_STATE
    def get_DL_NUMBER(self): return self.DL_NUMBER
    def set_DL_NUMBER(self, DL_NUMBER): self.DL_NUMBER = DL_NUMBER
    def get_PERMITTEDTERMINALS(self): return self.PERMITTEDTERMINALS
    def set_PERMITTEDTERMINALS(self, PERMITTEDTERMINALS): self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_ACCOUNT_TYPE(self, value):
        # Validate type ACCOUNT_TYPE, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NUMBER(self, value):
        # Validate type ACCOUNT_NUMBER, a restriction on xs:string.
        pass
    def validate_ROUTING_NUMBER(self, value):
        # Validate type ROUTING_NUMBER, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NAME(self, value):
        # Validate type ACCOUNT_NAME, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_IPADDRESS(self, value):
        # Validate type IPADDRESS, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_DL_STATE(self, value):
        # Validate type DL_STATE, a restriction on xs:string.
        pass
    def validate_DL_NUMBER(self, value):
        # Validate type DL_NUMBER, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.ACCOUNT_TYPE is not None or
            self.ACCOUNT_NUMBER is not None or
            self.ROUTING_NUMBER is not None or
            self.ACCOUNT_NAME is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.POSTCODE is not None or
            self.COUNTRY is not None or
            self.PHONE is not None or
            self.IPADDRESS is not None or
            self.EMAIL is not None or
            self.DL_STATE is not None or
            self.DL_NUMBER is not None or
            self.PERMITTEDTERMINALS is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECUREUPDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.ACCOUNT_TYPE is not None:
            ACCOUNT_TYPE_ = self.ACCOUNT_TYPE
            etree_.SubElement(element, '{}ACCOUNT_TYPE').text = self.gds_format_string(ACCOUNT_TYPE_)
        if self.ACCOUNT_NUMBER is not None:
            ACCOUNT_NUMBER_ = self.ACCOUNT_NUMBER
            etree_.SubElement(element, '{}ACCOUNT_NUMBER').text = self.gds_format_string(ACCOUNT_NUMBER_)
        if self.ROUTING_NUMBER is not None:
            ROUTING_NUMBER_ = self.ROUTING_NUMBER
            etree_.SubElement(element, '{}ROUTING_NUMBER').text = self.gds_format_string(ROUTING_NUMBER_)
        if self.ACCOUNT_NAME is not None:
            ACCOUNT_NAME_ = self.ACCOUNT_NAME
            etree_.SubElement(element, '{}ACCOUNT_NAME').text = self.gds_format_string(ACCOUNT_NAME_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.IPADDRESS is not None:
            IPADDRESS_ = self.IPADDRESS
            etree_.SubElement(element, '{}IPADDRESS').text = self.gds_format_string(IPADDRESS_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.DL_STATE is not None:
            DL_STATE_ = self.DL_STATE
            etree_.SubElement(element, '{}DL_STATE').text = self.gds_format_string(DL_STATE_)
        if self.DL_NUMBER is not None:
            DL_NUMBER_ = self.DL_NUMBER
            etree_.SubElement(element, '{}DL_NUMBER').text = self.gds_format_string(DL_NUMBER_)
        if self.PERMITTEDTERMINALS is not None:
            PERMITTEDTERMINALS_ = self.PERMITTEDTERMINALS
            PERMITTEDTERMINALS_.to_etree(element, name_='PERMITTEDTERMINALS', mapping_=mapping_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECUREUPDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.ACCOUNT_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_TYPE=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_TYPE)))
        if self.ACCOUNT_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NUMBER)))
        if self.ROUTING_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ROUTING_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ROUTING_NUMBER)))
        if self.ACCOUNT_NAME is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NAME=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NAME)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.IPADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('IPADDRESS=%s,\n' % self.gds_encode(quote_python(self.IPADDRESS)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.DL_STATE is not None:
            showIndent(outfile, level)
            outfile.write('DL_STATE=%s,\n' % self.gds_encode(quote_python(self.DL_STATE)))
        if self.DL_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('DL_NUMBER=%s,\n' % self.gds_encode(quote_python(self.DL_NUMBER)))
        if self.PERMITTEDTERMINALS is not None:
            showIndent(outfile, level)
            outfile.write('PERMITTEDTERMINALS=model_.PERMITTEDTERMINALS(\n')
            self.PERMITTEDTERMINALS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'ACCOUNT_TYPE':
            ACCOUNT_TYPE_ = child_.text
            ACCOUNT_TYPE_ = self.gds_validate_string(ACCOUNT_TYPE_, node, 'ACCOUNT_TYPE')
            self.ACCOUNT_TYPE = ACCOUNT_TYPE_
            # validate type ACCOUNT_TYPE
            self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        elif nodeName_ == 'ACCOUNT_NUMBER':
            ACCOUNT_NUMBER_ = child_.text
            ACCOUNT_NUMBER_ = self.gds_validate_string(ACCOUNT_NUMBER_, node, 'ACCOUNT_NUMBER')
            self.ACCOUNT_NUMBER = ACCOUNT_NUMBER_
            # validate type ACCOUNT_NUMBER
            self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        elif nodeName_ == 'ROUTING_NUMBER':
            ROUTING_NUMBER_ = child_.text
            ROUTING_NUMBER_ = self.gds_validate_string(ROUTING_NUMBER_, node, 'ROUTING_NUMBER')
            self.ROUTING_NUMBER = ROUTING_NUMBER_
            # validate type ROUTING_NUMBER
            self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        elif nodeName_ == 'ACCOUNT_NAME':
            ACCOUNT_NAME_ = child_.text
            ACCOUNT_NAME_ = self.gds_validate_string(ACCOUNT_NAME_, node, 'ACCOUNT_NAME')
            self.ACCOUNT_NAME = ACCOUNT_NAME_
            # validate type ACCOUNT_NAME
            self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'IPADDRESS':
            IPADDRESS_ = child_.text
            IPADDRESS_ = self.gds_validate_string(IPADDRESS_, node, 'IPADDRESS')
            self.IPADDRESS = IPADDRESS_
            # validate type IPADDRESS
            self.validate_IPADDRESS(self.IPADDRESS)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'DL_STATE':
            DL_STATE_ = child_.text
            DL_STATE_ = self.gds_validate_string(DL_STATE_, node, 'DL_STATE')
            self.DL_STATE = DL_STATE_
            # validate type DL_STATE
            self.validate_DL_STATE(self.DL_STATE)
        elif nodeName_ == 'DL_NUMBER':
            DL_NUMBER_ = child_.text
            DL_NUMBER_ = self.gds_validate_string(DL_NUMBER_, node, 'DL_NUMBER')
            self.DL_NUMBER = DL_NUMBER_
            # validate type DL_NUMBER
            self.validate_DL_NUMBER(self.DL_NUMBER)
        elif nodeName_ == 'PERMITTEDTERMINALS':
            obj_ = PERMITTEDTERMINALS.factory()
            obj_.build(child_)
            self.PERMITTEDTERMINALS = obj_
            obj_.original_tagname_ = 'PERMITTEDTERMINALS'
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ACHSECUREUPDATE


class ACHSECUREUPDATERESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ACHREFERENCE', ['ACHREFERENCE', 'xs:string'], 0, 0, {'ref': 'ACHREFERENCE', 'name': 'ACHREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, ACHREFERENCE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.ACHREFERENCE = ACHREFERENCE
        self.validate_ACHREFERENCE(self.ACHREFERENCE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECUREUPDATERESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECUREUPDATERESPONSE.subclass:
            return ACHSECUREUPDATERESPONSE.subclass(*args_, **kwargs_)
        else:
            return ACHSECUREUPDATERESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_ACHREFERENCE(self): return self.ACHREFERENCE
    def set_ACHREFERENCE(self, ACHREFERENCE): self.ACHREFERENCE = ACHREFERENCE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_ACHREFERENCE(self, value):
        # Validate type ACHREFERENCE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.ACHREFERENCE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECUREUPDATERESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.ACHREFERENCE is not None:
            ACHREFERENCE_ = self.ACHREFERENCE
            etree_.SubElement(element, '{}ACHREFERENCE').text = self.gds_format_string(ACHREFERENCE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECUREUPDATERESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.ACHREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('ACHREFERENCE=%s,\n' % self.gds_encode(quote_python(self.ACHREFERENCE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'ACHREFERENCE':
            ACHREFERENCE_ = child_.text
            ACHREFERENCE_ = self.gds_validate_string(ACHREFERENCE_, node, 'ACHREFERENCE')
            self.ACHREFERENCE = ACHREFERENCE_
            # validate type ACHREFERENCE
            self.validate_ACHREFERENCE(self.ACHREFERENCE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ACHSECUREUPDATERESPONSE


class ACHSECUREREMOVAL(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ACHREFERENCE', ['ACHREFERENCE', 'xs:string'], 0, 0, {'ref': 'ACHREFERENCE', 'name': 'ACHREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, ACHREFERENCE=None, TERMINALID=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.ACHREFERENCE = ACHREFERENCE
        self.validate_ACHREFERENCE(self.ACHREFERENCE)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECUREREMOVAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECUREREMOVAL.subclass:
            return ACHSECUREREMOVAL.subclass(*args_, **kwargs_)
        else:
            return ACHSECUREREMOVAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_ACHREFERENCE(self): return self.ACHREFERENCE
    def set_ACHREFERENCE(self, ACHREFERENCE): self.ACHREFERENCE = ACHREFERENCE
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_ACHREFERENCE(self, value):
        # Validate type ACHREFERENCE, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.ACHREFERENCE is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECUREREMOVAL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.ACHREFERENCE is not None:
            ACHREFERENCE_ = self.ACHREFERENCE
            etree_.SubElement(element, '{}ACHREFERENCE').text = self.gds_format_string(ACHREFERENCE_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECUREREMOVAL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.ACHREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('ACHREFERENCE=%s,\n' % self.gds_encode(quote_python(self.ACHREFERENCE)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'ACHREFERENCE':
            ACHREFERENCE_ = child_.text
            ACHREFERENCE_ = self.gds_validate_string(ACHREFERENCE_, node, 'ACHREFERENCE')
            self.ACHREFERENCE = ACHREFERENCE_
            # validate type ACHREFERENCE
            self.validate_ACHREFERENCE(self.ACHREFERENCE)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ACHSECUREREMOVAL


class ACHSECUREREMOVALRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECUREREMOVALRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECUREREMOVALRESPONSE.subclass:
            return ACHSECUREREMOVALRESPONSE.subclass(*args_, **kwargs_)
        else:
            return ACHSECUREREMOVALRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECUREREMOVALRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECUREREMOVALRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ACHSECUREREMOVALRESPONSE


class ACHSECURESEARCH(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('PERMITTEDTERMINALSREQUIRED', ['PERMITTEDTERMINALSREQUIRED', 'xs:string'], 0, 1, {'ref': 'PERMITTEDTERMINALSREQUIRED', 'minOccurs': '0', 'name': 'PERMITTEDTERMINALSREQUIRED', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, PERMITTEDTERMINALSREQUIRED=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.PERMITTEDTERMINALSREQUIRED = PERMITTEDTERMINALSREQUIRED
        self.validate_PERMITTEDTERMINALSREQUIRED(self.PERMITTEDTERMINALSREQUIRED)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECURESEARCH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECURESEARCH.subclass:
            return ACHSECURESEARCH.subclass(*args_, **kwargs_)
        else:
            return ACHSECURESEARCH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_PERMITTEDTERMINALSREQUIRED(self): return self.PERMITTEDTERMINALSREQUIRED
    def set_PERMITTEDTERMINALSREQUIRED(self, PERMITTEDTERMINALSREQUIRED): self.PERMITTEDTERMINALSREQUIRED = PERMITTEDTERMINALSREQUIRED
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_PERMITTEDTERMINALSREQUIRED(self, value):
        # Validate type PERMITTEDTERMINALSREQUIRED, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.PERMITTEDTERMINALSREQUIRED is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECURESEARCH', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.PERMITTEDTERMINALSREQUIRED is not None:
            PERMITTEDTERMINALSREQUIRED_ = self.PERMITTEDTERMINALSREQUIRED
            etree_.SubElement(element, '{}PERMITTEDTERMINALSREQUIRED').text = self.gds_format_string(PERMITTEDTERMINALSREQUIRED_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECURESEARCH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.PERMITTEDTERMINALSREQUIRED is not None:
            showIndent(outfile, level)
            outfile.write('PERMITTEDTERMINALSREQUIRED=%s,\n' % self.gds_encode(quote_python(self.PERMITTEDTERMINALSREQUIRED)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'PERMITTEDTERMINALSREQUIRED':
            PERMITTEDTERMINALSREQUIRED_ = child_.text
            PERMITTEDTERMINALSREQUIRED_ = self.gds_validate_string(PERMITTEDTERMINALSREQUIRED_, node, 'PERMITTEDTERMINALSREQUIRED')
            self.PERMITTEDTERMINALSREQUIRED = PERMITTEDTERMINALSREQUIRED_
            # validate type PERMITTEDTERMINALSREQUIRED
            self.validate_PERMITTEDTERMINALSREQUIRED(self.PERMITTEDTERMINALSREQUIRED)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ACHSECURESEARCH


class ACHSECURESEARCHRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ACHREFERENCE', ['ACHREFERENCE', 'xs:string'], 0, 0, {'ref': 'ACHREFERENCE', 'name': 'ACHREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NAME', ['ACCOUNT_NAME', 'xs:string'], 0, 0, {'ref': 'ACCOUNT_NAME', 'name': 'ACCOUNT_NAME', 'type': 'xs:string'}, None),
        MemberSpec_('PERMITTEDTERMINALS', 'PERMITTEDTERMINALS', 0, 1, {'ref': 'PERMITTEDTERMINALS', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PERMITTEDTERMINALS', 'type': 'PERMITTEDTERMINALS'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, ACHREFERENCE=None, ACCOUNT_NAME=None, PERMITTEDTERMINALS=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.ACHREFERENCE = ACHREFERENCE
        self.validate_ACHREFERENCE(self.ACHREFERENCE)
        self.ACCOUNT_NAME = ACCOUNT_NAME
        self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECURESEARCHRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECURESEARCHRESPONSE.subclass:
            return ACHSECURESEARCHRESPONSE.subclass(*args_, **kwargs_)
        else:
            return ACHSECURESEARCHRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_ACHREFERENCE(self): return self.ACHREFERENCE
    def set_ACHREFERENCE(self, ACHREFERENCE): self.ACHREFERENCE = ACHREFERENCE
    def get_ACCOUNT_NAME(self): return self.ACCOUNT_NAME
    def set_ACCOUNT_NAME(self, ACCOUNT_NAME): self.ACCOUNT_NAME = ACCOUNT_NAME
    def get_PERMITTEDTERMINALS(self): return self.PERMITTEDTERMINALS
    def set_PERMITTEDTERMINALS(self, PERMITTEDTERMINALS): self.PERMITTEDTERMINALS = PERMITTEDTERMINALS
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_ACHREFERENCE(self, value):
        # Validate type ACHREFERENCE, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NAME(self, value):
        # Validate type ACCOUNT_NAME, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.ACHREFERENCE is not None or
            self.ACCOUNT_NAME is not None or
            self.PERMITTEDTERMINALS is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECURESEARCHRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.ACHREFERENCE is not None:
            ACHREFERENCE_ = self.ACHREFERENCE
            etree_.SubElement(element, '{}ACHREFERENCE').text = self.gds_format_string(ACHREFERENCE_)
        if self.ACCOUNT_NAME is not None:
            ACCOUNT_NAME_ = self.ACCOUNT_NAME
            etree_.SubElement(element, '{}ACCOUNT_NAME').text = self.gds_format_string(ACCOUNT_NAME_)
        if self.PERMITTEDTERMINALS is not None:
            PERMITTEDTERMINALS_ = self.PERMITTEDTERMINALS
            PERMITTEDTERMINALS_.to_etree(element, name_='PERMITTEDTERMINALS', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECURESEARCHRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.ACHREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('ACHREFERENCE=%s,\n' % self.gds_encode(quote_python(self.ACHREFERENCE)))
        if self.ACCOUNT_NAME is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NAME=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NAME)))
        if self.PERMITTEDTERMINALS is not None:
            showIndent(outfile, level)
            outfile.write('PERMITTEDTERMINALS=model_.PERMITTEDTERMINALS(\n')
            self.PERMITTEDTERMINALS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'ACHREFERENCE':
            ACHREFERENCE_ = child_.text
            ACHREFERENCE_ = self.gds_validate_string(ACHREFERENCE_, node, 'ACHREFERENCE')
            self.ACHREFERENCE = ACHREFERENCE_
            # validate type ACHREFERENCE
            self.validate_ACHREFERENCE(self.ACHREFERENCE)
        elif nodeName_ == 'ACCOUNT_NAME':
            ACCOUNT_NAME_ = child_.text
            ACCOUNT_NAME_ = self.gds_validate_string(ACCOUNT_NAME_, node, 'ACCOUNT_NAME')
            self.ACCOUNT_NAME = ACCOUNT_NAME_
            # validate type ACCOUNT_NAME
            self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        elif nodeName_ == 'PERMITTEDTERMINALS':
            obj_ = PERMITTEDTERMINALS.factory()
            obj_.build(child_)
            self.PERMITTEDTERMINALS = obj_
            obj_.original_tagname_ = 'PERMITTEDTERMINALS'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ACHSECURESEARCHRESPONSE


class ADD_ACH_SUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('STOREDSUBSCRIPTIONREF', ['STOREDSUBSCRIPTIONREF', 'xs:string'], 0, 1, {'ref': 'STOREDSUBSCRIPTIONREF', 'minOccurs': '0', 'name': 'STOREDSUBSCRIPTIONREF', 'type': 'xs:string'}, None),
        MemberSpec_('SECUREACHACCOUNTMERCHANTREF', ['SECUREACHACCOUNTMERCHANTREF', 'xs:string'], 0, 1, {'ref': 'SECUREACHACCOUNTMERCHANTREF', 'minOccurs': '0', 'name': 'SECUREACHACCOUNTMERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ACHREFERENCE', ['ACHREFERENCE', 'xs:string'], 0, 1, {'ref': 'ACHREFERENCE', 'minOccurs': '0', 'name': 'ACHREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('SEC_CODE', ['SEC_CODE', 'xs:string'], 0, 0, {'ref': 'SEC_CODE', 'name': 'SEC_CODE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('INITIALAMOUNT', 'xs:double', 0, 1, {'ref': 'INITIALAMOUNT', 'minOccurs': '0', 'name': 'INITIALAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('STARTDATE', ['STARTDATE', 'xs:string'], 0, 0, {'ref': 'STARTDATE', 'name': 'STARTDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ENDDATE', ['ENDDATE', 'xs:string'], 0, 1, {'ref': 'ENDDATE', 'minOccurs': '0', 'name': 'ENDDATE', 'type': 'xs:string'}, None),
        MemberSpec_('NEWSTOREDSUBSCRIPTIONINFO', 'NEWSTOREDSUBSCRIPTIONINFO', 0, 1, {'ref': 'NEWSTOREDSUBSCRIPTIONINFO', 'minOccurs': '0', 'name': 'NEWSTOREDSUBSCRIPTIONINFO', 'type': 'NEWSTOREDSUBSCRIPTIONINFO'}, None),
        MemberSpec_('NOTIFICATIONLANGUAGE', ['NOTIFICATIONLANGUAGE', 'xs:string'], 0, 1, {'ref': 'NOTIFICATIONLANGUAGE', 'minOccurs': '0', 'name': 'NOTIFICATIONLANGUAGE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, STOREDSUBSCRIPTIONREF=None, SECUREACHACCOUNTMERCHANTREF=None, ACHREFERENCE=None, SEC_CODE=None, DATETIME=None, RECURRINGAMOUNT=None, INITIALAMOUNT=None, STARTDATE=None, ENDDATE=None, NEWSTOREDSUBSCRIPTIONINFO=None, NOTIFICATIONLANGUAGE=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF
        self.validate_STOREDSUBSCRIPTIONREF(self.STOREDSUBSCRIPTIONREF)
        self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF
        self.validate_SECUREACHACCOUNTMERCHANTREF(self.SECUREACHACCOUNTMERCHANTREF)
        self.ACHREFERENCE = ACHREFERENCE
        self.validate_ACHREFERENCE(self.ACHREFERENCE)
        self.SEC_CODE = SEC_CODE
        self.validate_SEC_CODE(self.SEC_CODE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.INITIALAMOUNT = INITIALAMOUNT
        self.STARTDATE = STARTDATE
        self.validate_STARTDATE(self.STARTDATE)
        self.ENDDATE = ENDDATE
        self.validate_ENDDATE(self.ENDDATE)
        self.NEWSTOREDSUBSCRIPTIONINFO = NEWSTOREDSUBSCRIPTIONINFO
        self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
        self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADD_ACH_SUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADD_ACH_SUBSCRIPTION.subclass:
            return ADD_ACH_SUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return ADD_ACH_SUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_STOREDSUBSCRIPTIONREF(self): return self.STOREDSUBSCRIPTIONREF
    def set_STOREDSUBSCRIPTIONREF(self, STOREDSUBSCRIPTIONREF): self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF
    def get_SECUREACHACCOUNTMERCHANTREF(self): return self.SECUREACHACCOUNTMERCHANTREF
    def set_SECUREACHACCOUNTMERCHANTREF(self, SECUREACHACCOUNTMERCHANTREF): self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF
    def get_ACHREFERENCE(self): return self.ACHREFERENCE
    def set_ACHREFERENCE(self, ACHREFERENCE): self.ACHREFERENCE = ACHREFERENCE
    def get_SEC_CODE(self): return self.SEC_CODE
    def set_SEC_CODE(self, SEC_CODE): self.SEC_CODE = SEC_CODE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_INITIALAMOUNT(self): return self.INITIALAMOUNT
    def set_INITIALAMOUNT(self, INITIALAMOUNT): self.INITIALAMOUNT = INITIALAMOUNT
    def get_STARTDATE(self): return self.STARTDATE
    def set_STARTDATE(self, STARTDATE): self.STARTDATE = STARTDATE
    def get_ENDDATE(self): return self.ENDDATE
    def set_ENDDATE(self, ENDDATE): self.ENDDATE = ENDDATE
    def get_NEWSTOREDSUBSCRIPTIONINFO(self): return self.NEWSTOREDSUBSCRIPTIONINFO
    def set_NEWSTOREDSUBSCRIPTIONINFO(self, NEWSTOREDSUBSCRIPTIONINFO): self.NEWSTOREDSUBSCRIPTIONINFO = NEWSTOREDSUBSCRIPTIONINFO
    def get_NOTIFICATIONLANGUAGE(self): return self.NOTIFICATIONLANGUAGE
    def set_NOTIFICATIONLANGUAGE(self, NOTIFICATIONLANGUAGE): self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_STOREDSUBSCRIPTIONREF(self, value):
        # Validate type STOREDSUBSCRIPTIONREF, a restriction on xs:string.
        pass
    def validate_SECUREACHACCOUNTMERCHANTREF(self, value):
        # Validate type SECUREACHACCOUNTMERCHANTREF, a restriction on xs:string.
        pass
    def validate_ACHREFERENCE(self, value):
        # Validate type ACHREFERENCE, a restriction on xs:string.
        pass
    def validate_SEC_CODE(self, value):
        # Validate type SEC_CODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_STARTDATE(self, value):
        # Validate type STARTDATE, a restriction on xs:string.
        pass
    def validate_ENDDATE(self, value):
        # Validate type ENDDATE, a restriction on xs:string.
        pass
    def validate_NOTIFICATIONLANGUAGE(self, value):
        # Validate type NOTIFICATIONLANGUAGE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.STOREDSUBSCRIPTIONREF is not None or
            self.SECUREACHACCOUNTMERCHANTREF is not None or
            self.ACHREFERENCE is not None or
            self.SEC_CODE is not None or
            self.DATETIME is not None or
            self.RECURRINGAMOUNT is not None or
            self.INITIALAMOUNT is not None or
            self.STARTDATE is not None or
            self.ENDDATE is not None or
            self.NEWSTOREDSUBSCRIPTIONINFO is not None or
            self.NOTIFICATIONLANGUAGE is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADD_ACH_SUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.STOREDSUBSCRIPTIONREF is not None:
            STOREDSUBSCRIPTIONREF_ = self.STOREDSUBSCRIPTIONREF
            etree_.SubElement(element, '{}STOREDSUBSCRIPTIONREF').text = self.gds_format_string(STOREDSUBSCRIPTIONREF_)
        if self.SECUREACHACCOUNTMERCHANTREF is not None:
            SECUREACHACCOUNTMERCHANTREF_ = self.SECUREACHACCOUNTMERCHANTREF
            etree_.SubElement(element, '{}SECUREACHACCOUNTMERCHANTREF').text = self.gds_format_string(SECUREACHACCOUNTMERCHANTREF_)
        if self.ACHREFERENCE is not None:
            ACHREFERENCE_ = self.ACHREFERENCE
            etree_.SubElement(element, '{}ACHREFERENCE').text = self.gds_format_string(ACHREFERENCE_)
        if self.SEC_CODE is not None:
            SEC_CODE_ = self.SEC_CODE
            etree_.SubElement(element, '{}SEC_CODE').text = self.gds_format_string(SEC_CODE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.INITIALAMOUNT is not None:
            INITIALAMOUNT_ = self.INITIALAMOUNT
            etree_.SubElement(element, '{}INITIALAMOUNT').text = self.gds_format_double(INITIALAMOUNT_)
        if self.STARTDATE is not None:
            STARTDATE_ = self.STARTDATE
            etree_.SubElement(element, '{}STARTDATE').text = self.gds_format_string(STARTDATE_)
        if self.ENDDATE is not None:
            ENDDATE_ = self.ENDDATE
            etree_.SubElement(element, '{}ENDDATE').text = self.gds_format_string(ENDDATE_)
        if self.NEWSTOREDSUBSCRIPTIONINFO is not None:
            NEWSTOREDSUBSCRIPTIONINFO_ = self.NEWSTOREDSUBSCRIPTIONINFO
            NEWSTOREDSUBSCRIPTIONINFO_.to_etree(element, name_='NEWSTOREDSUBSCRIPTIONINFO', mapping_=mapping_)
        if self.NOTIFICATIONLANGUAGE is not None:
            NOTIFICATIONLANGUAGE_ = self.NOTIFICATIONLANGUAGE
            etree_.SubElement(element, '{}NOTIFICATIONLANGUAGE').text = self.gds_format_string(NOTIFICATIONLANGUAGE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADD_ACH_SUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.STOREDSUBSCRIPTIONREF is not None:
            showIndent(outfile, level)
            outfile.write('STOREDSUBSCRIPTIONREF=%s,\n' % self.gds_encode(quote_python(self.STOREDSUBSCRIPTIONREF)))
        if self.SECUREACHACCOUNTMERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('SECUREACHACCOUNTMERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.SECUREACHACCOUNTMERCHANTREF)))
        if self.ACHREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('ACHREFERENCE=%s,\n' % self.gds_encode(quote_python(self.ACHREFERENCE)))
        if self.SEC_CODE is not None:
            showIndent(outfile, level)
            outfile.write('SEC_CODE=%s,\n' % self.gds_encode(quote_python(self.SEC_CODE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.INITIALAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('INITIALAMOUNT=%e,\n' % self.INITIALAMOUNT)
        if self.STARTDATE is not None:
            showIndent(outfile, level)
            outfile.write('STARTDATE=%s,\n' % self.gds_encode(quote_python(self.STARTDATE)))
        if self.ENDDATE is not None:
            showIndent(outfile, level)
            outfile.write('ENDDATE=%s,\n' % self.gds_encode(quote_python(self.ENDDATE)))
        if self.NEWSTOREDSUBSCRIPTIONINFO is not None:
            showIndent(outfile, level)
            outfile.write('NEWSTOREDSUBSCRIPTIONINFO=model_.NEWSTOREDSUBSCRIPTIONINFO(\n')
            self.NEWSTOREDSUBSCRIPTIONINFO.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NOTIFICATIONLANGUAGE is not None:
            showIndent(outfile, level)
            outfile.write('NOTIFICATIONLANGUAGE=%s,\n' % self.gds_encode(quote_python(self.NOTIFICATIONLANGUAGE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'STOREDSUBSCRIPTIONREF':
            STOREDSUBSCRIPTIONREF_ = child_.text
            STOREDSUBSCRIPTIONREF_ = self.gds_validate_string(STOREDSUBSCRIPTIONREF_, node, 'STOREDSUBSCRIPTIONREF')
            self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF_
            # validate type STOREDSUBSCRIPTIONREF
            self.validate_STOREDSUBSCRIPTIONREF(self.STOREDSUBSCRIPTIONREF)
        elif nodeName_ == 'SECUREACHACCOUNTMERCHANTREF':
            SECUREACHACCOUNTMERCHANTREF_ = child_.text
            SECUREACHACCOUNTMERCHANTREF_ = self.gds_validate_string(SECUREACHACCOUNTMERCHANTREF_, node, 'SECUREACHACCOUNTMERCHANTREF')
            self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF_
            # validate type SECUREACHACCOUNTMERCHANTREF
            self.validate_SECUREACHACCOUNTMERCHANTREF(self.SECUREACHACCOUNTMERCHANTREF)
        elif nodeName_ == 'ACHREFERENCE':
            ACHREFERENCE_ = child_.text
            ACHREFERENCE_ = self.gds_validate_string(ACHREFERENCE_, node, 'ACHREFERENCE')
            self.ACHREFERENCE = ACHREFERENCE_
            # validate type ACHREFERENCE
            self.validate_ACHREFERENCE(self.ACHREFERENCE)
        elif nodeName_ == 'SEC_CODE':
            SEC_CODE_ = child_.text
            SEC_CODE_ = self.gds_validate_string(SEC_CODE_, node, 'SEC_CODE')
            self.SEC_CODE = SEC_CODE_
            # validate type SEC_CODE
            self.validate_SEC_CODE(self.SEC_CODE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'INITIALAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'INITIALAMOUNT')
            self.INITIALAMOUNT = fval_
        elif nodeName_ == 'STARTDATE':
            STARTDATE_ = child_.text
            STARTDATE_ = self.gds_validate_string(STARTDATE_, node, 'STARTDATE')
            self.STARTDATE = STARTDATE_
            # validate type STARTDATE
            self.validate_STARTDATE(self.STARTDATE)
        elif nodeName_ == 'ENDDATE':
            ENDDATE_ = child_.text
            ENDDATE_ = self.gds_validate_string(ENDDATE_, node, 'ENDDATE')
            self.ENDDATE = ENDDATE_
            # validate type ENDDATE
            self.validate_ENDDATE(self.ENDDATE)
        elif nodeName_ == 'NEWSTOREDSUBSCRIPTIONINFO':
            obj_ = NEWSTOREDSUBSCRIPTIONINFO.factory()
            obj_.build(child_)
            self.NEWSTOREDSUBSCRIPTIONINFO = obj_
            obj_.original_tagname_ = 'NEWSTOREDSUBSCRIPTIONINFO'
        elif nodeName_ == 'NOTIFICATIONLANGUAGE':
            NOTIFICATIONLANGUAGE_ = child_.text
            NOTIFICATIONLANGUAGE_ = self.gds_validate_string(NOTIFICATIONLANGUAGE_, node, 'NOTIFICATIONLANGUAGE')
            self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE_
            # validate type NOTIFICATIONLANGUAGE
            self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ADD_ACH_SUBSCRIPTION


class ADD_ACH_SUBSCRIPTION_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADD_ACH_SUBSCRIPTION_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADD_ACH_SUBSCRIPTION_RESPONSE.subclass:
            return ADD_ACH_SUBSCRIPTION_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return ADD_ACH_SUBSCRIPTION_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADD_ACH_SUBSCRIPTION_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADD_ACH_SUBSCRIPTION_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ADD_ACH_SUBSCRIPTION_RESPONSE


class UPDATE_ACH_SUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('SECUREACHACCOUNTMERCHANTREF', ['SECUREACHACCOUNTMERCHANTREF', 'xs:string'], 0, 1, {'ref': 'SECUREACHACCOUNTMERCHANTREF', 'minOccurs': '0', 'name': 'SECUREACHACCOUNTMERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ACHREFERENCE', ['ACHREFERENCE', 'xs:string'], 0, 1, {'ref': 'ACHREFERENCE', 'minOccurs': '0', 'name': 'ACHREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('SEC_CODE', ['SEC_CODE', 'xs:string'], 0, 1, {'ref': 'SEC_CODE', 'minOccurs': '0', 'name': 'SEC_CODE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('NAME', ['NAME', 'xs:string'], 0, 1, {'ref': 'NAME', 'minOccurs': '0', 'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('LENGTH', 'xs:unsignedInt', 0, 1, {'ref': 'LENGTH', 'minOccurs': '0', 'name': 'LENGTH', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('SKIPPERIODCOUNT', 'xs:unsignedInt', 0, 1, {'ref': 'SKIPPERIODCOUNT', 'minOccurs': '0', 'name': 'SKIPPERIODCOUNT', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('STARTDATE', ['STARTDATE', 'xs:string'], 0, 1, {'ref': 'STARTDATE', 'minOccurs': '0', 'name': 'STARTDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ENDDATE', ['ENDDATE', 'xs:string'], 0, 1, {'ref': 'ENDDATE', 'minOccurs': '0', 'name': 'ENDDATE', 'type': 'xs:string'}, None),
        MemberSpec_('NOTIFICATIONLANGUAGE', ['NOTIFICATIONLANGUAGE', 'xs:string'], 0, 1, {'ref': 'NOTIFICATIONLANGUAGE', 'minOccurs': '0', 'name': 'NOTIFICATIONLANGUAGE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, SECUREACHACCOUNTMERCHANTREF=None, ACHREFERENCE=None, SEC_CODE=None, DATETIME=None, NAME=None, DESCRIPTION=None, LENGTH=None, SKIPPERIODCOUNT=None, RECURRINGAMOUNT=None, STARTDATE=None, ENDDATE=None, NOTIFICATIONLANGUAGE=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF
        self.validate_SECUREACHACCOUNTMERCHANTREF(self.SECUREACHACCOUNTMERCHANTREF)
        self.ACHREFERENCE = ACHREFERENCE
        self.validate_ACHREFERENCE(self.ACHREFERENCE)
        self.SEC_CODE = SEC_CODE
        self.validate_SEC_CODE(self.SEC_CODE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.NAME = NAME
        self.validate_NAME(self.NAME)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.LENGTH = LENGTH
        self.SKIPPERIODCOUNT = SKIPPERIODCOUNT
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.STARTDATE = STARTDATE
        self.validate_STARTDATE(self.STARTDATE)
        self.ENDDATE = ENDDATE
        self.validate_ENDDATE(self.ENDDATE)
        self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
        self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATE_ACH_SUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATE_ACH_SUBSCRIPTION.subclass:
            return UPDATE_ACH_SUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return UPDATE_ACH_SUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_SECUREACHACCOUNTMERCHANTREF(self): return self.SECUREACHACCOUNTMERCHANTREF
    def set_SECUREACHACCOUNTMERCHANTREF(self, SECUREACHACCOUNTMERCHANTREF): self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF
    def get_ACHREFERENCE(self): return self.ACHREFERENCE
    def set_ACHREFERENCE(self, ACHREFERENCE): self.ACHREFERENCE = ACHREFERENCE
    def get_SEC_CODE(self): return self.SEC_CODE
    def set_SEC_CODE(self, SEC_CODE): self.SEC_CODE = SEC_CODE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_LENGTH(self): return self.LENGTH
    def set_LENGTH(self, LENGTH): self.LENGTH = LENGTH
    def get_SKIPPERIODCOUNT(self): return self.SKIPPERIODCOUNT
    def set_SKIPPERIODCOUNT(self, SKIPPERIODCOUNT): self.SKIPPERIODCOUNT = SKIPPERIODCOUNT
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_STARTDATE(self): return self.STARTDATE
    def set_STARTDATE(self, STARTDATE): self.STARTDATE = STARTDATE
    def get_ENDDATE(self): return self.ENDDATE
    def set_ENDDATE(self, ENDDATE): self.ENDDATE = ENDDATE
    def get_NOTIFICATIONLANGUAGE(self): return self.NOTIFICATIONLANGUAGE
    def set_NOTIFICATIONLANGUAGE(self, NOTIFICATIONLANGUAGE): self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_SECUREACHACCOUNTMERCHANTREF(self, value):
        # Validate type SECUREACHACCOUNTMERCHANTREF, a restriction on xs:string.
        pass
    def validate_ACHREFERENCE(self, value):
        # Validate type ACHREFERENCE, a restriction on xs:string.
        pass
    def validate_SEC_CODE(self, value):
        # Validate type SEC_CODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_NAME(self, value):
        # Validate type NAME, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_STARTDATE(self, value):
        # Validate type STARTDATE, a restriction on xs:string.
        pass
    def validate_ENDDATE(self, value):
        # Validate type ENDDATE, a restriction on xs:string.
        pass
    def validate_NOTIFICATIONLANGUAGE(self, value):
        # Validate type NOTIFICATIONLANGUAGE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.SECUREACHACCOUNTMERCHANTREF is not None or
            self.ACHREFERENCE is not None or
            self.SEC_CODE is not None or
            self.DATETIME is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.LENGTH is not None or
            self.SKIPPERIODCOUNT is not None or
            self.RECURRINGAMOUNT is not None or
            self.STARTDATE is not None or
            self.ENDDATE is not None or
            self.NOTIFICATIONLANGUAGE is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATE_ACH_SUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.SECUREACHACCOUNTMERCHANTREF is not None:
            SECUREACHACCOUNTMERCHANTREF_ = self.SECUREACHACCOUNTMERCHANTREF
            etree_.SubElement(element, '{}SECUREACHACCOUNTMERCHANTREF').text = self.gds_format_string(SECUREACHACCOUNTMERCHANTREF_)
        if self.ACHREFERENCE is not None:
            ACHREFERENCE_ = self.ACHREFERENCE
            etree_.SubElement(element, '{}ACHREFERENCE').text = self.gds_format_string(ACHREFERENCE_)
        if self.SEC_CODE is not None:
            SEC_CODE_ = self.SEC_CODE
            etree_.SubElement(element, '{}SEC_CODE').text = self.gds_format_string(SEC_CODE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.LENGTH is not None:
            LENGTH_ = self.LENGTH
            etree_.SubElement(element, '{}LENGTH').text = self.gds_format_integer(LENGTH_)
        if self.SKIPPERIODCOUNT is not None:
            SKIPPERIODCOUNT_ = self.SKIPPERIODCOUNT
            etree_.SubElement(element, '{}SKIPPERIODCOUNT').text = self.gds_format_integer(SKIPPERIODCOUNT_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.STARTDATE is not None:
            STARTDATE_ = self.STARTDATE
            etree_.SubElement(element, '{}STARTDATE').text = self.gds_format_string(STARTDATE_)
        if self.ENDDATE is not None:
            ENDDATE_ = self.ENDDATE
            etree_.SubElement(element, '{}ENDDATE').text = self.gds_format_string(ENDDATE_)
        if self.NOTIFICATIONLANGUAGE is not None:
            NOTIFICATIONLANGUAGE_ = self.NOTIFICATIONLANGUAGE
            etree_.SubElement(element, '{}NOTIFICATIONLANGUAGE').text = self.gds_format_string(NOTIFICATIONLANGUAGE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATE_ACH_SUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.SECUREACHACCOUNTMERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('SECUREACHACCOUNTMERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.SECUREACHACCOUNTMERCHANTREF)))
        if self.ACHREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('ACHREFERENCE=%s,\n' % self.gds_encode(quote_python(self.ACHREFERENCE)))
        if self.SEC_CODE is not None:
            showIndent(outfile, level)
            outfile.write('SEC_CODE=%s,\n' % self.gds_encode(quote_python(self.SEC_CODE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('LENGTH=%d,\n' % self.LENGTH)
        if self.SKIPPERIODCOUNT is not None:
            showIndent(outfile, level)
            outfile.write('SKIPPERIODCOUNT=%d,\n' % self.SKIPPERIODCOUNT)
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.STARTDATE is not None:
            showIndent(outfile, level)
            outfile.write('STARTDATE=%s,\n' % self.gds_encode(quote_python(self.STARTDATE)))
        if self.ENDDATE is not None:
            showIndent(outfile, level)
            outfile.write('ENDDATE=%s,\n' % self.gds_encode(quote_python(self.ENDDATE)))
        if self.NOTIFICATIONLANGUAGE is not None:
            showIndent(outfile, level)
            outfile.write('NOTIFICATIONLANGUAGE=%s,\n' % self.gds_encode(quote_python(self.NOTIFICATIONLANGUAGE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'SECUREACHACCOUNTMERCHANTREF':
            SECUREACHACCOUNTMERCHANTREF_ = child_.text
            SECUREACHACCOUNTMERCHANTREF_ = self.gds_validate_string(SECUREACHACCOUNTMERCHANTREF_, node, 'SECUREACHACCOUNTMERCHANTREF')
            self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF_
            # validate type SECUREACHACCOUNTMERCHANTREF
            self.validate_SECUREACHACCOUNTMERCHANTREF(self.SECUREACHACCOUNTMERCHANTREF)
        elif nodeName_ == 'ACHREFERENCE':
            ACHREFERENCE_ = child_.text
            ACHREFERENCE_ = self.gds_validate_string(ACHREFERENCE_, node, 'ACHREFERENCE')
            self.ACHREFERENCE = ACHREFERENCE_
            # validate type ACHREFERENCE
            self.validate_ACHREFERENCE(self.ACHREFERENCE)
        elif nodeName_ == 'SEC_CODE':
            SEC_CODE_ = child_.text
            SEC_CODE_ = self.gds_validate_string(SEC_CODE_, node, 'SEC_CODE')
            self.SEC_CODE = SEC_CODE_
            # validate type SEC_CODE
            self.validate_SEC_CODE(self.SEC_CODE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
            # validate type NAME
            self.validate_NAME(self.NAME)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'LENGTH' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LENGTH')
            self.LENGTH = ival_
        elif nodeName_ == 'SKIPPERIODCOUNT' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SKIPPERIODCOUNT')
            self.SKIPPERIODCOUNT = ival_
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'STARTDATE':
            STARTDATE_ = child_.text
            STARTDATE_ = self.gds_validate_string(STARTDATE_, node, 'STARTDATE')
            self.STARTDATE = STARTDATE_
            # validate type STARTDATE
            self.validate_STARTDATE(self.STARTDATE)
        elif nodeName_ == 'ENDDATE':
            ENDDATE_ = child_.text
            ENDDATE_ = self.gds_validate_string(ENDDATE_, node, 'ENDDATE')
            self.ENDDATE = ENDDATE_
            # validate type ENDDATE
            self.validate_ENDDATE(self.ENDDATE)
        elif nodeName_ == 'NOTIFICATIONLANGUAGE':
            NOTIFICATIONLANGUAGE_ = child_.text
            NOTIFICATIONLANGUAGE_ = self.gds_validate_string(NOTIFICATIONLANGUAGE_, node, 'NOTIFICATIONLANGUAGE')
            self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE_
            # validate type NOTIFICATIONLANGUAGE
            self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class UPDATE_ACH_SUBSCRIPTION


class UPDATE_ACH_SUBSCRIPTION_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATE_ACH_SUBSCRIPTION_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATE_ACH_SUBSCRIPTION_RESPONSE.subclass:
            return UPDATE_ACH_SUBSCRIPTION_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return UPDATE_ACH_SUBSCRIPTION_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATE_ACH_SUBSCRIPTION_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATE_ACH_SUBSCRIPTION_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class UPDATE_ACH_SUBSCRIPTION_RESPONSE


class ACH_SUBSCRIPTION_PAYMENT(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('SUBSCRIPTIONREF', ['SUBSCRIPTIONREF', 'xs:string'], 0, 0, {'ref': 'SUBSCRIPTIONREF', 'name': 'SUBSCRIPTIONREF', 'type': 'xs:string'}, None),
        MemberSpec_('SEC_CODE', ['SEC_CODE', 'xs:string'], 0, 0, {'ref': 'SEC_CODE', 'name': 'SEC_CODE', 'type': 'xs:string'}, None),
        MemberSpec_('CHECK_NUMBER', ['CHECK_NUMBER', 'xs:string'], 0, 1, {'ref': 'CHECK_NUMBER', 'minOccurs': '0', 'name': 'CHECK_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, AMOUNT=None, SUBSCRIPTIONREF=None, SEC_CODE=None, CHECK_NUMBER=None, DESCRIPTION=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.SUBSCRIPTIONREF = SUBSCRIPTIONREF
        self.validate_SUBSCRIPTIONREF(self.SUBSCRIPTIONREF)
        self.SEC_CODE = SEC_CODE
        self.validate_SEC_CODE(self.SEC_CODE)
        self.CHECK_NUMBER = CHECK_NUMBER
        self.validate_CHECK_NUMBER(self.CHECK_NUMBER)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_SUBSCRIPTION_PAYMENT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_SUBSCRIPTION_PAYMENT.subclass:
            return ACH_SUBSCRIPTION_PAYMENT.subclass(*args_, **kwargs_)
        else:
            return ACH_SUBSCRIPTION_PAYMENT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_SUBSCRIPTIONREF(self): return self.SUBSCRIPTIONREF
    def set_SUBSCRIPTIONREF(self, SUBSCRIPTIONREF): self.SUBSCRIPTIONREF = SUBSCRIPTIONREF
    def get_SEC_CODE(self): return self.SEC_CODE
    def set_SEC_CODE(self, SEC_CODE): self.SEC_CODE = SEC_CODE
    def get_CHECK_NUMBER(self): return self.CHECK_NUMBER
    def set_CHECK_NUMBER(self, CHECK_NUMBER): self.CHECK_NUMBER = CHECK_NUMBER
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_SUBSCRIPTIONREF(self, value):
        # Validate type SUBSCRIPTIONREF, a restriction on xs:string.
        pass
    def validate_SEC_CODE(self, value):
        # Validate type SEC_CODE, a restriction on xs:string.
        pass
    def validate_CHECK_NUMBER(self, value):
        # Validate type CHECK_NUMBER, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.SUBSCRIPTIONREF is not None or
            self.SEC_CODE is not None or
            self.CHECK_NUMBER is not None or
            self.DESCRIPTION is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_SUBSCRIPTION_PAYMENT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.SUBSCRIPTIONREF is not None:
            SUBSCRIPTIONREF_ = self.SUBSCRIPTIONREF
            etree_.SubElement(element, '{}SUBSCRIPTIONREF').text = self.gds_format_string(SUBSCRIPTIONREF_)
        if self.SEC_CODE is not None:
            SEC_CODE_ = self.SEC_CODE
            etree_.SubElement(element, '{}SEC_CODE').text = self.gds_format_string(SEC_CODE_)
        if self.CHECK_NUMBER is not None:
            CHECK_NUMBER_ = self.CHECK_NUMBER
            etree_.SubElement(element, '{}CHECK_NUMBER').text = self.gds_format_string(CHECK_NUMBER_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_SUBSCRIPTION_PAYMENT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.SUBSCRIPTIONREF is not None:
            showIndent(outfile, level)
            outfile.write('SUBSCRIPTIONREF=%s,\n' % self.gds_encode(quote_python(self.SUBSCRIPTIONREF)))
        if self.SEC_CODE is not None:
            showIndent(outfile, level)
            outfile.write('SEC_CODE=%s,\n' % self.gds_encode(quote_python(self.SEC_CODE)))
        if self.CHECK_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CHECK_NUMBER=%s,\n' % self.gds_encode(quote_python(self.CHECK_NUMBER)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'SUBSCRIPTIONREF':
            SUBSCRIPTIONREF_ = child_.text
            SUBSCRIPTIONREF_ = self.gds_validate_string(SUBSCRIPTIONREF_, node, 'SUBSCRIPTIONREF')
            self.SUBSCRIPTIONREF = SUBSCRIPTIONREF_
            # validate type SUBSCRIPTIONREF
            self.validate_SUBSCRIPTIONREF(self.SUBSCRIPTIONREF)
        elif nodeName_ == 'SEC_CODE':
            SEC_CODE_ = child_.text
            SEC_CODE_ = self.gds_validate_string(SEC_CODE_, node, 'SEC_CODE')
            self.SEC_CODE = SEC_CODE_
            # validate type SEC_CODE
            self.validate_SEC_CODE(self.SEC_CODE)
        elif nodeName_ == 'CHECK_NUMBER':
            CHECK_NUMBER_ = child_.text
            CHECK_NUMBER_ = self.gds_validate_string(CHECK_NUMBER_, node, 'CHECK_NUMBER')
            self.CHECK_NUMBER = CHECK_NUMBER_
            # validate type CHECK_NUMBER
            self.validate_CHECK_NUMBER(self.CHECK_NUMBER)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ACH_SUBSCRIPTION_PAYMENT


class ACH_SUBSCRIPTION_PAYMENT_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, APPROVALCODE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_SUBSCRIPTION_PAYMENT_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_SUBSCRIPTION_PAYMENT_RESPONSE.subclass:
            return ACH_SUBSCRIPTION_PAYMENT_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return ACH_SUBSCRIPTION_PAYMENT_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.APPROVALCODE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_SUBSCRIPTION_PAYMENT_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_SUBSCRIPTION_PAYMENT_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class ACH_SUBSCRIPTION_PAYMENT_RESPONSE


class TERMINAL_CONFIGURATION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'minOccurs': '1', 'maxOccurs': '1', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOM_FIELD_LANGUAGE', ['CUSTOM_FIELD_LANGUAGEType', 'xs:string'], 0, 1, {'name': 'CUSTOM_FIELD_LANGUAGE', 'minOccurs': '0', 'maxOccurs': '1', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'minOccurs': '1', 'maxOccurs': '1', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, CUSTOM_FIELD_LANGUAGE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.CUSTOM_FIELD_LANGUAGE = CUSTOM_FIELD_LANGUAGE
        self.validate_CUSTOM_FIELD_LANGUAGEType(self.CUSTOM_FIELD_LANGUAGE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TERMINAL_CONFIGURATION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TERMINAL_CONFIGURATION.subclass:
            return TERMINAL_CONFIGURATION.subclass(*args_, **kwargs_)
        else:
            return TERMINAL_CONFIGURATION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_CUSTOM_FIELD_LANGUAGE(self): return self.CUSTOM_FIELD_LANGUAGE
    def set_CUSTOM_FIELD_LANGUAGE(self, CUSTOM_FIELD_LANGUAGE): self.CUSTOM_FIELD_LANGUAGE = CUSTOM_FIELD_LANGUAGE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_CUSTOM_FIELD_LANGUAGEType(self, value):
        # Validate type CUSTOM_FIELD_LANGUAGEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CUSTOM_FIELD_LANGUAGEType' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CUSTOM_FIELD_LANGUAGEType' % {"value" : value.encode("utf-8")} )
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.CUSTOM_FIELD_LANGUAGE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TERMINAL_CONFIGURATION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.CUSTOM_FIELD_LANGUAGE is not None:
            CUSTOM_FIELD_LANGUAGE_ = self.CUSTOM_FIELD_LANGUAGE
            etree_.SubElement(element, '{}CUSTOM_FIELD_LANGUAGE').text = self.gds_format_string(CUSTOM_FIELD_LANGUAGE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TERMINAL_CONFIGURATION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.CUSTOM_FIELD_LANGUAGE is not None:
            showIndent(outfile, level)
            outfile.write('CUSTOM_FIELD_LANGUAGE=%s,\n' % self.gds_encode(quote_python(self.CUSTOM_FIELD_LANGUAGE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'CUSTOM_FIELD_LANGUAGE':
            CUSTOM_FIELD_LANGUAGE_ = child_.text
            CUSTOM_FIELD_LANGUAGE_ = self.gds_validate_string(CUSTOM_FIELD_LANGUAGE_, node, 'CUSTOM_FIELD_LANGUAGE')
            self.CUSTOM_FIELD_LANGUAGE = CUSTOM_FIELD_LANGUAGE_
            # validate type CUSTOM_FIELD_LANGUAGEType
            self.validate_CUSTOM_FIELD_LANGUAGEType(self.CUSTOM_FIELD_LANGUAGE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID]
        if self.CUSTOM_FIELD_LANGUAGE:
            hash_list.append(self.CUSTOM_FIELD_LANGUAGE)
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class TERMINAL_CONFIGURATION


class API_ADDRESS_MODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, API_ADDRESS_MODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if API_ADDRESS_MODE.subclass:
            return API_ADDRESS_MODE.subclass(*args_, **kwargs_)
        else:
            return API_ADDRESS_MODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='API_ADDRESS_MODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='API_ADDRESS_MODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class API_ADDRESS_MODE


class TXN_DATA_LEVEL(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TXN_DATA_LEVEL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TXN_DATA_LEVEL.subclass:
            return TXN_DATA_LEVEL.subclass(*args_, **kwargs_)
        else:
            return TXN_DATA_LEVEL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TXN_DATA_LEVEL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TXN_DATA_LEVEL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TXN_DATA_LEVEL


class CUSTOM_FIELDS(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('CUSTOM_FIELD', 'CUSTOM_FIELDType', 1, 1, {'name': 'CUSTOM_FIELD', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'type': 'CUSTOM_FIELDType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CUSTOM_FIELD=None):
        self.original_tagname_ = None
        if CUSTOM_FIELD is None:
            self.CUSTOM_FIELD = []
        else:
            self.CUSTOM_FIELD = CUSTOM_FIELD
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CUSTOM_FIELDS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CUSTOM_FIELDS.subclass:
            return CUSTOM_FIELDS.subclass(*args_, **kwargs_)
        else:
            return CUSTOM_FIELDS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CUSTOM_FIELD(self): return self.CUSTOM_FIELD
    def set_CUSTOM_FIELD(self, CUSTOM_FIELD): self.CUSTOM_FIELD = CUSTOM_FIELD
    def add_CUSTOM_FIELD(self, value): self.CUSTOM_FIELD.append(value)
    def insert_CUSTOM_FIELD_at(self, index, value): self.CUSTOM_FIELD.insert(index, value)
    def replace_CUSTOM_FIELD_at(self, index, value): self.CUSTOM_FIELD[index] = value
    def hasContent_(self):
        if (
            self.CUSTOM_FIELD
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CUSTOM_FIELDS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for CUSTOM_FIELD_ in self.CUSTOM_FIELD:
            CUSTOM_FIELD_.to_etree(element, name_='CUSTOM_FIELD', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CUSTOM_FIELDS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CUSTOM_FIELD=[\n')
        level += 1
        for CUSTOM_FIELD_ in self.CUSTOM_FIELD:
            showIndent(outfile, level)
            outfile.write('model_.CUSTOM_FIELDType(\n')
            CUSTOM_FIELD_.exportLiteral(outfile, level, name_='CUSTOM_FIELDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CUSTOM_FIELD':
            obj_ = CUSTOM_FIELDType.factory()
            obj_.build(child_)
            self.CUSTOM_FIELD.append(obj_)
            obj_.original_tagname_ = 'CUSTOM_FIELD'
# end class CUSTOM_FIELDS


class TERMINAL_CONFIGURATION_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'minOccurs': '1', 'maxOccurs': '1', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('BANK_SETTINGS', 'BANK_SETTINGSType', 0, 0, {'name': 'BANK_SETTINGS', 'minOccurs': '1', 'maxOccurs': '1', 'type': 'BANK_SETTINGSType'}, None),
        MemberSpec_('SUPPORTED_CURRENCIES', 'SUPPORTED_CURRENCIESType', 0, 1, {'name': 'SUPPORTED_CURRENCIES', 'minOccurs': '0', 'maxOccurs': '1', 'type': 'SUPPORTED_CURRENCIESType'}, None),
        MemberSpec_('FEATURES', 'FEATURESType', 0, 1, {'name': 'FEATURES', 'minOccurs': '0', 'maxOccurs': '1', 'type': 'FEATURESType'}, None),
        MemberSpec_('SUPPORTED_CARDTYPES', 'SUPPORTED_CARDTYPESType', 0, 1, {'name': 'SUPPORTED_CARDTYPES', 'minOccurs': '0', 'maxOccurs': '1', 'type': 'SUPPORTED_CARDTYPESType'}, None),
        MemberSpec_('SECURITY_FRAUD', 'SECURITY_FRAUDType', 0, 0, {'name': 'SECURITY_FRAUD', 'type': 'SECURITY_FRAUDType'}, None),
        MemberSpec_('INTEGRATION', 'INTEGRATIONType', 0, 1, {'name': 'INTEGRATION', 'minOccurs': '0', 'maxOccurs': '1', 'type': 'INTEGRATIONType'}, None),
        MemberSpec_('ALLOW_ACH_JH', 'xs:boolean', 0, 1, {'name': 'ALLOW_ACH_JH', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
        MemberSpec_('CUSTOM_FIELDS', 'CUSTOM_FIELDS', 0, 1, {'ref': 'CUSTOM_FIELDS', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'CUSTOM_FIELDS', 'type': 'CUSTOM_FIELDS'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'minOccurs': '1', 'maxOccurs': '1', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'minOccurs': '1', 'maxOccurs': '1', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, BANK_SETTINGS=None, SUPPORTED_CURRENCIES=None, FEATURES=None, SUPPORTED_CARDTYPES=None, SECURITY_FRAUD=None, INTEGRATION=None, ALLOW_ACH_JH=None, CUSTOM_FIELDS=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.BANK_SETTINGS = BANK_SETTINGS
        self.SUPPORTED_CURRENCIES = SUPPORTED_CURRENCIES
        self.FEATURES = FEATURES
        self.SUPPORTED_CARDTYPES = SUPPORTED_CARDTYPES
        self.SECURITY_FRAUD = SECURITY_FRAUD
        self.INTEGRATION = INTEGRATION
        self.ALLOW_ACH_JH = ALLOW_ACH_JH
        self.CUSTOM_FIELDS = CUSTOM_FIELDS
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TERMINAL_CONFIGURATION_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TERMINAL_CONFIGURATION_RESPONSE.subclass:
            return TERMINAL_CONFIGURATION_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return TERMINAL_CONFIGURATION_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_BANK_SETTINGS(self): return self.BANK_SETTINGS
    def set_BANK_SETTINGS(self, BANK_SETTINGS): self.BANK_SETTINGS = BANK_SETTINGS
    def get_SUPPORTED_CURRENCIES(self): return self.SUPPORTED_CURRENCIES
    def set_SUPPORTED_CURRENCIES(self, SUPPORTED_CURRENCIES): self.SUPPORTED_CURRENCIES = SUPPORTED_CURRENCIES
    def get_FEATURES(self): return self.FEATURES
    def set_FEATURES(self, FEATURES): self.FEATURES = FEATURES
    def get_SUPPORTED_CARDTYPES(self): return self.SUPPORTED_CARDTYPES
    def set_SUPPORTED_CARDTYPES(self, SUPPORTED_CARDTYPES): self.SUPPORTED_CARDTYPES = SUPPORTED_CARDTYPES
    def get_SECURITY_FRAUD(self): return self.SECURITY_FRAUD
    def set_SECURITY_FRAUD(self, SECURITY_FRAUD): self.SECURITY_FRAUD = SECURITY_FRAUD
    def get_INTEGRATION(self): return self.INTEGRATION
    def set_INTEGRATION(self, INTEGRATION): self.INTEGRATION = INTEGRATION
    def get_ALLOW_ACH_JH(self): return self.ALLOW_ACH_JH
    def set_ALLOW_ACH_JH(self, ALLOW_ACH_JH): self.ALLOW_ACH_JH = ALLOW_ACH_JH
    def get_CUSTOM_FIELDS(self): return self.CUSTOM_FIELDS
    def set_CUSTOM_FIELDS(self, CUSTOM_FIELDS): self.CUSTOM_FIELDS = CUSTOM_FIELDS
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.BANK_SETTINGS is not None or
            self.SUPPORTED_CURRENCIES is not None or
            self.FEATURES is not None or
            self.SUPPORTED_CARDTYPES is not None or
            self.SECURITY_FRAUD is not None or
            self.INTEGRATION is not None or
            self.ALLOW_ACH_JH is not None or
            self.CUSTOM_FIELDS is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TERMINAL_CONFIGURATION_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.BANK_SETTINGS is not None:
            BANK_SETTINGS_ = self.BANK_SETTINGS
            BANK_SETTINGS_.to_etree(element, name_='BANK_SETTINGS', mapping_=mapping_)
        if self.SUPPORTED_CURRENCIES is not None:
            SUPPORTED_CURRENCIES_ = self.SUPPORTED_CURRENCIES
            SUPPORTED_CURRENCIES_.to_etree(element, name_='SUPPORTED_CURRENCIES', mapping_=mapping_)
        if self.FEATURES is not None:
            FEATURES_ = self.FEATURES
            FEATURES_.to_etree(element, name_='FEATURES', mapping_=mapping_)
        if self.SUPPORTED_CARDTYPES is not None:
            SUPPORTED_CARDTYPES_ = self.SUPPORTED_CARDTYPES
            SUPPORTED_CARDTYPES_.to_etree(element, name_='SUPPORTED_CARDTYPES', mapping_=mapping_)
        if self.SECURITY_FRAUD is not None:
            SECURITY_FRAUD_ = self.SECURITY_FRAUD
            SECURITY_FRAUD_.to_etree(element, name_='SECURITY_FRAUD', mapping_=mapping_)
        if self.INTEGRATION is not None:
            INTEGRATION_ = self.INTEGRATION
            INTEGRATION_.to_etree(element, name_='INTEGRATION', mapping_=mapping_)
        if self.ALLOW_ACH_JH is not None:
            ALLOW_ACH_JH_ = self.ALLOW_ACH_JH
            etree_.SubElement(element, '{}ALLOW_ACH_JH').text = self.gds_format_boolean(ALLOW_ACH_JH_)
        if self.CUSTOM_FIELDS is not None:
            CUSTOM_FIELDS_ = self.CUSTOM_FIELDS
            CUSTOM_FIELDS_.to_etree(element, name_='CUSTOM_FIELDS', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TERMINAL_CONFIGURATION_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.BANK_SETTINGS is not None:
            showIndent(outfile, level)
            outfile.write('BANK_SETTINGS=model_.BANK_SETTINGSType(\n')
            self.BANK_SETTINGS.exportLiteral(outfile, level, name_='BANK_SETTINGS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SUPPORTED_CURRENCIES is not None:
            showIndent(outfile, level)
            outfile.write('SUPPORTED_CURRENCIES=model_.SUPPORTED_CURRENCIESType(\n')
            self.SUPPORTED_CURRENCIES.exportLiteral(outfile, level, name_='SUPPORTED_CURRENCIES')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FEATURES is not None:
            showIndent(outfile, level)
            outfile.write('FEATURES=model_.FEATURESType(\n')
            self.FEATURES.exportLiteral(outfile, level, name_='FEATURES')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SUPPORTED_CARDTYPES is not None:
            showIndent(outfile, level)
            outfile.write('SUPPORTED_CARDTYPES=model_.SUPPORTED_CARDTYPESType(\n')
            self.SUPPORTED_CARDTYPES.exportLiteral(outfile, level, name_='SUPPORTED_CARDTYPES')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SECURITY_FRAUD is not None:
            showIndent(outfile, level)
            outfile.write('SECURITY_FRAUD=model_.SECURITY_FRAUDType(\n')
            self.SECURITY_FRAUD.exportLiteral(outfile, level, name_='SECURITY_FRAUD')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.INTEGRATION is not None:
            showIndent(outfile, level)
            outfile.write('INTEGRATION=model_.INTEGRATIONType(\n')
            self.INTEGRATION.exportLiteral(outfile, level, name_='INTEGRATION')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ALLOW_ACH_JH is not None:
            showIndent(outfile, level)
            outfile.write('ALLOW_ACH_JH=%s,\n' % self.ALLOW_ACH_JH)
        if self.CUSTOM_FIELDS is not None:
            showIndent(outfile, level)
            outfile.write('CUSTOM_FIELDS=model_.CUSTOM_FIELDS(\n')
            self.CUSTOM_FIELDS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'BANK_SETTINGS':
            obj_ = BANK_SETTINGSType.factory()
            obj_.build(child_)
            self.BANK_SETTINGS = obj_
            obj_.original_tagname_ = 'BANK_SETTINGS'
        elif nodeName_ == 'SUPPORTED_CURRENCIES':
            obj_ = SUPPORTED_CURRENCIESType.factory()
            obj_.build(child_)
            self.SUPPORTED_CURRENCIES = obj_
            obj_.original_tagname_ = 'SUPPORTED_CURRENCIES'
        elif nodeName_ == 'FEATURES':
            obj_ = FEATURESType.factory()
            obj_.build(child_)
            self.FEATURES = obj_
            obj_.original_tagname_ = 'FEATURES'
        elif nodeName_ == 'SUPPORTED_CARDTYPES':
            obj_ = SUPPORTED_CARDTYPESType.factory()
            obj_.build(child_)
            self.SUPPORTED_CARDTYPES = obj_
            obj_.original_tagname_ = 'SUPPORTED_CARDTYPES'
        elif nodeName_ == 'SECURITY_FRAUD':
            obj_ = SECURITY_FRAUDType.factory()
            obj_.build(child_)
            self.SECURITY_FRAUD = obj_
            obj_.original_tagname_ = 'SECURITY_FRAUD'
        elif nodeName_ == 'INTEGRATION':
            obj_ = INTEGRATIONType.factory()
            obj_.build(child_)
            self.INTEGRATION = obj_
            obj_.original_tagname_ = 'INTEGRATION'
        elif nodeName_ == 'ALLOW_ACH_JH':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ALLOW_ACH_JH')
            self.ALLOW_ACH_JH = ival_
        elif nodeName_ == 'CUSTOM_FIELDS':
            obj_ = CUSTOM_FIELDS.factory()
            obj_.build(child_)
            self.CUSTOM_FIELDS = obj_
            obj_.original_tagname_ = 'CUSTOM_FIELDS'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID]
        if self.CUSTOM_FIELD_LANGUAGE:
            hash_list.append(self.CUSTOM_FIELD_LANGUAGE)
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class TERMINAL_CONFIGURATION_RESPONSE


class CREATE_PAYMENT_LINK(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 1, {'ref': 'ORDERID', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('SUBTOTAL', ['SUBTOTALType', 'xs:decimal'], 0, 1, {'name': 'SUBTOTAL', 'minOccurs': '0', 'type': 'xs:decimal'}, None),
        MemberSpec_('DISCOUNT', ['DISCOUNTType', 'xs:decimal'], 0, 1, {'name': 'DISCOUNT', 'minOccurs': '0', 'type': 'xs:decimal'}, None),
        MemberSpec_('TAX', ['TAXType', 'xs:decimal'], 0, 1, {'name': 'TAX', 'minOccurs': '0', 'type': 'xs:decimal'}, None),
        MemberSpec_('TOTAL_DUTY_AMOUNT', ['defaultDecimal', 'xs:decimal'], 0, 1, {'name': 'TOTAL_DUTY_AMOUNT', 'type': 'xs:decimal', 'minOccurs': '0'}, None),
        MemberSpec_('TOTAL_FREIGHT_AMOUNT', ['defaultDecimal', 'xs:decimal'], 0, 1, {'name': 'TOTAL_FREIGHT_AMOUNT', 'type': 'xs:decimal', 'minOccurs': '0'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CREATION_DATE', ['CREATION_DATEType', 'xs:string'], 0, 1, {'name': 'CREATION_DATE', 'minOccurs': '0', 'maxOccurs': '1', 'type': 'xs:string'}, None),
        MemberSpec_('EXPIRATION_DATE', ['EXPIRATION_DATEType', 'xs:string'], 0, 0, {'name': 'EXPIRATION_DATE', 'type': 'xs:string'}, None),
        MemberSpec_('AUTH_TYPE', ['AUTH_TYPE', 'xs:int'], 0, 1, {'ref': 'AUTH_TYPE', 'minOccurs': '0', 'name': 'AUTH_TYPE', 'type': 'xs:int'}, None),
        MemberSpec_('LEVEL_DATA', ['LEVEL_DATA', 'xs:int'], 0, 1, {'ref': 'LEVEL_DATA', 'minOccurs': '0', 'name': 'LEVEL_DATA', 'type': 'xs:int'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('ITEMS', 'ITEMSType', 0, 1, {'name': 'ITEMS', 'minOccurs': '0', 'type': 'ITEMSType'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, ORDERID=None, CURRENCY=None, SUBTOTAL=None, DISCOUNT=None, TAX=None, TOTAL_DUTY_AMOUNT=None, TOTAL_FREIGHT_AMOUNT=None, AMOUNT=None, DESCRIPTION=None, MERCHANTREF=None, CREATION_DATE=None, EXPIRATION_DATE=None, AUTH_TYPE=None, LEVEL_DATA=None, LEVEL_2_DATA=None, ITEMS=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.SUBTOTAL = SUBTOTAL
        self.validate_SUBTOTALType(self.SUBTOTAL)
        self.DISCOUNT = DISCOUNT
        self.validate_DISCOUNTType(self.DISCOUNT)
        self.TAX = TAX
        self.validate_TAXType(self.TAX)
        self.TOTAL_DUTY_AMOUNT = TOTAL_DUTY_AMOUNT
        self.validate_defaultDecimal(self.TOTAL_DUTY_AMOUNT)
        self.TOTAL_FREIGHT_AMOUNT = TOTAL_FREIGHT_AMOUNT
        self.validate_defaultDecimal(self.TOTAL_FREIGHT_AMOUNT)
        self.AMOUNT = AMOUNT
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.CREATION_DATE = CREATION_DATE
        self.validate_CREATION_DATEType(self.CREATION_DATE)
        self.EXPIRATION_DATE = EXPIRATION_DATE
        self.validate_EXPIRATION_DATEType(self.EXPIRATION_DATE)
        self.AUTH_TYPE = AUTH_TYPE
        self.validate_AUTH_TYPE(self.AUTH_TYPE)
        self.LEVEL_DATA = LEVEL_DATA
        self.validate_LEVEL_DATA(self.LEVEL_DATA)
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.ITEMS = ITEMS
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CREATE_PAYMENT_LINK)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CREATE_PAYMENT_LINK.subclass:
            return CREATE_PAYMENT_LINK.subclass(*args_, **kwargs_)
        else:
            return CREATE_PAYMENT_LINK(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_SUBTOTAL(self): return self.SUBTOTAL
    def set_SUBTOTAL(self, SUBTOTAL): self.SUBTOTAL = SUBTOTAL
    def get_DISCOUNT(self): return self.DISCOUNT
    def set_DISCOUNT(self, DISCOUNT): self.DISCOUNT = DISCOUNT
    def get_TAX(self): return self.TAX
    def set_TAX(self, TAX): self.TAX = TAX
    def get_TOTAL_DUTY_AMOUNT(self): return self.TOTAL_DUTY_AMOUNT
    def set_TOTAL_DUTY_AMOUNT(self, TOTAL_DUTY_AMOUNT): self.TOTAL_DUTY_AMOUNT = TOTAL_DUTY_AMOUNT
    def get_TOTAL_FREIGHT_AMOUNT(self): return self.TOTAL_FREIGHT_AMOUNT
    def set_TOTAL_FREIGHT_AMOUNT(self, TOTAL_FREIGHT_AMOUNT): self.TOTAL_FREIGHT_AMOUNT = TOTAL_FREIGHT_AMOUNT
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_CREATION_DATE(self): return self.CREATION_DATE
    def set_CREATION_DATE(self, CREATION_DATE): self.CREATION_DATE = CREATION_DATE
    def get_EXPIRATION_DATE(self): return self.EXPIRATION_DATE
    def set_EXPIRATION_DATE(self, EXPIRATION_DATE): self.EXPIRATION_DATE = EXPIRATION_DATE
    def get_AUTH_TYPE(self): return self.AUTH_TYPE
    def set_AUTH_TYPE(self, AUTH_TYPE): self.AUTH_TYPE = AUTH_TYPE
    def get_LEVEL_DATA(self): return self.LEVEL_DATA
    def set_LEVEL_DATA(self, LEVEL_DATA): self.LEVEL_DATA = LEVEL_DATA
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_ITEMS(self): return self.ITEMS
    def set_ITEMS(self, ITEMS): self.ITEMS = ITEMS
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_SUBTOTALType(self, value):
        # Validate type SUBTOTALType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.001:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on SUBTOTALType' % {"value" : value} )
            if len(str(value)) >= 13:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on SUBTOTALType' % {"value" : value} )
    def validate_DISCOUNTType(self, value):
        # Validate type DISCOUNTType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on DISCOUNTType' % {"value" : value} )
            if value > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DISCOUNTType' % {"value" : value} )
    def validate_TAXType(self, value):
        # Validate type TAXType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on TAXType' % {"value" : value} )
            if value > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TAXType' % {"value" : value} )
    def validate_defaultDecimal(self, value):
        # Validate type defaultDecimal, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on defaultDecimal' % {"value" : value} )
            if len(str(value)) >= 13:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on defaultDecimal' % {"value" : value} )
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_CREATION_DATEType(self, value):
        # Validate type CREATION_DATEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CREATION_DATEType' % {"value" : value.encode("utf-8")} )
            if len(value) < 10:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CREATION_DATEType' % {"value" : value.encode("utf-8")} )
    def validate_EXPIRATION_DATEType(self, value):
        # Validate type EXPIRATION_DATEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on EXPIRATION_DATEType' % {"value" : value.encode("utf-8")} )
            if len(value) < 10:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on EXPIRATION_DATEType' % {"value" : value.encode("utf-8")} )
    def validate_AUTH_TYPE(self, value):
        # Validate type AUTH_TYPE, a restriction on xs:int.
        pass
    def validate_LEVEL_DATA(self, value):
        # Validate type LEVEL_DATA, a restriction on xs:int.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.ORDERID is not None or
            self.CURRENCY is not None or
            self.SUBTOTAL is not None or
            self.DISCOUNT is not None or
            self.TAX is not None or
            self.TOTAL_DUTY_AMOUNT is not None or
            self.TOTAL_FREIGHT_AMOUNT is not None or
            self.AMOUNT is not None or
            self.DESCRIPTION is not None or
            self.MERCHANTREF is not None or
            self.CREATION_DATE is not None or
            self.EXPIRATION_DATE is not None or
            self.AUTH_TYPE is not None or
            self.LEVEL_DATA is not None or
            self.LEVEL_2_DATA is not None or
            self.ITEMS is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CREATE_PAYMENT_LINK', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.SUBTOTAL is not None:
            SUBTOTAL_ = self.SUBTOTAL
            etree_.SubElement(element, '{}SUBTOTAL').text = self.gds_format_float(SUBTOTAL_)
        if self.DISCOUNT is not None:
            DISCOUNT_ = self.DISCOUNT
            etree_.SubElement(element, '{}DISCOUNT').text = self.gds_format_float(DISCOUNT_)
        if self.TAX is not None:
            TAX_ = self.TAX
            etree_.SubElement(element, '{}TAX').text = self.gds_format_float(TAX_)
        if self.TOTAL_DUTY_AMOUNT is not None:
            TOTAL_DUTY_AMOUNT_ = self.TOTAL_DUTY_AMOUNT
            etree_.SubElement(element, '{}TOTAL_DUTY_AMOUNT').text = self.gds_format_float(TOTAL_DUTY_AMOUNT_)
        if self.TOTAL_FREIGHT_AMOUNT is not None:
            TOTAL_FREIGHT_AMOUNT_ = self.TOTAL_FREIGHT_AMOUNT
            etree_.SubElement(element, '{}TOTAL_FREIGHT_AMOUNT').text = self.gds_format_float(TOTAL_FREIGHT_AMOUNT_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.CREATION_DATE is not None:
            CREATION_DATE_ = self.CREATION_DATE
            etree_.SubElement(element, '{}CREATION_DATE').text = self.gds_format_string(CREATION_DATE_)
        if self.EXPIRATION_DATE is not None:
            EXPIRATION_DATE_ = self.EXPIRATION_DATE
            etree_.SubElement(element, '{}EXPIRATION_DATE').text = self.gds_format_string(EXPIRATION_DATE_)
        if self.AUTH_TYPE is not None:
            AUTH_TYPE_ = self.AUTH_TYPE
            etree_.SubElement(element, '{}AUTH_TYPE').text = self.gds_format_integer(AUTH_TYPE_)
        if self.LEVEL_DATA is not None:
            LEVEL_DATA_ = self.LEVEL_DATA
            etree_.SubElement(element, '{}LEVEL_DATA').text = self.gds_format_integer(LEVEL_DATA_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.ITEMS is not None:
            ITEMS_ = self.ITEMS
            ITEMS_.to_etree(element, name_='ITEMS', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CREATE_PAYMENT_LINK'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.SUBTOTAL is not None:
            showIndent(outfile, level)
            outfile.write('SUBTOTAL=%f,\n' % self.SUBTOTAL)
        if self.DISCOUNT is not None:
            showIndent(outfile, level)
            outfile.write('DISCOUNT=%f,\n' % self.DISCOUNT)
        if self.TAX is not None:
            showIndent(outfile, level)
            outfile.write('TAX=%f,\n' % self.TAX)
        if self.TOTAL_DUTY_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TOTAL_DUTY_AMOUNT=%f,\n' % self.TOTAL_DUTY_AMOUNT)
        if self.TOTAL_FREIGHT_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TOTAL_FREIGHT_AMOUNT=%f,\n' % self.TOTAL_FREIGHT_AMOUNT)
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.CREATION_DATE is not None:
            showIndent(outfile, level)
            outfile.write('CREATION_DATE=%s,\n' % self.gds_encode(quote_python(self.CREATION_DATE)))
        if self.EXPIRATION_DATE is not None:
            showIndent(outfile, level)
            outfile.write('EXPIRATION_DATE=%s,\n' % self.gds_encode(quote_python(self.EXPIRATION_DATE)))
        if self.AUTH_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('AUTH_TYPE=%d,\n' % self.AUTH_TYPE)
        if self.LEVEL_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_DATA=%d,\n' % self.LEVEL_DATA)
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ITEMS is not None:
            showIndent(outfile, level)
            outfile.write('ITEMS=model_.ITEMSType(\n')
            self.ITEMS.exportLiteral(outfile, level, name_='ITEMS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'SUBTOTAL' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SUBTOTAL')
            self.SUBTOTAL = fval_
            # validate type SUBTOTALType
            self.validate_SUBTOTALType(self.SUBTOTAL)
        elif nodeName_ == 'DISCOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DISCOUNT')
            self.DISCOUNT = fval_
            # validate type DISCOUNTType
            self.validate_DISCOUNTType(self.DISCOUNT)
        elif nodeName_ == 'TAX' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TAX')
            self.TAX = fval_
            # validate type TAXType
            self.validate_TAXType(self.TAX)
        elif nodeName_ == 'TOTAL_DUTY_AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TOTAL_DUTY_AMOUNT')
            self.TOTAL_DUTY_AMOUNT = fval_
            # validate type defaultDecimal
            self.validate_defaultDecimal(self.TOTAL_DUTY_AMOUNT)
        elif nodeName_ == 'TOTAL_FREIGHT_AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TOTAL_FREIGHT_AMOUNT')
            self.TOTAL_FREIGHT_AMOUNT = fval_
            # validate type defaultDecimal
            self.validate_defaultDecimal(self.TOTAL_FREIGHT_AMOUNT)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'CREATION_DATE':
            CREATION_DATE_ = child_.text
            CREATION_DATE_ = self.gds_validate_string(CREATION_DATE_, node, 'CREATION_DATE')
            self.CREATION_DATE = CREATION_DATE_
            # validate type CREATION_DATEType
            self.validate_CREATION_DATEType(self.CREATION_DATE)
        elif nodeName_ == 'EXPIRATION_DATE':
            EXPIRATION_DATE_ = child_.text
            EXPIRATION_DATE_ = self.gds_validate_string(EXPIRATION_DATE_, node, 'EXPIRATION_DATE')
            self.EXPIRATION_DATE = EXPIRATION_DATE_
            # validate type EXPIRATION_DATEType
            self.validate_EXPIRATION_DATEType(self.EXPIRATION_DATE)
        elif nodeName_ == 'AUTH_TYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AUTH_TYPE')
            self.AUTH_TYPE = ival_
            # validate type AUTH_TYPE
            self.validate_AUTH_TYPE(self.AUTH_TYPE)
        elif nodeName_ == 'LEVEL_DATA' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LEVEL_DATA')
            self.LEVEL_DATA = ival_
            # validate type LEVEL_DATA
            self.validate_LEVEL_DATA(self.LEVEL_DATA)
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'ITEMS':
            obj_ = ITEMSType.factory()
            obj_.build(child_)
            self.ITEMS = obj_
            obj_.original_tagname_ = 'ITEMS'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        from decimal import Decimal
        from constants import Currency
        hash_list = [self.TERMINALID]
        if self.ORDERID:
            hash_list.append(self.ORDERID)
        hash_list.append(self.CURRENCY)
        if self.SUBTOTAL:
            hash_list.append(self.SUBTOTAL)
        if self.DISCOUNT:
            hash_list.append(self.DISCOUNT)
        if self.TAX:
            hash_list.append(self.TAX)
        if self.TOTAL_DUTY_AMOUNT:
            hash_list.append(self.TOTAL_DUTY_AMOUNT)
        if self.TOTAL_FREIGHT_AMOUNT:
            hash_list.append(self.TOTAL_FREIGHT_AMOUNT)
        hash_list.append(str(Decimal(self.AMOUNT).quantize(Decimal(10) ** -Currency[self.CURRENCY].minorunits)))
        if self.DESCRIPTION:
            hash_list.append(self.DESCRIPTION)
        hash_list.append(self.MERCHANTREF)
        if self.CREATION_DATE:
            hash_list.append(self.CREATION_DATE)
        if self.EXPIRATION_DATE:
            hash_list.append(self.EXPIRATION_DATE)
        if self.AUTH_TYPE:
            hash_list.append(str(self.AUTH_TYPE))
        if self.LEVEL_2_DATA:
            hash_list.append(self.LEVEL_2_DATA.hash_string)
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class CREATE_PAYMENT_LINK


class LEVEL_DATA(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LEVEL_DATA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LEVEL_DATA.subclass:
            return LEVEL_DATA.subclass(*args_, **kwargs_)
        else:
            return LEVEL_DATA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LEVEL_DATA', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LEVEL_DATA'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LEVEL_DATA


class AUTH_TYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AUTH_TYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AUTH_TYPE.subclass:
            return AUTH_TYPE.subclass(*args_, **kwargs_)
        else:
            return AUTH_TYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AUTH_TYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AUTH_TYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AUTH_TYPE


class PAYMENT_LINK_STATUS(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAYMENT_LINK_STATUS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAYMENT_LINK_STATUS.subclass:
            return PAYMENT_LINK_STATUS.subclass(*args_, **kwargs_)
        else:
            return PAYMENT_LINK_STATUS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAYMENT_LINK_STATUS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAYMENT_LINK_STATUS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PAYMENT_LINK_STATUS


class ITEM(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('COMMODITY_CODE', ['COMMODITY_CODEType1', 'xs:string'], 0, 1, {'name': 'COMMODITY_CODE', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('CODE', ['CODEType', 'xs:string'], 0, 0, {'name': 'CODE', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTIONType2', 'xs:string'], 0, 0, {'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('QUANTITY', ['QUANTITYType', 'xs:decimal'], 0, 0, {'name': 'QUANTITY', 'type': 'xs:decimal'}, None),
        MemberSpec_('UNIT_OF_MEASURE', ['UNIT_OF_MEASUREType3', 'xs:string'], 0, 1, {'name': 'UNIT_OF_MEASURE', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('PRICE', ['PRICEType', 'xs:decimal'], 0, 0, {'name': 'PRICE', 'type': 'xs:decimal'}, None),
        MemberSpec_('DISCOUNT_RATE', ['DISCOUNT_RATEType4', 'xs:decimal'], 0, 1, {'name': 'DISCOUNT_RATE', 'minOccurs': '0', 'type': 'xs:decimal'}, None),
        MemberSpec_('TAX_RATE', ['TAX_RATEType5', 'xs:decimal'], 0, 1, {'name': 'TAX_RATE', 'minOccurs': '0', 'type': 'xs:decimal'}, None),
        MemberSpec_('AMOUNT', ['AMOUNTType', 'xs:decimal'], 0, 0, {'name': 'AMOUNT', 'type': 'xs:decimal'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, COMMODITY_CODE=None, CODE=None, DESCRIPTION=None, QUANTITY=None, UNIT_OF_MEASURE=None, PRICE=None, DISCOUNT_RATE=None, TAX_RATE=None, AMOUNT=None):
        self.original_tagname_ = None
        self.COMMODITY_CODE = COMMODITY_CODE
        self.validate_COMMODITY_CODEType1(self.COMMODITY_CODE)
        self.CODE = CODE
        self.validate_CODEType(self.CODE)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTIONType2(self.DESCRIPTION)
        self.QUANTITY = QUANTITY
        self.validate_QUANTITYType(self.QUANTITY)
        self.UNIT_OF_MEASURE = UNIT_OF_MEASURE
        self.validate_UNIT_OF_MEASUREType3(self.UNIT_OF_MEASURE)
        self.PRICE = PRICE
        self.validate_PRICEType(self.PRICE)
        self.DISCOUNT_RATE = DISCOUNT_RATE
        self.validate_DISCOUNT_RATEType4(self.DISCOUNT_RATE)
        self.TAX_RATE = TAX_RATE
        self.validate_TAX_RATEType5(self.TAX_RATE)
        self.AMOUNT = AMOUNT
        self.validate_AMOUNTType(self.AMOUNT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ITEM)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ITEM.subclass:
            return ITEM.subclass(*args_, **kwargs_)
        else:
            return ITEM(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_COMMODITY_CODE(self): return self.COMMODITY_CODE
    def set_COMMODITY_CODE(self, COMMODITY_CODE): self.COMMODITY_CODE = COMMODITY_CODE
    def get_CODE(self): return self.CODE
    def set_CODE(self, CODE): self.CODE = CODE
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_QUANTITY(self): return self.QUANTITY
    def set_QUANTITY(self, QUANTITY): self.QUANTITY = QUANTITY
    def get_UNIT_OF_MEASURE(self): return self.UNIT_OF_MEASURE
    def set_UNIT_OF_MEASURE(self, UNIT_OF_MEASURE): self.UNIT_OF_MEASURE = UNIT_OF_MEASURE
    def get_PRICE(self): return self.PRICE
    def set_PRICE(self, PRICE): self.PRICE = PRICE
    def get_DISCOUNT_RATE(self): return self.DISCOUNT_RATE
    def set_DISCOUNT_RATE(self, DISCOUNT_RATE): self.DISCOUNT_RATE = DISCOUNT_RATE
    def get_TAX_RATE(self): return self.TAX_RATE
    def set_TAX_RATE(self, TAX_RATE): self.TAX_RATE = TAX_RATE
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def validate_COMMODITY_CODEType1(self, value):
        # Validate type COMMODITY_CODEType1, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on COMMODITY_CODEType1' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on COMMODITY_CODEType1' % {"value" : value.encode("utf-8")} )
    def validate_CODEType(self, value):
        # Validate type CODEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CODEType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CODEType' % {"value" : value.encode("utf-8")} )
    def validate_DESCRIPTIONType2(self, value):
        # Validate type DESCRIPTIONType2, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 250:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DESCRIPTIONType2' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DESCRIPTIONType2' % {"value" : value.encode("utf-8")} )
    def validate_QUANTITYType(self, value):
        # Validate type QUANTITYType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on QUANTITYType' % {"value" : value} )
            if value > 999999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on QUANTITYType' % {"value" : value} )
    def validate_UNIT_OF_MEASUREType3(self, value):
        # Validate type UNIT_OF_MEASUREType3, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on UNIT_OF_MEASUREType3' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on UNIT_OF_MEASUREType3' % {"value" : value.encode("utf-8")} )
    def validate_PRICEType(self, value):
        # Validate type PRICEType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PRICEType' % {"value" : value} )
            if len(str(value)) >= 13:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PRICEType' % {"value" : value} )
    def validate_DISCOUNT_RATEType4(self, value):
        # Validate type DISCOUNT_RATEType4, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on DISCOUNT_RATEType4' % {"value" : value} )
            if value > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DISCOUNT_RATEType4' % {"value" : value} )
    def validate_TAX_RATEType5(self, value):
        # Validate type TAX_RATEType5, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on TAX_RATEType5' % {"value" : value} )
            if value > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TAX_RATEType5' % {"value" : value} )
    def validate_AMOUNTType(self, value):
        # Validate type AMOUNTType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on AMOUNTType' % {"value" : value} )
            if len(str(value)) >= 13:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on AMOUNTType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.COMMODITY_CODE is not None or
            self.CODE is not None or
            self.DESCRIPTION is not None or
            self.QUANTITY is not None or
            self.UNIT_OF_MEASURE is not None or
            self.PRICE is not None or
            self.DISCOUNT_RATE is not None or
            self.TAX_RATE is not None or
            self.AMOUNT is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ITEM', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.COMMODITY_CODE is not None:
            COMMODITY_CODE_ = self.COMMODITY_CODE
            etree_.SubElement(element, '{}COMMODITY_CODE').text = self.gds_format_string(COMMODITY_CODE_)
        if self.CODE is not None:
            CODE_ = self.CODE
            etree_.SubElement(element, '{}CODE').text = self.gds_format_string(CODE_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.QUANTITY is not None:
            QUANTITY_ = self.QUANTITY
            etree_.SubElement(element, '{}QUANTITY').text = self.gds_format_float(QUANTITY_)
        if self.UNIT_OF_MEASURE is not None:
            UNIT_OF_MEASURE_ = self.UNIT_OF_MEASURE
            etree_.SubElement(element, '{}UNIT_OF_MEASURE').text = self.gds_format_string(UNIT_OF_MEASURE_)
        if self.PRICE is not None:
            PRICE_ = self.PRICE
            etree_.SubElement(element, '{}PRICE').text = self.gds_format_float(PRICE_)
        if self.DISCOUNT_RATE is not None:
            DISCOUNT_RATE_ = self.DISCOUNT_RATE
            etree_.SubElement(element, '{}DISCOUNT_RATE').text = self.gds_format_float(DISCOUNT_RATE_)
        if self.TAX_RATE is not None:
            TAX_RATE_ = self.TAX_RATE
            etree_.SubElement(element, '{}TAX_RATE').text = self.gds_format_float(TAX_RATE_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_float(AMOUNT_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ITEM'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.COMMODITY_CODE is not None:
            showIndent(outfile, level)
            outfile.write('COMMODITY_CODE=%s,\n' % self.gds_encode(quote_python(self.COMMODITY_CODE)))
        if self.CODE is not None:
            showIndent(outfile, level)
            outfile.write('CODE=%s,\n' % self.gds_encode(quote_python(self.CODE)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.QUANTITY is not None:
            showIndent(outfile, level)
            outfile.write('QUANTITY=%f,\n' % self.QUANTITY)
        if self.UNIT_OF_MEASURE is not None:
            showIndent(outfile, level)
            outfile.write('UNIT_OF_MEASURE=%s,\n' % self.gds_encode(quote_python(self.UNIT_OF_MEASURE)))
        if self.PRICE is not None:
            showIndent(outfile, level)
            outfile.write('PRICE=%f,\n' % self.PRICE)
        if self.DISCOUNT_RATE is not None:
            showIndent(outfile, level)
            outfile.write('DISCOUNT_RATE=%f,\n' % self.DISCOUNT_RATE)
        if self.TAX_RATE is not None:
            showIndent(outfile, level)
            outfile.write('TAX_RATE=%f,\n' % self.TAX_RATE)
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%f,\n' % self.AMOUNT)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'COMMODITY_CODE':
            COMMODITY_CODE_ = child_.text
            COMMODITY_CODE_ = self.gds_validate_string(COMMODITY_CODE_, node, 'COMMODITY_CODE')
            self.COMMODITY_CODE = COMMODITY_CODE_
            # validate type COMMODITY_CODEType1
            self.validate_COMMODITY_CODEType1(self.COMMODITY_CODE)
        elif nodeName_ == 'CODE':
            CODE_ = child_.text
            CODE_ = self.gds_validate_string(CODE_, node, 'CODE')
            self.CODE = CODE_
            # validate type CODEType
            self.validate_CODEType(self.CODE)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTIONType2
            self.validate_DESCRIPTIONType2(self.DESCRIPTION)
        elif nodeName_ == 'QUANTITY' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'QUANTITY')
            self.QUANTITY = fval_
            # validate type QUANTITYType
            self.validate_QUANTITYType(self.QUANTITY)
        elif nodeName_ == 'UNIT_OF_MEASURE':
            UNIT_OF_MEASURE_ = child_.text
            UNIT_OF_MEASURE_ = self.gds_validate_string(UNIT_OF_MEASURE_, node, 'UNIT_OF_MEASURE')
            self.UNIT_OF_MEASURE = UNIT_OF_MEASURE_
            # validate type UNIT_OF_MEASUREType3
            self.validate_UNIT_OF_MEASUREType3(self.UNIT_OF_MEASURE)
        elif nodeName_ == 'PRICE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PRICE')
            self.PRICE = fval_
            # validate type PRICEType
            self.validate_PRICEType(self.PRICE)
        elif nodeName_ == 'DISCOUNT_RATE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DISCOUNT_RATE')
            self.DISCOUNT_RATE = fval_
            # validate type DISCOUNT_RATEType4
            self.validate_DISCOUNT_RATEType4(self.DISCOUNT_RATE)
        elif nodeName_ == 'TAX_RATE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TAX_RATE')
            self.TAX_RATE = fval_
            # validate type TAX_RATEType5
            self.validate_TAX_RATEType5(self.TAX_RATE)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
            # validate type AMOUNTType
            self.validate_AMOUNTType(self.AMOUNT)
# end class ITEM


class CREATE_PAYMENT_LINK_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('PAY_NOW_BUTTON', 'xs:string', 0, 0, {'name': 'PAY_NOW_BUTTON', 'type': 'xs:string'}, None),
        MemberSpec_('PAY_NOW_URL', 'xs:string', 0, 0, {'name': 'PAY_NOW_URL', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, MERCHANTREF=None, PAY_NOW_BUTTON=None, PAY_NOW_URL=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.PAY_NOW_BUTTON = PAY_NOW_BUTTON
        self.PAY_NOW_URL = PAY_NOW_URL
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CREATE_PAYMENT_LINK_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CREATE_PAYMENT_LINK_RESPONSE.subclass:
            return CREATE_PAYMENT_LINK_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return CREATE_PAYMENT_LINK_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_PAY_NOW_BUTTON(self): return self.PAY_NOW_BUTTON
    def set_PAY_NOW_BUTTON(self, PAY_NOW_BUTTON): self.PAY_NOW_BUTTON = PAY_NOW_BUTTON
    def get_PAY_NOW_URL(self): return self.PAY_NOW_URL
    def set_PAY_NOW_URL(self, PAY_NOW_URL): self.PAY_NOW_URL = PAY_NOW_URL
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.MERCHANTREF is not None or
            self.PAY_NOW_BUTTON is not None or
            self.PAY_NOW_URL is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CREATE_PAYMENT_LINK_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.PAY_NOW_BUTTON is not None:
            PAY_NOW_BUTTON_ = self.PAY_NOW_BUTTON
            etree_.SubElement(element, '{}PAY_NOW_BUTTON').text = self.gds_format_string(PAY_NOW_BUTTON_)
        if self.PAY_NOW_URL is not None:
            PAY_NOW_URL_ = self.PAY_NOW_URL
            etree_.SubElement(element, '{}PAY_NOW_URL').text = self.gds_format_string(PAY_NOW_URL_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CREATE_PAYMENT_LINK_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.PAY_NOW_BUTTON is not None:
            showIndent(outfile, level)
            outfile.write('PAY_NOW_BUTTON=%s,\n' % self.gds_encode(quote_python(self.PAY_NOW_BUTTON)))
        if self.PAY_NOW_URL is not None:
            showIndent(outfile, level)
            outfile.write('PAY_NOW_URL=%s,\n' % self.gds_encode(quote_python(self.PAY_NOW_URL)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'PAY_NOW_BUTTON':
            PAY_NOW_BUTTON_ = child_.text
            PAY_NOW_BUTTON_ = self.gds_validate_string(PAY_NOW_BUTTON_, node, 'PAY_NOW_BUTTON')
            self.PAY_NOW_BUTTON = PAY_NOW_BUTTON_
        elif nodeName_ == 'PAY_NOW_URL':
            PAY_NOW_URL_ = child_.text
            PAY_NOW_URL_ = self.gds_validate_string(PAY_NOW_URL_, node, 'PAY_NOW_URL')
            self.PAY_NOW_URL = PAY_NOW_URL_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class CREATE_PAYMENT_LINK_RESPONSE


class SEND_PAYMENT_LINK_EMAIL(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOMER_NAME', ['CUSTOMER_NAMEType', 'xs:string'], 0, 0, {'name': 'CUSTOMER_NAME', 'type': 'xs:string'}, None),
        MemberSpec_('CUSTOMER_EMAIL', ['CUSTOMER_EMAILType', 'xs:string'], 0, 0, {'name': 'CUSTOMER_EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL_BODY', 'xs:string', 0, 1, {'name': 'EMAIL_BODY', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('LOGO_URL', ['LOGO_URLType', 'xs:string'], 0, 1, {'name': 'LOGO_URL', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('FOOTER_NOTES', ['FOOTER_NOTESType', 'xs:string'], 0, 1, {'name': 'FOOTER_NOTES', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, MERCHANTREF=None, CUSTOMER_NAME=None, CUSTOMER_EMAIL=None, EMAIL_BODY=None, LOGO_URL=None, FOOTER_NOTES=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.CUSTOMER_NAME = CUSTOMER_NAME
        self.validate_CUSTOMER_NAMEType(self.CUSTOMER_NAME)
        self.CUSTOMER_EMAIL = CUSTOMER_EMAIL
        self.validate_CUSTOMER_EMAILType(self.CUSTOMER_EMAIL)
        self.EMAIL_BODY = EMAIL_BODY
        self.LOGO_URL = LOGO_URL
        self.validate_LOGO_URLType(self.LOGO_URL)
        self.FOOTER_NOTES = FOOTER_NOTES
        self.validate_FOOTER_NOTESType(self.FOOTER_NOTES)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SEND_PAYMENT_LINK_EMAIL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SEND_PAYMENT_LINK_EMAIL.subclass:
            return SEND_PAYMENT_LINK_EMAIL.subclass(*args_, **kwargs_)
        else:
            return SEND_PAYMENT_LINK_EMAIL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_CUSTOMER_NAME(self): return self.CUSTOMER_NAME
    def set_CUSTOMER_NAME(self, CUSTOMER_NAME): self.CUSTOMER_NAME = CUSTOMER_NAME
    def get_CUSTOMER_EMAIL(self): return self.CUSTOMER_EMAIL
    def set_CUSTOMER_EMAIL(self, CUSTOMER_EMAIL): self.CUSTOMER_EMAIL = CUSTOMER_EMAIL
    def get_EMAIL_BODY(self): return self.EMAIL_BODY
    def set_EMAIL_BODY(self, EMAIL_BODY): self.EMAIL_BODY = EMAIL_BODY
    def get_LOGO_URL(self): return self.LOGO_URL
    def set_LOGO_URL(self, LOGO_URL): self.LOGO_URL = LOGO_URL
    def get_FOOTER_NOTES(self): return self.FOOTER_NOTES
    def set_FOOTER_NOTES(self, FOOTER_NOTES): self.FOOTER_NOTES = FOOTER_NOTES
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_CUSTOMER_NAMEType(self, value):
        # Validate type CUSTOMER_NAMEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CUSTOMER_NAMEType' % {"value" : value.encode("utf-8")} )
    def validate_CUSTOMER_EMAILType(self, value):
        # Validate type CUSTOMER_EMAILType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CUSTOMER_EMAILType' % {"value" : value.encode("utf-8")} )
    def validate_LOGO_URLType(self, value):
        # Validate type LOGO_URLType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 200:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on LOGO_URLType' % {"value" : value.encode("utf-8")} )
    def validate_FOOTER_NOTESType(self, value):
        # Validate type FOOTER_NOTESType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on FOOTER_NOTESType' % {"value" : value.encode("utf-8")} )
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.MERCHANTREF is not None or
            self.CUSTOMER_NAME is not None or
            self.CUSTOMER_EMAIL is not None or
            self.EMAIL_BODY is not None or
            self.LOGO_URL is not None or
            self.FOOTER_NOTES is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SEND_PAYMENT_LINK_EMAIL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.CUSTOMER_NAME is not None:
            CUSTOMER_NAME_ = self.CUSTOMER_NAME
            etree_.SubElement(element, '{}CUSTOMER_NAME').text = self.gds_format_string(CUSTOMER_NAME_)
        if self.CUSTOMER_EMAIL is not None:
            CUSTOMER_EMAIL_ = self.CUSTOMER_EMAIL
            etree_.SubElement(element, '{}CUSTOMER_EMAIL').text = self.gds_format_string(CUSTOMER_EMAIL_)
        if self.EMAIL_BODY is not None:
            EMAIL_BODY_ = self.EMAIL_BODY
            etree_.SubElement(element, '{}EMAIL_BODY').text = self.gds_format_string(EMAIL_BODY_)
        if self.LOGO_URL is not None:
            LOGO_URL_ = self.LOGO_URL
            etree_.SubElement(element, '{}LOGO_URL').text = self.gds_format_string(LOGO_URL_)
        if self.FOOTER_NOTES is not None:
            FOOTER_NOTES_ = self.FOOTER_NOTES
            etree_.SubElement(element, '{}FOOTER_NOTES').text = self.gds_format_string(FOOTER_NOTES_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SEND_PAYMENT_LINK_EMAIL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.CUSTOMER_NAME is not None:
            showIndent(outfile, level)
            outfile.write('CUSTOMER_NAME=%s,\n' % self.gds_encode(quote_python(self.CUSTOMER_NAME)))
        if self.CUSTOMER_EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('CUSTOMER_EMAIL=%s,\n' % self.gds_encode(quote_python(self.CUSTOMER_EMAIL)))
        if self.EMAIL_BODY is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL_BODY=%s,\n' % self.gds_encode(quote_python(self.EMAIL_BODY)))
        if self.LOGO_URL is not None:
            showIndent(outfile, level)
            outfile.write('LOGO_URL=%s,\n' % self.gds_encode(quote_python(self.LOGO_URL)))
        if self.FOOTER_NOTES is not None:
            showIndent(outfile, level)
            outfile.write('FOOTER_NOTES=%s,\n' % self.gds_encode(quote_python(self.FOOTER_NOTES)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'CUSTOMER_NAME':
            CUSTOMER_NAME_ = child_.text
            CUSTOMER_NAME_ = self.gds_validate_string(CUSTOMER_NAME_, node, 'CUSTOMER_NAME')
            self.CUSTOMER_NAME = CUSTOMER_NAME_
            # validate type CUSTOMER_NAMEType
            self.validate_CUSTOMER_NAMEType(self.CUSTOMER_NAME)
        elif nodeName_ == 'CUSTOMER_EMAIL':
            CUSTOMER_EMAIL_ = child_.text
            CUSTOMER_EMAIL_ = self.gds_validate_string(CUSTOMER_EMAIL_, node, 'CUSTOMER_EMAIL')
            self.CUSTOMER_EMAIL = CUSTOMER_EMAIL_
            # validate type CUSTOMER_EMAILType
            self.validate_CUSTOMER_EMAILType(self.CUSTOMER_EMAIL)
        elif nodeName_ == 'EMAIL_BODY':
            EMAIL_BODY_ = child_.text
            EMAIL_BODY_ = self.gds_validate_string(EMAIL_BODY_, node, 'EMAIL_BODY')
            self.EMAIL_BODY = EMAIL_BODY_
        elif nodeName_ == 'LOGO_URL':
            LOGO_URL_ = child_.text
            LOGO_URL_ = self.gds_validate_string(LOGO_URL_, node, 'LOGO_URL')
            self.LOGO_URL = LOGO_URL_
            # validate type LOGO_URLType
            self.validate_LOGO_URLType(self.LOGO_URL)
        elif nodeName_ == 'FOOTER_NOTES':
            FOOTER_NOTES_ = child_.text
            FOOTER_NOTES_ = self.gds_validate_string(FOOTER_NOTES_, node, 'FOOTER_NOTES')
            self.FOOTER_NOTES = FOOTER_NOTES_
            # validate type FOOTER_NOTESType
            self.validate_FOOTER_NOTESType(self.FOOTER_NOTES)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID, self.MERCHANTREF, self.CUSTOMER_NAME, self.CUSTOMER_EMAIL, self.DATETIME]
        return ':'.join(hash_list)
# end class SEND_PAYMENT_LINK_EMAIL


class SEND_PAYMENT_LINK_EMAIL_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SEND_PAYMENT_LINK_EMAIL_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SEND_PAYMENT_LINK_EMAIL_RESPONSE.subclass:
            return SEND_PAYMENT_LINK_EMAIL_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return SEND_PAYMENT_LINK_EMAIL_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SEND_PAYMENT_LINK_EMAIL_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SEND_PAYMENT_LINK_EMAIL_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class SEND_PAYMENT_LINK_EMAIL_RESPONSE


class CANCEL_PAYMENT_LINK(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CANCEL_PAYMENT_LINK)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CANCEL_PAYMENT_LINK.subclass:
            return CANCEL_PAYMENT_LINK.subclass(*args_, **kwargs_)
        else:
            return CANCEL_PAYMENT_LINK(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CANCEL_PAYMENT_LINK', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CANCEL_PAYMENT_LINK'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class CANCEL_PAYMENT_LINK


class CANCEL_PAYMENT_LINK_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CANCEL_PAYMENT_LINK_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CANCEL_PAYMENT_LINK_RESPONSE.subclass:
            return CANCEL_PAYMENT_LINK_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return CANCEL_PAYMENT_LINK_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CANCEL_PAYMENT_LINK_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CANCEL_PAYMENT_LINK_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class CANCEL_PAYMENT_LINK_RESPONSE


class GET_PAYMENT_LINK(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GET_PAYMENT_LINK)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GET_PAYMENT_LINK.subclass:
            return GET_PAYMENT_LINK.subclass(*args_, **kwargs_)
        else:
            return GET_PAYMENT_LINK(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='GET_PAYMENT_LINK', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GET_PAYMENT_LINK'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class GET_PAYMENT_LINK


class GET_PAYMENT_LINK_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('AUTH_TYPE', ['AUTH_TYPE', 'xs:int'], 0, 0, {'ref': 'AUTH_TYPE', 'name': 'AUTH_TYPE', 'type': 'xs:int'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('CREATION_DATE', ['CREATION_DATEType6', 'xs:string'], 0, 0, {'name': 'CREATION_DATE', 'type': 'xs:string'}, None),
        MemberSpec_('EXPIRATION_DATE', ['EXPIRATION_DATEType7', 'xs:string'], 0, 0, {'name': 'EXPIRATION_DATE', 'type': 'xs:string'}, None),
        MemberSpec_('PAYMENT_LINK_STATUS', ['PAYMENT_LINK_STATUS', 'xs:string'], 0, 0, {'ref': 'PAYMENT_LINK_STATUS', 'name': 'PAYMENT_LINK_STATUS', 'type': 'xs:string'}, None),
        MemberSpec_('PAY_NOW_URL', 'xs:string', 0, 0, {'name': 'PAY_NOW_URL', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, MERCHANTREF=None, ORDERID=None, AUTH_TYPE=None, CURRENCY=None, AMOUNT=None, DESCRIPTION=None, CREATION_DATE=None, EXPIRATION_DATE=None, PAYMENT_LINK_STATUS=None, PAY_NOW_URL=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.AUTH_TYPE = AUTH_TYPE
        self.validate_AUTH_TYPE(self.AUTH_TYPE)
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.AMOUNT = AMOUNT
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.CREATION_DATE = CREATION_DATE
        self.validate_CREATION_DATEType6(self.CREATION_DATE)
        self.EXPIRATION_DATE = EXPIRATION_DATE
        self.validate_EXPIRATION_DATEType7(self.EXPIRATION_DATE)
        self.PAYMENT_LINK_STATUS = PAYMENT_LINK_STATUS
        self.validate_PAYMENT_LINK_STATUS(self.PAYMENT_LINK_STATUS)
        self.PAY_NOW_URL = PAY_NOW_URL
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GET_PAYMENT_LINK_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GET_PAYMENT_LINK_RESPONSE.subclass:
            return GET_PAYMENT_LINK_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return GET_PAYMENT_LINK_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_AUTH_TYPE(self): return self.AUTH_TYPE
    def set_AUTH_TYPE(self, AUTH_TYPE): self.AUTH_TYPE = AUTH_TYPE
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_CREATION_DATE(self): return self.CREATION_DATE
    def set_CREATION_DATE(self, CREATION_DATE): self.CREATION_DATE = CREATION_DATE
    def get_EXPIRATION_DATE(self): return self.EXPIRATION_DATE
    def set_EXPIRATION_DATE(self, EXPIRATION_DATE): self.EXPIRATION_DATE = EXPIRATION_DATE
    def get_PAYMENT_LINK_STATUS(self): return self.PAYMENT_LINK_STATUS
    def set_PAYMENT_LINK_STATUS(self, PAYMENT_LINK_STATUS): self.PAYMENT_LINK_STATUS = PAYMENT_LINK_STATUS
    def get_PAY_NOW_URL(self): return self.PAY_NOW_URL
    def set_PAY_NOW_URL(self, PAY_NOW_URL): self.PAY_NOW_URL = PAY_NOW_URL
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_AUTH_TYPE(self, value):
        # Validate type AUTH_TYPE, a restriction on xs:int.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_CREATION_DATEType6(self, value):
        # Validate type CREATION_DATEType6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CREATION_DATEType6' % {"value" : value.encode("utf-8")} )
            if len(value) < 10:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CREATION_DATEType6' % {"value" : value.encode("utf-8")} )
    def validate_EXPIRATION_DATEType7(self, value):
        # Validate type EXPIRATION_DATEType7, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on EXPIRATION_DATEType7' % {"value" : value.encode("utf-8")} )
            if len(value) < 10:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on EXPIRATION_DATEType7' % {"value" : value.encode("utf-8")} )
    def validate_PAYMENT_LINK_STATUS(self, value):
        # Validate type PAYMENT_LINK_STATUS, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.MERCHANTREF is not None or
            self.ORDERID is not None or
            self.AUTH_TYPE is not None or
            self.CURRENCY is not None or
            self.AMOUNT is not None or
            self.DESCRIPTION is not None or
            self.CREATION_DATE is not None or
            self.EXPIRATION_DATE is not None or
            self.PAYMENT_LINK_STATUS is not None or
            self.PAY_NOW_URL is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='GET_PAYMENT_LINK_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.AUTH_TYPE is not None:
            AUTH_TYPE_ = self.AUTH_TYPE
            etree_.SubElement(element, '{}AUTH_TYPE').text = self.gds_format_integer(AUTH_TYPE_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.CREATION_DATE is not None:
            CREATION_DATE_ = self.CREATION_DATE
            etree_.SubElement(element, '{}CREATION_DATE').text = self.gds_format_string(CREATION_DATE_)
        if self.EXPIRATION_DATE is not None:
            EXPIRATION_DATE_ = self.EXPIRATION_DATE
            etree_.SubElement(element, '{}EXPIRATION_DATE').text = self.gds_format_string(EXPIRATION_DATE_)
        if self.PAYMENT_LINK_STATUS is not None:
            PAYMENT_LINK_STATUS_ = self.PAYMENT_LINK_STATUS
            etree_.SubElement(element, '{}PAYMENT_LINK_STATUS').text = self.gds_format_string(PAYMENT_LINK_STATUS_)
        if self.PAY_NOW_URL is not None:
            PAY_NOW_URL_ = self.PAY_NOW_URL
            etree_.SubElement(element, '{}PAY_NOW_URL').text = self.gds_format_string(PAY_NOW_URL_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GET_PAYMENT_LINK_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.AUTH_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('AUTH_TYPE=%d,\n' % self.AUTH_TYPE)
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.CREATION_DATE is not None:
            showIndent(outfile, level)
            outfile.write('CREATION_DATE=%s,\n' % self.gds_encode(quote_python(self.CREATION_DATE)))
        if self.EXPIRATION_DATE is not None:
            showIndent(outfile, level)
            outfile.write('EXPIRATION_DATE=%s,\n' % self.gds_encode(quote_python(self.EXPIRATION_DATE)))
        if self.PAYMENT_LINK_STATUS is not None:
            showIndent(outfile, level)
            outfile.write('PAYMENT_LINK_STATUS=%s,\n' % self.gds_encode(quote_python(self.PAYMENT_LINK_STATUS)))
        if self.PAY_NOW_URL is not None:
            showIndent(outfile, level)
            outfile.write('PAY_NOW_URL=%s,\n' % self.gds_encode(quote_python(self.PAY_NOW_URL)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'AUTH_TYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AUTH_TYPE')
            self.AUTH_TYPE = ival_
            # validate type AUTH_TYPE
            self.validate_AUTH_TYPE(self.AUTH_TYPE)
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'CREATION_DATE':
            CREATION_DATE_ = child_.text
            CREATION_DATE_ = self.gds_validate_string(CREATION_DATE_, node, 'CREATION_DATE')
            self.CREATION_DATE = CREATION_DATE_
            # validate type CREATION_DATEType6
            self.validate_CREATION_DATEType6(self.CREATION_DATE)
        elif nodeName_ == 'EXPIRATION_DATE':
            EXPIRATION_DATE_ = child_.text
            EXPIRATION_DATE_ = self.gds_validate_string(EXPIRATION_DATE_, node, 'EXPIRATION_DATE')
            self.EXPIRATION_DATE = EXPIRATION_DATE_
            # validate type EXPIRATION_DATEType7
            self.validate_EXPIRATION_DATEType7(self.EXPIRATION_DATE)
        elif nodeName_ == 'PAYMENT_LINK_STATUS':
            PAYMENT_LINK_STATUS_ = child_.text
            PAYMENT_LINK_STATUS_ = self.gds_validate_string(PAYMENT_LINK_STATUS_, node, 'PAYMENT_LINK_STATUS')
            self.PAYMENT_LINK_STATUS = PAYMENT_LINK_STATUS_
            # validate type PAYMENT_LINK_STATUS
            self.validate_PAYMENT_LINK_STATUS(self.PAYMENT_LINK_STATUS)
        elif nodeName_ == 'PAY_NOW_URL':
            PAY_NOW_URL_ = child_.text
            PAY_NOW_URL_ = self.gds_validate_string(PAY_NOW_URL_, node, 'PAY_NOW_URL')
            self.PAY_NOW_URL = PAY_NOW_URL_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class GET_PAYMENT_LINK_RESPONSE


class ACCOUNT_VERIFICATION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 0, {'ref': 'CARDNUMBER', 'name': 'CARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 0, {'ref': 'CARDEXPIRY', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 0, {'ref': 'CARDHOLDERNAME', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('CVV', ['CVV', 'xs:string'], 0, 1, {'ref': 'CVV', 'minOccurs': '0', 'name': 'CVV', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, CARDNUMBER=None, CARDEXPIRY=None, CARDHOLDERNAME=None, CVV=None, ADDRESS1=None, ADDRESS2=None, POSTCODE=None, CREDENTIALONFILE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.CVV = CVV
        self.validate_CVV(self.CVV)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACCOUNT_VERIFICATION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACCOUNT_VERIFICATION.subclass:
            return ACCOUNT_VERIFICATION.subclass(*args_, **kwargs_)
        else:
            return ACCOUNT_VERIFICATION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_CVV(self): return self.CVV
    def set_CVV(self, CVV): self.CVV = CVV
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_CVV(self, value):
        # Validate type CVV, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.CARDNUMBER is not None or
            self.CARDEXPIRY is not None or
            self.CARDHOLDERNAME is not None or
            self.CVV is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.POSTCODE is not None or
            self.CREDENTIALONFILE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACCOUNT_VERIFICATION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.CVV is not None:
            CVV_ = self.CVV
            etree_.SubElement(element, '{}CVV').text = self.gds_format_string(CVV_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACCOUNT_VERIFICATION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.CVV is not None:
            showIndent(outfile, level)
            outfile.write('CVV=%s,\n' % self.gds_encode(quote_python(self.CVV)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'CVV':
            CVV_ = child_.text
            CVV_ = self.gds_validate_string(CVV_, node, 'CVV')
            self.CVV = CVV_
            # validate type CVV
            self.validate_CVV(self.CVV)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.TERMINALID]
        hash_list.append(self.CARDNUMBER)
        hash_list.append(self.CARDEXPIRY)
        hash_list.append(self.CARDHOLDERNAME)
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class ACCOUNT_VERIFICATION


class ACCOUNT_VERIFICATION_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('STATUS', ['STATUSType', 'xs:string'], 0, 0, {'name': 'STATUS', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSE_DETAIL', 'xs:string', 0, 1, {'name': 'RESPONSE_DETAIL', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, STATUS=None, RESPONSE_DETAIL=None, CREDENTIALONFILE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.STATUS = STATUS
        self.validate_STATUSType(self.STATUS)
        self.RESPONSE_DETAIL = RESPONSE_DETAIL
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACCOUNT_VERIFICATION_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACCOUNT_VERIFICATION_RESPONSE.subclass:
            return ACCOUNT_VERIFICATION_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return ACCOUNT_VERIFICATION_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STATUS(self): return self.STATUS
    def set_STATUS(self, STATUS): self.STATUS = STATUS
    def get_RESPONSE_DETAIL(self): return self.RESPONSE_DETAIL
    def set_RESPONSE_DETAIL(self, RESPONSE_DETAIL): self.RESPONSE_DETAIL = RESPONSE_DETAIL
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_STATUSType(self, value):
        # Validate type STATUSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['VERIFIED', 'UNVERIFIED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on STATUSType' % {"value" : value.encode("utf-8")} )
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.STATUS is not None or
            self.RESPONSE_DETAIL is not None or
            self.CREDENTIALONFILE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACCOUNT_VERIFICATION_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.STATUS is not None:
            STATUS_ = self.STATUS
            etree_.SubElement(element, '{}STATUS').text = self.gds_format_string(STATUS_)
        if self.RESPONSE_DETAIL is not None:
            RESPONSE_DETAIL_ = self.RESPONSE_DETAIL
            etree_.SubElement(element, '{}RESPONSE_DETAIL').text = self.gds_format_string(RESPONSE_DETAIL_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACCOUNT_VERIFICATION_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.STATUS is not None:
            showIndent(outfile, level)
            outfile.write('STATUS=%s,\n' % self.gds_encode(quote_python(self.STATUS)))
        if self.RESPONSE_DETAIL is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSE_DETAIL=%s,\n' % self.gds_encode(quote_python(self.RESPONSE_DETAIL)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STATUS':
            STATUS_ = child_.text
            STATUS_ = self.gds_validate_string(STATUS_, node, 'STATUS')
            self.STATUS = STATUS_
            # validate type STATUSType
            self.validate_STATUSType(self.STATUS)
        elif nodeName_ == 'RESPONSE_DETAIL':
            RESPONSE_DETAIL_ = child_.text
            RESPONSE_DETAIL_ = self.gds_validate_string(RESPONSE_DETAIL_, node, 'RESPONSE_DETAIL')
            self.RESPONSE_DETAIL = RESPONSE_DETAIL_
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)


    @property
    def hash_string(self):
        hash_list = [self.terminal_id]
        hash_list.append(self.STATUS)
        if self.RESPONSE_DETAIL:
            hash_list.append(self.RESPONSE_DETAIL)
        hash_list.append(self.DATETIME)
        return ':'.join(hash_list)
# end class ACCOUNT_VERIFICATION_RESPONSE


class RESPONSE_DETAIL(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RESPONSE_DETAIL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RESPONSE_DETAIL.subclass:
            return RESPONSE_DETAIL.subclass(*args_, **kwargs_)
        else:
            return RESPONSE_DETAIL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RESPONSE_DETAIL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RESPONSE_DETAIL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RESPONSE_DETAIL


class GET_TRANSACTION_DETAILS(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, 10),
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, 10),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, UNIQUEREF=None, ORDERID=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.UNIQUEREF = UNIQUEREF
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GET_TRANSACTION_DETAILS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GET_TRANSACTION_DETAILS.subclass:
            return GET_TRANSACTION_DETAILS.subclass(*args_, **kwargs_)
        else:
            return GET_TRANSACTION_DETAILS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.UNIQUEREF is not None or
            self.ORDERID is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='GET_TRANSACTION_DETAILS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GET_TRANSACTION_DETAILS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class GET_TRANSACTION_DETAILS


class GET_TRANSACTION_DETAILS_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 0, {'ref': 'UNIQUEREF', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TRANSACTION_STATUS', 'xs:string', 0, 0, {'name': 'TRANSACTION_STATUS', 'type': 'xs:string'}, None),
        MemberSpec_('TRANSACTION_DATE', ['TRANSACTION_DATEType', 'xs:string'], 0, 0, {'name': 'TRANSACTION_DATE', 'type': 'xs:string'}, None),
        MemberSpec_('OPERATOR', ['OPERATOR', 'xs:string'], 0, 1, {'ref': 'OPERATOR', 'minOccurs': '0', 'name': 'OPERATOR', 'type': 'xs:string'}, None),
        MemberSpec_('TRANSACTION_TYPE', ['TRANSACTION_TYPEType', 'xs:string'], 0, 0, {'name': 'TRANSACTION_TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('AUTHORIZEDAMOUNT', 'xs:double', 0, 0, {'ref': 'AUTHORIZEDAMOUNT', 'name': 'AUTHORIZEDAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('ADDITIONAL_DETAILS', 'ADDITIONAL_DETAILSType', 0, 0, {'name': 'ADDITIONAL_DETAILS', 'type': 'ADDITIONAL_DETAILSType'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, UNIQUEREF=None, ORDERID=None, TRANSACTION_STATUS=None, TRANSACTION_DATE=None, OPERATOR=None, TRANSACTION_TYPE=None, CURRENCY=None, AUTHORIZEDAMOUNT=None, ADDITIONAL_DETAILS=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.UNIQUEREF = UNIQUEREF
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TRANSACTION_STATUS = TRANSACTION_STATUS
        self.TRANSACTION_DATE = TRANSACTION_DATE
        self.validate_TRANSACTION_DATEType(self.TRANSACTION_DATE)
        self.OPERATOR = OPERATOR
        self.validate_OPERATOR(self.OPERATOR)
        self.TRANSACTION_TYPE = TRANSACTION_TYPE
        self.validate_TRANSACTION_TYPEType(self.TRANSACTION_TYPE)
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.AUTHORIZEDAMOUNT = AUTHORIZEDAMOUNT
        self.ADDITIONAL_DETAILS = ADDITIONAL_DETAILS
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GET_TRANSACTION_DETAILS_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GET_TRANSACTION_DETAILS_RESPONSE.subclass:
            return GET_TRANSACTION_DETAILS_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return GET_TRANSACTION_DETAILS_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TRANSACTION_STATUS(self): return self.TRANSACTION_STATUS
    def set_TRANSACTION_STATUS(self, TRANSACTION_STATUS): self.TRANSACTION_STATUS = TRANSACTION_STATUS
    def get_TRANSACTION_DATE(self): return self.TRANSACTION_DATE
    def set_TRANSACTION_DATE(self, TRANSACTION_DATE): self.TRANSACTION_DATE = TRANSACTION_DATE
    def get_OPERATOR(self): return self.OPERATOR
    def set_OPERATOR(self, OPERATOR): self.OPERATOR = OPERATOR
    def get_TRANSACTION_TYPE(self): return self.TRANSACTION_TYPE
    def set_TRANSACTION_TYPE(self, TRANSACTION_TYPE): self.TRANSACTION_TYPE = TRANSACTION_TYPE
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_AUTHORIZEDAMOUNT(self): return self.AUTHORIZEDAMOUNT
    def set_AUTHORIZEDAMOUNT(self, AUTHORIZEDAMOUNT): self.AUTHORIZEDAMOUNT = AUTHORIZEDAMOUNT
    def get_ADDITIONAL_DETAILS(self): return self.ADDITIONAL_DETAILS
    def set_ADDITIONAL_DETAILS(self, ADDITIONAL_DETAILS): self.ADDITIONAL_DETAILS = ADDITIONAL_DETAILS
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TRANSACTION_DATEType(self, value):
        # Validate type TRANSACTION_DATEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TRANSACTION_DATEType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TRANSACTION_DATEType' % {"value" : value.encode("utf-8")} )
    def validate_OPERATOR(self, value):
        # Validate type OPERATOR, a restriction on xs:string.
        pass
    def validate_TRANSACTION_TYPEType(self, value):
        # Validate type TRANSACTION_TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SALE', 'REFUND', 'PREAUTH', 'COMPLETION']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TRANSACTION_TYPEType' % {"value" : value.encode("utf-8")} )
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.UNIQUEREF is not None or
            self.ORDERID is not None or
            self.TRANSACTION_STATUS is not None or
            self.TRANSACTION_DATE is not None or
            self.OPERATOR is not None or
            self.TRANSACTION_TYPE is not None or
            self.CURRENCY is not None or
            self.AUTHORIZEDAMOUNT is not None or
            self.ADDITIONAL_DETAILS is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='GET_TRANSACTION_DETAILS_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TRANSACTION_STATUS is not None:
            TRANSACTION_STATUS_ = self.TRANSACTION_STATUS
            etree_.SubElement(element, '{}TRANSACTION_STATUS').text = self.gds_format_string(TRANSACTION_STATUS_)
        if self.TRANSACTION_DATE is not None:
            TRANSACTION_DATE_ = self.TRANSACTION_DATE
            etree_.SubElement(element, '{}TRANSACTION_DATE').text = self.gds_format_string(TRANSACTION_DATE_)
        if self.OPERATOR is not None:
            OPERATOR_ = self.OPERATOR
            etree_.SubElement(element, '{}OPERATOR').text = self.gds_format_string(OPERATOR_)
        if self.TRANSACTION_TYPE is not None:
            TRANSACTION_TYPE_ = self.TRANSACTION_TYPE
            etree_.SubElement(element, '{}TRANSACTION_TYPE').text = self.gds_format_string(TRANSACTION_TYPE_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.AUTHORIZEDAMOUNT is not None:
            AUTHORIZEDAMOUNT_ = self.AUTHORIZEDAMOUNT
            etree_.SubElement(element, '{}AUTHORIZEDAMOUNT').text = self.gds_format_double(AUTHORIZEDAMOUNT_)
        if self.ADDITIONAL_DETAILS is not None:
            ADDITIONAL_DETAILS_ = self.ADDITIONAL_DETAILS
            ADDITIONAL_DETAILS_.to_etree(element, name_='ADDITIONAL_DETAILS', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GET_TRANSACTION_DETAILS_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TRANSACTION_STATUS is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTION_STATUS=%s,\n' % self.gds_encode(quote_python(self.TRANSACTION_STATUS)))
        if self.TRANSACTION_DATE is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTION_DATE=%s,\n' % self.gds_encode(quote_python(self.TRANSACTION_DATE)))
        if self.OPERATOR is not None:
            showIndent(outfile, level)
            outfile.write('OPERATOR=%s,\n' % self.gds_encode(quote_python(self.OPERATOR)))
        if self.TRANSACTION_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTION_TYPE=%s,\n' % self.gds_encode(quote_python(self.TRANSACTION_TYPE)))
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.AUTHORIZEDAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AUTHORIZEDAMOUNT=%e,\n' % self.AUTHORIZEDAMOUNT)
        if self.ADDITIONAL_DETAILS is not None:
            showIndent(outfile, level)
            outfile.write('ADDITIONAL_DETAILS=model_.ADDITIONAL_DETAILSType(\n')
            self.ADDITIONAL_DETAILS.exportLiteral(outfile, level, name_='ADDITIONAL_DETAILS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TRANSACTION_STATUS':
            TRANSACTION_STATUS_ = child_.text
            TRANSACTION_STATUS_ = self.gds_validate_string(TRANSACTION_STATUS_, node, 'TRANSACTION_STATUS')
            self.TRANSACTION_STATUS = TRANSACTION_STATUS_
        elif nodeName_ == 'TRANSACTION_DATE':
            TRANSACTION_DATE_ = child_.text
            TRANSACTION_DATE_ = self.gds_validate_string(TRANSACTION_DATE_, node, 'TRANSACTION_DATE')
            self.TRANSACTION_DATE = TRANSACTION_DATE_
            # validate type TRANSACTION_DATEType
            self.validate_TRANSACTION_DATEType(self.TRANSACTION_DATE)
        elif nodeName_ == 'OPERATOR':
            OPERATOR_ = child_.text
            OPERATOR_ = self.gds_validate_string(OPERATOR_, node, 'OPERATOR')
            self.OPERATOR = OPERATOR_
            # validate type OPERATOR
            self.validate_OPERATOR(self.OPERATOR)
        elif nodeName_ == 'TRANSACTION_TYPE':
            TRANSACTION_TYPE_ = child_.text
            TRANSACTION_TYPE_ = self.gds_validate_string(TRANSACTION_TYPE_, node, 'TRANSACTION_TYPE')
            self.TRANSACTION_TYPE = TRANSACTION_TYPE_
            # validate type TRANSACTION_TYPEType
            self.validate_TRANSACTION_TYPEType(self.TRANSACTION_TYPE)
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'AUTHORIZEDAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AUTHORIZEDAMOUNT')
            self.AUTHORIZEDAMOUNT = fval_
        elif nodeName_ == 'ADDITIONAL_DETAILS':
            obj_ = ADDITIONAL_DETAILSType.factory()
            obj_.build(child_)
            self.ADDITIONAL_DETAILS = obj_
            obj_.original_tagname_ = 'ADDITIONAL_DETAILS'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
# end class GET_TRANSACTION_DETAILS_RESPONSE


class SHIPPING_ADDRESSType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('FULL_NAME', ['FULL_NAMEType', 'xs:string'], 0, 1, {'name': 'FULL_NAME', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, FULL_NAME=None, ADDRESS1=None, ADDRESS2=None, CITY=None, REGION=None, POSTCODE=None, COUNTRY=None):
        self.original_tagname_ = None
        self.FULL_NAME = FULL_NAME
        self.validate_FULL_NAMEType(self.FULL_NAME)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SHIPPING_ADDRESSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SHIPPING_ADDRESSType.subclass:
            return SHIPPING_ADDRESSType.subclass(*args_, **kwargs_)
        else:
            return SHIPPING_ADDRESSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FULL_NAME(self): return self.FULL_NAME
    def set_FULL_NAME(self, FULL_NAME): self.FULL_NAME = FULL_NAME
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def validate_FULL_NAMEType(self, value):
        # Validate type FULL_NAMEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on FULL_NAMEType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on FULL_NAMEType' % {"value" : value.encode("utf-8")} )
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.FULL_NAME is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.POSTCODE is not None or
            self.COUNTRY is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SHIPPING_ADDRESSType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.FULL_NAME is not None:
            FULL_NAME_ = self.FULL_NAME
            etree_.SubElement(element, '{}FULL_NAME').text = self.gds_format_string(FULL_NAME_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SHIPPING_ADDRESSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FULL_NAME is not None:
            showIndent(outfile, level)
            outfile.write('FULL_NAME=%s,\n' % self.gds_encode(quote_python(self.FULL_NAME)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FULL_NAME':
            FULL_NAME_ = child_.text
            FULL_NAME_ = self.gds_validate_string(FULL_NAME_, node, 'FULL_NAME')
            self.FULL_NAME = FULL_NAME_
            # validate type FULL_NAMEType
            self.validate_FULL_NAMEType(self.FULL_NAME)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)


    @property
    def hash_string(self):
        hash_list = []
        if self.FULL_NAME:
            hash_list.append(self.FULL_NAME)
        if self.ADDRESS1:
            hash_list.append(self.ADDRESS1)
        if self.ADDRESS2:
            hash_list.append(self.ADDRESS2)
        if self.CITY:
            hash_list.append(self.CITY)
        if self.REGION:
            hash_list.append(self.REGION)
        if self.POSTCODE:
            hash_list.append(self.POSTCODE)
        if self.COUNTRY:
            hash_list.append(self.COUNTRY)
        return ':'.join(hash_list)
# end class SHIPPING_ADDRESSType


class SUMMARYType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TOTAL_DISCOUNT_AMOUNT', 'emptyDecimalAllowed', 0, 1, {'name': 'TOTAL_DISCOUNT_AMOUNT', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('TOTAL_FREIGHT_AMOUNT', 'emptyDecimalAllowed', 0, 1, {'name': 'TOTAL_FREIGHT_AMOUNT', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('TOTAL_DUTY_AMOUNT', 'emptyDecimalAllowed', 0, 1, {'name': 'TOTAL_DUTY_AMOUNT', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TOTAL_DISCOUNT_AMOUNT=None, TOTAL_FREIGHT_AMOUNT=None, TOTAL_DUTY_AMOUNT=None):
        self.original_tagname_ = None
        self.TOTAL_DISCOUNT_AMOUNT = TOTAL_DISCOUNT_AMOUNT
        self.validate_emptyDecimalAllowed(self.TOTAL_DISCOUNT_AMOUNT)
        self.TOTAL_FREIGHT_AMOUNT = TOTAL_FREIGHT_AMOUNT
        self.validate_emptyDecimalAllowed(self.TOTAL_FREIGHT_AMOUNT)
        self.TOTAL_DUTY_AMOUNT = TOTAL_DUTY_AMOUNT
        self.validate_emptyDecimalAllowed(self.TOTAL_DUTY_AMOUNT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUMMARYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUMMARYType.subclass:
            return SUMMARYType.subclass(*args_, **kwargs_)
        else:
            return SUMMARYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TOTAL_DISCOUNT_AMOUNT(self): return self.TOTAL_DISCOUNT_AMOUNT
    def set_TOTAL_DISCOUNT_AMOUNT(self, TOTAL_DISCOUNT_AMOUNT): self.TOTAL_DISCOUNT_AMOUNT = TOTAL_DISCOUNT_AMOUNT
    def get_TOTAL_FREIGHT_AMOUNT(self): return self.TOTAL_FREIGHT_AMOUNT
    def set_TOTAL_FREIGHT_AMOUNT(self, TOTAL_FREIGHT_AMOUNT): self.TOTAL_FREIGHT_AMOUNT = TOTAL_FREIGHT_AMOUNT
    def get_TOTAL_DUTY_AMOUNT(self): return self.TOTAL_DUTY_AMOUNT
    def set_TOTAL_DUTY_AMOUNT(self, TOTAL_DUTY_AMOUNT): self.TOTAL_DUTY_AMOUNT = TOTAL_DUTY_AMOUNT
    def validate_emptyDecimalAllowed(self, value):
        # Validate type emptyDecimalAllowed, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.TOTAL_DISCOUNT_AMOUNT is not None or
            self.TOTAL_FREIGHT_AMOUNT is not None or
            self.TOTAL_DUTY_AMOUNT is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SUMMARYType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TOTAL_DISCOUNT_AMOUNT is not None:
            TOTAL_DISCOUNT_AMOUNT_ = self.TOTAL_DISCOUNT_AMOUNT
            etree_.SubElement(element, '{}TOTAL_DISCOUNT_AMOUNT').text = self.gds_format_string(TOTAL_DISCOUNT_AMOUNT_)
        if self.TOTAL_FREIGHT_AMOUNT is not None:
            TOTAL_FREIGHT_AMOUNT_ = self.TOTAL_FREIGHT_AMOUNT
            etree_.SubElement(element, '{}TOTAL_FREIGHT_AMOUNT').text = self.gds_format_string(TOTAL_FREIGHT_AMOUNT_)
        if self.TOTAL_DUTY_AMOUNT is not None:
            TOTAL_DUTY_AMOUNT_ = self.TOTAL_DUTY_AMOUNT
            etree_.SubElement(element, '{}TOTAL_DUTY_AMOUNT').text = self.gds_format_string(TOTAL_DUTY_AMOUNT_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SUMMARYType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TOTAL_DISCOUNT_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TOTAL_DISCOUNT_AMOUNT=%s,\n' % self.gds_encode(quote_python(self.TOTAL_DISCOUNT_AMOUNT)))
        if self.TOTAL_FREIGHT_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TOTAL_FREIGHT_AMOUNT=%s,\n' % self.gds_encode(quote_python(self.TOTAL_FREIGHT_AMOUNT)))
        if self.TOTAL_DUTY_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TOTAL_DUTY_AMOUNT=%s,\n' % self.gds_encode(quote_python(self.TOTAL_DUTY_AMOUNT)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TOTAL_DISCOUNT_AMOUNT':
            TOTAL_DISCOUNT_AMOUNT_ = child_.text
            TOTAL_DISCOUNT_AMOUNT_ = self.gds_validate_string(TOTAL_DISCOUNT_AMOUNT_, node, 'TOTAL_DISCOUNT_AMOUNT')
            self.TOTAL_DISCOUNT_AMOUNT = TOTAL_DISCOUNT_AMOUNT_
            # validate type emptyDecimalAllowed
            self.validate_emptyDecimalAllowed(self.TOTAL_DISCOUNT_AMOUNT)
        elif nodeName_ == 'TOTAL_FREIGHT_AMOUNT':
            TOTAL_FREIGHT_AMOUNT_ = child_.text
            TOTAL_FREIGHT_AMOUNT_ = self.gds_validate_string(TOTAL_FREIGHT_AMOUNT_, node, 'TOTAL_FREIGHT_AMOUNT')
            self.TOTAL_FREIGHT_AMOUNT = TOTAL_FREIGHT_AMOUNT_
            # validate type emptyDecimalAllowed
            self.validate_emptyDecimalAllowed(self.TOTAL_FREIGHT_AMOUNT)
        elif nodeName_ == 'TOTAL_DUTY_AMOUNT':
            TOTAL_DUTY_AMOUNT_ = child_.text
            TOTAL_DUTY_AMOUNT_ = self.gds_validate_string(TOTAL_DUTY_AMOUNT_, node, 'TOTAL_DUTY_AMOUNT')
            self.TOTAL_DUTY_AMOUNT = TOTAL_DUTY_AMOUNT_
            # validate type emptyDecimalAllowed
            self.validate_emptyDecimalAllowed(self.TOTAL_DUTY_AMOUNT)
# end class SUMMARYType


class LINE_ITEMSType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('LINE_ITEM', 'LINE_ITEMType', 1, 1, {'name': 'LINE_ITEM', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'type': 'LINE_ITEMType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, LINE_ITEM=None):
        self.original_tagname_ = None
        if LINE_ITEM is None:
            self.LINE_ITEM = []
        else:
            self.LINE_ITEM = LINE_ITEM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LINE_ITEMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LINE_ITEMSType.subclass:
            return LINE_ITEMSType.subclass(*args_, **kwargs_)
        else:
            return LINE_ITEMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LINE_ITEM(self): return self.LINE_ITEM
    def set_LINE_ITEM(self, LINE_ITEM): self.LINE_ITEM = LINE_ITEM
    def add_LINE_ITEM(self, value): self.LINE_ITEM.append(value)
    def insert_LINE_ITEM_at(self, index, value): self.LINE_ITEM.insert(index, value)
    def replace_LINE_ITEM_at(self, index, value): self.LINE_ITEM[index] = value
    def hasContent_(self):
        if (
            self.LINE_ITEM
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LINE_ITEMSType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for LINE_ITEM_ in self.LINE_ITEM:
            LINE_ITEM_.to_etree(element, name_='LINE_ITEM', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LINE_ITEMSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LINE_ITEM=[\n')
        level += 1
        for LINE_ITEM_ in self.LINE_ITEM:
            showIndent(outfile, level)
            outfile.write('model_.LINE_ITEMType(\n')
            LINE_ITEM_.exportLiteral(outfile, level, name_='LINE_ITEMType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LINE_ITEM':
            obj_ = LINE_ITEMType.factory()
            obj_.build(child_)
            self.LINE_ITEM.append(obj_)
            obj_.original_tagname_ = 'LINE_ITEM'
# end class LINE_ITEMSType


class LINE_ITEMType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('COMMODITY_CODE', ['COMMODITY_CODEType', 'xs:string'], 0, 1, {'name': 'COMMODITY_CODE', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('PRODUCT_CODE', ['PRODUCT_CODEType', 'xs:string'], 0, 1, {'name': 'PRODUCT_CODE', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTIONType', 'xs:string'], 0, 1, {'name': 'DESCRIPTION', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('QUANTITY', 'xs:double', 0, 0, {'name': 'QUANTITY', 'type': 'xs:double'}, None),
        MemberSpec_('UNIT_OF_MEASURE', ['UNIT_OF_MEASUREType', 'xs:string'], 0, 1, {'name': 'UNIT_OF_MEASURE', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('UNIT_PRICE', ['UNIT_PRICEType', 'xs:decimal'], 0, 0, {'name': 'UNIT_PRICE', 'type': 'xs:decimal'}, None),
        MemberSpec_('DISCOUNT_RATE', ['DISCOUNT_RATEType', 'xs:double'], 0, 1, {'name': 'DISCOUNT_RATE', 'minOccurs': '0', 'type': 'xs:double'}, None),
        MemberSpec_('TAX_RATE', ['TAX_RATEType', 'xs:double'], 0, 1, {'name': 'TAX_RATE', 'minOccurs': '0', 'type': 'xs:double'}, None),
        MemberSpec_('TOTAL_AMOUNT', 'emptyDecimalAllowed', 0, 1, {'name': 'TOTAL_AMOUNT', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, COMMODITY_CODE=None, PRODUCT_CODE=None, DESCRIPTION=None, QUANTITY=None, UNIT_OF_MEASURE=None, UNIT_PRICE=None, DISCOUNT_RATE=None, TAX_RATE=None, TOTAL_AMOUNT=None):
        self.original_tagname_ = None
        self.COMMODITY_CODE = COMMODITY_CODE
        self.validate_COMMODITY_CODEType(self.COMMODITY_CODE)
        self.PRODUCT_CODE = PRODUCT_CODE
        self.validate_PRODUCT_CODEType(self.PRODUCT_CODE)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTIONType(self.DESCRIPTION)
        self.QUANTITY = QUANTITY
        self.UNIT_OF_MEASURE = UNIT_OF_MEASURE
        self.validate_UNIT_OF_MEASUREType(self.UNIT_OF_MEASURE)
        self.UNIT_PRICE = UNIT_PRICE
        self.validate_UNIT_PRICEType(self.UNIT_PRICE)
        self.DISCOUNT_RATE = DISCOUNT_RATE
        self.validate_DISCOUNT_RATEType(self.DISCOUNT_RATE)
        self.TAX_RATE = TAX_RATE
        self.validate_TAX_RATEType(self.TAX_RATE)
        self.TOTAL_AMOUNT = TOTAL_AMOUNT
        self.validate_emptyDecimalAllowed(self.TOTAL_AMOUNT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LINE_ITEMType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LINE_ITEMType.subclass:
            return LINE_ITEMType.subclass(*args_, **kwargs_)
        else:
            return LINE_ITEMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_COMMODITY_CODE(self): return self.COMMODITY_CODE
    def set_COMMODITY_CODE(self, COMMODITY_CODE): self.COMMODITY_CODE = COMMODITY_CODE
    def get_PRODUCT_CODE(self): return self.PRODUCT_CODE
    def set_PRODUCT_CODE(self, PRODUCT_CODE): self.PRODUCT_CODE = PRODUCT_CODE
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_QUANTITY(self): return self.QUANTITY
    def set_QUANTITY(self, QUANTITY): self.QUANTITY = QUANTITY
    def get_UNIT_OF_MEASURE(self): return self.UNIT_OF_MEASURE
    def set_UNIT_OF_MEASURE(self, UNIT_OF_MEASURE): self.UNIT_OF_MEASURE = UNIT_OF_MEASURE
    def get_UNIT_PRICE(self): return self.UNIT_PRICE
    def set_UNIT_PRICE(self, UNIT_PRICE): self.UNIT_PRICE = UNIT_PRICE
    def get_DISCOUNT_RATE(self): return self.DISCOUNT_RATE
    def set_DISCOUNT_RATE(self, DISCOUNT_RATE): self.DISCOUNT_RATE = DISCOUNT_RATE
    def get_TAX_RATE(self): return self.TAX_RATE
    def set_TAX_RATE(self, TAX_RATE): self.TAX_RATE = TAX_RATE
    def get_TOTAL_AMOUNT(self): return self.TOTAL_AMOUNT
    def set_TOTAL_AMOUNT(self, TOTAL_AMOUNT): self.TOTAL_AMOUNT = TOTAL_AMOUNT
    def validate_COMMODITY_CODEType(self, value):
        # Validate type COMMODITY_CODEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on COMMODITY_CODEType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on COMMODITY_CODEType' % {"value" : value.encode("utf-8")} )
    def validate_PRODUCT_CODEType(self, value):
        # Validate type PRODUCT_CODEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PRODUCT_CODEType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PRODUCT_CODEType' % {"value" : value.encode("utf-8")} )
    def validate_DESCRIPTIONType(self, value):
        # Validate type DESCRIPTIONType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 250:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DESCRIPTIONType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DESCRIPTIONType' % {"value" : value.encode("utf-8")} )
    def validate_UNIT_OF_MEASUREType(self, value):
        # Validate type UNIT_OF_MEASUREType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on UNIT_OF_MEASUREType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on UNIT_OF_MEASUREType' % {"value" : value.encode("utf-8")} )
    def validate_UNIT_PRICEType(self, value):
        # Validate type UNIT_PRICEType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on UNIT_PRICEType' % {"value" : value} )
            if len(str(value)) >= 13:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on UNIT_PRICEType' % {"value" : value} )
    def validate_DISCOUNT_RATEType(self, value):
        # Validate type DISCOUNT_RATEType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on DISCOUNT_RATEType' % {"value" : value} )
            if value > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DISCOUNT_RATEType' % {"value" : value} )
    def validate_TAX_RATEType(self, value):
        # Validate type TAX_RATEType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on TAX_RATEType' % {"value" : value} )
            if value > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TAX_RATEType' % {"value" : value} )
    def validate_emptyDecimalAllowed(self, value):
        # Validate type emptyDecimalAllowed, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.COMMODITY_CODE is not None or
            self.PRODUCT_CODE is not None or
            self.DESCRIPTION is not None or
            self.QUANTITY is not None or
            self.UNIT_OF_MEASURE is not None or
            self.UNIT_PRICE is not None or
            self.DISCOUNT_RATE is not None or
            self.TAX_RATE is not None or
            self.TOTAL_AMOUNT is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LINE_ITEMType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.COMMODITY_CODE is not None:
            COMMODITY_CODE_ = self.COMMODITY_CODE
            etree_.SubElement(element, '{}COMMODITY_CODE').text = self.gds_format_string(COMMODITY_CODE_)
        if self.PRODUCT_CODE is not None:
            PRODUCT_CODE_ = self.PRODUCT_CODE
            etree_.SubElement(element, '{}PRODUCT_CODE').text = self.gds_format_string(PRODUCT_CODE_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.QUANTITY is not None:
            QUANTITY_ = self.QUANTITY
            etree_.SubElement(element, '{}QUANTITY').text = self.gds_format_double(QUANTITY_)
        if self.UNIT_OF_MEASURE is not None:
            UNIT_OF_MEASURE_ = self.UNIT_OF_MEASURE
            etree_.SubElement(element, '{}UNIT_OF_MEASURE').text = self.gds_format_string(UNIT_OF_MEASURE_)
        if self.UNIT_PRICE is not None:
            UNIT_PRICE_ = self.UNIT_PRICE
            etree_.SubElement(element, '{}UNIT_PRICE').text = self.gds_format_float(UNIT_PRICE_)
        if self.DISCOUNT_RATE is not None:
            DISCOUNT_RATE_ = self.DISCOUNT_RATE
            etree_.SubElement(element, '{}DISCOUNT_RATE').text = self.gds_format_double(DISCOUNT_RATE_)
        if self.TAX_RATE is not None:
            TAX_RATE_ = self.TAX_RATE
            etree_.SubElement(element, '{}TAX_RATE').text = self.gds_format_double(TAX_RATE_)
        if self.TOTAL_AMOUNT is not None:
            TOTAL_AMOUNT_ = self.TOTAL_AMOUNT
            etree_.SubElement(element, '{}TOTAL_AMOUNT').text = self.gds_format_string(TOTAL_AMOUNT_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LINE_ITEMType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.COMMODITY_CODE is not None:
            showIndent(outfile, level)
            outfile.write('COMMODITY_CODE=%s,\n' % self.gds_encode(quote_python(self.COMMODITY_CODE)))
        if self.PRODUCT_CODE is not None:
            showIndent(outfile, level)
            outfile.write('PRODUCT_CODE=%s,\n' % self.gds_encode(quote_python(self.PRODUCT_CODE)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.QUANTITY is not None:
            showIndent(outfile, level)
            outfile.write('QUANTITY=%e,\n' % self.QUANTITY)
        if self.UNIT_OF_MEASURE is not None:
            showIndent(outfile, level)
            outfile.write('UNIT_OF_MEASURE=%s,\n' % self.gds_encode(quote_python(self.UNIT_OF_MEASURE)))
        if self.UNIT_PRICE is not None:
            showIndent(outfile, level)
            outfile.write('UNIT_PRICE=%f,\n' % self.UNIT_PRICE)
        if self.DISCOUNT_RATE is not None:
            showIndent(outfile, level)
            outfile.write('DISCOUNT_RATE=%e,\n' % self.DISCOUNT_RATE)
        if self.TAX_RATE is not None:
            showIndent(outfile, level)
            outfile.write('TAX_RATE=%e,\n' % self.TAX_RATE)
        if self.TOTAL_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TOTAL_AMOUNT=%s,\n' % self.gds_encode(quote_python(self.TOTAL_AMOUNT)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'COMMODITY_CODE':
            COMMODITY_CODE_ = child_.text
            COMMODITY_CODE_ = self.gds_validate_string(COMMODITY_CODE_, node, 'COMMODITY_CODE')
            self.COMMODITY_CODE = COMMODITY_CODE_
            # validate type COMMODITY_CODEType
            self.validate_COMMODITY_CODEType(self.COMMODITY_CODE)
        elif nodeName_ == 'PRODUCT_CODE':
            PRODUCT_CODE_ = child_.text
            PRODUCT_CODE_ = self.gds_validate_string(PRODUCT_CODE_, node, 'PRODUCT_CODE')
            self.PRODUCT_CODE = PRODUCT_CODE_
            # validate type PRODUCT_CODEType
            self.validate_PRODUCT_CODEType(self.PRODUCT_CODE)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTIONType
            self.validate_DESCRIPTIONType(self.DESCRIPTION)
        elif nodeName_ == 'QUANTITY' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'QUANTITY')
            self.QUANTITY = fval_
        elif nodeName_ == 'UNIT_OF_MEASURE':
            UNIT_OF_MEASURE_ = child_.text
            UNIT_OF_MEASURE_ = self.gds_validate_string(UNIT_OF_MEASURE_, node, 'UNIT_OF_MEASURE')
            self.UNIT_OF_MEASURE = UNIT_OF_MEASURE_
            # validate type UNIT_OF_MEASUREType
            self.validate_UNIT_OF_MEASUREType(self.UNIT_OF_MEASURE)
        elif nodeName_ == 'UNIT_PRICE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'UNIT_PRICE')
            self.UNIT_PRICE = fval_
            # validate type UNIT_PRICEType
            self.validate_UNIT_PRICEType(self.UNIT_PRICE)
        elif nodeName_ == 'DISCOUNT_RATE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DISCOUNT_RATE')
            self.DISCOUNT_RATE = fval_
            # validate type DISCOUNT_RATEType
            self.validate_DISCOUNT_RATEType(self.DISCOUNT_RATE)
        elif nodeName_ == 'TAX_RATE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TAX_RATE')
            self.TAX_RATE = fval_
            # validate type TAX_RATEType
            self.validate_TAX_RATEType(self.TAX_RATE)
        elif nodeName_ == 'TOTAL_AMOUNT':
            TOTAL_AMOUNT_ = child_.text
            TOTAL_AMOUNT_ = self.gds_validate_string(TOTAL_AMOUNT_, node, 'TOTAL_AMOUNT')
            self.TOTAL_AMOUNT = TOTAL_AMOUNT_
            # validate type emptyDecimalAllowed
            self.validate_emptyDecimalAllowed(self.TOTAL_AMOUNT)
# end class LINE_ITEMType


class CUSTOM_FIELDType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('NAME', 'xs:string', 0, 0, {'name': 'NAME', 'type': 'xs:string', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('DISPLAY_NAME', 'xs:string', 0, 0, {'name': 'DISPLAY_NAME', 'type': 'xs:string', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('DISPLAY_ORDER', 'xs:int', 0, 0, {'name': 'DISPLAY_ORDER', 'type': 'xs:int', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('TYPE', ['TYPEType', 'xs:string'], 0, 0, {'name': 'TYPE', 'minOccurs': '1', 'maxOccurs': '1', 'type': 'xs:string'}, None),
        MemberSpec_('PAYMENT_PAGE', 'xs:boolean', 0, 0, {'name': 'PAYMENT_PAGE', 'type': 'xs:boolean', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('SUBSCRIPTION', 'xs:boolean', 0, 1, {'name': 'SUBSCRIPTION', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
        MemberSpec_('MANDATORY', 'xs:boolean', 0, 0, {'name': 'MANDATORY', 'type': 'xs:boolean', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('SECURE_CARD_ONLY', 'xs:boolean', 0, 1, {'name': 'SECURE_CARD_ONLY', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, NAME=None, DISPLAY_NAME=None, DISPLAY_ORDER=None, TYPE=None, PAYMENT_PAGE=None, SUBSCRIPTION=None, MANDATORY=None, SECURE_CARD_ONLY=None):
        self.original_tagname_ = None
        self.NAME = NAME
        self.DISPLAY_NAME = DISPLAY_NAME
        self.DISPLAY_ORDER = DISPLAY_ORDER
        self.TYPE = TYPE
        self.validate_TYPEType(self.TYPE)
        self.PAYMENT_PAGE = PAYMENT_PAGE
        self.SUBSCRIPTION = SUBSCRIPTION
        self.MANDATORY = MANDATORY
        self.SECURE_CARD_ONLY = SECURE_CARD_ONLY
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CUSTOM_FIELDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CUSTOM_FIELDType.subclass:
            return CUSTOM_FIELDType.subclass(*args_, **kwargs_)
        else:
            return CUSTOM_FIELDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_DISPLAY_NAME(self): return self.DISPLAY_NAME
    def set_DISPLAY_NAME(self, DISPLAY_NAME): self.DISPLAY_NAME = DISPLAY_NAME
    def get_DISPLAY_ORDER(self): return self.DISPLAY_ORDER
    def set_DISPLAY_ORDER(self, DISPLAY_ORDER): self.DISPLAY_ORDER = DISPLAY_ORDER
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_PAYMENT_PAGE(self): return self.PAYMENT_PAGE
    def set_PAYMENT_PAGE(self, PAYMENT_PAGE): self.PAYMENT_PAGE = PAYMENT_PAGE
    def get_SUBSCRIPTION(self): return self.SUBSCRIPTION
    def set_SUBSCRIPTION(self, SUBSCRIPTION): self.SUBSCRIPTION = SUBSCRIPTION
    def get_MANDATORY(self): return self.MANDATORY
    def set_MANDATORY(self, MANDATORY): self.MANDATORY = MANDATORY
    def get_SECURE_CARD_ONLY(self): return self.SECURE_CARD_ONLY
    def set_SECURE_CARD_ONLY(self, SECURE_CARD_ONLY): self.SECURE_CARD_ONLY = SECURE_CARD_ONLY
    def validate_TYPEType(self, value):
        # Validate type TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['STRING', 'NUMERIC', 'BOOLEAN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TYPEType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.NAME is not None or
            self.DISPLAY_NAME is not None or
            self.DISPLAY_ORDER is not None or
            self.TYPE is not None or
            self.PAYMENT_PAGE is not None or
            self.SUBSCRIPTION is not None or
            self.MANDATORY is not None or
            self.SECURE_CARD_ONLY is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CUSTOM_FIELDType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.DISPLAY_NAME is not None:
            DISPLAY_NAME_ = self.DISPLAY_NAME
            etree_.SubElement(element, '{}DISPLAY_NAME').text = self.gds_format_string(DISPLAY_NAME_)
        if self.DISPLAY_ORDER is not None:
            DISPLAY_ORDER_ = self.DISPLAY_ORDER
            etree_.SubElement(element, '{}DISPLAY_ORDER').text = self.gds_format_integer(DISPLAY_ORDER_)
        if self.TYPE is not None:
            TYPE_ = self.TYPE
            etree_.SubElement(element, '{}TYPE').text = self.gds_format_string(TYPE_)
        if self.PAYMENT_PAGE is not None:
            PAYMENT_PAGE_ = self.PAYMENT_PAGE
            etree_.SubElement(element, '{}PAYMENT_PAGE').text = self.gds_format_boolean(PAYMENT_PAGE_)
        if self.SUBSCRIPTION is not None:
            SUBSCRIPTION_ = self.SUBSCRIPTION
            etree_.SubElement(element, '{}SUBSCRIPTION').text = self.gds_format_boolean(SUBSCRIPTION_)
        if self.MANDATORY is not None:
            MANDATORY_ = self.MANDATORY
            etree_.SubElement(element, '{}MANDATORY').text = self.gds_format_boolean(MANDATORY_)
        if self.SECURE_CARD_ONLY is not None:
            SECURE_CARD_ONLY_ = self.SECURE_CARD_ONLY
            etree_.SubElement(element, '{}SECURE_CARD_ONLY').text = self.gds_format_boolean(SECURE_CARD_ONLY_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CUSTOM_FIELDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.DISPLAY_NAME is not None:
            showIndent(outfile, level)
            outfile.write('DISPLAY_NAME=%s,\n' % self.gds_encode(quote_python(self.DISPLAY_NAME)))
        if self.DISPLAY_ORDER is not None:
            showIndent(outfile, level)
            outfile.write('DISPLAY_ORDER=%d,\n' % self.DISPLAY_ORDER)
        if self.TYPE is not None:
            showIndent(outfile, level)
            outfile.write('TYPE=%s,\n' % self.gds_encode(quote_python(self.TYPE)))
        if self.PAYMENT_PAGE is not None:
            showIndent(outfile, level)
            outfile.write('PAYMENT_PAGE=%s,\n' % self.PAYMENT_PAGE)
        if self.SUBSCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('SUBSCRIPTION=%s,\n' % self.SUBSCRIPTION)
        if self.MANDATORY is not None:
            showIndent(outfile, level)
            outfile.write('MANDATORY=%s,\n' % self.MANDATORY)
        if self.SECURE_CARD_ONLY is not None:
            showIndent(outfile, level)
            outfile.write('SECURE_CARD_ONLY=%s,\n' % self.SECURE_CARD_ONLY)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'DISPLAY_NAME':
            DISPLAY_NAME_ = child_.text
            DISPLAY_NAME_ = self.gds_validate_string(DISPLAY_NAME_, node, 'DISPLAY_NAME')
            self.DISPLAY_NAME = DISPLAY_NAME_
        elif nodeName_ == 'DISPLAY_ORDER' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DISPLAY_ORDER')
            self.DISPLAY_ORDER = ival_
        elif nodeName_ == 'TYPE':
            TYPE_ = child_.text
            TYPE_ = self.gds_validate_string(TYPE_, node, 'TYPE')
            self.TYPE = TYPE_
            # validate type TYPEType
            self.validate_TYPEType(self.TYPE)
        elif nodeName_ == 'PAYMENT_PAGE':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'PAYMENT_PAGE')
            self.PAYMENT_PAGE = ival_
        elif nodeName_ == 'SUBSCRIPTION':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SUBSCRIPTION')
            self.SUBSCRIPTION = ival_
        elif nodeName_ == 'MANDATORY':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'MANDATORY')
            self.MANDATORY = ival_
        elif nodeName_ == 'SECURE_CARD_ONLY':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SECURE_CARD_ONLY')
            self.SECURE_CARD_ONLY = ival_
# end class CUSTOM_FIELDType


class BANK_SETTINGSType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 1, {'ref': 'CURRENCY', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('ALLOW_MULTICURRENCY', 'xs:boolean', 0, 0, {'name': 'ALLOW_MULTICURRENCY', 'type': 'xs:boolean', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('ALLOW_EMCP', 'xs:boolean', 0, 0, {'name': 'ALLOW_EMCP', 'type': 'xs:boolean', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('ALLOW_EDCC', 'xs:boolean', 0, 1, {'name': 'ALLOW_EDCC', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
        MemberSpec_('ALLOW_MOTO', 'xs:boolean', 0, 0, {'name': 'ALLOW_MOTO', 'type': 'xs:boolean', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('ALLOW_CHP', 'xs:boolean', 0, 1, {'name': 'ALLOW_CHP', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
        MemberSpec_('ALLOW_INTERNET', 'xs:boolean', 0, 0, {'name': 'ALLOW_INTERNET', 'type': 'xs:boolean', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CURRENCY=None, ALLOW_MULTICURRENCY=None, ALLOW_EMCP=None, ALLOW_EDCC=None, ALLOW_MOTO=None, ALLOW_CHP=None, ALLOW_INTERNET=None):
        self.original_tagname_ = None
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.ALLOW_MULTICURRENCY = ALLOW_MULTICURRENCY
        self.ALLOW_EMCP = ALLOW_EMCP
        self.ALLOW_EDCC = ALLOW_EDCC
        self.ALLOW_MOTO = ALLOW_MOTO
        self.ALLOW_CHP = ALLOW_CHP
        self.ALLOW_INTERNET = ALLOW_INTERNET
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BANK_SETTINGSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BANK_SETTINGSType.subclass:
            return BANK_SETTINGSType.subclass(*args_, **kwargs_)
        else:
            return BANK_SETTINGSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_ALLOW_MULTICURRENCY(self): return self.ALLOW_MULTICURRENCY
    def set_ALLOW_MULTICURRENCY(self, ALLOW_MULTICURRENCY): self.ALLOW_MULTICURRENCY = ALLOW_MULTICURRENCY
    def get_ALLOW_EMCP(self): return self.ALLOW_EMCP
    def set_ALLOW_EMCP(self, ALLOW_EMCP): self.ALLOW_EMCP = ALLOW_EMCP
    def get_ALLOW_EDCC(self): return self.ALLOW_EDCC
    def set_ALLOW_EDCC(self, ALLOW_EDCC): self.ALLOW_EDCC = ALLOW_EDCC
    def get_ALLOW_MOTO(self): return self.ALLOW_MOTO
    def set_ALLOW_MOTO(self, ALLOW_MOTO): self.ALLOW_MOTO = ALLOW_MOTO
    def get_ALLOW_CHP(self): return self.ALLOW_CHP
    def set_ALLOW_CHP(self, ALLOW_CHP): self.ALLOW_CHP = ALLOW_CHP
    def get_ALLOW_INTERNET(self): return self.ALLOW_INTERNET
    def set_ALLOW_INTERNET(self, ALLOW_INTERNET): self.ALLOW_INTERNET = ALLOW_INTERNET
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.CURRENCY is not None or
            self.ALLOW_MULTICURRENCY is not None or
            self.ALLOW_EMCP is not None or
            self.ALLOW_EDCC is not None or
            self.ALLOW_MOTO is not None or
            self.ALLOW_CHP is not None or
            self.ALLOW_INTERNET is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BANK_SETTINGSType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.ALLOW_MULTICURRENCY is not None:
            ALLOW_MULTICURRENCY_ = self.ALLOW_MULTICURRENCY
            etree_.SubElement(element, '{}ALLOW_MULTICURRENCY').text = self.gds_format_boolean(ALLOW_MULTICURRENCY_)
        if self.ALLOW_EMCP is not None:
            ALLOW_EMCP_ = self.ALLOW_EMCP
            etree_.SubElement(element, '{}ALLOW_EMCP').text = self.gds_format_boolean(ALLOW_EMCP_)
        if self.ALLOW_EDCC is not None:
            ALLOW_EDCC_ = self.ALLOW_EDCC
            etree_.SubElement(element, '{}ALLOW_EDCC').text = self.gds_format_boolean(ALLOW_EDCC_)
        if self.ALLOW_MOTO is not None:
            ALLOW_MOTO_ = self.ALLOW_MOTO
            etree_.SubElement(element, '{}ALLOW_MOTO').text = self.gds_format_boolean(ALLOW_MOTO_)
        if self.ALLOW_CHP is not None:
            ALLOW_CHP_ = self.ALLOW_CHP
            etree_.SubElement(element, '{}ALLOW_CHP').text = self.gds_format_boolean(ALLOW_CHP_)
        if self.ALLOW_INTERNET is not None:
            ALLOW_INTERNET_ = self.ALLOW_INTERNET
            etree_.SubElement(element, '{}ALLOW_INTERNET').text = self.gds_format_boolean(ALLOW_INTERNET_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BANK_SETTINGSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.ALLOW_MULTICURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('ALLOW_MULTICURRENCY=%s,\n' % self.ALLOW_MULTICURRENCY)
        if self.ALLOW_EMCP is not None:
            showIndent(outfile, level)
            outfile.write('ALLOW_EMCP=%s,\n' % self.ALLOW_EMCP)
        if self.ALLOW_EDCC is not None:
            showIndent(outfile, level)
            outfile.write('ALLOW_EDCC=%s,\n' % self.ALLOW_EDCC)
        if self.ALLOW_MOTO is not None:
            showIndent(outfile, level)
            outfile.write('ALLOW_MOTO=%s,\n' % self.ALLOW_MOTO)
        if self.ALLOW_CHP is not None:
            showIndent(outfile, level)
            outfile.write('ALLOW_CHP=%s,\n' % self.ALLOW_CHP)
        if self.ALLOW_INTERNET is not None:
            showIndent(outfile, level)
            outfile.write('ALLOW_INTERNET=%s,\n' % self.ALLOW_INTERNET)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'ALLOW_MULTICURRENCY':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ALLOW_MULTICURRENCY')
            self.ALLOW_MULTICURRENCY = ival_
        elif nodeName_ == 'ALLOW_EMCP':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ALLOW_EMCP')
            self.ALLOW_EMCP = ival_
        elif nodeName_ == 'ALLOW_EDCC':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ALLOW_EDCC')
            self.ALLOW_EDCC = ival_
        elif nodeName_ == 'ALLOW_MOTO':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ALLOW_MOTO')
            self.ALLOW_MOTO = ival_
        elif nodeName_ == 'ALLOW_CHP':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ALLOW_CHP')
            self.ALLOW_CHP = ival_
        elif nodeName_ == 'ALLOW_INTERNET':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ALLOW_INTERNET')
            self.ALLOW_INTERNET = ival_
# end class BANK_SETTINGSType


class SUPPORTED_CURRENCIESType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 1, 1, {'ref': 'CURRENCY', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CURRENCY=None):
        self.original_tagname_ = None
        if CURRENCY is None:
            self.CURRENCY = []
        else:
            self.CURRENCY = CURRENCY
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUPPORTED_CURRENCIESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUPPORTED_CURRENCIESType.subclass:
            return SUPPORTED_CURRENCIESType.subclass(*args_, **kwargs_)
        else:
            return SUPPORTED_CURRENCIESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def add_CURRENCY(self, value): self.CURRENCY.append(value)
    def insert_CURRENCY_at(self, index, value): self.CURRENCY.insert(index, value)
    def replace_CURRENCY_at(self, index, value): self.CURRENCY[index] = value
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.CURRENCY
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SUPPORTED_CURRENCIESType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for CURRENCY_ in self.CURRENCY:
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SUPPORTED_CURRENCIESType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CURRENCY=[\n')
        level += 1
        for CURRENCY_ in self.CURRENCY:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(CURRENCY_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY.append(CURRENCY_)
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY[-1])
# end class SUPPORTED_CURRENCIESType


class FEATURESType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('SECURE_CARD_STORAGE', 'SECURE_CARD_STORAGEType', 0, 1, {'name': 'SECURE_CARD_STORAGE', 'minOccurs': '0', 'maxOccurs': '1', 'type': 'SECURE_CARD_STORAGEType'}, None),
        MemberSpec_('ENHANCED_DATA', 'ENHANCED_DATAType', 0, 1, {'name': 'ENHANCED_DATA', 'minOccurs': '0', 'maxOccurs': '1', 'type': 'ENHANCED_DATAType'}, None),
        MemberSpec_('SUPPORTS_APPLE_PAY', 'xs:boolean', 0, 1, {'name': 'SUPPORTS_APPLE_PAY', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
        MemberSpec_('SUPPORTS_GOOGLE_PAY', 'xs:boolean', 0, 1, {'name': 'SUPPORTS_GOOGLE_PAY', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
        MemberSpec_('SURCHARGE', 'SURCHARGEType', 0, 1, {'name': 'SURCHARGE', 'minOccurs': '0', 'maxOccurs': '1', 'type': 'SURCHARGEType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, SECURE_CARD_STORAGE=None, ENHANCED_DATA=None, SUPPORTS_APPLE_PAY=None, SUPPORTS_GOOGLE_PAY=None, SURCHARGE=None):
        self.original_tagname_ = None
        self.SECURE_CARD_STORAGE = SECURE_CARD_STORAGE
        self.ENHANCED_DATA = ENHANCED_DATA
        self.SUPPORTS_APPLE_PAY = SUPPORTS_APPLE_PAY
        self.SUPPORTS_GOOGLE_PAY = SUPPORTS_GOOGLE_PAY
        self.SURCHARGE = SURCHARGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FEATURESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FEATURESType.subclass:
            return FEATURESType.subclass(*args_, **kwargs_)
        else:
            return FEATURESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SECURE_CARD_STORAGE(self): return self.SECURE_CARD_STORAGE
    def set_SECURE_CARD_STORAGE(self, SECURE_CARD_STORAGE): self.SECURE_CARD_STORAGE = SECURE_CARD_STORAGE
    def get_ENHANCED_DATA(self): return self.ENHANCED_DATA
    def set_ENHANCED_DATA(self, ENHANCED_DATA): self.ENHANCED_DATA = ENHANCED_DATA
    def get_SUPPORTS_APPLE_PAY(self): return self.SUPPORTS_APPLE_PAY
    def set_SUPPORTS_APPLE_PAY(self, SUPPORTS_APPLE_PAY): self.SUPPORTS_APPLE_PAY = SUPPORTS_APPLE_PAY
    def get_SUPPORTS_GOOGLE_PAY(self): return self.SUPPORTS_GOOGLE_PAY
    def set_SUPPORTS_GOOGLE_PAY(self, SUPPORTS_GOOGLE_PAY): self.SUPPORTS_GOOGLE_PAY = SUPPORTS_GOOGLE_PAY
    def get_SURCHARGE(self): return self.SURCHARGE
    def set_SURCHARGE(self, SURCHARGE): self.SURCHARGE = SURCHARGE
    def hasContent_(self):
        if (
            self.SECURE_CARD_STORAGE is not None or
            self.ENHANCED_DATA is not None or
            self.SUPPORTS_APPLE_PAY is not None or
            self.SUPPORTS_GOOGLE_PAY is not None or
            self.SURCHARGE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FEATURESType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.SECURE_CARD_STORAGE is not None:
            SECURE_CARD_STORAGE_ = self.SECURE_CARD_STORAGE
            SECURE_CARD_STORAGE_.to_etree(element, name_='SECURE_CARD_STORAGE', mapping_=mapping_)
        if self.ENHANCED_DATA is not None:
            ENHANCED_DATA_ = self.ENHANCED_DATA
            ENHANCED_DATA_.to_etree(element, name_='ENHANCED_DATA', mapping_=mapping_)
        if self.SUPPORTS_APPLE_PAY is not None:
            SUPPORTS_APPLE_PAY_ = self.SUPPORTS_APPLE_PAY
            etree_.SubElement(element, '{}SUPPORTS_APPLE_PAY').text = self.gds_format_boolean(SUPPORTS_APPLE_PAY_)
        if self.SUPPORTS_GOOGLE_PAY is not None:
            SUPPORTS_GOOGLE_PAY_ = self.SUPPORTS_GOOGLE_PAY
            etree_.SubElement(element, '{}SUPPORTS_GOOGLE_PAY').text = self.gds_format_boolean(SUPPORTS_GOOGLE_PAY_)
        if self.SURCHARGE is not None:
            SURCHARGE_ = self.SURCHARGE
            SURCHARGE_.to_etree(element, name_='SURCHARGE', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FEATURESType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SECURE_CARD_STORAGE is not None:
            showIndent(outfile, level)
            outfile.write('SECURE_CARD_STORAGE=model_.SECURE_CARD_STORAGEType(\n')
            self.SECURE_CARD_STORAGE.exportLiteral(outfile, level, name_='SECURE_CARD_STORAGE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ENHANCED_DATA is not None:
            showIndent(outfile, level)
            outfile.write('ENHANCED_DATA=model_.ENHANCED_DATAType(\n')
            self.ENHANCED_DATA.exportLiteral(outfile, level, name_='ENHANCED_DATA')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SUPPORTS_APPLE_PAY is not None:
            showIndent(outfile, level)
            outfile.write('SUPPORTS_APPLE_PAY=%s,\n' % self.SUPPORTS_APPLE_PAY)
        if self.SUPPORTS_GOOGLE_PAY is not None:
            showIndent(outfile, level)
            outfile.write('SUPPORTS_GOOGLE_PAY=%s,\n' % self.SUPPORTS_GOOGLE_PAY)
        if self.SURCHARGE is not None:
            showIndent(outfile, level)
            outfile.write('SURCHARGE=model_.SURCHARGEType(\n')
            self.SURCHARGE.exportLiteral(outfile, level, name_='SURCHARGE')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SECURE_CARD_STORAGE':
            obj_ = SECURE_CARD_STORAGEType.factory()
            obj_.build(child_)
            self.SECURE_CARD_STORAGE = obj_
            obj_.original_tagname_ = 'SECURE_CARD_STORAGE'
        elif nodeName_ == 'ENHANCED_DATA':
            obj_ = ENHANCED_DATAType.factory()
            obj_.build(child_)
            self.ENHANCED_DATA = obj_
            obj_.original_tagname_ = 'ENHANCED_DATA'
        elif nodeName_ == 'SUPPORTS_APPLE_PAY':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SUPPORTS_APPLE_PAY')
            self.SUPPORTS_APPLE_PAY = ival_
        elif nodeName_ == 'SUPPORTS_GOOGLE_PAY':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SUPPORTS_GOOGLE_PAY')
            self.SUPPORTS_GOOGLE_PAY = ival_
        elif nodeName_ == 'SURCHARGE':
            obj_ = SURCHARGEType.factory()
            obj_.build(child_)
            self.SURCHARGE = obj_
            obj_.original_tagname_ = 'SURCHARGE'
# end class FEATURESType


class SECURE_CARD_STORAGEType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ENABLED', 'xs:boolean', 0, 1, {'ref': 'ENABLED', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'ENABLED', 'type': 'xs:boolean'}, None),
        MemberSpec_('ALLOW_SUBSCRIPTION', 'xs:boolean', 0, 1, {'name': 'ALLOW_SUBSCRIPTION', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ENABLED=None, ALLOW_SUBSCRIPTION=None):
        self.original_tagname_ = None
        self.ENABLED = ENABLED
        self.ALLOW_SUBSCRIPTION = ALLOW_SUBSCRIPTION
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURE_CARD_STORAGEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURE_CARD_STORAGEType.subclass:
            return SECURE_CARD_STORAGEType.subclass(*args_, **kwargs_)
        else:
            return SECURE_CARD_STORAGEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ENABLED(self): return self.ENABLED
    def set_ENABLED(self, ENABLED): self.ENABLED = ENABLED
    def get_ALLOW_SUBSCRIPTION(self): return self.ALLOW_SUBSCRIPTION
    def set_ALLOW_SUBSCRIPTION(self, ALLOW_SUBSCRIPTION): self.ALLOW_SUBSCRIPTION = ALLOW_SUBSCRIPTION
    def hasContent_(self):
        if (
            self.ENABLED is not None or
            self.ALLOW_SUBSCRIPTION is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURE_CARD_STORAGEType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ENABLED is not None:
            ENABLED_ = self.ENABLED
            etree_.SubElement(element, '{}ENABLED').text = self.gds_format_boolean(ENABLED_)
        if self.ALLOW_SUBSCRIPTION is not None:
            ALLOW_SUBSCRIPTION_ = self.ALLOW_SUBSCRIPTION
            etree_.SubElement(element, '{}ALLOW_SUBSCRIPTION').text = self.gds_format_boolean(ALLOW_SUBSCRIPTION_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURE_CARD_STORAGEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ENABLED is not None:
            showIndent(outfile, level)
            outfile.write('ENABLED=%s,\n' % self.ENABLED)
        if self.ALLOW_SUBSCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('ALLOW_SUBSCRIPTION=%s,\n' % self.ALLOW_SUBSCRIPTION)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ENABLED':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ENABLED')
            self.ENABLED = ival_
        elif nodeName_ == 'ALLOW_SUBSCRIPTION':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ALLOW_SUBSCRIPTION')
            self.ALLOW_SUBSCRIPTION = ival_
# end class SECURE_CARD_STORAGEType


class ENHANCED_DATAType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ENABLED', 'xs:boolean', 0, 1, {'ref': 'ENABLED', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'ENABLED', 'type': 'xs:boolean'}, None),
        MemberSpec_('TXN_DATA_LEVEL', ['TXN_DATA_LEVEL', 'xs:string'], 0, 1, {'ref': 'TXN_DATA_LEVEL', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'TXN_DATA_LEVEL', 'type': 'xs:string'}, None),
        MemberSpec_('API_ADDRESS_MODE', ['API_ADDRESS_MODE', 'xs:string'], 0, 1, {'ref': 'API_ADDRESS_MODE', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'API_ADDRESS_MODE', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ENABLED=None, TXN_DATA_LEVEL=None, API_ADDRESS_MODE=None):
        self.original_tagname_ = None
        self.ENABLED = ENABLED
        self.TXN_DATA_LEVEL = TXN_DATA_LEVEL
        self.validate_TXN_DATA_LEVEL(self.TXN_DATA_LEVEL)
        self.API_ADDRESS_MODE = API_ADDRESS_MODE
        self.validate_API_ADDRESS_MODE(self.API_ADDRESS_MODE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENHANCED_DATAType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENHANCED_DATAType.subclass:
            return ENHANCED_DATAType.subclass(*args_, **kwargs_)
        else:
            return ENHANCED_DATAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ENABLED(self): return self.ENABLED
    def set_ENABLED(self, ENABLED): self.ENABLED = ENABLED
    def get_TXN_DATA_LEVEL(self): return self.TXN_DATA_LEVEL
    def set_TXN_DATA_LEVEL(self, TXN_DATA_LEVEL): self.TXN_DATA_LEVEL = TXN_DATA_LEVEL
    def get_API_ADDRESS_MODE(self): return self.API_ADDRESS_MODE
    def set_API_ADDRESS_MODE(self, API_ADDRESS_MODE): self.API_ADDRESS_MODE = API_ADDRESS_MODE
    def validate_TXN_DATA_LEVEL(self, value):
        # Validate type TXN_DATA_LEVEL, a restriction on xs:string.
        pass
    def validate_API_ADDRESS_MODE(self, value):
        # Validate type API_ADDRESS_MODE, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ENABLED is not None or
            self.TXN_DATA_LEVEL is not None or
            self.API_ADDRESS_MODE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ENHANCED_DATAType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ENABLED is not None:
            ENABLED_ = self.ENABLED
            etree_.SubElement(element, '{}ENABLED').text = self.gds_format_boolean(ENABLED_)
        if self.TXN_DATA_LEVEL is not None:
            TXN_DATA_LEVEL_ = self.TXN_DATA_LEVEL
            etree_.SubElement(element, '{}TXN_DATA_LEVEL').text = self.gds_format_string(TXN_DATA_LEVEL_)
        if self.API_ADDRESS_MODE is not None:
            API_ADDRESS_MODE_ = self.API_ADDRESS_MODE
            etree_.SubElement(element, '{}API_ADDRESS_MODE').text = self.gds_format_string(API_ADDRESS_MODE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ENHANCED_DATAType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ENABLED is not None:
            showIndent(outfile, level)
            outfile.write('ENABLED=%s,\n' % self.ENABLED)
        if self.TXN_DATA_LEVEL is not None:
            showIndent(outfile, level)
            outfile.write('TXN_DATA_LEVEL=%s,\n' % self.gds_encode(quote_python(self.TXN_DATA_LEVEL)))
        if self.API_ADDRESS_MODE is not None:
            showIndent(outfile, level)
            outfile.write('API_ADDRESS_MODE=%s,\n' % self.gds_encode(quote_python(self.API_ADDRESS_MODE)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ENABLED':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ENABLED')
            self.ENABLED = ival_
        elif nodeName_ == 'TXN_DATA_LEVEL':
            TXN_DATA_LEVEL_ = child_.text
            TXN_DATA_LEVEL_ = self.gds_validate_string(TXN_DATA_LEVEL_, node, 'TXN_DATA_LEVEL')
            self.TXN_DATA_LEVEL = TXN_DATA_LEVEL_
            # validate type TXN_DATA_LEVEL
            self.validate_TXN_DATA_LEVEL(self.TXN_DATA_LEVEL)
        elif nodeName_ == 'API_ADDRESS_MODE':
            API_ADDRESS_MODE_ = child_.text
            API_ADDRESS_MODE_ = self.gds_validate_string(API_ADDRESS_MODE_, node, 'API_ADDRESS_MODE')
            self.API_ADDRESS_MODE = API_ADDRESS_MODE_
            # validate type API_ADDRESS_MODE
            self.validate_API_ADDRESS_MODE(self.API_ADDRESS_MODE)
# end class ENHANCED_DATAType


class SURCHARGEType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ENABLED', 'xs:boolean', 0, 1, {'ref': 'ENABLED', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'ENABLED', 'type': 'xs:boolean'}, None),
        MemberSpec_('SURCHARGE_PERCENT', ['surchargePercent', 'xs:decimal'], 0, 1, {'name': 'SURCHARGE_PERCENT', 'type': 'xs:decimal', 'minOccurs': '0', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ENABLED=None, SURCHARGE_PERCENT=None):
        self.original_tagname_ = None
        self.ENABLED = ENABLED
        self.SURCHARGE_PERCENT = SURCHARGE_PERCENT
        self.validate_surchargePercent(self.SURCHARGE_PERCENT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SURCHARGEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SURCHARGEType.subclass:
            return SURCHARGEType.subclass(*args_, **kwargs_)
        else:
            return SURCHARGEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ENABLED(self): return self.ENABLED
    def set_ENABLED(self, ENABLED): self.ENABLED = ENABLED
    def get_SURCHARGE_PERCENT(self): return self.SURCHARGE_PERCENT
    def set_SURCHARGE_PERCENT(self, SURCHARGE_PERCENT): self.SURCHARGE_PERCENT = SURCHARGE_PERCENT
    def validate_surchargePercent(self, value):
        # Validate type surchargePercent, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on surchargePercent' % {"value" : value} )
            if value >= 1000:
                warnings_.warn('Value "%(value)s" does not match xsd maxExclusive restriction on surchargePercent' % {"value" : value} )
    def hasContent_(self):
        if (
            self.ENABLED is not None or
            self.SURCHARGE_PERCENT is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SURCHARGEType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ENABLED is not None:
            ENABLED_ = self.ENABLED
            etree_.SubElement(element, '{}ENABLED').text = self.gds_format_boolean(ENABLED_)
        if self.SURCHARGE_PERCENT is not None:
            SURCHARGE_PERCENT_ = self.SURCHARGE_PERCENT
            etree_.SubElement(element, '{}SURCHARGE_PERCENT').text = self.gds_format_float(SURCHARGE_PERCENT_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SURCHARGEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ENABLED is not None:
            showIndent(outfile, level)
            outfile.write('ENABLED=%s,\n' % self.ENABLED)
        if self.SURCHARGE_PERCENT is not None:
            showIndent(outfile, level)
            outfile.write('SURCHARGE_PERCENT=%f,\n' % self.SURCHARGE_PERCENT)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ENABLED':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ENABLED')
            self.ENABLED = ival_
        elif nodeName_ == 'SURCHARGE_PERCENT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SURCHARGE_PERCENT')
            self.SURCHARGE_PERCENT = fval_
            # validate type surchargePercent
            self.validate_surchargePercent(self.SURCHARGE_PERCENT)
# end class SURCHARGEType


class SUPPORTED_CARDTYPESType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 1, 1, {'ref': 'CARDTYPE', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CARDTYPE=None):
        self.original_tagname_ = None
        if CARDTYPE is None:
            self.CARDTYPE = []
        else:
            self.CARDTYPE = CARDTYPE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUPPORTED_CARDTYPESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUPPORTED_CARDTYPESType.subclass:
            return SUPPORTED_CARDTYPESType.subclass(*args_, **kwargs_)
        else:
            return SUPPORTED_CARDTYPESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def add_CARDTYPE(self, value): self.CARDTYPE.append(value)
    def insert_CARDTYPE_at(self, index, value): self.CARDTYPE.insert(index, value)
    def replace_CARDTYPE_at(self, index, value): self.CARDTYPE[index] = value
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.CARDTYPE
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SUPPORTED_CARDTYPESType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for CARDTYPE_ in self.CARDTYPE:
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SUPPORTED_CARDTYPESType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CARDTYPE=[\n')
        level += 1
        for CARDTYPE_ in self.CARDTYPE:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(CARDTYPE_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE.append(CARDTYPE_)
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE[-1])
# end class SUPPORTED_CARDTYPESType


class SECURITY_FRAUDType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('SHOW_CVV', 'xs:boolean', 0, 0, {'name': 'SHOW_CVV', 'type': 'xs:boolean', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('AVS', 'AVSType', 0, 0, {'name': 'AVS', 'type': 'AVSType'}, None),
        MemberSpec_('ENABLE_3DS', 'xs:boolean', 0, 1, {'name': 'ENABLE_3DS', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
        MemberSpec_('ALLOW_MAX_MIND', 'xs:boolean', 0, 1, {'name': 'ALLOW_MAX_MIND', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
        MemberSpec_('SENTINEL_DEFEND', 'SENTINEL_DEFENDType', 0, 1, {'name': 'SENTINEL_DEFEND', 'minOccurs': '0', 'maxOccurs': '1', 'type': 'SENTINEL_DEFENDType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, SHOW_CVV=None, AVS=None, ENABLE_3DS=None, ALLOW_MAX_MIND=None, SENTINEL_DEFEND=None):
        self.original_tagname_ = None
        self.SHOW_CVV = SHOW_CVV
        self.AVS = AVS
        self.ENABLE_3DS = ENABLE_3DS
        self.ALLOW_MAX_MIND = ALLOW_MAX_MIND
        self.SENTINEL_DEFEND = SENTINEL_DEFEND
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURITY_FRAUDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURITY_FRAUDType.subclass:
            return SECURITY_FRAUDType.subclass(*args_, **kwargs_)
        else:
            return SECURITY_FRAUDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SHOW_CVV(self): return self.SHOW_CVV
    def set_SHOW_CVV(self, SHOW_CVV): self.SHOW_CVV = SHOW_CVV
    def get_AVS(self): return self.AVS
    def set_AVS(self, AVS): self.AVS = AVS
    def get_ENABLE_3DS(self): return self.ENABLE_3DS
    def set_ENABLE_3DS(self, ENABLE_3DS): self.ENABLE_3DS = ENABLE_3DS
    def get_ALLOW_MAX_MIND(self): return self.ALLOW_MAX_MIND
    def set_ALLOW_MAX_MIND(self, ALLOW_MAX_MIND): self.ALLOW_MAX_MIND = ALLOW_MAX_MIND
    def get_SENTINEL_DEFEND(self): return self.SENTINEL_DEFEND
    def set_SENTINEL_DEFEND(self, SENTINEL_DEFEND): self.SENTINEL_DEFEND = SENTINEL_DEFEND
    def hasContent_(self):
        if (
            self.SHOW_CVV is not None or
            self.AVS is not None or
            self.ENABLE_3DS is not None or
            self.ALLOW_MAX_MIND is not None or
            self.SENTINEL_DEFEND is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURITY_FRAUDType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.SHOW_CVV is not None:
            SHOW_CVV_ = self.SHOW_CVV
            etree_.SubElement(element, '{}SHOW_CVV').text = self.gds_format_boolean(SHOW_CVV_)
        if self.AVS is not None:
            AVS_ = self.AVS
            AVS_.to_etree(element, name_='AVS', mapping_=mapping_)
        if self.ENABLE_3DS is not None:
            ENABLE_3DS_ = self.ENABLE_3DS
            etree_.SubElement(element, '{}ENABLE_3DS').text = self.gds_format_boolean(ENABLE_3DS_)
        if self.ALLOW_MAX_MIND is not None:
            ALLOW_MAX_MIND_ = self.ALLOW_MAX_MIND
            etree_.SubElement(element, '{}ALLOW_MAX_MIND').text = self.gds_format_boolean(ALLOW_MAX_MIND_)
        if self.SENTINEL_DEFEND is not None:
            SENTINEL_DEFEND_ = self.SENTINEL_DEFEND
            SENTINEL_DEFEND_.to_etree(element, name_='SENTINEL_DEFEND', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURITY_FRAUDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SHOW_CVV is not None:
            showIndent(outfile, level)
            outfile.write('SHOW_CVV=%s,\n' % self.SHOW_CVV)
        if self.AVS is not None:
            showIndent(outfile, level)
            outfile.write('AVS=model_.AVSType(\n')
            self.AVS.exportLiteral(outfile, level, name_='AVS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ENABLE_3DS is not None:
            showIndent(outfile, level)
            outfile.write('ENABLE_3DS=%s,\n' % self.ENABLE_3DS)
        if self.ALLOW_MAX_MIND is not None:
            showIndent(outfile, level)
            outfile.write('ALLOW_MAX_MIND=%s,\n' % self.ALLOW_MAX_MIND)
        if self.SENTINEL_DEFEND is not None:
            showIndent(outfile, level)
            outfile.write('SENTINEL_DEFEND=model_.SENTINEL_DEFENDType(\n')
            self.SENTINEL_DEFEND.exportLiteral(outfile, level, name_='SENTINEL_DEFEND')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHOW_CVV':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SHOW_CVV')
            self.SHOW_CVV = ival_
        elif nodeName_ == 'AVS':
            obj_ = AVSType.factory()
            obj_.build(child_)
            self.AVS = obj_
            obj_.original_tagname_ = 'AVS'
        elif nodeName_ == 'ENABLE_3DS':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ENABLE_3DS')
            self.ENABLE_3DS = ival_
        elif nodeName_ == 'ALLOW_MAX_MIND':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ALLOW_MAX_MIND')
            self.ALLOW_MAX_MIND = ival_
        elif nodeName_ == 'SENTINEL_DEFEND':
            obj_ = SENTINEL_DEFENDType.factory()
            obj_.build(child_)
            self.SENTINEL_DEFEND = obj_
            obj_.original_tagname_ = 'SENTINEL_DEFEND'
# end class SECURITY_FRAUDType


class AVSType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ENABLED', 'xs:boolean', 0, 0, {'ref': 'ENABLED', 'minOccurs': '1', 'maxOccurs': '1', 'name': 'ENABLED', 'type': 'xs:boolean'}, None),
        MemberSpec_('COMPULSORY', 'xs:boolean', 0, 0, {'ref': 'COMPULSORY', 'minOccurs': '1', 'maxOccurs': '1', 'name': 'COMPULSORY', 'type': 'xs:boolean'}, None),
        MemberSpec_('API_ADDRESS_MODE', ['API_ADDRESS_MODE', 'xs:string'], 0, 1, {'ref': 'API_ADDRESS_MODE', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'API_ADDRESS_MODE', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ENABLED=None, COMPULSORY=None, API_ADDRESS_MODE=None):
        self.original_tagname_ = None
        self.ENABLED = ENABLED
        self.COMPULSORY = COMPULSORY
        self.API_ADDRESS_MODE = API_ADDRESS_MODE
        self.validate_API_ADDRESS_MODE(self.API_ADDRESS_MODE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AVSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AVSType.subclass:
            return AVSType.subclass(*args_, **kwargs_)
        else:
            return AVSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ENABLED(self): return self.ENABLED
    def set_ENABLED(self, ENABLED): self.ENABLED = ENABLED
    def get_COMPULSORY(self): return self.COMPULSORY
    def set_COMPULSORY(self, COMPULSORY): self.COMPULSORY = COMPULSORY
    def get_API_ADDRESS_MODE(self): return self.API_ADDRESS_MODE
    def set_API_ADDRESS_MODE(self, API_ADDRESS_MODE): self.API_ADDRESS_MODE = API_ADDRESS_MODE
    def validate_API_ADDRESS_MODE(self, value):
        # Validate type API_ADDRESS_MODE, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ENABLED is not None or
            self.COMPULSORY is not None or
            self.API_ADDRESS_MODE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AVSType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ENABLED is not None:
            ENABLED_ = self.ENABLED
            etree_.SubElement(element, '{}ENABLED').text = self.gds_format_boolean(ENABLED_)
        if self.COMPULSORY is not None:
            COMPULSORY_ = self.COMPULSORY
            etree_.SubElement(element, '{}COMPULSORY').text = self.gds_format_boolean(COMPULSORY_)
        if self.API_ADDRESS_MODE is not None:
            API_ADDRESS_MODE_ = self.API_ADDRESS_MODE
            etree_.SubElement(element, '{}API_ADDRESS_MODE').text = self.gds_format_string(API_ADDRESS_MODE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AVSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ENABLED is not None:
            showIndent(outfile, level)
            outfile.write('ENABLED=%s,\n' % self.ENABLED)
        if self.COMPULSORY is not None:
            showIndent(outfile, level)
            outfile.write('COMPULSORY=%s,\n' % self.COMPULSORY)
        if self.API_ADDRESS_MODE is not None:
            showIndent(outfile, level)
            outfile.write('API_ADDRESS_MODE=%s,\n' % self.gds_encode(quote_python(self.API_ADDRESS_MODE)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ENABLED':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ENABLED')
            self.ENABLED = ival_
        elif nodeName_ == 'COMPULSORY':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'COMPULSORY')
            self.COMPULSORY = ival_
        elif nodeName_ == 'API_ADDRESS_MODE':
            API_ADDRESS_MODE_ = child_.text
            API_ADDRESS_MODE_ = self.gds_validate_string(API_ADDRESS_MODE_, node, 'API_ADDRESS_MODE')
            self.API_ADDRESS_MODE = API_ADDRESS_MODE_
            # validate type API_ADDRESS_MODE
            self.validate_API_ADDRESS_MODE(self.API_ADDRESS_MODE)
# end class AVSType


class SENTINEL_DEFENDType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ENABLED', 'xs:boolean', 0, 1, {'ref': 'ENABLED', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'ENABLED', 'type': 'xs:boolean'}, None),
        MemberSpec_('ORGANIZATION_ID', ['ORGANIZATION_IDType', 'xs:string'], 0, 1, {'name': 'ORGANIZATION_ID', 'minOccurs': '0', 'maxOccurs': '1', 'type': 'xs:string'}, None),
        MemberSpec_('FRAUDREVIEWSESSIONID', ['FRAUDREVIEWSESSIONID', 'xs:string'], 0, 1, {'ref': 'FRAUDREVIEWSESSIONID', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'FRAUDREVIEWSESSIONID', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ENABLED=None, ORGANIZATION_ID=None, FRAUDREVIEWSESSIONID=None):
        self.original_tagname_ = None
        self.ENABLED = ENABLED
        self.ORGANIZATION_ID = ORGANIZATION_ID
        self.validate_ORGANIZATION_IDType(self.ORGANIZATION_ID)
        self.FRAUDREVIEWSESSIONID = FRAUDREVIEWSESSIONID
        self.validate_FRAUDREVIEWSESSIONID(self.FRAUDREVIEWSESSIONID)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SENTINEL_DEFENDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SENTINEL_DEFENDType.subclass:
            return SENTINEL_DEFENDType.subclass(*args_, **kwargs_)
        else:
            return SENTINEL_DEFENDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ENABLED(self): return self.ENABLED
    def set_ENABLED(self, ENABLED): self.ENABLED = ENABLED
    def get_ORGANIZATION_ID(self): return self.ORGANIZATION_ID
    def set_ORGANIZATION_ID(self, ORGANIZATION_ID): self.ORGANIZATION_ID = ORGANIZATION_ID
    def get_FRAUDREVIEWSESSIONID(self): return self.FRAUDREVIEWSESSIONID
    def set_FRAUDREVIEWSESSIONID(self, FRAUDREVIEWSESSIONID): self.FRAUDREVIEWSESSIONID = FRAUDREVIEWSESSIONID
    def validate_ORGANIZATION_IDType(self, value):
        # Validate type ORGANIZATION_IDType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 32:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ORGANIZATION_IDType' % {"value" : value.encode("utf-8")} )
    def validate_FRAUDREVIEWSESSIONID(self, value):
        # Validate type FRAUDREVIEWSESSIONID, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ENABLED is not None or
            self.ORGANIZATION_ID is not None or
            self.FRAUDREVIEWSESSIONID is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SENTINEL_DEFENDType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ENABLED is not None:
            ENABLED_ = self.ENABLED
            etree_.SubElement(element, '{}ENABLED').text = self.gds_format_boolean(ENABLED_)
        if self.ORGANIZATION_ID is not None:
            ORGANIZATION_ID_ = self.ORGANIZATION_ID
            etree_.SubElement(element, '{}ORGANIZATION_ID').text = self.gds_format_string(ORGANIZATION_ID_)
        if self.FRAUDREVIEWSESSIONID is not None:
            FRAUDREVIEWSESSIONID_ = self.FRAUDREVIEWSESSIONID
            etree_.SubElement(element, '{}FRAUDREVIEWSESSIONID').text = self.gds_format_string(FRAUDREVIEWSESSIONID_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SENTINEL_DEFENDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ENABLED is not None:
            showIndent(outfile, level)
            outfile.write('ENABLED=%s,\n' % self.ENABLED)
        if self.ORGANIZATION_ID is not None:
            showIndent(outfile, level)
            outfile.write('ORGANIZATION_ID=%s,\n' % self.gds_encode(quote_python(self.ORGANIZATION_ID)))
        if self.FRAUDREVIEWSESSIONID is not None:
            showIndent(outfile, level)
            outfile.write('FRAUDREVIEWSESSIONID=%s,\n' % self.gds_encode(quote_python(self.FRAUDREVIEWSESSIONID)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ENABLED':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ENABLED')
            self.ENABLED = ival_
        elif nodeName_ == 'ORGANIZATION_ID':
            ORGANIZATION_ID_ = child_.text
            ORGANIZATION_ID_ = self.gds_validate_string(ORGANIZATION_ID_, node, 'ORGANIZATION_ID')
            self.ORGANIZATION_ID = ORGANIZATION_ID_
            # validate type ORGANIZATION_IDType
            self.validate_ORGANIZATION_IDType(self.ORGANIZATION_ID)
        elif nodeName_ == 'FRAUDREVIEWSESSIONID':
            FRAUDREVIEWSESSIONID_ = child_.text
            FRAUDREVIEWSESSIONID_ = self.gds_validate_string(FRAUDREVIEWSESSIONID_, node, 'FRAUDREVIEWSESSIONID')
            self.FRAUDREVIEWSESSIONID = FRAUDREVIEWSESSIONID_
            # validate type FRAUDREVIEWSESSIONID
            self.validate_FRAUDREVIEWSESSIONID(self.FRAUDREVIEWSESSIONID)
# end class SENTINEL_DEFENDType


class INTEGRATIONType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ENABLE_BACKGROUND_VALIDATION', 'xs:boolean', 0, 1, {'name': 'ENABLE_BACKGROUND_VALIDATION', 'type': 'xs:boolean', 'minOccurs': '0', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ENABLE_BACKGROUND_VALIDATION=None):
        self.original_tagname_ = None
        self.ENABLE_BACKGROUND_VALIDATION = ENABLE_BACKGROUND_VALIDATION
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INTEGRATIONType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INTEGRATIONType.subclass:
            return INTEGRATIONType.subclass(*args_, **kwargs_)
        else:
            return INTEGRATIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ENABLE_BACKGROUND_VALIDATION(self): return self.ENABLE_BACKGROUND_VALIDATION
    def set_ENABLE_BACKGROUND_VALIDATION(self, ENABLE_BACKGROUND_VALIDATION): self.ENABLE_BACKGROUND_VALIDATION = ENABLE_BACKGROUND_VALIDATION
    def hasContent_(self):
        if (
            self.ENABLE_BACKGROUND_VALIDATION is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='INTEGRATIONType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ENABLE_BACKGROUND_VALIDATION is not None:
            ENABLE_BACKGROUND_VALIDATION_ = self.ENABLE_BACKGROUND_VALIDATION
            etree_.SubElement(element, '{}ENABLE_BACKGROUND_VALIDATION').text = self.gds_format_boolean(ENABLE_BACKGROUND_VALIDATION_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='INTEGRATIONType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ENABLE_BACKGROUND_VALIDATION is not None:
            showIndent(outfile, level)
            outfile.write('ENABLE_BACKGROUND_VALIDATION=%s,\n' % self.ENABLE_BACKGROUND_VALIDATION)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ENABLE_BACKGROUND_VALIDATION':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ENABLE_BACKGROUND_VALIDATION')
            self.ENABLE_BACKGROUND_VALIDATION = ival_
# end class INTEGRATIONType


class ITEMSType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ITEM', 'ITEM', 1, 1, {'ref': 'ITEM', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'ITEM', 'type': 'ITEM'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ITEM=None):
        self.original_tagname_ = None
        if ITEM is None:
            self.ITEM = []
        else:
            self.ITEM = ITEM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ITEMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ITEMSType.subclass:
            return ITEMSType.subclass(*args_, **kwargs_)
        else:
            return ITEMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ITEM(self): return self.ITEM
    def set_ITEM(self, ITEM): self.ITEM = ITEM
    def add_ITEM(self, value): self.ITEM.append(value)
    def insert_ITEM_at(self, index, value): self.ITEM.insert(index, value)
    def replace_ITEM_at(self, index, value): self.ITEM[index] = value
    def hasContent_(self):
        if (
            self.ITEM
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ITEMSType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for ITEM_ in self.ITEM:
            ITEM_.to_etree(element, name_='ITEM', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ITEMSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ITEM=[\n')
        level += 1
        for ITEM_ in self.ITEM:
            showIndent(outfile, level)
            outfile.write('model_.ITEM(\n')
            ITEM_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ITEM':
            obj_ = ITEM.factory()
            obj_.build(child_)
            self.ITEM.append(obj_)
            obj_.original_tagname_ = 'ITEM'
# end class ITEMSType


class ADDITIONAL_DETAILSType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('BATCH_NUMBER', 'xs:integer', 0, 1, {'name': 'BATCH_NUMBER', 'type': 'xs:integer', 'minOccurs': '0'}, None),
        MemberSpec_('BULK_NUMBER', 'xs:string', 0, 1, {'name': 'BULK_NUMBER', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('PROCESSINGTERMINAL', ['PROCESSINGTERMINAL', 'xs:string'], 0, 1, {'ref': 'PROCESSINGTERMINAL', 'minOccurs': '0', 'name': 'PROCESSINGTERMINAL', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('FOREIGNCURRENCYINFORMATION', 'FOREIGNCURRENCYINFORMATION', 0, 1, {'ref': 'FOREIGNCURRENCYINFORMATION', 'minOccurs': '0', 'name': 'FOREIGNCURRENCYINFORMATION', 'type': 'FOREIGNCURRENCYINFORMATION'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('TRANSACTION_CUSTOM_FIELDS', 'TRANSACTION_CUSTOM_FIELDSType', 0, 0, {'name': 'TRANSACTION_CUSTOM_FIELDS', 'type': 'TRANSACTION_CUSTOM_FIELDSType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, BATCH_NUMBER=None, BULK_NUMBER=None, PROCESSINGTERMINAL=None, RESPONSECODE=None, RESPONSETEXT=None, APPROVALCODE=None, FOREIGNCURRENCYINFORMATION=None, DESCRIPTION=None, TRANSACTION_CUSTOM_FIELDS=None):
        self.original_tagname_ = None
        self.BATCH_NUMBER = BATCH_NUMBER
        self.BULK_NUMBER = BULK_NUMBER
        self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
        self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.TRANSACTION_CUSTOM_FIELDS = TRANSACTION_CUSTOM_FIELDS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDITIONAL_DETAILSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDITIONAL_DETAILSType.subclass:
            return ADDITIONAL_DETAILSType.subclass(*args_, **kwargs_)
        else:
            return ADDITIONAL_DETAILSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BATCH_NUMBER(self): return self.BATCH_NUMBER
    def set_BATCH_NUMBER(self, BATCH_NUMBER): self.BATCH_NUMBER = BATCH_NUMBER
    def get_BULK_NUMBER(self): return self.BULK_NUMBER
    def set_BULK_NUMBER(self, BULK_NUMBER): self.BULK_NUMBER = BULK_NUMBER
    def get_PROCESSINGTERMINAL(self): return self.PROCESSINGTERMINAL
    def set_PROCESSINGTERMINAL(self, PROCESSINGTERMINAL): self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_FOREIGNCURRENCYINFORMATION(self): return self.FOREIGNCURRENCYINFORMATION
    def set_FOREIGNCURRENCYINFORMATION(self, FOREIGNCURRENCYINFORMATION): self.FOREIGNCURRENCYINFORMATION = FOREIGNCURRENCYINFORMATION
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_TRANSACTION_CUSTOM_FIELDS(self): return self.TRANSACTION_CUSTOM_FIELDS
    def set_TRANSACTION_CUSTOM_FIELDS(self, TRANSACTION_CUSTOM_FIELDS): self.TRANSACTION_CUSTOM_FIELDS = TRANSACTION_CUSTOM_FIELDS
    def validate_PROCESSINGTERMINAL(self, value):
        # Validate type PROCESSINGTERMINAL, a restriction on xs:string.
        pass
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.BATCH_NUMBER is not None or
            self.BULK_NUMBER is not None or
            self.PROCESSINGTERMINAL is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.APPROVALCODE is not None or
            self.FOREIGNCURRENCYINFORMATION is not None or
            self.DESCRIPTION is not None or
            self.TRANSACTION_CUSTOM_FIELDS is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDITIONAL_DETAILSType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.BATCH_NUMBER is not None:
            BATCH_NUMBER_ = self.BATCH_NUMBER
            etree_.SubElement(element, '{}BATCH_NUMBER').text = self.gds_format_integer(BATCH_NUMBER_)
        if self.BULK_NUMBER is not None:
            BULK_NUMBER_ = self.BULK_NUMBER
            etree_.SubElement(element, '{}BULK_NUMBER').text = self.gds_format_string(BULK_NUMBER_)
        if self.PROCESSINGTERMINAL is not None:
            PROCESSINGTERMINAL_ = self.PROCESSINGTERMINAL
            etree_.SubElement(element, '{}PROCESSINGTERMINAL').text = self.gds_format_string(PROCESSINGTERMINAL_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.FOREIGNCURRENCYINFORMATION is not None:
            FOREIGNCURRENCYINFORMATION_ = self.FOREIGNCURRENCYINFORMATION
            FOREIGNCURRENCYINFORMATION_.to_etree(element, name_='FOREIGNCURRENCYINFORMATION', mapping_=mapping_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.TRANSACTION_CUSTOM_FIELDS is not None:
            TRANSACTION_CUSTOM_FIELDS_ = self.TRANSACTION_CUSTOM_FIELDS
            TRANSACTION_CUSTOM_FIELDS_.to_etree(element, name_='TRANSACTION_CUSTOM_FIELDS', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDITIONAL_DETAILSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BATCH_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('BATCH_NUMBER=%d,\n' % self.BATCH_NUMBER)
        if self.BULK_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('BULK_NUMBER=%s,\n' % self.gds_encode(quote_python(self.BULK_NUMBER)))
        if self.PROCESSINGTERMINAL is not None:
            showIndent(outfile, level)
            outfile.write('PROCESSINGTERMINAL=%s,\n' % self.gds_encode(quote_python(self.PROCESSINGTERMINAL)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.FOREIGNCURRENCYINFORMATION is not None:
            showIndent(outfile, level)
            outfile.write('FOREIGNCURRENCYINFORMATION=model_.FOREIGNCURRENCYINFORMATION(\n')
            self.FOREIGNCURRENCYINFORMATION.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.TRANSACTION_CUSTOM_FIELDS is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTION_CUSTOM_FIELDS=model_.TRANSACTION_CUSTOM_FIELDSType(\n')
            self.TRANSACTION_CUSTOM_FIELDS.exportLiteral(outfile, level, name_='TRANSACTION_CUSTOM_FIELDS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BATCH_NUMBER' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BATCH_NUMBER')
            self.BATCH_NUMBER = ival_
        elif nodeName_ == 'BULK_NUMBER':
            BULK_NUMBER_ = child_.text
            BULK_NUMBER_ = self.gds_validate_string(BULK_NUMBER_, node, 'BULK_NUMBER')
            self.BULK_NUMBER = BULK_NUMBER_
        elif nodeName_ == 'PROCESSINGTERMINAL':
            PROCESSINGTERMINAL_ = child_.text
            PROCESSINGTERMINAL_ = self.gds_validate_string(PROCESSINGTERMINAL_, node, 'PROCESSINGTERMINAL')
            self.PROCESSINGTERMINAL = PROCESSINGTERMINAL_
            # validate type PROCESSINGTERMINAL
            self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'FOREIGNCURRENCYINFORMATION':
            obj_ = FOREIGNCURRENCYINFORMATION.factory()
            obj_.build(child_)
            self.FOREIGNCURRENCYINFORMATION = obj_
            obj_.original_tagname_ = 'FOREIGNCURRENCYINFORMATION'
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'TRANSACTION_CUSTOM_FIELDS':
            obj_ = TRANSACTION_CUSTOM_FIELDSType.factory()
            obj_.build(child_)
            self.TRANSACTION_CUSTOM_FIELDS = obj_
            obj_.original_tagname_ = 'TRANSACTION_CUSTOM_FIELDS'
# end class ADDITIONAL_DETAILSType


class TRANSACTION_CUSTOM_FIELDSType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TRANSACTION_CUSTOM_FIELD', 'TRANSACTION_CUSTOM_FIELDType', 1, 1, {'name': 'TRANSACTION_CUSTOM_FIELD', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'type': 'TRANSACTION_CUSTOM_FIELDType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TRANSACTION_CUSTOM_FIELD=None):
        self.original_tagname_ = None
        if TRANSACTION_CUSTOM_FIELD is None:
            self.TRANSACTION_CUSTOM_FIELD = []
        else:
            self.TRANSACTION_CUSTOM_FIELD = TRANSACTION_CUSTOM_FIELD
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRANSACTION_CUSTOM_FIELDSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRANSACTION_CUSTOM_FIELDSType.subclass:
            return TRANSACTION_CUSTOM_FIELDSType.subclass(*args_, **kwargs_)
        else:
            return TRANSACTION_CUSTOM_FIELDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TRANSACTION_CUSTOM_FIELD(self): return self.TRANSACTION_CUSTOM_FIELD
    def set_TRANSACTION_CUSTOM_FIELD(self, TRANSACTION_CUSTOM_FIELD): self.TRANSACTION_CUSTOM_FIELD = TRANSACTION_CUSTOM_FIELD
    def add_TRANSACTION_CUSTOM_FIELD(self, value): self.TRANSACTION_CUSTOM_FIELD.append(value)
    def insert_TRANSACTION_CUSTOM_FIELD_at(self, index, value): self.TRANSACTION_CUSTOM_FIELD.insert(index, value)
    def replace_TRANSACTION_CUSTOM_FIELD_at(self, index, value): self.TRANSACTION_CUSTOM_FIELD[index] = value
    def hasContent_(self):
        if (
            self.TRANSACTION_CUSTOM_FIELD
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TRANSACTION_CUSTOM_FIELDSType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for TRANSACTION_CUSTOM_FIELD_ in self.TRANSACTION_CUSTOM_FIELD:
            TRANSACTION_CUSTOM_FIELD_.to_etree(element, name_='TRANSACTION_CUSTOM_FIELD', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TRANSACTION_CUSTOM_FIELDSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TRANSACTION_CUSTOM_FIELD=[\n')
        level += 1
        for TRANSACTION_CUSTOM_FIELD_ in self.TRANSACTION_CUSTOM_FIELD:
            showIndent(outfile, level)
            outfile.write('model_.TRANSACTION_CUSTOM_FIELDType(\n')
            TRANSACTION_CUSTOM_FIELD_.exportLiteral(outfile, level, name_='TRANSACTION_CUSTOM_FIELDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TRANSACTION_CUSTOM_FIELD':
            obj_ = TRANSACTION_CUSTOM_FIELDType.factory()
            obj_.build(child_)
            self.TRANSACTION_CUSTOM_FIELD.append(obj_)
            obj_.original_tagname_ = 'TRANSACTION_CUSTOM_FIELD'
# end class TRANSACTION_CUSTOM_FIELDSType


class TRANSACTION_CUSTOM_FIELDType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('NAME', 'xs:string', 0, 0, {'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('VALUE', 'xs:string', 0, 0, {'name': 'VALUE', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, NAME=None, VALUE=None):
        self.original_tagname_ = None
        self.NAME = NAME
        self.VALUE = VALUE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRANSACTION_CUSTOM_FIELDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRANSACTION_CUSTOM_FIELDType.subclass:
            return TRANSACTION_CUSTOM_FIELDType.subclass(*args_, **kwargs_)
        else:
            return TRANSACTION_CUSTOM_FIELDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_VALUE(self): return self.VALUE
    def set_VALUE(self, VALUE): self.VALUE = VALUE
    def hasContent_(self):
        if (
            self.NAME is not None or
            self.VALUE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TRANSACTION_CUSTOM_FIELDType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.VALUE is not None:
            VALUE_ = self.VALUE
            etree_.SubElement(element, '{}VALUE').text = self.gds_format_string(VALUE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TRANSACTION_CUSTOM_FIELDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.VALUE is not None:
            showIndent(outfile, level)
            outfile.write('VALUE=%s,\n' % self.gds_encode(quote_python(self.VALUE)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'VALUE':
            VALUE_ = child_.text
            VALUE_ = self.gds_validate_string(VALUE_, node, 'VALUE')
            self.VALUE = VALUE_
# end class TRANSACTION_CUSTOM_FIELDType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'xs_string'
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'xs_string'
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'xs_string'
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'xs_string'
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from gateway import *\n\n')
        sys.stdout.write('import gateway as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ACCOUNT_NAME",
    "ACCOUNT_NUMBER",
    "ACCOUNT_TYPE",
    "ACCOUNT_VERIFICATION",
    "ACCOUNT_VERIFICATION_RESPONSE",
    "ACHREFERENCE",
    "ACHREINITIATION",
    "ACHREINITIATIONRESPONSE",
    "ACHSECUREREGISTRATION",
    "ACHSECUREREGISTRATIONRESPONSE",
    "ACHSECUREREMOVAL",
    "ACHSECUREREMOVALRESPONSE",
    "ACHSECURESEARCH",
    "ACHSECURESEARCHRESPONSE",
    "ACHSECUREUPDATE",
    "ACHSECUREUPDATERESPONSE",
    "ACH_ACCOUNT",
    "ACH_ACCOUNT_TYPE",
    "ACH_ADDRESS1",
    "ACH_ADDRESS2",
    "ACH_CHECK_NUMBER",
    "ACH_CITY",
    "ACH_FIRST_NAME",
    "ACH_LAST_NAME",
    "ACH_NOTIFICATION_URL",
    "ACH_PHONE_NUMBER",
    "ACH_SECURE",
    "ACH_SEC_CODE",
    "ACH_STATE",
    "ACH_SUBSCRIPTION_PAYMENT",
    "ACH_SUBSCRIPTION_PAYMENT_RESPONSE",
    "ACH_TERMINALID",
    "ACH_ZIP",
    "ADDITIONAL_DETAILSType",
    "ADDITIONAL_FIELD",
    "ADDRESS1",
    "ADDRESS2",
    "ADDSTOREDSUBSCRIPTION",
    "ADDSTOREDSUBSCRIPTIONRESPONSE",
    "ADDSUBSCRIPTION",
    "ADDSUBSCRIPTIONRESPONSE",
    "ADD_ACH_SUBSCRIPTION",
    "ADD_ACH_SUBSCRIPTION_RESPONSE",
    "ANDROIDPAYLOAD",
    "API_ADDRESS_MODE",
    "APPLEPAYLOAD",
    "APPROVALCODE",
    "AUTH_TYPE",
    "AUTOREADY",
    "AVSONLY",
    "AVSRESPONSE",
    "AVSType",
    "BANKRESPONSECODE",
    "BANK_SETTINGSType",
    "BILLTOFIRSTNAME",
    "BILLTOLASTNAME",
    "BSB_NUMBER",
    "CANCELSUBSCRIPTION",
    "CANCELSUBSCRIPTIONRESPONSE",
    "CANCEL_PAYMENT_LINK",
    "CANCEL_PAYMENT_LINK_RESPONSE",
    "CARDBIN",
    "CARDCURRENCY",
    "CARDCURRENCYRATERESPONSE",
    "CARDDETAILS",
    "CARDEXPIRY",
    "CARDHOLDERNAME",
    "CARDNUMBER",
    "CARDREFERENCE",
    "CARDTYPE",
    "CAVV",
    "CHECK_NUMBER",
    "CITY",
    "COUNTRY",
    "CREATE_PAYMENT_LINK",
    "CREATE_PAYMENT_LINK_RESPONSE",
    "CREATIONDATE",
    "CREDENTIALONFILE",
    "CURRENCY",
    "CUSTOMFIELD",
    "CUSTOM_FIELDS",
    "CUSTOM_FIELDType",
    "CVV",
    "CVVRESPONSE",
    "DATETIME",
    "DEBIT_DATE",
    "DECLINEDREFUNDORDERID",
    "DELETESTOREDSUBSCRIPTION",
    "DELETESTOREDSUBSCRIPTIONRESPONSE",
    "DELETESUBSCRIPTION",
    "DELETESUBSCRIPTIONRESPONSE",
    "DESCRIPTION",
    "DEVICEID",
    "DL_NUMBER",
    "DL_STATE",
    "DONTCHECKSECURITY",
    "DS_TRANS_ID",
    "DUKPTCARDDETAILS",
    "EDCCDECISION",
    "EMAIL",
    "ENCRYPTEDPAYLOAD",
    "ENCRYPTEDTRACK",
    "ENDDATE",
    "ENHANCED_DATAType",
    "ENHANCED_DATA_TEMPLATE",
    "ERROR",
    "ERRORCODE",
    "ERRORSTRING",
    "EXCHANGERATESOURCENAME",
    "FEATURESType",
    "FOREIGNCURRENCYINFORMATION",
    "FORMATID",
    "FRAUDREVIEWREASONCODE",
    "FRAUDREVIEWRESPONSE",
    "FRAUDREVIEWRISKRATING",
    "FRAUDREVIEWSCORE",
    "FRAUDREVIEWSESSIONID",
    "FRAUDREVIEWSTATUS",
    "FROMSTATUS",
    "FXCURRENCY",
    "FXCURRENCYRATERESPONSE",
    "GETCARDCURRENCYRATE",
    "GETFXCURRENCYRATE",
    "GET_PAYMENT_LINK",
    "GET_PAYMENT_LINK_RESPONSE",
    "GET_TRANSACTION_DETAILS",
    "GET_TRANSACTION_DETAILS_RESPONSE",
    "GOOGLEPAYLOAD",
    "HASH",
    "INTEGRATIONType",
    "IPADDRESS",
    "ISSUENO",
    "ITEM",
    "ITEMSType",
    "KSN",
    "LEVEL_2_DATA",
    "LEVEL_3_DATA",
    "LEVEL_DATA",
    "LINE_ITEMSType",
    "LINE_ITEMType",
    "MASKEDCARDNUMBER",
    "MERCHANTREF",
    "MOBILENUMBER",
    "MPIREF",
    "NAME",
    "NEWSTOREDSUBSCRIPTIONINFO",
    "NOTIFICATIONLANGUAGE",
    "OFFLINEPAYMENT",
    "OFFLINEPAYMENTRESPONSE",
    "ONDELETE",
    "ONUPDATE",
    "OPERATOR",
    "ORDERID",
    "PAREFERENCENUMBER",
    "PAYLOAD",
    "PAYMENT",
    "PAYMENTACH",
    "PAYMENTACHRESPONSE",
    "PAYMENTDIRECTDEBIT",
    "PAYMENTRESPONSE",
    "PAYMENT_LINK_STATUS",
    "PERIODTYPE",
    "PERMITTEDTERMINALS",
    "PERMITTEDTERMINALSREQUIRED",
    "PHONE",
    "POSDEVICE",
    "POSTCODE",
    "PREAUTH",
    "PREAUTHCOMPLETION",
    "PREAUTHCOMPLETIONRESPONSE",
    "PREAUTHRESPONSE",
    "PROCESSINGTERMINAL",
    "REASON",
    "REFUND",
    "REFUNDRESPONSE",
    "REGION",
    "RESPONSECODE",
    "RESPONSETEXT",
    "ROUTING_NUMBER",
    "SECUREACHACCOUNTMERCHANTREF",
    "SECURECARD",
    "SECURECARDMERCHANTREF",
    "SECURECARDREGISTRATION",
    "SECURECARDREGISTRATIONRESPONSE",
    "SECURECARDREMOVAL",
    "SECURECARDREMOVALRESPONSE",
    "SECURECARDSEARCH",
    "SECURECARDSEARCHRESPONSE",
    "SECURECARDUPDATE",
    "SECURECARDUPDATERESPONSE",
    "SECURE_CARD_ADVANCED_SEARCH",
    "SECURE_CARD_ADVANCED_SEARCH_RESPONSE",
    "SECURE_CARD_STORAGEType",
    "SECURITY_FRAUDType",
    "SEC_CODE",
    "SEND_PAYMENT_LINK_EMAIL",
    "SEND_PAYMENT_LINK_EMAIL_RESPONSE",
    "SENTINEL_DEFENDType",
    "SHIPPING_ADDRESSType",
    "SIGNATURE",
    "STARTDATE",
    "STOREDSUBSCRIPTIONREF",
    "SUBSCRIPTIONPAYMENT",
    "SUBSCRIPTIONPAYMENTRESPONSE",
    "SUBSCRIPTIONREF",
    "SUMMARYType",
    "SUPPORTED_CARDTYPESType",
    "SUPPORTED_CURRENCIESType",
    "SURCHARGEType",
    "TERMINALCURRENCY",
    "TERMINALID",
    "TERMINALTYPE",
    "TERMINAL_CONFIGURATION",
    "TERMINAL_CONFIGURATION_RESPONSE",
    "THREEDS_PROTOCOL_VERSION",
    "TOSTATUS",
    "TRACKDATA",
    "TRANSACTIONTYPE",
    "TRANSACTIONUPDATE",
    "TRANSACTIONUPDATERESPONSE",
    "TRANSACTION_CUSTOM_FIELDSType",
    "TRANSACTION_CUSTOM_FIELDType",
    "TXN_DATA_LEVEL",
    "TYPE",
    "UNREFERENCEDREFUND",
    "UNREFERENCEDREFUNDRESPONSE",
    "UPDATESTOREDSUBSCRIPTION",
    "UPDATESTOREDSUBSCRIPTIONRESPONSE",
    "UPDATESUBSCRIPTION",
    "UPDATESUBSCRIPTIONRESPONSE",
    "UPDATE_ACH_SUBSCRIPTION",
    "UPDATE_ACH_SUBSCRIPTION_RESPONSE",
    "UPDATE_TRANSACTION_ENHANCED_DATA",
    "UPDATE_TRANSACTION_ENHANCED_DATA_RESPONSE",
    "VOICEIDPAYMENT",
    "VOICEIDREQUEST",
    "VOICEIDRESPONSE",
    "XID"
]
