#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated  by generateDS.py.
# Python 3.8.5 (default, Jan 27 2021, 15:41:15)  [GCC 9.3.0]
#
# Command line options:
#   ('--user-methods', 'boarding_user_methods')
#   ('--export', 'etree literal')
#   ('--use-getter-setter', 'new')
#   ('--no-dates', '')
#   ('--no-versions', '')
#   ('-f', '')
#   ('-o', 'payment_page.py')
#
# Command line arguments:
#   payment_page.xsd
#
# Command line:
#   /usr/local/bin/generateDS --user-methods="boarding_user_methods" --export="etree literal" --use-getter-setter="new" --no-dates --no-versions -f -o "payment_page.py" payment_page.xsd
#
# Current working directory (os.getcwd()):
#   model
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class STOREDCREDENTIALTXTYPE(object):
    FIRST_TXN='FIRST_TXN'
    SUBSEQUENT_MERCHANT_INITIATED_TXN='SUBSEQUENT_MERCHANT_INITIATED_TXN'
    SUBSEQUENT_CARDHOLDER_INITIATED_TXN='SUBSEQUENT_CARDHOLDER_INITIATED_TXN'


class STOREDCREDENTIALUSE(object):
    UNSCHEDULED='UNSCHEDULED'
    INSTALLMENT='INSTALLMENT'
    RECURRING='RECURRING'


class empty(object):
    _=''


class ORDERID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ORDERID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ORDERID.subclass:
            return ORDERID.subclass(*args_, **kwargs_)
        else:
            return ORDERID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ORDERID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ORDERID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ORDERID


class TERMINALID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TERMINALID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TERMINALID.subclass:
            return TERMINALID.subclass(*args_, **kwargs_)
        else:
            return TERMINALID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TERMINALID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TERMINALID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class TERMINALID


class DATETIME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATETIME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATETIME.subclass:
            return DATETIME.subclass(*args_, **kwargs_)
        else:
            return DATETIME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DATETIME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DATETIME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class DATETIME


class CARDNUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDNUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDNUMBER.subclass:
            return CARDNUMBER.subclass(*args_, **kwargs_)
        else:
            return CARDNUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDNUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDNUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class CARDNUMBER


class CREDENTIALONFILE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('BRANDTXIDENTIFIER', ['BRANDTXIDENTIFIER', 'xs:string'], 0, 1, {'name': 'BRANDTXIDENTIFIER', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('ORIGINALBRANDTXIDENTIFIER', ['BRANDTXIDENTIFIER', 'xs:string'], 0, 1, {'name': 'ORIGINALBRANDTXIDENTIFIER', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('STOREDCREDENTIALTXTYPE', ['STOREDCREDENTIALTXTYPE', 'xs:string'], 0, 1, {'name': 'STOREDCREDENTIALTXTYPE', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('STOREDCREDENTIALUSE', ['STOREDCREDENTIALUSE', 'xs:string'], 0, 1, {'name': 'STOREDCREDENTIALUSE', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, BRANDTXIDENTIFIER=None, ORIGINALBRANDTXIDENTIFIER=None, STOREDCREDENTIALTXTYPE=None, STOREDCREDENTIALUSE=None):
        self.original_tagname_ = None
        self.BRANDTXIDENTIFIER = BRANDTXIDENTIFIER
        self.validate_BRANDTXIDENTIFIER(self.BRANDTXIDENTIFIER)
        self.ORIGINALBRANDTXIDENTIFIER = ORIGINALBRANDTXIDENTIFIER
        self.validate_BRANDTXIDENTIFIER(self.ORIGINALBRANDTXIDENTIFIER)
        self.STOREDCREDENTIALTXTYPE = STOREDCREDENTIALTXTYPE
        self.validate_STOREDCREDENTIALTXTYPE(self.STOREDCREDENTIALTXTYPE)
        self.STOREDCREDENTIALUSE = STOREDCREDENTIALUSE
        self.validate_STOREDCREDENTIALUSE(self.STOREDCREDENTIALUSE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CREDENTIALONFILE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CREDENTIALONFILE.subclass:
            return CREDENTIALONFILE.subclass(*args_, **kwargs_)
        else:
            return CREDENTIALONFILE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BRANDTXIDENTIFIER(self): return self.BRANDTXIDENTIFIER
    def set_BRANDTXIDENTIFIER(self, BRANDTXIDENTIFIER): self.BRANDTXIDENTIFIER = BRANDTXIDENTIFIER
    def get_ORIGINALBRANDTXIDENTIFIER(self): return self.ORIGINALBRANDTXIDENTIFIER
    def set_ORIGINALBRANDTXIDENTIFIER(self, ORIGINALBRANDTXIDENTIFIER): self.ORIGINALBRANDTXIDENTIFIER = ORIGINALBRANDTXIDENTIFIER
    def get_STOREDCREDENTIALTXTYPE(self): return self.STOREDCREDENTIALTXTYPE
    def set_STOREDCREDENTIALTXTYPE(self, STOREDCREDENTIALTXTYPE): self.STOREDCREDENTIALTXTYPE = STOREDCREDENTIALTXTYPE
    def get_STOREDCREDENTIALUSE(self): return self.STOREDCREDENTIALUSE
    def set_STOREDCREDENTIALUSE(self, STOREDCREDENTIALUSE): self.STOREDCREDENTIALUSE = STOREDCREDENTIALUSE
    def validate_BRANDTXIDENTIFIER(self, value):
        # Validate type BRANDTXIDENTIFIER, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on BRANDTXIDENTIFIER' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BRANDTXIDENTIFIER' % {"value" : value.encode("utf-8")} )
    def validate_STOREDCREDENTIALTXTYPE(self, value):
        # Validate type STOREDCREDENTIALTXTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FIRST_TXN', 'SUBSEQUENT_MERCHANT_INITIATED_TXN', 'SUBSEQUENT_CARDHOLDER_INITIATED_TXN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on STOREDCREDENTIALTXTYPE' % {"value" : value.encode("utf-8")} )
    def validate_STOREDCREDENTIALUSE(self, value):
        # Validate type STOREDCREDENTIALUSE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['UNSCHEDULED', 'INSTALLMENT', 'RECURRING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on STOREDCREDENTIALUSE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.BRANDTXIDENTIFIER is not None or
            self.ORIGINALBRANDTXIDENTIFIER is not None or
            self.STOREDCREDENTIALTXTYPE is not None or
            self.STOREDCREDENTIALUSE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CREDENTIALONFILE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.BRANDTXIDENTIFIER is not None:
            BRANDTXIDENTIFIER_ = self.BRANDTXIDENTIFIER
            etree_.SubElement(element, '{}BRANDTXIDENTIFIER').text = self.gds_format_string(BRANDTXIDENTIFIER_)
        if self.ORIGINALBRANDTXIDENTIFIER is not None:
            ORIGINALBRANDTXIDENTIFIER_ = self.ORIGINALBRANDTXIDENTIFIER
            etree_.SubElement(element, '{}ORIGINALBRANDTXIDENTIFIER').text = self.gds_format_string(ORIGINALBRANDTXIDENTIFIER_)
        if self.STOREDCREDENTIALTXTYPE is not None:
            STOREDCREDENTIALTXTYPE_ = self.STOREDCREDENTIALTXTYPE
            etree_.SubElement(element, '{}STOREDCREDENTIALTXTYPE').text = self.gds_format_string(STOREDCREDENTIALTXTYPE_)
        if self.STOREDCREDENTIALUSE is not None:
            STOREDCREDENTIALUSE_ = self.STOREDCREDENTIALUSE
            etree_.SubElement(element, '{}STOREDCREDENTIALUSE').text = self.gds_format_string(STOREDCREDENTIALUSE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CREDENTIALONFILE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BRANDTXIDENTIFIER is not None:
            showIndent(outfile, level)
            outfile.write('BRANDTXIDENTIFIER=%s,\n' % self.gds_encode(quote_python(self.BRANDTXIDENTIFIER)))
        if self.ORIGINALBRANDTXIDENTIFIER is not None:
            showIndent(outfile, level)
            outfile.write('ORIGINALBRANDTXIDENTIFIER=%s,\n' % self.gds_encode(quote_python(self.ORIGINALBRANDTXIDENTIFIER)))
        if self.STOREDCREDENTIALTXTYPE is not None:
            showIndent(outfile, level)
            outfile.write('STOREDCREDENTIALTXTYPE=%s,\n' % self.gds_encode(quote_python(self.STOREDCREDENTIALTXTYPE)))
        if self.STOREDCREDENTIALUSE is not None:
            showIndent(outfile, level)
            outfile.write('STOREDCREDENTIALUSE=%s,\n' % self.gds_encode(quote_python(self.STOREDCREDENTIALUSE)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BRANDTXIDENTIFIER':
            BRANDTXIDENTIFIER_ = child_.text
            BRANDTXIDENTIFIER_ = self.gds_validate_string(BRANDTXIDENTIFIER_, node, 'BRANDTXIDENTIFIER')
            self.BRANDTXIDENTIFIER = BRANDTXIDENTIFIER_
            # validate type BRANDTXIDENTIFIER
            self.validate_BRANDTXIDENTIFIER(self.BRANDTXIDENTIFIER)
        elif nodeName_ == 'ORIGINALBRANDTXIDENTIFIER':
            ORIGINALBRANDTXIDENTIFIER_ = child_.text
            ORIGINALBRANDTXIDENTIFIER_ = self.gds_validate_string(ORIGINALBRANDTXIDENTIFIER_, node, 'ORIGINALBRANDTXIDENTIFIER')
            self.ORIGINALBRANDTXIDENTIFIER = ORIGINALBRANDTXIDENTIFIER_
            # validate type BRANDTXIDENTIFIER
            self.validate_BRANDTXIDENTIFIER(self.ORIGINALBRANDTXIDENTIFIER)
        elif nodeName_ == 'STOREDCREDENTIALTXTYPE':
            STOREDCREDENTIALTXTYPE_ = child_.text
            STOREDCREDENTIALTXTYPE_ = self.gds_validate_string(STOREDCREDENTIALTXTYPE_, node, 'STOREDCREDENTIALTXTYPE')
            self.STOREDCREDENTIALTXTYPE = STOREDCREDENTIALTXTYPE_
            # validate type STOREDCREDENTIALTXTYPE
            self.validate_STOREDCREDENTIALTXTYPE(self.STOREDCREDENTIALTXTYPE)
        elif nodeName_ == 'STOREDCREDENTIALUSE':
            STOREDCREDENTIALUSE_ = child_.text
            STOREDCREDENTIALUSE_ = self.gds_validate_string(STOREDCREDENTIALUSE_, node, 'STOREDCREDENTIALUSE')
            self.STOREDCREDENTIALUSE = STOREDCREDENTIALUSE_
            # validate type STOREDCREDENTIALUSE
            self.validate_STOREDCREDENTIALUSE(self.STOREDCREDENTIALUSE)
    def sample_method(self):
        pass
# end class CREDENTIALONFILE


class CARDTYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDTYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDTYPE.subclass:
            return CARDTYPE.subclass(*args_, **kwargs_)
        else:
            return CARDTYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDTYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDTYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class CARDTYPE


class CARDEXPIRY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDEXPIRY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDEXPIRY.subclass:
            return CARDEXPIRY.subclass(*args_, **kwargs_)
        else:
            return CARDEXPIRY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDEXPIRY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDEXPIRY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class CARDEXPIRY


class CARDHOLDERNAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDHOLDERNAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDHOLDERNAME.subclass:
            return CARDHOLDERNAME.subclass(*args_, **kwargs_)
        else:
            return CARDHOLDERNAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDHOLDERNAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDHOLDERNAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class CARDHOLDERNAME


class ACCOUNT_NAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACCOUNT_NAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACCOUNT_NAME.subclass:
            return ACCOUNT_NAME.subclass(*args_, **kwargs_)
        else:
            return ACCOUNT_NAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACCOUNT_NAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACCOUNT_NAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACCOUNT_NAME


class HASH(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HASH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HASH.subclass:
            return HASH.subclass(*args_, **kwargs_)
        else:
            return HASH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='HASH', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='HASH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class HASH


class CURRENCY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CURRENCY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CURRENCY.subclass:
            return CURRENCY.subclass(*args_, **kwargs_)
        else:
            return CURRENCY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CURRENCY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CURRENCY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class CURRENCY


class AUTOREADY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AUTOREADY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AUTOREADY.subclass:
            return AUTOREADY.subclass(*args_, **kwargs_)
        else:
            return AUTOREADY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AUTOREADY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AUTOREADY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class AUTOREADY


class EMAIL(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EMAIL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EMAIL.subclass:
            return EMAIL.subclass(*args_, **kwargs_)
        else:
            return EMAIL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='EMAIL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='EMAIL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class EMAIL


class DESCRIPTION(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DESCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DESCRIPTION.subclass:
            return DESCRIPTION.subclass(*args_, **kwargs_)
        else:
            return DESCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DESCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DESCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class DESCRIPTION


class RECEIPTPAGEURL(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RECEIPTPAGEURL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RECEIPTPAGEURL.subclass:
            return RECEIPTPAGEURL.subclass(*args_, **kwargs_)
        else:
            return RECEIPTPAGEURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RECEIPTPAGEURL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RECEIPTPAGEURL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class RECEIPTPAGEURL


class VALIDATIONURL(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VALIDATIONURL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VALIDATIONURL.subclass:
            return VALIDATIONURL.subclass(*args_, **kwargs_)
        else:
            return VALIDATIONURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VALIDATIONURL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='VALIDATIONURL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class VALIDATIONURL


class ADDRESS1(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDRESS1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDRESS1.subclass:
            return ADDRESS1.subclass(*args_, **kwargs_)
        else:
            return ADDRESS1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDRESS1', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDRESS1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ADDRESS1


class ADDRESS2(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDRESS2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDRESS2.subclass:
            return ADDRESS2.subclass(*args_, **kwargs_)
        else:
            return ADDRESS2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDRESS2', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDRESS2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ADDRESS2


class POSTCODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POSTCODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POSTCODE.subclass:
            return POSTCODE.subclass(*args_, **kwargs_)
        else:
            return POSTCODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='POSTCODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='POSTCODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class POSTCODE


class BILLTOFIRSTNAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BILLTOFIRSTNAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BILLTOFIRSTNAME.subclass:
            return BILLTOFIRSTNAME.subclass(*args_, **kwargs_)
        else:
            return BILLTOFIRSTNAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BILLTOFIRSTNAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BILLTOFIRSTNAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class BILLTOFIRSTNAME


class BILLTOLASTNAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BILLTOLASTNAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BILLTOLASTNAME.subclass:
            return BILLTOLASTNAME.subclass(*args_, **kwargs_)
        else:
            return BILLTOLASTNAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BILLTOLASTNAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BILLTOLASTNAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class BILLTOLASTNAME


class MERCHANTREF(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MERCHANTREF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MERCHANTREF.subclass:
            return MERCHANTREF.subclass(*args_, **kwargs_)
        else:
            return MERCHANTREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MERCHANTREF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MERCHANTREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class MERCHANTREF


class SECURECARDREFERENCE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDREFERENCE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDREFERENCE.subclass:
            return SECURECARDREFERENCE.subclass(*args_, **kwargs_)
        else:
            return SECURECARDREFERENCE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDREFERENCE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDREFERENCE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class SECURECARDREFERENCE


class MOBILENUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MOBILENUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MOBILENUMBER.subclass:
            return MOBILENUMBER.subclass(*args_, **kwargs_)
        else:
            return MOBILENUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MOBILENUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MOBILENUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class MOBILENUMBER


class TERMINALTYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TERMINALTYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TERMINALTYPE.subclass:
            return TERMINALTYPE.subclass(*args_, **kwargs_)
        else:
            return TERMINALTYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TERMINALTYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TERMINALTYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class TERMINALTYPE


class TRANSACTIONTYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRANSACTIONTYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRANSACTIONTYPE.subclass:
            return TRANSACTIONTYPE.subclass(*args_, **kwargs_)
        else:
            return TRANSACTIONTYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TRANSACTIONTYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TRANSACTIONTYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class TRANSACTIONTYPE


class PAYMENTTYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAYMENTTYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAYMENTTYPE.subclass:
            return PAYMENTTYPE.subclass(*args_, **kwargs_)
        else:
            return PAYMENTTYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAYMENTTYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAYMENTTYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class PAYMENTTYPE


class COUNTRY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COUNTRY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COUNTRY.subclass:
            return COUNTRY.subclass(*args_, **kwargs_)
        else:
            return COUNTRY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='COUNTRY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='COUNTRY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class COUNTRY


class CITY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CITY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CITY.subclass:
            return CITY.subclass(*args_, **kwargs_)
        else:
            return CITY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CITY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CITY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class CITY


class REGION(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REGION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REGION.subclass:
            return REGION.subclass(*args_, **kwargs_)
        else:
            return REGION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='REGION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='REGION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class REGION


class LEVEL_2_DATA(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('CUSTOMER_REF_NUMBER', ['CUSTOMER_REF_NUMBERType', 'xs:string'], 0, 1, {'name': 'CUSTOMER_REF_NUMBER', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('TAX_AMOUNT', 'emptyDecimalAllowed', 0, 1, {'name': 'TAX_AMOUNT', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('SHIPPING_ADDRESS', 'SHIPPING_ADDRESSType', 0, 1, {'name': 'SHIPPING_ADDRESS', 'minOccurs': '0', 'type': 'SHIPPING_ADDRESSType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CUSTOMER_REF_NUMBER=None, TAX_AMOUNT=None, SHIPPING_ADDRESS=None):
        self.original_tagname_ = None
        self.CUSTOMER_REF_NUMBER = CUSTOMER_REF_NUMBER
        self.validate_CUSTOMER_REF_NUMBERType(self.CUSTOMER_REF_NUMBER)
        self.TAX_AMOUNT = TAX_AMOUNT
        self.validate_emptyDecimalAllowed(self.TAX_AMOUNT)
        self.SHIPPING_ADDRESS = SHIPPING_ADDRESS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LEVEL_2_DATA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LEVEL_2_DATA.subclass:
            return LEVEL_2_DATA.subclass(*args_, **kwargs_)
        else:
            return LEVEL_2_DATA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CUSTOMER_REF_NUMBER(self): return self.CUSTOMER_REF_NUMBER
    def set_CUSTOMER_REF_NUMBER(self, CUSTOMER_REF_NUMBER): self.CUSTOMER_REF_NUMBER = CUSTOMER_REF_NUMBER
    def get_TAX_AMOUNT(self): return self.TAX_AMOUNT
    def set_TAX_AMOUNT(self, TAX_AMOUNT): self.TAX_AMOUNT = TAX_AMOUNT
    def get_SHIPPING_ADDRESS(self): return self.SHIPPING_ADDRESS
    def set_SHIPPING_ADDRESS(self, SHIPPING_ADDRESS): self.SHIPPING_ADDRESS = SHIPPING_ADDRESS
    def validate_CUSTOMER_REF_NUMBERType(self, value):
        # Validate type CUSTOMER_REF_NUMBERType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 48:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CUSTOMER_REF_NUMBERType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CUSTOMER_REF_NUMBERType' % {"value" : value.encode("utf-8")} )
    def validate_emptyDecimalAllowed(self, value):
        # Validate type emptyDecimalAllowed, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.CUSTOMER_REF_NUMBER is not None or
            self.TAX_AMOUNT is not None or
            self.SHIPPING_ADDRESS is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LEVEL_2_DATA', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.CUSTOMER_REF_NUMBER is not None:
            CUSTOMER_REF_NUMBER_ = self.CUSTOMER_REF_NUMBER
            etree_.SubElement(element, '{}CUSTOMER_REF_NUMBER').text = self.gds_format_string(CUSTOMER_REF_NUMBER_)
        if self.TAX_AMOUNT is not None:
            TAX_AMOUNT_ = self.TAX_AMOUNT
            etree_.SubElement(element, '{}TAX_AMOUNT').text = self.gds_format_string(TAX_AMOUNT_)
        if self.SHIPPING_ADDRESS is not None:
            SHIPPING_ADDRESS_ = self.SHIPPING_ADDRESS
            SHIPPING_ADDRESS_.to_etree(element, name_='SHIPPING_ADDRESS', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LEVEL_2_DATA'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CUSTOMER_REF_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CUSTOMER_REF_NUMBER=%s,\n' % self.gds_encode(quote_python(self.CUSTOMER_REF_NUMBER)))
        if self.TAX_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TAX_AMOUNT=%s,\n' % self.gds_encode(quote_python(self.TAX_AMOUNT)))
        if self.SHIPPING_ADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('SHIPPING_ADDRESS=model_.SHIPPING_ADDRESSType(\n')
            self.SHIPPING_ADDRESS.exportLiteral(outfile, level, name_='SHIPPING_ADDRESS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CUSTOMER_REF_NUMBER':
            CUSTOMER_REF_NUMBER_ = child_.text
            CUSTOMER_REF_NUMBER_ = self.gds_validate_string(CUSTOMER_REF_NUMBER_, node, 'CUSTOMER_REF_NUMBER')
            self.CUSTOMER_REF_NUMBER = CUSTOMER_REF_NUMBER_
            # validate type CUSTOMER_REF_NUMBERType
            self.validate_CUSTOMER_REF_NUMBERType(self.CUSTOMER_REF_NUMBER)
        elif nodeName_ == 'TAX_AMOUNT':
            TAX_AMOUNT_ = child_.text
            TAX_AMOUNT_ = self.gds_validate_string(TAX_AMOUNT_, node, 'TAX_AMOUNT')
            self.TAX_AMOUNT = TAX_AMOUNT_
            # validate type emptyDecimalAllowed
            self.validate_emptyDecimalAllowed(self.TAX_AMOUNT)
        elif nodeName_ == 'SHIPPING_ADDRESS':
            obj_ = SHIPPING_ADDRESSType.factory()
            obj_.build(child_)
            self.SHIPPING_ADDRESS = obj_
            obj_.original_tagname_ = 'SHIPPING_ADDRESS'
    def sample_method(self):
        pass
# end class LEVEL_2_DATA


class LEVEL_3_DATA(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('SUMMARY', 'SUMMARYType', 0, 1, {'name': 'SUMMARY', 'minOccurs': '0', 'type': 'SUMMARYType'}, None),
        MemberSpec_('LINE_ITEMS', 'LINE_ITEMSType', 0, 1, {'name': 'LINE_ITEMS', 'minOccurs': '0', 'type': 'LINE_ITEMSType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, SUMMARY=None, LINE_ITEMS=None):
        self.original_tagname_ = None
        self.SUMMARY = SUMMARY
        self.LINE_ITEMS = LINE_ITEMS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LEVEL_3_DATA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LEVEL_3_DATA.subclass:
            return LEVEL_3_DATA.subclass(*args_, **kwargs_)
        else:
            return LEVEL_3_DATA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SUMMARY(self): return self.SUMMARY
    def set_SUMMARY(self, SUMMARY): self.SUMMARY = SUMMARY
    def get_LINE_ITEMS(self): return self.LINE_ITEMS
    def set_LINE_ITEMS(self, LINE_ITEMS): self.LINE_ITEMS = LINE_ITEMS
    def hasContent_(self):
        if (
            self.SUMMARY is not None or
            self.LINE_ITEMS is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LEVEL_3_DATA', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.SUMMARY is not None:
            SUMMARY_ = self.SUMMARY
            SUMMARY_.to_etree(element, name_='SUMMARY', mapping_=mapping_)
        if self.LINE_ITEMS is not None:
            LINE_ITEMS_ = self.LINE_ITEMS
            LINE_ITEMS_.to_etree(element, name_='LINE_ITEMS', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LEVEL_3_DATA'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SUMMARY is not None:
            showIndent(outfile, level)
            outfile.write('SUMMARY=model_.SUMMARYType(\n')
            self.SUMMARY.exportLiteral(outfile, level, name_='SUMMARY')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LINE_ITEMS is not None:
            showIndent(outfile, level)
            outfile.write('LINE_ITEMS=model_.LINE_ITEMSType(\n')
            self.LINE_ITEMS.exportLiteral(outfile, level, name_='LINE_ITEMS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SUMMARY':
            obj_ = SUMMARYType.factory()
            obj_.build(child_)
            self.SUMMARY = obj_
            obj_.original_tagname_ = 'SUMMARY'
        elif nodeName_ == 'LINE_ITEMS':
            obj_ = LINE_ITEMSType.factory()
            obj_.build(child_)
            self.LINE_ITEMS = obj_
            obj_.original_tagname_ = 'LINE_ITEMS'
    def sample_method(self):
        pass
# end class LEVEL_3_DATA


class ACCOUNT_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACCOUNT_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACCOUNT_NUMBER.subclass:
            return ACCOUNT_NUMBER.subclass(*args_, **kwargs_)
        else:
            return ACCOUNT_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACCOUNT_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACCOUNT_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACCOUNT_NUMBER


class ACCOUNT_TYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACCOUNT_TYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACCOUNT_TYPE.subclass:
            return ACCOUNT_TYPE.subclass(*args_, **kwargs_)
        else:
            return ACCOUNT_TYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACCOUNT_TYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACCOUNT_TYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACCOUNT_TYPE


class SEC_CODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SEC_CODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SEC_CODE.subclass:
            return SEC_CODE.subclass(*args_, **kwargs_)
        else:
            return SEC_CODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SEC_CODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SEC_CODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class SEC_CODE


class DL_STATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DL_STATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DL_STATE.subclass:
            return DL_STATE.subclass(*args_, **kwargs_)
        else:
            return DL_STATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DL_STATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DL_STATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class DL_STATE


class DL_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DL_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DL_NUMBER.subclass:
            return DL_NUMBER.subclass(*args_, **kwargs_)
        else:
            return DL_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DL_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DL_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class DL_NUMBER


class ROUTING_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ROUTING_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ROUTING_NUMBER.subclass:
            return ROUTING_NUMBER.subclass(*args_, **kwargs_)
        else:
            return ROUTING_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ROUTING_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ROUTING_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ROUTING_NUMBER


class CHECK_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CHECK_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CHECK_NUMBER.subclass:
            return CHECK_NUMBER.subclass(*args_, **kwargs_)
        else:
            return CHECK_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CHECK_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CHECK_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class CHECK_NUMBER


class IPADDRESS(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPADDRESS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPADDRESS.subclass:
            return IPADDRESS.subclass(*args_, **kwargs_)
        else:
            return IPADDRESS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='IPADDRESS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='IPADDRESS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class IPADDRESS


class PHONE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PHONE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PHONE.subclass:
            return PHONE.subclass(*args_, **kwargs_)
        else:
            return PHONE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PHONE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PHONE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class PHONE


class PaymentPage(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('AUTOREADY', ['AUTOREADY', 'xs:string'], 0, 1, {'ref': 'AUTOREADY', 'minOccurs': '0', 'name': 'AUTOREADY', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('RECEIPTPAGEURL', ['RECEIPTPAGEURL', 'xs:string'], 0, 0, {'ref': 'RECEIPTPAGEURL', 'name': 'RECEIPTPAGEURL', 'type': 'xs:string'}, None),
        MemberSpec_('VALIDATIONURL', ['VALIDATIONURL', 'xs:string'], 0, 0, {'ref': 'VALIDATIONURL', 'name': 'VALIDATIONURL', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 1, {'ref': 'CARDHOLDERNAME', 'minOccurs': '0', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 0, {'ref': 'PHONE', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('BILLTOFIRSTNAME', ['BILLTOFIRSTNAME', 'xs:string'], 0, 1, {'ref': 'BILLTOFIRSTNAME', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'BILLTOFIRSTNAME', 'type': 'xs:string'}, None),
        MemberSpec_('BILLTOLASTNAME', ['BILLTOLASTNAME', 'xs:string'], 0, 1, {'ref': 'BILLTOLASTNAME', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'BILLTOLASTNAME', 'type': 'xs:string'}, None),
        MemberSpec_('TRANSACTIONTYPE', ['TRANSACTIONTYPE', 'xs:int'], 0, 0, {'ref': 'TRANSACTIONTYPE', 'name': 'TRANSACTIONTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('PAYMENTTYPE', ['PAYMENTTYPE', 'xs:string'], 0, 0, {'ref': 'PAYMENTTYPE', 'name': 'PAYMENTTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ACH_NOTIFICATION_URL', ['ACH_NOTIFICATION_URL', 'xs:string'], 0, 0, {'ref': 'ACH_NOTIFICATION_URL', 'name': 'ACH_NOTIFICATION_URL', 'type': 'xs:string'}, None),
        MemberSpec_('SECURECARDMERCHANTREF', ['SECURECARDMERCHANTREF', 'xs:string'], 0, 0, {'ref': 'SECURECARDMERCHANTREF', 'name': 'SECURECARDMERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 0, {'ref': 'CARDNUMBER', 'name': 'CARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 0, {'ref': 'CARDTYPE', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 1, {'ref': 'CARDEXPIRY', 'minOccurs': '0', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALTYPE', ['TERMINALTYPE', 'xs:int'], 0, 0, {'ref': 'TERMINALTYPE', 'name': 'TERMINALTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('LEVEL_3_DATA', 'LEVEL_3_DATA', 0, 1, {'ref': 'LEVEL_3_DATA', 'minOccurs': '0', 'name': 'LEVEL_3_DATA', 'type': 'LEVEL_3_DATA'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TERMINALID=None, AMOUNT=None, ORDERID=None, DATETIME=None, HASH=None, CURRENCY=None, AUTOREADY=None, EMAIL=None, RECEIPTPAGEURL=None, VALIDATIONURL=None, CARDHOLDERNAME=None, ADDRESS1=None, ADDRESS2=None, POSTCODE=None, CITY=None, REGION=None, COUNTRY=None, PHONE=None, BILLTOFIRSTNAME=None, BILLTOLASTNAME=None, TRANSACTIONTYPE=None, PAYMENTTYPE=None, ACH_NOTIFICATION_URL=None, SECURECARDMERCHANTREF=None, CARDNUMBER=None, CARDTYPE=None, CARDEXPIRY=None, TERMINALTYPE=None, LEVEL_2_DATA=None, LEVEL_3_DATA=None, CREDENTIALONFILE=None):
        self.original_tagname_ = None
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.AUTOREADY = AUTOREADY
        self.validate_AUTOREADY(self.AUTOREADY)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.RECEIPTPAGEURL = RECEIPTPAGEURL
        self.validate_RECEIPTPAGEURL(self.RECEIPTPAGEURL)
        self.VALIDATIONURL = VALIDATIONURL
        self.validate_VALIDATIONURL(self.VALIDATIONURL)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.BILLTOFIRSTNAME = BILLTOFIRSTNAME
        self.validate_BILLTOFIRSTNAME(self.BILLTOFIRSTNAME)
        self.BILLTOLASTNAME = BILLTOLASTNAME
        self.validate_BILLTOLASTNAME(self.BILLTOLASTNAME)
        self.TRANSACTIONTYPE = TRANSACTIONTYPE
        self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        self.PAYMENTTYPE = PAYMENTTYPE
        self.validate_PAYMENTTYPE(self.PAYMENTTYPE)
        self.ACH_NOTIFICATION_URL = ACH_NOTIFICATION_URL
        self.validate_ACH_NOTIFICATION_URL(self.ACH_NOTIFICATION_URL)
        self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF
        self.validate_SECURECARDMERCHANTREF(self.SECURECARDMERCHANTREF)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.TERMINALTYPE = TERMINALTYPE
        self.validate_TERMINALTYPE(self.TERMINALTYPE)
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.LEVEL_3_DATA = LEVEL_3_DATA
        self.CREDENTIALONFILE = CREDENTIALONFILE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentPage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentPage.subclass:
            return PaymentPage.subclass(*args_, **kwargs_)
        else:
            return PaymentPage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_AUTOREADY(self): return self.AUTOREADY
    def set_AUTOREADY(self, AUTOREADY): self.AUTOREADY = AUTOREADY
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_RECEIPTPAGEURL(self): return self.RECEIPTPAGEURL
    def set_RECEIPTPAGEURL(self, RECEIPTPAGEURL): self.RECEIPTPAGEURL = RECEIPTPAGEURL
    def get_VALIDATIONURL(self): return self.VALIDATIONURL
    def set_VALIDATIONURL(self, VALIDATIONURL): self.VALIDATIONURL = VALIDATIONURL
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_BILLTOFIRSTNAME(self): return self.BILLTOFIRSTNAME
    def set_BILLTOFIRSTNAME(self, BILLTOFIRSTNAME): self.BILLTOFIRSTNAME = BILLTOFIRSTNAME
    def get_BILLTOLASTNAME(self): return self.BILLTOLASTNAME
    def set_BILLTOLASTNAME(self, BILLTOLASTNAME): self.BILLTOLASTNAME = BILLTOLASTNAME
    def get_TRANSACTIONTYPE(self): return self.TRANSACTIONTYPE
    def set_TRANSACTIONTYPE(self, TRANSACTIONTYPE): self.TRANSACTIONTYPE = TRANSACTIONTYPE
    def get_PAYMENTTYPE(self): return self.PAYMENTTYPE
    def set_PAYMENTTYPE(self, PAYMENTTYPE): self.PAYMENTTYPE = PAYMENTTYPE
    def get_ACH_NOTIFICATION_URL(self): return self.ACH_NOTIFICATION_URL
    def set_ACH_NOTIFICATION_URL(self, ACH_NOTIFICATION_URL): self.ACH_NOTIFICATION_URL = ACH_NOTIFICATION_URL
    def get_SECURECARDMERCHANTREF(self): return self.SECURECARDMERCHANTREF
    def set_SECURECARDMERCHANTREF(self, SECURECARDMERCHANTREF): self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_TERMINALTYPE(self): return self.TERMINALTYPE
    def set_TERMINALTYPE(self, TERMINALTYPE): self.TERMINALTYPE = TERMINALTYPE
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_LEVEL_3_DATA(self): return self.LEVEL_3_DATA
    def set_LEVEL_3_DATA(self, LEVEL_3_DATA): self.LEVEL_3_DATA = LEVEL_3_DATA
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_AUTOREADY(self, value):
        # Validate type AUTOREADY, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_RECEIPTPAGEURL(self, value):
        # Validate type RECEIPTPAGEURL, a restriction on xs:string.
        pass
    def validate_VALIDATIONURL(self, value):
        # Validate type VALIDATIONURL, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_BILLTOFIRSTNAME(self, value):
        # Validate type BILLTOFIRSTNAME, a restriction on xs:string.
        pass
    def validate_BILLTOLASTNAME(self, value):
        # Validate type BILLTOLASTNAME, a restriction on xs:string.
        pass
    def validate_TRANSACTIONTYPE(self, value):
        # Validate type TRANSACTIONTYPE, a restriction on xs:int.
        pass
    def validate_PAYMENTTYPE(self, value):
        # Validate type PAYMENTTYPE, a restriction on xs:string.
        pass
    def validate_ACH_NOTIFICATION_URL(self, value):
        # Validate type ACH_NOTIFICATION_URL, a restriction on xs:string.
        pass
    def validate_SECURECARDMERCHANTREF(self, value):
        # Validate type SECURECARDMERCHANTREF, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_TERMINALTYPE(self, value):
        # Validate type TERMINALTYPE, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.ORDERID is not None or
            self.DATETIME is not None or
            self.HASH is not None or
            self.CURRENCY is not None or
            self.AUTOREADY is not None or
            self.EMAIL is not None or
            self.RECEIPTPAGEURL is not None or
            self.VALIDATIONURL is not None or
            self.CARDHOLDERNAME is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.POSTCODE is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.COUNTRY is not None or
            self.PHONE is not None or
            self.BILLTOFIRSTNAME is not None or
            self.BILLTOLASTNAME is not None or
            self.TRANSACTIONTYPE is not None or
            self.PAYMENTTYPE is not None or
            self.ACH_NOTIFICATION_URL is not None or
            self.SECURECARDMERCHANTREF is not None or
            self.CARDNUMBER is not None or
            self.CARDTYPE is not None or
            self.CARDEXPIRY is not None or
            self.TERMINALTYPE is not None or
            self.LEVEL_2_DATA is not None or
            self.LEVEL_3_DATA is not None or
            self.CREDENTIALONFILE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PaymentPage', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.AUTOREADY is not None:
            AUTOREADY_ = self.AUTOREADY
            etree_.SubElement(element, '{}AUTOREADY').text = self.gds_format_string(AUTOREADY_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.RECEIPTPAGEURL is not None:
            RECEIPTPAGEURL_ = self.RECEIPTPAGEURL
            etree_.SubElement(element, '{}RECEIPTPAGEURL').text = self.gds_format_string(RECEIPTPAGEURL_)
        if self.VALIDATIONURL is not None:
            VALIDATIONURL_ = self.VALIDATIONURL
            etree_.SubElement(element, '{}VALIDATIONURL').text = self.gds_format_string(VALIDATIONURL_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.BILLTOFIRSTNAME is not None:
            BILLTOFIRSTNAME_ = self.BILLTOFIRSTNAME
            etree_.SubElement(element, '{}BILLTOFIRSTNAME').text = self.gds_format_string(BILLTOFIRSTNAME_)
        if self.BILLTOLASTNAME is not None:
            BILLTOLASTNAME_ = self.BILLTOLASTNAME
            etree_.SubElement(element, '{}BILLTOLASTNAME').text = self.gds_format_string(BILLTOLASTNAME_)
        if self.TRANSACTIONTYPE is not None:
            TRANSACTIONTYPE_ = self.TRANSACTIONTYPE
            etree_.SubElement(element, '{}TRANSACTIONTYPE').text = self.gds_format_integer(TRANSACTIONTYPE_)
        if self.PAYMENTTYPE is not None:
            PAYMENTTYPE_ = self.PAYMENTTYPE
            etree_.SubElement(element, '{}PAYMENTTYPE').text = self.gds_format_string(PAYMENTTYPE_)
        if self.ACH_NOTIFICATION_URL is not None:
            ACH_NOTIFICATION_URL_ = self.ACH_NOTIFICATION_URL
            etree_.SubElement(element, '{}ACH_NOTIFICATION_URL').text = self.gds_format_string(ACH_NOTIFICATION_URL_)
        if self.SECURECARDMERCHANTREF is not None:
            SECURECARDMERCHANTREF_ = self.SECURECARDMERCHANTREF
            etree_.SubElement(element, '{}SECURECARDMERCHANTREF').text = self.gds_format_string(SECURECARDMERCHANTREF_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.TERMINALTYPE is not None:
            TERMINALTYPE_ = self.TERMINALTYPE
            etree_.SubElement(element, '{}TERMINALTYPE').text = self.gds_format_integer(TERMINALTYPE_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.LEVEL_3_DATA is not None:
            LEVEL_3_DATA_ = self.LEVEL_3_DATA
            LEVEL_3_DATA_.to_etree(element, name_='LEVEL_3_DATA', mapping_=mapping_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PaymentPage'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.AUTOREADY is not None:
            showIndent(outfile, level)
            outfile.write('AUTOREADY=%s,\n' % self.gds_encode(quote_python(self.AUTOREADY)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.RECEIPTPAGEURL is not None:
            showIndent(outfile, level)
            outfile.write('RECEIPTPAGEURL=%s,\n' % self.gds_encode(quote_python(self.RECEIPTPAGEURL)))
        if self.VALIDATIONURL is not None:
            showIndent(outfile, level)
            outfile.write('VALIDATIONURL=%s,\n' % self.gds_encode(quote_python(self.VALIDATIONURL)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.BILLTOFIRSTNAME is not None:
            showIndent(outfile, level)
            outfile.write('BILLTOFIRSTNAME=%s,\n' % self.gds_encode(quote_python(self.BILLTOFIRSTNAME)))
        if self.BILLTOLASTNAME is not None:
            showIndent(outfile, level)
            outfile.write('BILLTOLASTNAME=%s,\n' % self.gds_encode(quote_python(self.BILLTOLASTNAME)))
        if self.TRANSACTIONTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTIONTYPE=%d,\n' % self.TRANSACTIONTYPE)
        if self.PAYMENTTYPE is not None:
            showIndent(outfile, level)
            outfile.write('PAYMENTTYPE=%s,\n' % self.gds_encode(quote_python(self.PAYMENTTYPE)))
        if self.ACH_NOTIFICATION_URL is not None:
            showIndent(outfile, level)
            outfile.write('ACH_NOTIFICATION_URL=%s,\n' % self.gds_encode(quote_python(self.ACH_NOTIFICATION_URL)))
        if self.SECURECARDMERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('SECURECARDMERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.SECURECARDMERCHANTREF)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.TERMINALTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALTYPE=%d,\n' % self.TERMINALTYPE)
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LEVEL_3_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_3_DATA=model_.LEVEL_3_DATA(\n')
            self.LEVEL_3_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'AUTOREADY':
            AUTOREADY_ = child_.text
            AUTOREADY_ = self.gds_validate_string(AUTOREADY_, node, 'AUTOREADY')
            self.AUTOREADY = AUTOREADY_
            # validate type AUTOREADY
            self.validate_AUTOREADY(self.AUTOREADY)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'RECEIPTPAGEURL':
            RECEIPTPAGEURL_ = child_.text
            RECEIPTPAGEURL_ = self.gds_validate_string(RECEIPTPAGEURL_, node, 'RECEIPTPAGEURL')
            self.RECEIPTPAGEURL = RECEIPTPAGEURL_
            # validate type RECEIPTPAGEURL
            self.validate_RECEIPTPAGEURL(self.RECEIPTPAGEURL)
        elif nodeName_ == 'VALIDATIONURL':
            VALIDATIONURL_ = child_.text
            VALIDATIONURL_ = self.gds_validate_string(VALIDATIONURL_, node, 'VALIDATIONURL')
            self.VALIDATIONURL = VALIDATIONURL_
            # validate type VALIDATIONURL
            self.validate_VALIDATIONURL(self.VALIDATIONURL)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'BILLTOFIRSTNAME':
            BILLTOFIRSTNAME_ = child_.text
            BILLTOFIRSTNAME_ = self.gds_validate_string(BILLTOFIRSTNAME_, node, 'BILLTOFIRSTNAME')
            self.BILLTOFIRSTNAME = BILLTOFIRSTNAME_
            # validate type BILLTOFIRSTNAME
            self.validate_BILLTOFIRSTNAME(self.BILLTOFIRSTNAME)
        elif nodeName_ == 'BILLTOLASTNAME':
            BILLTOLASTNAME_ = child_.text
            BILLTOLASTNAME_ = self.gds_validate_string(BILLTOLASTNAME_, node, 'BILLTOLASTNAME')
            self.BILLTOLASTNAME = BILLTOLASTNAME_
            # validate type BILLTOLASTNAME
            self.validate_BILLTOLASTNAME(self.BILLTOLASTNAME)
        elif nodeName_ == 'TRANSACTIONTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TRANSACTIONTYPE')
            self.TRANSACTIONTYPE = ival_
            # validate type TRANSACTIONTYPE
            self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        elif nodeName_ == 'PAYMENTTYPE':
            PAYMENTTYPE_ = child_.text
            PAYMENTTYPE_ = self.gds_validate_string(PAYMENTTYPE_, node, 'PAYMENTTYPE')
            self.PAYMENTTYPE = PAYMENTTYPE_
            # validate type PAYMENTTYPE
            self.validate_PAYMENTTYPE(self.PAYMENTTYPE)
        elif nodeName_ == 'ACH_NOTIFICATION_URL':
            ACH_NOTIFICATION_URL_ = child_.text
            ACH_NOTIFICATION_URL_ = self.gds_validate_string(ACH_NOTIFICATION_URL_, node, 'ACH_NOTIFICATION_URL')
            self.ACH_NOTIFICATION_URL = ACH_NOTIFICATION_URL_
            # validate type ACH_NOTIFICATION_URL
            self.validate_ACH_NOTIFICATION_URL(self.ACH_NOTIFICATION_URL)
        elif nodeName_ == 'SECURECARDMERCHANTREF':
            SECURECARDMERCHANTREF_ = child_.text
            SECURECARDMERCHANTREF_ = self.gds_validate_string(SECURECARDMERCHANTREF_, node, 'SECURECARDMERCHANTREF')
            self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF_
            # validate type SECURECARDMERCHANTREF
            self.validate_SECURECARDMERCHANTREF(self.SECURECARDMERCHANTREF)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'TERMINALTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TERMINALTYPE')
            self.TERMINALTYPE = ival_
            # validate type TERMINALTYPE
            self.validate_TERMINALTYPE(self.TERMINALTYPE)
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'LEVEL_3_DATA':
            obj_ = LEVEL_3_DATA.factory()
            obj_.build(child_)
            self.LEVEL_3_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_3_DATA'
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
    def sample_method(self):
        pass
# end class PaymentPage


class PAYMENTACH(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALTYPE', ['TERMINALTYPE', 'xs:int'], 0, 0, {'ref': 'TERMINALTYPE', 'name': 'TERMINALTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('ACH_SECURE', ['ACH_SECURE', 'xs:string'], 0, 1, {'ref': 'ACH_SECURE', 'minOccurs': '0', 'name': 'ACH_SECURE', 'type': 'xs:string'}, None),
        MemberSpec_('SEC_CODE', ['SEC_CODE', 'xs:string'], 0, 0, {'ref': 'SEC_CODE', 'name': 'SEC_CODE', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_TYPE', ['ACCOUNT_TYPE', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_TYPE', 'minOccurs': '0', 'name': 'ACCOUNT_TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NUMBER', ['ACCOUNT_NUMBER', 'xs:string'], 0, 0, {'ref': 'ACCOUNT_NUMBER', 'name': 'ACCOUNT_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ROUTING_NUMBER', ['ROUTING_NUMBER', 'xs:string'], 0, 1, {'ref': 'ROUTING_NUMBER', 'minOccurs': '0', 'name': 'ROUTING_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NAME', ['ACCOUNT_NAME', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_NAME', 'minOccurs': '0', 'name': 'ACCOUNT_NAME', 'type': 'xs:string'}, None),
        MemberSpec_('CHECK_NUMBER', ['CHECK_NUMBER', 'xs:string'], 0, 1, {'ref': 'CHECK_NUMBER', 'minOccurs': '0', 'name': 'CHECK_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('IPADDRESS', ['IPADDRESS', 'xs:string'], 0, 1, {'ref': 'IPADDRESS', 'minOccurs': '0', 'name': 'IPADDRESS', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('DL_STATE', ['DL_STATE', 'xs:string'], 0, 1, {'ref': 'DL_STATE', 'minOccurs': '0', 'name': 'DL_STATE', 'type': 'xs:string'}, None),
        MemberSpec_('DL_NUMBER', ['DL_NUMBER', 'xs:string'], 0, 1, {'ref': 'DL_NUMBER', 'minOccurs': '0', 'name': 'DL_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, AMOUNT=None, CURRENCY=None, DATETIME=None, TERMINALTYPE=None, ACH_SECURE=None, SEC_CODE=None, ACCOUNT_TYPE=None, ACCOUNT_NUMBER=None, ROUTING_NUMBER=None, ACCOUNT_NAME=None, CHECK_NUMBER=None, ADDRESS1=None, ADDRESS2=None, CITY=None, REGION=None, POSTCODE=None, COUNTRY=None, PHONE=None, IPADDRESS=None, EMAIL=None, DESCRIPTION=None, DL_STATE=None, DL_NUMBER=None, HASH=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.TERMINALTYPE = TERMINALTYPE
        self.validate_TERMINALTYPE(self.TERMINALTYPE)
        self.ACH_SECURE = ACH_SECURE
        self.validate_ACH_SECURE(self.ACH_SECURE)
        self.SEC_CODE = SEC_CODE
        self.validate_SEC_CODE(self.SEC_CODE)
        self.ACCOUNT_TYPE = ACCOUNT_TYPE
        self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
        self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        self.ROUTING_NUMBER = ROUTING_NUMBER
        self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        self.ACCOUNT_NAME = ACCOUNT_NAME
        self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        self.CHECK_NUMBER = CHECK_NUMBER
        self.validate_CHECK_NUMBER(self.CHECK_NUMBER)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.IPADDRESS = IPADDRESS
        self.validate_IPADDRESS(self.IPADDRESS)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.DL_STATE = DL_STATE
        self.validate_DL_STATE(self.DL_STATE)
        self.DL_NUMBER = DL_NUMBER
        self.validate_DL_NUMBER(self.DL_NUMBER)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAYMENTACH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAYMENTACH.subclass:
            return PAYMENTACH.subclass(*args_, **kwargs_)
        else:
            return PAYMENTACH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_TERMINALTYPE(self): return self.TERMINALTYPE
    def set_TERMINALTYPE(self, TERMINALTYPE): self.TERMINALTYPE = TERMINALTYPE
    def get_ACH_SECURE(self): return self.ACH_SECURE
    def set_ACH_SECURE(self, ACH_SECURE): self.ACH_SECURE = ACH_SECURE
    def get_SEC_CODE(self): return self.SEC_CODE
    def set_SEC_CODE(self, SEC_CODE): self.SEC_CODE = SEC_CODE
    def get_ACCOUNT_TYPE(self): return self.ACCOUNT_TYPE
    def set_ACCOUNT_TYPE(self, ACCOUNT_TYPE): self.ACCOUNT_TYPE = ACCOUNT_TYPE
    def get_ACCOUNT_NUMBER(self): return self.ACCOUNT_NUMBER
    def set_ACCOUNT_NUMBER(self, ACCOUNT_NUMBER): self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
    def get_ROUTING_NUMBER(self): return self.ROUTING_NUMBER
    def set_ROUTING_NUMBER(self, ROUTING_NUMBER): self.ROUTING_NUMBER = ROUTING_NUMBER
    def get_ACCOUNT_NAME(self): return self.ACCOUNT_NAME
    def set_ACCOUNT_NAME(self, ACCOUNT_NAME): self.ACCOUNT_NAME = ACCOUNT_NAME
    def get_CHECK_NUMBER(self): return self.CHECK_NUMBER
    def set_CHECK_NUMBER(self, CHECK_NUMBER): self.CHECK_NUMBER = CHECK_NUMBER
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_IPADDRESS(self): return self.IPADDRESS
    def set_IPADDRESS(self, IPADDRESS): self.IPADDRESS = IPADDRESS
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_DL_STATE(self): return self.DL_STATE
    def set_DL_STATE(self, DL_STATE): self.DL_STATE = DL_STATE
    def get_DL_NUMBER(self): return self.DL_NUMBER
    def set_DL_NUMBER(self, DL_NUMBER): self.DL_NUMBER = DL_NUMBER
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_TERMINALTYPE(self, value):
        # Validate type TERMINALTYPE, a restriction on xs:int.
        pass
    def validate_ACH_SECURE(self, value):
        # Validate type ACH_SECURE, a restriction on xs:string.
        pass
    def validate_SEC_CODE(self, value):
        # Validate type SEC_CODE, a restriction on xs:string.
        pass
    def validate_ACCOUNT_TYPE(self, value):
        # Validate type ACCOUNT_TYPE, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NUMBER(self, value):
        # Validate type ACCOUNT_NUMBER, a restriction on xs:string.
        pass
    def validate_ROUTING_NUMBER(self, value):
        # Validate type ROUTING_NUMBER, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NAME(self, value):
        # Validate type ACCOUNT_NAME, a restriction on xs:string.
        pass
    def validate_CHECK_NUMBER(self, value):
        # Validate type CHECK_NUMBER, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_IPADDRESS(self, value):
        # Validate type IPADDRESS, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_DL_STATE(self, value):
        # Validate type DL_STATE, a restriction on xs:string.
        pass
    def validate_DL_NUMBER(self, value):
        # Validate type DL_NUMBER, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.CURRENCY is not None or
            self.DATETIME is not None or
            self.TERMINALTYPE is not None or
            self.ACH_SECURE is not None or
            self.SEC_CODE is not None or
            self.ACCOUNT_TYPE is not None or
            self.ACCOUNT_NUMBER is not None or
            self.ROUTING_NUMBER is not None or
            self.ACCOUNT_NAME is not None or
            self.CHECK_NUMBER is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.POSTCODE is not None or
            self.COUNTRY is not None or
            self.PHONE is not None or
            self.IPADDRESS is not None or
            self.EMAIL is not None or
            self.DESCRIPTION is not None or
            self.DL_STATE is not None or
            self.DL_NUMBER is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAYMENTACH', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.TERMINALTYPE is not None:
            TERMINALTYPE_ = self.TERMINALTYPE
            etree_.SubElement(element, '{}TERMINALTYPE').text = self.gds_format_integer(TERMINALTYPE_)
        if self.ACH_SECURE is not None:
            ACH_SECURE_ = self.ACH_SECURE
            etree_.SubElement(element, '{}ACH_SECURE').text = self.gds_format_string(ACH_SECURE_)
        if self.SEC_CODE is not None:
            SEC_CODE_ = self.SEC_CODE
            etree_.SubElement(element, '{}SEC_CODE').text = self.gds_format_string(SEC_CODE_)
        if self.ACCOUNT_TYPE is not None:
            ACCOUNT_TYPE_ = self.ACCOUNT_TYPE
            etree_.SubElement(element, '{}ACCOUNT_TYPE').text = self.gds_format_string(ACCOUNT_TYPE_)
        if self.ACCOUNT_NUMBER is not None:
            ACCOUNT_NUMBER_ = self.ACCOUNT_NUMBER
            etree_.SubElement(element, '{}ACCOUNT_NUMBER').text = self.gds_format_string(ACCOUNT_NUMBER_)
        if self.ROUTING_NUMBER is not None:
            ROUTING_NUMBER_ = self.ROUTING_NUMBER
            etree_.SubElement(element, '{}ROUTING_NUMBER').text = self.gds_format_string(ROUTING_NUMBER_)
        if self.ACCOUNT_NAME is not None:
            ACCOUNT_NAME_ = self.ACCOUNT_NAME
            etree_.SubElement(element, '{}ACCOUNT_NAME').text = self.gds_format_string(ACCOUNT_NAME_)
        if self.CHECK_NUMBER is not None:
            CHECK_NUMBER_ = self.CHECK_NUMBER
            etree_.SubElement(element, '{}CHECK_NUMBER').text = self.gds_format_string(CHECK_NUMBER_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.IPADDRESS is not None:
            IPADDRESS_ = self.IPADDRESS
            etree_.SubElement(element, '{}IPADDRESS').text = self.gds_format_string(IPADDRESS_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.DL_STATE is not None:
            DL_STATE_ = self.DL_STATE
            etree_.SubElement(element, '{}DL_STATE').text = self.gds_format_string(DL_STATE_)
        if self.DL_NUMBER is not None:
            DL_NUMBER_ = self.DL_NUMBER
            etree_.SubElement(element, '{}DL_NUMBER').text = self.gds_format_string(DL_NUMBER_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAYMENTACH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.TERMINALTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALTYPE=%d,\n' % self.TERMINALTYPE)
        if self.ACH_SECURE is not None:
            showIndent(outfile, level)
            outfile.write('ACH_SECURE=%s,\n' % self.gds_encode(quote_python(self.ACH_SECURE)))
        if self.SEC_CODE is not None:
            showIndent(outfile, level)
            outfile.write('SEC_CODE=%s,\n' % self.gds_encode(quote_python(self.SEC_CODE)))
        if self.ACCOUNT_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_TYPE=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_TYPE)))
        if self.ACCOUNT_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NUMBER)))
        if self.ROUTING_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ROUTING_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ROUTING_NUMBER)))
        if self.ACCOUNT_NAME is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NAME=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NAME)))
        if self.CHECK_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CHECK_NUMBER=%s,\n' % self.gds_encode(quote_python(self.CHECK_NUMBER)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.IPADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('IPADDRESS=%s,\n' % self.gds_encode(quote_python(self.IPADDRESS)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.DL_STATE is not None:
            showIndent(outfile, level)
            outfile.write('DL_STATE=%s,\n' % self.gds_encode(quote_python(self.DL_STATE)))
        if self.DL_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('DL_NUMBER=%s,\n' % self.gds_encode(quote_python(self.DL_NUMBER)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'TERMINALTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TERMINALTYPE')
            self.TERMINALTYPE = ival_
            # validate type TERMINALTYPE
            self.validate_TERMINALTYPE(self.TERMINALTYPE)
        elif nodeName_ == 'ACH_SECURE':
            ACH_SECURE_ = child_.text
            ACH_SECURE_ = self.gds_validate_string(ACH_SECURE_, node, 'ACH_SECURE')
            self.ACH_SECURE = ACH_SECURE_
            # validate type ACH_SECURE
            self.validate_ACH_SECURE(self.ACH_SECURE)
        elif nodeName_ == 'SEC_CODE':
            SEC_CODE_ = child_.text
            SEC_CODE_ = self.gds_validate_string(SEC_CODE_, node, 'SEC_CODE')
            self.SEC_CODE = SEC_CODE_
            # validate type SEC_CODE
            self.validate_SEC_CODE(self.SEC_CODE)
        elif nodeName_ == 'ACCOUNT_TYPE':
            ACCOUNT_TYPE_ = child_.text
            ACCOUNT_TYPE_ = self.gds_validate_string(ACCOUNT_TYPE_, node, 'ACCOUNT_TYPE')
            self.ACCOUNT_TYPE = ACCOUNT_TYPE_
            # validate type ACCOUNT_TYPE
            self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        elif nodeName_ == 'ACCOUNT_NUMBER':
            ACCOUNT_NUMBER_ = child_.text
            ACCOUNT_NUMBER_ = self.gds_validate_string(ACCOUNT_NUMBER_, node, 'ACCOUNT_NUMBER')
            self.ACCOUNT_NUMBER = ACCOUNT_NUMBER_
            # validate type ACCOUNT_NUMBER
            self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        elif nodeName_ == 'ROUTING_NUMBER':
            ROUTING_NUMBER_ = child_.text
            ROUTING_NUMBER_ = self.gds_validate_string(ROUTING_NUMBER_, node, 'ROUTING_NUMBER')
            self.ROUTING_NUMBER = ROUTING_NUMBER_
            # validate type ROUTING_NUMBER
            self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        elif nodeName_ == 'ACCOUNT_NAME':
            ACCOUNT_NAME_ = child_.text
            ACCOUNT_NAME_ = self.gds_validate_string(ACCOUNT_NAME_, node, 'ACCOUNT_NAME')
            self.ACCOUNT_NAME = ACCOUNT_NAME_
            # validate type ACCOUNT_NAME
            self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        elif nodeName_ == 'CHECK_NUMBER':
            CHECK_NUMBER_ = child_.text
            CHECK_NUMBER_ = self.gds_validate_string(CHECK_NUMBER_, node, 'CHECK_NUMBER')
            self.CHECK_NUMBER = CHECK_NUMBER_
            # validate type CHECK_NUMBER
            self.validate_CHECK_NUMBER(self.CHECK_NUMBER)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'IPADDRESS':
            IPADDRESS_ = child_.text
            IPADDRESS_ = self.gds_validate_string(IPADDRESS_, node, 'IPADDRESS')
            self.IPADDRESS = IPADDRESS_
            # validate type IPADDRESS
            self.validate_IPADDRESS(self.IPADDRESS)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'DL_STATE':
            DL_STATE_ = child_.text
            DL_STATE_ = self.gds_validate_string(DL_STATE_, node, 'DL_STATE')
            self.DL_STATE = DL_STATE_
            # validate type DL_STATE
            self.validate_DL_STATE(self.DL_STATE)
        elif nodeName_ == 'DL_NUMBER':
            DL_NUMBER_ = child_.text
            DL_NUMBER_ = self.gds_validate_string(DL_NUMBER_, node, 'DL_NUMBER')
            self.DL_NUMBER = DL_NUMBER_
            # validate type DL_NUMBER
            self.validate_DL_NUMBER(self.DL_NUMBER)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class PAYMENTACH


class RESPONSECODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RESPONSECODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RESPONSECODE.subclass:
            return RESPONSECODE.subclass(*args_, **kwargs_)
        else:
            return RESPONSECODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RESPONSECODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RESPONSECODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class RESPONSECODE


class RESPONSETEXT(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RESPONSETEXT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RESPONSETEXT.subclass:
            return RESPONSETEXT.subclass(*args_, **kwargs_)
        else:
            return RESPONSETEXT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RESPONSETEXT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RESPONSETEXT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class RESPONSETEXT


class APPROVALCODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, APPROVALCODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if APPROVALCODE.subclass:
            return APPROVALCODE.subclass(*args_, **kwargs_)
        else:
            return APPROVALCODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='APPROVALCODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='APPROVALCODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class APPROVALCODE


class BANKRESPONSECODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BANKRESPONSECODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BANKRESPONSECODE.subclass:
            return BANKRESPONSECODE.subclass(*args_, **kwargs_)
        else:
            return BANKRESPONSECODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BANKRESPONSECODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BANKRESPONSECODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class BANKRESPONSECODE


class AVSRESPONSE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AVSRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AVSRESPONSE.subclass:
            return AVSRESPONSE.subclass(*args_, **kwargs_)
        else:
            return AVSRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AVSRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AVSRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class AVSRESPONSE


class CVVRESPONSE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CVVRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CVVRESPONSE.subclass:
            return CVVRESPONSE.subclass(*args_, **kwargs_)
        else:
            return CVVRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CVVRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CVVRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class CVVRESPONSE


class PAYMENTRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('BANKRESPONSECODE', ['BANKRESPONSECODE', 'xs:string'], 0, 1, {'ref': 'BANKRESPONSECODE', 'minOccurs': '0', 'name': 'BANKRESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('AUTHORIZEDAMOUNT', 'xs:double', 0, 1, {'ref': 'AUTHORIZEDAMOUNT', 'minOccurs': '0', 'name': 'AUTHORIZEDAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('AVSRESPONSE', ['AVSRESPONSE', 'xs:string'], 0, 1, {'ref': 'AVSRESPONSE', 'minOccurs': '0', 'name': 'AVSRESPONSE', 'type': 'xs:string'}, None),
        MemberSpec_('CVVRESPONSE', ['CVVRESPONSE', 'xs:string'], 0, 1, {'ref': 'CVVRESPONSE', 'minOccurs': '0', 'name': 'CVVRESPONSE', 'type': 'xs:string'}, None),
        MemberSpec_('PROCESSINGTERMINAL', ['PROCESSINGTERMINAL', 'xs:string'], 0, 1, {'ref': 'PROCESSINGTERMINAL', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PROCESSINGTERMINAL', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', 'xs:string', 0, 1, {'ref': 'CARDREFERENCE', 'minOccurs': '0', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 1, {'ref': 'MERCHANTREF', 'minOccurs': '0', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, APPROVALCODE=None, BANKRESPONSECODE=None, AUTHORIZEDAMOUNT=None, DATETIME=None, AVSRESPONSE=None, CVVRESPONSE=None, PROCESSINGTERMINAL=None, CARDREFERENCE=None, MERCHANTREF=None, CREDENTIALONFILE=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.BANKRESPONSECODE = BANKRESPONSECODE
        self.validate_BANKRESPONSECODE(self.BANKRESPONSECODE)
        self.AUTHORIZEDAMOUNT = AUTHORIZEDAMOUNT
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.AVSRESPONSE = AVSRESPONSE
        self.validate_AVSRESPONSE(self.AVSRESPONSE)
        self.CVVRESPONSE = CVVRESPONSE
        self.validate_CVVRESPONSE(self.CVVRESPONSE)
        self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
        self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        self.CARDREFERENCE = CARDREFERENCE
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAYMENTRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAYMENTRESPONSE.subclass:
            return PAYMENTRESPONSE.subclass(*args_, **kwargs_)
        else:
            return PAYMENTRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_BANKRESPONSECODE(self): return self.BANKRESPONSECODE
    def set_BANKRESPONSECODE(self, BANKRESPONSECODE): self.BANKRESPONSECODE = BANKRESPONSECODE
    def get_AUTHORIZEDAMOUNT(self): return self.AUTHORIZEDAMOUNT
    def set_AUTHORIZEDAMOUNT(self, AUTHORIZEDAMOUNT): self.AUTHORIZEDAMOUNT = AUTHORIZEDAMOUNT
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_AVSRESPONSE(self): return self.AVSRESPONSE
    def set_AVSRESPONSE(self, AVSRESPONSE): self.AVSRESPONSE = AVSRESPONSE
    def get_CVVRESPONSE(self): return self.CVVRESPONSE
    def set_CVVRESPONSE(self, CVVRESPONSE): self.CVVRESPONSE = CVVRESPONSE
    def get_PROCESSINGTERMINAL(self): return self.PROCESSINGTERMINAL
    def set_PROCESSINGTERMINAL(self, PROCESSINGTERMINAL): self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_BANKRESPONSECODE(self, value):
        # Validate type BANKRESPONSECODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_AVSRESPONSE(self, value):
        # Validate type AVSRESPONSE, a restriction on xs:string.
        pass
    def validate_CVVRESPONSE(self, value):
        # Validate type CVVRESPONSE, a restriction on xs:string.
        pass
    def validate_PROCESSINGTERMINAL(self, value):
        # Validate type PROCESSINGTERMINAL, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.APPROVALCODE is not None or
            self.BANKRESPONSECODE is not None or
            self.AUTHORIZEDAMOUNT is not None or
            self.DATETIME is not None or
            self.AVSRESPONSE is not None or
            self.CVVRESPONSE is not None or
            self.PROCESSINGTERMINAL is not None or
            self.CARDREFERENCE is not None or
            self.MERCHANTREF is not None or
            self.CREDENTIALONFILE is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAYMENTRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.BANKRESPONSECODE is not None:
            BANKRESPONSECODE_ = self.BANKRESPONSECODE
            etree_.SubElement(element, '{}BANKRESPONSECODE').text = self.gds_format_string(BANKRESPONSECODE_)
        if self.AUTHORIZEDAMOUNT is not None:
            AUTHORIZEDAMOUNT_ = self.AUTHORIZEDAMOUNT
            etree_.SubElement(element, '{}AUTHORIZEDAMOUNT').text = self.gds_format_double(AUTHORIZEDAMOUNT_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.AVSRESPONSE is not None:
            AVSRESPONSE_ = self.AVSRESPONSE
            etree_.SubElement(element, '{}AVSRESPONSE').text = self.gds_format_string(AVSRESPONSE_)
        if self.CVVRESPONSE is not None:
            CVVRESPONSE_ = self.CVVRESPONSE
            etree_.SubElement(element, '{}CVVRESPONSE').text = self.gds_format_string(CVVRESPONSE_)
        if self.PROCESSINGTERMINAL is not None:
            PROCESSINGTERMINAL_ = self.PROCESSINGTERMINAL
            etree_.SubElement(element, '{}PROCESSINGTERMINAL').text = self.gds_format_string(PROCESSINGTERMINAL_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAYMENTRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.BANKRESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('BANKRESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.BANKRESPONSECODE)))
        if self.AUTHORIZEDAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AUTHORIZEDAMOUNT=%e,\n' % self.AUTHORIZEDAMOUNT)
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.AVSRESPONSE is not None:
            showIndent(outfile, level)
            outfile.write('AVSRESPONSE=%s,\n' % self.gds_encode(quote_python(self.AVSRESPONSE)))
        if self.CVVRESPONSE is not None:
            showIndent(outfile, level)
            outfile.write('CVVRESPONSE=%s,\n' % self.gds_encode(quote_python(self.CVVRESPONSE)))
        if self.PROCESSINGTERMINAL is not None:
            showIndent(outfile, level)
            outfile.write('PROCESSINGTERMINAL=%s,\n' % self.gds_encode(quote_python(self.PROCESSINGTERMINAL)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'BANKRESPONSECODE':
            BANKRESPONSECODE_ = child_.text
            BANKRESPONSECODE_ = self.gds_validate_string(BANKRESPONSECODE_, node, 'BANKRESPONSECODE')
            self.BANKRESPONSECODE = BANKRESPONSECODE_
            # validate type BANKRESPONSECODE
            self.validate_BANKRESPONSECODE(self.BANKRESPONSECODE)
        elif nodeName_ == 'AUTHORIZEDAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AUTHORIZEDAMOUNT')
            self.AUTHORIZEDAMOUNT = fval_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'AVSRESPONSE':
            AVSRESPONSE_ = child_.text
            AVSRESPONSE_ = self.gds_validate_string(AVSRESPONSE_, node, 'AVSRESPONSE')
            self.AVSRESPONSE = AVSRESPONSE_
            # validate type AVSRESPONSE
            self.validate_AVSRESPONSE(self.AVSRESPONSE)
        elif nodeName_ == 'CVVRESPONSE':
            CVVRESPONSE_ = child_.text
            CVVRESPONSE_ = self.gds_validate_string(CVVRESPONSE_, node, 'CVVRESPONSE')
            self.CVVRESPONSE = CVVRESPONSE_
            # validate type CVVRESPONSE
            self.validate_CVVRESPONSE(self.CVVRESPONSE)
        elif nodeName_ == 'PROCESSINGTERMINAL':
            PROCESSINGTERMINAL_ = child_.text
            PROCESSINGTERMINAL_ = self.gds_validate_string(PROCESSINGTERMINAL_, node, 'PROCESSINGTERMINAL')
            self.PROCESSINGTERMINAL = PROCESSINGTERMINAL_
            # validate type PROCESSINGTERMINAL
            self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class PAYMENTRESPONSE


class PAYMENTACHRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, APPROVALCODE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAYMENTACHRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAYMENTACHRESPONSE.subclass:
            return PAYMENTACHRESPONSE.subclass(*args_, **kwargs_)
        else:
            return PAYMENTACHRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.APPROVALCODE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PAYMENTACHRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PAYMENTACHRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class PAYMENTACHRESPONSE


class ERRORSTRING(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ERRORSTRING)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ERRORSTRING.subclass:
            return ERRORSTRING.subclass(*args_, **kwargs_)
        else:
            return ERRORSTRING(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ERRORSTRING', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ERRORSTRING'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ERRORSTRING


class ERRORCODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ERRORCODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ERRORCODE.subclass:
            return ERRORCODE.subclass(*args_, **kwargs_)
        else:
            return ERRORCODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ERRORCODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ERRORCODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ERRORCODE


class ERROR(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ERRORCODE', ['ERRORCODE', 'xs:string'], 0, 1, {'ref': 'ERRORCODE', 'minOccurs': '0', 'name': 'ERRORCODE', 'type': 'xs:string'}, None),
        MemberSpec_('ERRORSTRING', ['ERRORSTRING', 'xs:string'], 0, 0, {'ref': 'ERRORSTRING', 'name': 'ERRORSTRING', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ERRORCODE=None, ERRORSTRING=None):
        self.original_tagname_ = None
        self.ERRORCODE = ERRORCODE
        self.validate_ERRORCODE(self.ERRORCODE)
        self.ERRORSTRING = ERRORSTRING
        self.validate_ERRORSTRING(self.ERRORSTRING)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ERROR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ERROR.subclass:
            return ERROR.subclass(*args_, **kwargs_)
        else:
            return ERROR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ERRORCODE(self): return self.ERRORCODE
    def set_ERRORCODE(self, ERRORCODE): self.ERRORCODE = ERRORCODE
    def get_ERRORSTRING(self): return self.ERRORSTRING
    def set_ERRORSTRING(self, ERRORSTRING): self.ERRORSTRING = ERRORSTRING
    def validate_ERRORCODE(self, value):
        # Validate type ERRORCODE, a restriction on xs:string.
        pass
    def validate_ERRORSTRING(self, value):
        # Validate type ERRORSTRING, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ERRORCODE is not None or
            self.ERRORSTRING is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ERROR', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ERRORCODE is not None:
            ERRORCODE_ = self.ERRORCODE
            etree_.SubElement(element, '{}ERRORCODE').text = self.gds_format_string(ERRORCODE_)
        if self.ERRORSTRING is not None:
            ERRORSTRING_ = self.ERRORSTRING
            etree_.SubElement(element, '{}ERRORSTRING').text = self.gds_format_string(ERRORSTRING_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ERROR'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ERRORCODE is not None:
            showIndent(outfile, level)
            outfile.write('ERRORCODE=%s,\n' % self.gds_encode(quote_python(self.ERRORCODE)))
        if self.ERRORSTRING is not None:
            showIndent(outfile, level)
            outfile.write('ERRORSTRING=%s,\n' % self.gds_encode(quote_python(self.ERRORSTRING)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ERRORCODE':
            ERRORCODE_ = child_.text
            ERRORCODE_ = self.gds_validate_string(ERRORCODE_, node, 'ERRORCODE')
            self.ERRORCODE = ERRORCODE_
            # validate type ERRORCODE
            self.validate_ERRORCODE(self.ERRORCODE)
        elif nodeName_ == 'ERRORSTRING':
            ERRORSTRING_ = child_.text
            ERRORSTRING_ = self.gds_validate_string(ERRORSTRING_, node, 'ERRORSTRING')
            self.ERRORSTRING = ERRORSTRING_
            # validate type ERRORSTRING
            self.validate_ERRORSTRING(self.ERRORSTRING)
    def sample_method(self):
        pass
# end class ERROR


class PREAUTH(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 0, {'ref': 'CARDNUMBER', 'name': 'CARDNUMBER', 'type': 'xs:string'}, 1),
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 0, {'ref': 'CARDTYPE', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 1, {'ref': 'CARDEXPIRY', 'minOccurs': '0', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 1, {'ref': 'CARDHOLDERNAME', 'minOccurs': '0', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALTYPE', ['TERMINALTYPE', 'xs:int'], 0, 0, {'ref': 'TERMINALTYPE', 'name': 'TERMINALTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('TRANSACTIONTYPE', ['TRANSACTIONTYPE', 'xs:int'], 0, 0, {'ref': 'TRANSACTIONTYPE', 'name': 'TRANSACTIONTYPE', 'type': 'xs:int'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('CVV', 'xs:string', 0, 1, {'ref': 'CVV', 'minOccurs': '0', 'name': 'CVV', 'type': 'xs:string'}, None),
        MemberSpec_('ISSUENO', 'xs:string', 0, 1, {'ref': 'ISSUENO', 'minOccurs': '0', 'name': 'ISSUENO', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('RECURRINGTXNREF', ['UID', 'xs:string'], 0, 1, {'name': 'RECURRINGTXNREF', 'type': 'xs:string', 'minOccurs': '0', 'maxOccurs': '1'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('LEVEL_3_DATA', 'LEVEL_3_DATA', 0, 1, {'ref': 'LEVEL_3_DATA', 'minOccurs': '0', 'name': 'LEVEL_3_DATA', 'type': 'LEVEL_3_DATA'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, AMOUNT=None, DATETIME=None, CARDNUMBER=None, CARDTYPE=None, CARDEXPIRY=None, CARDHOLDERNAME=None, HASH=None, CURRENCY=None, TERMINALTYPE=None, TRANSACTIONTYPE=None, EMAIL=None, CVV=None, ISSUENO=None, ADDRESS1=None, ADDRESS2=None, POSTCODE=None, DESCRIPTION=None, CITY=None, REGION=None, COUNTRY=None, RECURRINGTXNREF=None, LEVEL_2_DATA=None, LEVEL_3_DATA=None, CREDENTIALONFILE=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.TERMINALTYPE = TERMINALTYPE
        self.validate_TERMINALTYPE(self.TERMINALTYPE)
        self.TRANSACTIONTYPE = TRANSACTIONTYPE
        self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.CVV = CVV
        self.ISSUENO = ISSUENO
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.RECURRINGTXNREF = RECURRINGTXNREF
        self.validate_UID(self.RECURRINGTXNREF)
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.LEVEL_3_DATA = LEVEL_3_DATA
        self.CREDENTIALONFILE = CREDENTIALONFILE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PREAUTH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PREAUTH.subclass:
            return PREAUTH.subclass(*args_, **kwargs_)
        else:
            return PREAUTH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_TERMINALTYPE(self): return self.TERMINALTYPE
    def set_TERMINALTYPE(self, TERMINALTYPE): self.TERMINALTYPE = TERMINALTYPE
    def get_TRANSACTIONTYPE(self): return self.TRANSACTIONTYPE
    def set_TRANSACTIONTYPE(self, TRANSACTIONTYPE): self.TRANSACTIONTYPE = TRANSACTIONTYPE
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_CVV(self): return self.CVV
    def set_CVV(self, CVV): self.CVV = CVV
    def get_ISSUENO(self): return self.ISSUENO
    def set_ISSUENO(self, ISSUENO): self.ISSUENO = ISSUENO
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_RECURRINGTXNREF(self): return self.RECURRINGTXNREF
    def set_RECURRINGTXNREF(self, RECURRINGTXNREF): self.RECURRINGTXNREF = RECURRINGTXNREF
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_LEVEL_3_DATA(self): return self.LEVEL_3_DATA
    def set_LEVEL_3_DATA(self, LEVEL_3_DATA): self.LEVEL_3_DATA = LEVEL_3_DATA
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_TERMINALTYPE(self, value):
        # Validate type TERMINALTYPE, a restriction on xs:int.
        pass
    def validate_TRANSACTIONTYPE(self, value):
        # Validate type TRANSACTIONTYPE, a restriction on xs:int.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_UID(self, value):
        # Validate type UID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on UID' % {"value" : value.encode("utf-8")} )
            if len(value) < 10:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on UID' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.DATETIME is not None or
            self.CARDNUMBER is not None or
            self.CARDTYPE is not None or
            self.CARDEXPIRY is not None or
            self.CARDHOLDERNAME is not None or
            self.HASH is not None or
            self.CURRENCY is not None or
            self.TERMINALTYPE is not None or
            self.TRANSACTIONTYPE is not None or
            self.EMAIL is not None or
            self.CVV is not None or
            self.ISSUENO is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.POSTCODE is not None or
            self.DESCRIPTION is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.COUNTRY is not None or
            self.RECURRINGTXNREF is not None or
            self.LEVEL_2_DATA is not None or
            self.LEVEL_3_DATA is not None or
            self.CREDENTIALONFILE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PREAUTH', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.TERMINALTYPE is not None:
            TERMINALTYPE_ = self.TERMINALTYPE
            etree_.SubElement(element, '{}TERMINALTYPE').text = self.gds_format_integer(TERMINALTYPE_)
        if self.TRANSACTIONTYPE is not None:
            TRANSACTIONTYPE_ = self.TRANSACTIONTYPE
            etree_.SubElement(element, '{}TRANSACTIONTYPE').text = self.gds_format_integer(TRANSACTIONTYPE_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.CVV is not None:
            CVV_ = self.CVV
            etree_.SubElement(element, '{}CVV').text = self.gds_format_string(CVV_)
        if self.ISSUENO is not None:
            ISSUENO_ = self.ISSUENO
            etree_.SubElement(element, '{}ISSUENO').text = self.gds_format_string(ISSUENO_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.RECURRINGTXNREF is not None:
            RECURRINGTXNREF_ = self.RECURRINGTXNREF
            etree_.SubElement(element, '{}RECURRINGTXNREF').text = self.gds_format_string(RECURRINGTXNREF_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.LEVEL_3_DATA is not None:
            LEVEL_3_DATA_ = self.LEVEL_3_DATA
            LEVEL_3_DATA_.to_etree(element, name_='LEVEL_3_DATA', mapping_=mapping_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PREAUTH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.TERMINALTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALTYPE=%d,\n' % self.TERMINALTYPE)
        if self.TRANSACTIONTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTIONTYPE=%d,\n' % self.TRANSACTIONTYPE)
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.CVV is not None:
            showIndent(outfile, level)
            outfile.write('CVV=%s,\n' % self.gds_encode(quote_python(self.CVV)))
        if self.ISSUENO is not None:
            showIndent(outfile, level)
            outfile.write('ISSUENO=%s,\n' % self.gds_encode(quote_python(self.ISSUENO)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.RECURRINGTXNREF is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGTXNREF=%s,\n' % self.gds_encode(quote_python(self.RECURRINGTXNREF)))
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LEVEL_3_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_3_DATA=model_.LEVEL_3_DATA(\n')
            self.LEVEL_3_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'TERMINALTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TERMINALTYPE')
            self.TERMINALTYPE = ival_
            # validate type TERMINALTYPE
            self.validate_TERMINALTYPE(self.TERMINALTYPE)
        elif nodeName_ == 'TRANSACTIONTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TRANSACTIONTYPE')
            self.TRANSACTIONTYPE = ival_
            # validate type TRANSACTIONTYPE
            self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'CVV':
            CVV_ = child_.text
            CVV_ = self.gds_validate_string(CVV_, node, 'CVV')
            self.CVV = CVV_
        elif nodeName_ == 'ISSUENO':
            ISSUENO_ = child_.text
            ISSUENO_ = self.gds_validate_string(ISSUENO_, node, 'ISSUENO')
            self.ISSUENO = ISSUENO_
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'RECURRINGTXNREF':
            RECURRINGTXNREF_ = child_.text
            RECURRINGTXNREF_ = self.gds_validate_string(RECURRINGTXNREF_, node, 'RECURRINGTXNREF')
            self.RECURRINGTXNREF = RECURRINGTXNREF_
            # validate type UID
            self.validate_UID(self.RECURRINGTXNREF)
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'LEVEL_3_DATA':
            obj_ = LEVEL_3_DATA.factory()
            obj_.build(child_)
            self.LEVEL_3_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_3_DATA'
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
    def sample_method(self):
        pass
# end class PREAUTH


class PREAUTHRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('BANKRESPONSECODE', ['BANKRESPONSECODE', 'xs:string'], 0, 1, {'ref': 'BANKRESPONSECODE', 'minOccurs': '0', 'name': 'BANKRESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('AVSRESPONSE', ['AVSRESPONSE', 'xs:string'], 0, 1, {'ref': 'AVSRESPONSE', 'minOccurs': '0', 'name': 'AVSRESPONSE', 'type': 'xs:string'}, None),
        MemberSpec_('CVVRESPONSE', ['CVVRESPONSE', 'xs:string'], 0, 1, {'ref': 'CVVRESPONSE', 'minOccurs': '0', 'name': 'CVVRESPONSE', 'type': 'xs:string'}, None),
        MemberSpec_('PROCESSINGTERMINAL', ['PROCESSINGTERMINAL', 'xs:string'], 0, 1, {'ref': 'PROCESSINGTERMINAL', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'PROCESSINGTERMINAL', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', 'xs:string', 0, 1, {'ref': 'CARDREFERENCE', 'minOccurs': '0', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 1, {'ref': 'MERCHANTREF', 'minOccurs': '0', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, BANKRESPONSECODE=None, APPROVALCODE=None, DATETIME=None, AVSRESPONSE=None, CVVRESPONSE=None, PROCESSINGTERMINAL=None, CARDREFERENCE=None, MERCHANTREF=None, CREDENTIALONFILE=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.BANKRESPONSECODE = BANKRESPONSECODE
        self.validate_BANKRESPONSECODE(self.BANKRESPONSECODE)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.AVSRESPONSE = AVSRESPONSE
        self.validate_AVSRESPONSE(self.AVSRESPONSE)
        self.CVVRESPONSE = CVVRESPONSE
        self.validate_CVVRESPONSE(self.CVVRESPONSE)
        self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
        self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        self.CARDREFERENCE = CARDREFERENCE
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PREAUTHRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PREAUTHRESPONSE.subclass:
            return PREAUTHRESPONSE.subclass(*args_, **kwargs_)
        else:
            return PREAUTHRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_BANKRESPONSECODE(self): return self.BANKRESPONSECODE
    def set_BANKRESPONSECODE(self, BANKRESPONSECODE): self.BANKRESPONSECODE = BANKRESPONSECODE
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_AVSRESPONSE(self): return self.AVSRESPONSE
    def set_AVSRESPONSE(self, AVSRESPONSE): self.AVSRESPONSE = AVSRESPONSE
    def get_CVVRESPONSE(self): return self.CVVRESPONSE
    def set_CVVRESPONSE(self, CVVRESPONSE): self.CVVRESPONSE = CVVRESPONSE
    def get_PROCESSINGTERMINAL(self): return self.PROCESSINGTERMINAL
    def set_PROCESSINGTERMINAL(self, PROCESSINGTERMINAL): self.PROCESSINGTERMINAL = PROCESSINGTERMINAL
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_BANKRESPONSECODE(self, value):
        # Validate type BANKRESPONSECODE, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_AVSRESPONSE(self, value):
        # Validate type AVSRESPONSE, a restriction on xs:string.
        pass
    def validate_CVVRESPONSE(self, value):
        # Validate type CVVRESPONSE, a restriction on xs:string.
        pass
    def validate_PROCESSINGTERMINAL(self, value):
        # Validate type PROCESSINGTERMINAL, a restriction on xs:string.
        pass
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.BANKRESPONSECODE is not None or
            self.APPROVALCODE is not None or
            self.DATETIME is not None or
            self.AVSRESPONSE is not None or
            self.CVVRESPONSE is not None or
            self.PROCESSINGTERMINAL is not None or
            self.CARDREFERENCE is not None or
            self.MERCHANTREF is not None or
            self.CREDENTIALONFILE is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PREAUTHRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.BANKRESPONSECODE is not None:
            BANKRESPONSECODE_ = self.BANKRESPONSECODE
            etree_.SubElement(element, '{}BANKRESPONSECODE').text = self.gds_format_string(BANKRESPONSECODE_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.AVSRESPONSE is not None:
            AVSRESPONSE_ = self.AVSRESPONSE
            etree_.SubElement(element, '{}AVSRESPONSE').text = self.gds_format_string(AVSRESPONSE_)
        if self.CVVRESPONSE is not None:
            CVVRESPONSE_ = self.CVVRESPONSE
            etree_.SubElement(element, '{}CVVRESPONSE').text = self.gds_format_string(CVVRESPONSE_)
        if self.PROCESSINGTERMINAL is not None:
            PROCESSINGTERMINAL_ = self.PROCESSINGTERMINAL
            etree_.SubElement(element, '{}PROCESSINGTERMINAL').text = self.gds_format_string(PROCESSINGTERMINAL_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PREAUTHRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.BANKRESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('BANKRESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.BANKRESPONSECODE)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.AVSRESPONSE is not None:
            showIndent(outfile, level)
            outfile.write('AVSRESPONSE=%s,\n' % self.gds_encode(quote_python(self.AVSRESPONSE)))
        if self.CVVRESPONSE is not None:
            showIndent(outfile, level)
            outfile.write('CVVRESPONSE=%s,\n' % self.gds_encode(quote_python(self.CVVRESPONSE)))
        if self.PROCESSINGTERMINAL is not None:
            showIndent(outfile, level)
            outfile.write('PROCESSINGTERMINAL=%s,\n' % self.gds_encode(quote_python(self.PROCESSINGTERMINAL)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'BANKRESPONSECODE':
            BANKRESPONSECODE_ = child_.text
            BANKRESPONSECODE_ = self.gds_validate_string(BANKRESPONSECODE_, node, 'BANKRESPONSECODE')
            self.BANKRESPONSECODE = BANKRESPONSECODE_
            # validate type BANKRESPONSECODE
            self.validate_BANKRESPONSECODE(self.BANKRESPONSECODE)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'AVSRESPONSE':
            AVSRESPONSE_ = child_.text
            AVSRESPONSE_ = self.gds_validate_string(AVSRESPONSE_, node, 'AVSRESPONSE')
            self.AVSRESPONSE = AVSRESPONSE_
            # validate type AVSRESPONSE
            self.validate_AVSRESPONSE(self.AVSRESPONSE)
        elif nodeName_ == 'CVVRESPONSE':
            CVVRESPONSE_ = child_.text
            CVVRESPONSE_ = self.gds_validate_string(CVVRESPONSE_, node, 'CVVRESPONSE')
            self.CVVRESPONSE = CVVRESPONSE_
            # validate type CVVRESPONSE
            self.validate_CVVRESPONSE(self.CVVRESPONSE)
        elif nodeName_ == 'PROCESSINGTERMINAL':
            PROCESSINGTERMINAL_ = child_.text
            PROCESSINGTERMINAL_ = self.gds_validate_string(PROCESSINGTERMINAL_, node, 'PROCESSINGTERMINAL')
            self.PROCESSINGTERMINAL = PROCESSINGTERMINAL_
            # validate type PROCESSINGTERMINAL
            self.validate_PROCESSINGTERMINAL(self.PROCESSINGTERMINAL)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
        elif nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class PREAUTHRESPONSE


class SECURECARDREGISTRATION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 0, {'ref': 'CARDNUMBER', 'name': 'CARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 0, {'ref': 'CARDEXPIRY', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 0, {'ref': 'CARDTYPE', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 0, {'ref': 'CARDHOLDERNAME', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CVV', 'xs:string', 0, 1, {'ref': 'CVV', 'minOccurs': '0', 'name': 'CVV', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('ISSUENO', 'xs:string', 0, 1, {'ref': 'ISSUENO', 'minOccurs': '0', 'name': 'ISSUENO', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('TRANSACTIONTYPE', ['TRANSACTIONTYPE', 'xs:int'], 0, 1, {'ref': 'TRANSACTIONTYPE', 'minOccurs': '0', 'name': 'TRANSACTIONTYPE', 'type': 'xs:int'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, CARDNUMBER=None, CARDEXPIRY=None, CARDTYPE=None, CARDHOLDERNAME=None, HASH=None, CVV=None, ADDRESS1=None, POSTCODE=None, ISSUENO=None, EMAIL=None, CREDENTIALONFILE=None, TRANSACTIONTYPE=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.CVV = CVV
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.ISSUENO = ISSUENO
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.TRANSACTIONTYPE = TRANSACTIONTYPE
        self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDREGISTRATION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDREGISTRATION.subclass:
            return SECURECARDREGISTRATION.subclass(*args_, **kwargs_)
        else:
            return SECURECARDREGISTRATION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CVV(self): return self.CVV
    def set_CVV(self, CVV): self.CVV = CVV
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_ISSUENO(self): return self.ISSUENO
    def set_ISSUENO(self, ISSUENO): self.ISSUENO = ISSUENO
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_TRANSACTIONTYPE(self): return self.TRANSACTIONTYPE
    def set_TRANSACTIONTYPE(self, TRANSACTIONTYPE): self.TRANSACTIONTYPE = TRANSACTIONTYPE
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_TRANSACTIONTYPE(self, value):
        # Validate type TRANSACTIONTYPE, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.CARDNUMBER is not None or
            self.CARDEXPIRY is not None or
            self.CARDTYPE is not None or
            self.CARDHOLDERNAME is not None or
            self.HASH is not None or
            self.CVV is not None or
            self.ADDRESS1 is not None or
            self.POSTCODE is not None or
            self.ISSUENO is not None or
            self.EMAIL is not None or
            self.CREDENTIALONFILE is not None or
            self.TRANSACTIONTYPE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDREGISTRATION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.CVV is not None:
            CVV_ = self.CVV
            etree_.SubElement(element, '{}CVV').text = self.gds_format_string(CVV_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.ISSUENO is not None:
            ISSUENO_ = self.ISSUENO
            etree_.SubElement(element, '{}ISSUENO').text = self.gds_format_string(ISSUENO_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.TRANSACTIONTYPE is not None:
            TRANSACTIONTYPE_ = self.TRANSACTIONTYPE
            etree_.SubElement(element, '{}TRANSACTIONTYPE').text = self.gds_format_integer(TRANSACTIONTYPE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDREGISTRATION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.CVV is not None:
            showIndent(outfile, level)
            outfile.write('CVV=%s,\n' % self.gds_encode(quote_python(self.CVV)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.ISSUENO is not None:
            showIndent(outfile, level)
            outfile.write('ISSUENO=%s,\n' % self.gds_encode(quote_python(self.ISSUENO)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TRANSACTIONTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTIONTYPE=%d,\n' % self.TRANSACTIONTYPE)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CVV':
            CVV_ = child_.text
            CVV_ = self.gds_validate_string(CVV_, node, 'CVV')
            self.CVV = CVV_
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'ISSUENO':
            ISSUENO_ = child_.text
            ISSUENO_ = self.gds_validate_string(ISSUENO_, node, 'ISSUENO')
            self.ISSUENO = ISSUENO_
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'TRANSACTIONTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TRANSACTIONTYPE')
            self.TRANSACTIONTYPE = ival_
            # validate type TRANSACTIONTYPE
            self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
    def sample_method(self):
        pass
# end class SECURECARDREGISTRATION


class SECURECARDREGISTRATIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', 'xs:string', 0, 0, {'ref': 'CARDREFERENCE', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, CARDREFERENCE=None, CREDENTIALONFILE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.CARDREFERENCE = CARDREFERENCE
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDREGISTRATIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDREGISTRATIONRESPONSE.subclass:
            return SECURECARDREGISTRATIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return SECURECARDREGISTRATIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.CARDREFERENCE is not None or
            self.CREDENTIALONFILE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDREGISTRATIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDREGISTRATIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class SECURECARDREGISTRATIONRESPONSE


class SECURECARDUPDATE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 1, {'ref': 'CARDNUMBER', 'minOccurs': '0', 'name': 'CARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 1, {'ref': 'CARDEXPIRY', 'minOccurs': '0', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 1, {'ref': 'CARDTYPE', 'minOccurs': '0', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 1, {'ref': 'CARDHOLDERNAME', 'minOccurs': '0', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CVV', 'xs:string', 0, 1, {'ref': 'CVV', 'minOccurs': '0', 'name': 'CVV', 'type': 'xs:string'}, None),
        MemberSpec_('ISSUENO', 'xs:string', 0, 1, {'ref': 'ISSUENO', 'minOccurs': '0', 'name': 'ISSUENO', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('TRANSACTIONTYPE', ['TRANSACTIONTYPE', 'xs:int'], 0, 1, {'ref': 'TRANSACTIONTYPE', 'minOccurs': '0', 'name': 'TRANSACTIONTYPE', 'type': 'xs:int'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, CARDNUMBER=None, CARDEXPIRY=None, CARDTYPE=None, CARDHOLDERNAME=None, HASH=None, CVV=None, ISSUENO=None, EMAIL=None, CREDENTIALONFILE=None, TRANSACTIONTYPE=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.CVV = CVV
        self.ISSUENO = ISSUENO
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.TRANSACTIONTYPE = TRANSACTIONTYPE
        self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDUPDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDUPDATE.subclass:
            return SECURECARDUPDATE.subclass(*args_, **kwargs_)
        else:
            return SECURECARDUPDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CVV(self): return self.CVV
    def set_CVV(self, CVV): self.CVV = CVV
    def get_ISSUENO(self): return self.ISSUENO
    def set_ISSUENO(self, ISSUENO): self.ISSUENO = ISSUENO
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_TRANSACTIONTYPE(self): return self.TRANSACTIONTYPE
    def set_TRANSACTIONTYPE(self, TRANSACTIONTYPE): self.TRANSACTIONTYPE = TRANSACTIONTYPE
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_TRANSACTIONTYPE(self, value):
        # Validate type TRANSACTIONTYPE, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.CARDNUMBER is not None or
            self.CARDEXPIRY is not None or
            self.CARDTYPE is not None or
            self.CARDHOLDERNAME is not None or
            self.HASH is not None or
            self.CVV is not None or
            self.ISSUENO is not None or
            self.EMAIL is not None or
            self.CREDENTIALONFILE is not None or
            self.TRANSACTIONTYPE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDUPDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.CVV is not None:
            CVV_ = self.CVV
            etree_.SubElement(element, '{}CVV').text = self.gds_format_string(CVV_)
        if self.ISSUENO is not None:
            ISSUENO_ = self.ISSUENO
            etree_.SubElement(element, '{}ISSUENO').text = self.gds_format_string(ISSUENO_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.TRANSACTIONTYPE is not None:
            TRANSACTIONTYPE_ = self.TRANSACTIONTYPE
            etree_.SubElement(element, '{}TRANSACTIONTYPE').text = self.gds_format_integer(TRANSACTIONTYPE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDUPDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.CVV is not None:
            showIndent(outfile, level)
            outfile.write('CVV=%s,\n' % self.gds_encode(quote_python(self.CVV)))
        if self.ISSUENO is not None:
            showIndent(outfile, level)
            outfile.write('ISSUENO=%s,\n' % self.gds_encode(quote_python(self.ISSUENO)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TRANSACTIONTYPE is not None:
            showIndent(outfile, level)
            outfile.write('TRANSACTIONTYPE=%d,\n' % self.TRANSACTIONTYPE)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CVV':
            CVV_ = child_.text
            CVV_ = self.gds_validate_string(CVV_, node, 'CVV')
            self.CVV = CVV_
        elif nodeName_ == 'ISSUENO':
            ISSUENO_ = child_.text
            ISSUENO_ = self.gds_validate_string(ISSUENO_, node, 'ISSUENO')
            self.ISSUENO = ISSUENO_
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'TRANSACTIONTYPE' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TRANSACTIONTYPE')
            self.TRANSACTIONTYPE = ival_
            # validate type TRANSACTIONTYPE
            self.validate_TRANSACTIONTYPE(self.TRANSACTIONTYPE)
    def sample_method(self):
        pass
# end class SECURECARDUPDATE


class SECURECARDUPDATERESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', 'xs:string', 0, 0, {'ref': 'CARDREFERENCE', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, CARDREFERENCE=None, CREDENTIALONFILE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.CARDREFERENCE = CARDREFERENCE
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDUPDATERESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDUPDATERESPONSE.subclass:
            return SECURECARDUPDATERESPONSE.subclass(*args_, **kwargs_)
        else:
            return SECURECARDUPDATERESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.CARDREFERENCE is not None or
            self.CREDENTIALONFILE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDUPDATERESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDUPDATERESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class SECURECARDUPDATERESPONSE


class NAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NAME.subclass:
            return NAME.subclass(*args_, **kwargs_)
        else:
            return NAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='NAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class NAME


class PERIODTYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERIODTYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERIODTYPE.subclass:
            return PERIODTYPE.subclass(*args_, **kwargs_)
        else:
            return PERIODTYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PERIODTYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PERIODTYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class PERIODTYPE


class TYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TYPE.subclass:
            return TYPE.subclass(*args_, **kwargs_)
        else:
            return TYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class TYPE


class ONUPDATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ONUPDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ONUPDATE.subclass:
            return ONUPDATE.subclass(*args_, **kwargs_)
        else:
            return ONUPDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ONUPDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ONUPDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ONUPDATE


class ONDELETE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ONDELETE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ONDELETE.subclass:
            return ONDELETE.subclass(*args_, **kwargs_)
        else:
            return ONDELETE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ONDELETE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ONDELETE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ONDELETE


class ADDSTOREDSUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('NAME', ['NAME', 'xs:string'], 0, 0, {'ref': 'NAME', 'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('PERIODTYPE', ['PERIODTYPE', 'xs:string'], 0, 0, {'ref': 'PERIODTYPE', 'name': 'PERIODTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('LENGTH', 'xs:unsignedInt', 0, 0, {'ref': 'LENGTH', 'name': 'LENGTH', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('INITIALAMOUNT', 'xs:double', 0, 1, {'ref': 'INITIALAMOUNT', 'minOccurs': '0', 'name': 'INITIALAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('TYPE', ['TYPE', 'xs:string'], 0, 0, {'ref': 'TYPE', 'name': 'TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ONUPDATE', ['ONUPDATE', 'xs:string'], 0, 0, {'ref': 'ONUPDATE', 'name': 'ONUPDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ONDELETE', ['ONDELETE', 'xs:string'], 0, 0, {'ref': 'ONDELETE', 'name': 'ONDELETE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, NAME=None, DESCRIPTION=None, PERIODTYPE=None, LENGTH=None, CURRENCY=None, RECURRINGAMOUNT=None, INITIALAMOUNT=None, TYPE=None, ONUPDATE=None, ONDELETE=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.NAME = NAME
        self.validate_NAME(self.NAME)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.PERIODTYPE = PERIODTYPE
        self.validate_PERIODTYPE(self.PERIODTYPE)
        self.LENGTH = LENGTH
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.INITIALAMOUNT = INITIALAMOUNT
        self.TYPE = TYPE
        self.validate_TYPE(self.TYPE)
        self.ONUPDATE = ONUPDATE
        self.validate_ONUPDATE(self.ONUPDATE)
        self.ONDELETE = ONDELETE
        self.validate_ONDELETE(self.ONDELETE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDSTOREDSUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDSTOREDSUBSCRIPTION.subclass:
            return ADDSTOREDSUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return ADDSTOREDSUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_PERIODTYPE(self): return self.PERIODTYPE
    def set_PERIODTYPE(self, PERIODTYPE): self.PERIODTYPE = PERIODTYPE
    def get_LENGTH(self): return self.LENGTH
    def set_LENGTH(self, LENGTH): self.LENGTH = LENGTH
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_INITIALAMOUNT(self): return self.INITIALAMOUNT
    def set_INITIALAMOUNT(self, INITIALAMOUNT): self.INITIALAMOUNT = INITIALAMOUNT
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ONUPDATE(self): return self.ONUPDATE
    def set_ONUPDATE(self, ONUPDATE): self.ONUPDATE = ONUPDATE
    def get_ONDELETE(self): return self.ONDELETE
    def set_ONDELETE(self, ONDELETE): self.ONDELETE = ONDELETE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_NAME(self, value):
        # Validate type NAME, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_PERIODTYPE(self, value):
        # Validate type PERIODTYPE, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_TYPE(self, value):
        # Validate type TYPE, a restriction on xs:string.
        pass
    def validate_ONUPDATE(self, value):
        # Validate type ONUPDATE, a restriction on xs:string.
        pass
    def validate_ONDELETE(self, value):
        # Validate type ONDELETE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.PERIODTYPE is not None or
            self.LENGTH is not None or
            self.CURRENCY is not None or
            self.RECURRINGAMOUNT is not None or
            self.INITIALAMOUNT is not None or
            self.TYPE is not None or
            self.ONUPDATE is not None or
            self.ONDELETE is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDSTOREDSUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.PERIODTYPE is not None:
            PERIODTYPE_ = self.PERIODTYPE
            etree_.SubElement(element, '{}PERIODTYPE').text = self.gds_format_string(PERIODTYPE_)
        if self.LENGTH is not None:
            LENGTH_ = self.LENGTH
            etree_.SubElement(element, '{}LENGTH').text = self.gds_format_integer(LENGTH_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.INITIALAMOUNT is not None:
            INITIALAMOUNT_ = self.INITIALAMOUNT
            etree_.SubElement(element, '{}INITIALAMOUNT').text = self.gds_format_double(INITIALAMOUNT_)
        if self.TYPE is not None:
            TYPE_ = self.TYPE
            etree_.SubElement(element, '{}TYPE').text = self.gds_format_string(TYPE_)
        if self.ONUPDATE is not None:
            ONUPDATE_ = self.ONUPDATE
            etree_.SubElement(element, '{}ONUPDATE').text = self.gds_format_string(ONUPDATE_)
        if self.ONDELETE is not None:
            ONDELETE_ = self.ONDELETE
            etree_.SubElement(element, '{}ONDELETE').text = self.gds_format_string(ONDELETE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDSTOREDSUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.PERIODTYPE is not None:
            showIndent(outfile, level)
            outfile.write('PERIODTYPE=%s,\n' % self.gds_encode(quote_python(self.PERIODTYPE)))
        if self.LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('LENGTH=%d,\n' % self.LENGTH)
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.INITIALAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('INITIALAMOUNT=%e,\n' % self.INITIALAMOUNT)
        if self.TYPE is not None:
            showIndent(outfile, level)
            outfile.write('TYPE=%s,\n' % self.gds_encode(quote_python(self.TYPE)))
        if self.ONUPDATE is not None:
            showIndent(outfile, level)
            outfile.write('ONUPDATE=%s,\n' % self.gds_encode(quote_python(self.ONUPDATE)))
        if self.ONDELETE is not None:
            showIndent(outfile, level)
            outfile.write('ONDELETE=%s,\n' % self.gds_encode(quote_python(self.ONDELETE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
            # validate type NAME
            self.validate_NAME(self.NAME)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'PERIODTYPE':
            PERIODTYPE_ = child_.text
            PERIODTYPE_ = self.gds_validate_string(PERIODTYPE_, node, 'PERIODTYPE')
            self.PERIODTYPE = PERIODTYPE_
            # validate type PERIODTYPE
            self.validate_PERIODTYPE(self.PERIODTYPE)
        elif nodeName_ == 'LENGTH' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LENGTH')
            self.LENGTH = ival_
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'INITIALAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'INITIALAMOUNT')
            self.INITIALAMOUNT = fval_
        elif nodeName_ == 'TYPE':
            TYPE_ = child_.text
            TYPE_ = self.gds_validate_string(TYPE_, node, 'TYPE')
            self.TYPE = TYPE_
            # validate type TYPE
            self.validate_TYPE(self.TYPE)
        elif nodeName_ == 'ONUPDATE':
            ONUPDATE_ = child_.text
            ONUPDATE_ = self.gds_validate_string(ONUPDATE_, node, 'ONUPDATE')
            self.ONUPDATE = ONUPDATE_
            # validate type ONUPDATE
            self.validate_ONUPDATE(self.ONUPDATE)
        elif nodeName_ == 'ONDELETE':
            ONDELETE_ = child_.text
            ONDELETE_ = self.gds_validate_string(ONDELETE_, node, 'ONDELETE')
            self.ONDELETE = ONDELETE_
            # validate type ONDELETE
            self.validate_ONDELETE(self.ONDELETE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class ADDSTOREDSUBSCRIPTION


class ADDSTOREDSUBSCRIPTIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDSTOREDSUBSCRIPTIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDSTOREDSUBSCRIPTIONRESPONSE.subclass:
            return ADDSTOREDSUBSCRIPTIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return ADDSTOREDSUBSCRIPTIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDSTOREDSUBSCRIPTIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDSTOREDSUBSCRIPTIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class ADDSTOREDSUBSCRIPTIONRESPONSE


class UPDATESTOREDSUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('NAME', ['NAME', 'xs:string'], 0, 0, {'ref': 'NAME', 'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('LENGTH', 'xs:unsignedInt', 0, 0, {'ref': 'LENGTH', 'name': 'LENGTH', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('INITIALAMOUNT', 'xs:double', 0, 1, {'ref': 'INITIALAMOUNT', 'minOccurs': '0', 'name': 'INITIALAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('TYPE', ['TYPE', 'xs:string'], 0, 0, {'ref': 'TYPE', 'name': 'TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ONUPDATE', ['ONUPDATE', 'xs:string'], 0, 0, {'ref': 'ONUPDATE', 'name': 'ONUPDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ONDELETE', ['ONDELETE', 'xs:string'], 0, 0, {'ref': 'ONDELETE', 'name': 'ONDELETE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, NAME=None, DESCRIPTION=None, LENGTH=None, CURRENCY=None, RECURRINGAMOUNT=None, INITIALAMOUNT=None, TYPE=None, ONUPDATE=None, ONDELETE=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.NAME = NAME
        self.validate_NAME(self.NAME)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.LENGTH = LENGTH
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.INITIALAMOUNT = INITIALAMOUNT
        self.TYPE = TYPE
        self.validate_TYPE(self.TYPE)
        self.ONUPDATE = ONUPDATE
        self.validate_ONUPDATE(self.ONUPDATE)
        self.ONDELETE = ONDELETE
        self.validate_ONDELETE(self.ONDELETE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATESTOREDSUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATESTOREDSUBSCRIPTION.subclass:
            return UPDATESTOREDSUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return UPDATESTOREDSUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_LENGTH(self): return self.LENGTH
    def set_LENGTH(self, LENGTH): self.LENGTH = LENGTH
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_INITIALAMOUNT(self): return self.INITIALAMOUNT
    def set_INITIALAMOUNT(self, INITIALAMOUNT): self.INITIALAMOUNT = INITIALAMOUNT
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ONUPDATE(self): return self.ONUPDATE
    def set_ONUPDATE(self, ONUPDATE): self.ONUPDATE = ONUPDATE
    def get_ONDELETE(self): return self.ONDELETE
    def set_ONDELETE(self, ONDELETE): self.ONDELETE = ONDELETE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_NAME(self, value):
        # Validate type NAME, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_TYPE(self, value):
        # Validate type TYPE, a restriction on xs:string.
        pass
    def validate_ONUPDATE(self, value):
        # Validate type ONUPDATE, a restriction on xs:string.
        pass
    def validate_ONDELETE(self, value):
        # Validate type ONDELETE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.LENGTH is not None or
            self.CURRENCY is not None or
            self.RECURRINGAMOUNT is not None or
            self.INITIALAMOUNT is not None or
            self.TYPE is not None or
            self.ONUPDATE is not None or
            self.ONDELETE is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATESTOREDSUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.LENGTH is not None:
            LENGTH_ = self.LENGTH
            etree_.SubElement(element, '{}LENGTH').text = self.gds_format_integer(LENGTH_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.INITIALAMOUNT is not None:
            INITIALAMOUNT_ = self.INITIALAMOUNT
            etree_.SubElement(element, '{}INITIALAMOUNT').text = self.gds_format_double(INITIALAMOUNT_)
        if self.TYPE is not None:
            TYPE_ = self.TYPE
            etree_.SubElement(element, '{}TYPE').text = self.gds_format_string(TYPE_)
        if self.ONUPDATE is not None:
            ONUPDATE_ = self.ONUPDATE
            etree_.SubElement(element, '{}ONUPDATE').text = self.gds_format_string(ONUPDATE_)
        if self.ONDELETE is not None:
            ONDELETE_ = self.ONDELETE
            etree_.SubElement(element, '{}ONDELETE').text = self.gds_format_string(ONDELETE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATESTOREDSUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('LENGTH=%d,\n' % self.LENGTH)
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.INITIALAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('INITIALAMOUNT=%e,\n' % self.INITIALAMOUNT)
        if self.TYPE is not None:
            showIndent(outfile, level)
            outfile.write('TYPE=%s,\n' % self.gds_encode(quote_python(self.TYPE)))
        if self.ONUPDATE is not None:
            showIndent(outfile, level)
            outfile.write('ONUPDATE=%s,\n' % self.gds_encode(quote_python(self.ONUPDATE)))
        if self.ONDELETE is not None:
            showIndent(outfile, level)
            outfile.write('ONDELETE=%s,\n' % self.gds_encode(quote_python(self.ONDELETE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
            # validate type NAME
            self.validate_NAME(self.NAME)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'LENGTH' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LENGTH')
            self.LENGTH = ival_
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'INITIALAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'INITIALAMOUNT')
            self.INITIALAMOUNT = fval_
        elif nodeName_ == 'TYPE':
            TYPE_ = child_.text
            TYPE_ = self.gds_validate_string(TYPE_, node, 'TYPE')
            self.TYPE = TYPE_
            # validate type TYPE
            self.validate_TYPE(self.TYPE)
        elif nodeName_ == 'ONUPDATE':
            ONUPDATE_ = child_.text
            ONUPDATE_ = self.gds_validate_string(ONUPDATE_, node, 'ONUPDATE')
            self.ONUPDATE = ONUPDATE_
            # validate type ONUPDATE
            self.validate_ONUPDATE(self.ONUPDATE)
        elif nodeName_ == 'ONDELETE':
            ONDELETE_ = child_.text
            ONDELETE_ = self.gds_validate_string(ONDELETE_, node, 'ONDELETE')
            self.ONDELETE = ONDELETE_
            # validate type ONDELETE
            self.validate_ONDELETE(self.ONDELETE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class UPDATESTOREDSUBSCRIPTION


class UPDATESTOREDSUBSCRIPTIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATESTOREDSUBSCRIPTIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATESTOREDSUBSCRIPTIONRESPONSE.subclass:
            return UPDATESTOREDSUBSCRIPTIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return UPDATESTOREDSUBSCRIPTIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATESTOREDSUBSCRIPTIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATESTOREDSUBSCRIPTIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class UPDATESTOREDSUBSCRIPTIONRESPONSE


class STOREDSUBSCRIPTIONREF(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STOREDSUBSCRIPTIONREF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STOREDSUBSCRIPTIONREF.subclass:
            return STOREDSUBSCRIPTIONREF.subclass(*args_, **kwargs_)
        else:
            return STOREDSUBSCRIPTIONREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='STOREDSUBSCRIPTIONREF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='STOREDSUBSCRIPTIONREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class STOREDSUBSCRIPTIONREF


class SECURECARDMERCHANTREF(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECURECARDMERCHANTREF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECURECARDMERCHANTREF.subclass:
            return SECURECARDMERCHANTREF.subclass(*args_, **kwargs_)
        else:
            return SECURECARDMERCHANTREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECURECARDMERCHANTREF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECURECARDMERCHANTREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class SECURECARDMERCHANTREF


class SECUREACHACCOUNTMERCHANTREF(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SECUREACHACCOUNTMERCHANTREF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SECUREACHACCOUNTMERCHANTREF.subclass:
            return SECUREACHACCOUNTMERCHANTREF.subclass(*args_, **kwargs_)
        else:
            return SECUREACHACCOUNTMERCHANTREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SECUREACHACCOUNTMERCHANTREF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SECUREACHACCOUNTMERCHANTREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class SECUREACHACCOUNTMERCHANTREF


class STARTDATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STARTDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STARTDATE.subclass:
            return STARTDATE.subclass(*args_, **kwargs_)
        else:
            return STARTDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='STARTDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='STARTDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class STARTDATE


class ENDDATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENDDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENDDATE.subclass:
            return ENDDATE.subclass(*args_, **kwargs_)
        else:
            return ENDDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ENDDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ENDDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ENDDATE


class EDCCDECISION(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EDCCDECISION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EDCCDECISION.subclass:
            return EDCCDECISION.subclass(*args_, **kwargs_)
        else:
            return EDCCDECISION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='EDCCDECISION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='EDCCDECISION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class EDCCDECISION


class NEWSTOREDSUBSCRIPTIONINFO(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('NAME', ['NAME', 'xs:string'], 0, 0, {'ref': 'NAME', 'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 0, {'ref': 'DESCRIPTION', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('PERIODTYPE', ['PERIODTYPE', 'xs:string'], 0, 0, {'ref': 'PERIODTYPE', 'name': 'PERIODTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('LENGTH', 'xs:unsignedInt', 0, 0, {'ref': 'LENGTH', 'name': 'LENGTH', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('CURRENCY', ['CURRENCY', 'xs:string'], 0, 0, {'ref': 'CURRENCY', 'name': 'CURRENCY', 'type': 'xs:string'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('INITIALAMOUNT', 'xs:double', 0, 1, {'ref': 'INITIALAMOUNT', 'minOccurs': '0', 'name': 'INITIALAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('TYPE', ['TYPE', 'xs:string'], 0, 0, {'ref': 'TYPE', 'name': 'TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ONUPDATE', ['ONUPDATE', 'xs:string'], 0, 0, {'ref': 'ONUPDATE', 'name': 'ONUPDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ONDELETE', ['ONDELETE', 'xs:string'], 0, 0, {'ref': 'ONDELETE', 'name': 'ONDELETE', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, NAME=None, DESCRIPTION=None, PERIODTYPE=None, LENGTH=None, CURRENCY=None, RECURRINGAMOUNT=None, INITIALAMOUNT=None, TYPE=None, ONUPDATE=None, ONDELETE=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.NAME = NAME
        self.validate_NAME(self.NAME)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.PERIODTYPE = PERIODTYPE
        self.validate_PERIODTYPE(self.PERIODTYPE)
        self.LENGTH = LENGTH
        self.CURRENCY = CURRENCY
        self.validate_CURRENCY(self.CURRENCY)
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.INITIALAMOUNT = INITIALAMOUNT
        self.TYPE = TYPE
        self.validate_TYPE(self.TYPE)
        self.ONUPDATE = ONUPDATE
        self.validate_ONUPDATE(self.ONUPDATE)
        self.ONDELETE = ONDELETE
        self.validate_ONDELETE(self.ONDELETE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NEWSTOREDSUBSCRIPTIONINFO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NEWSTOREDSUBSCRIPTIONINFO.subclass:
            return NEWSTOREDSUBSCRIPTIONINFO.subclass(*args_, **kwargs_)
        else:
            return NEWSTOREDSUBSCRIPTIONINFO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_PERIODTYPE(self): return self.PERIODTYPE
    def set_PERIODTYPE(self, PERIODTYPE): self.PERIODTYPE = PERIODTYPE
    def get_LENGTH(self): return self.LENGTH
    def set_LENGTH(self, LENGTH): self.LENGTH = LENGTH
    def get_CURRENCY(self): return self.CURRENCY
    def set_CURRENCY(self, CURRENCY): self.CURRENCY = CURRENCY
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_INITIALAMOUNT(self): return self.INITIALAMOUNT
    def set_INITIALAMOUNT(self, INITIALAMOUNT): self.INITIALAMOUNT = INITIALAMOUNT
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ONUPDATE(self): return self.ONUPDATE
    def set_ONUPDATE(self, ONUPDATE): self.ONUPDATE = ONUPDATE
    def get_ONDELETE(self): return self.ONDELETE
    def set_ONDELETE(self, ONDELETE): self.ONDELETE = ONDELETE
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_NAME(self, value):
        # Validate type NAME, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_PERIODTYPE(self, value):
        # Validate type PERIODTYPE, a restriction on xs:string.
        pass
    def validate_CURRENCY(self, value):
        # Validate type CURRENCY, a restriction on xs:string.
        pass
    def validate_TYPE(self, value):
        # Validate type TYPE, a restriction on xs:string.
        pass
    def validate_ONUPDATE(self, value):
        # Validate type ONUPDATE, a restriction on xs:string.
        pass
    def validate_ONDELETE(self, value):
        # Validate type ONDELETE, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.PERIODTYPE is not None or
            self.LENGTH is not None or
            self.CURRENCY is not None or
            self.RECURRINGAMOUNT is not None or
            self.INITIALAMOUNT is not None or
            self.TYPE is not None or
            self.ONUPDATE is not None or
            self.ONDELETE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='NEWSTOREDSUBSCRIPTIONINFO', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.PERIODTYPE is not None:
            PERIODTYPE_ = self.PERIODTYPE
            etree_.SubElement(element, '{}PERIODTYPE').text = self.gds_format_string(PERIODTYPE_)
        if self.LENGTH is not None:
            LENGTH_ = self.LENGTH
            etree_.SubElement(element, '{}LENGTH').text = self.gds_format_integer(LENGTH_)
        if self.CURRENCY is not None:
            CURRENCY_ = self.CURRENCY
            etree_.SubElement(element, '{}CURRENCY').text = self.gds_format_string(CURRENCY_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.INITIALAMOUNT is not None:
            INITIALAMOUNT_ = self.INITIALAMOUNT
            etree_.SubElement(element, '{}INITIALAMOUNT').text = self.gds_format_double(INITIALAMOUNT_)
        if self.TYPE is not None:
            TYPE_ = self.TYPE
            etree_.SubElement(element, '{}TYPE').text = self.gds_format_string(TYPE_)
        if self.ONUPDATE is not None:
            ONUPDATE_ = self.ONUPDATE
            etree_.SubElement(element, '{}ONUPDATE').text = self.gds_format_string(ONUPDATE_)
        if self.ONDELETE is not None:
            ONDELETE_ = self.ONDELETE
            etree_.SubElement(element, '{}ONDELETE').text = self.gds_format_string(ONDELETE_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NEWSTOREDSUBSCRIPTIONINFO'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.PERIODTYPE is not None:
            showIndent(outfile, level)
            outfile.write('PERIODTYPE=%s,\n' % self.gds_encode(quote_python(self.PERIODTYPE)))
        if self.LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('LENGTH=%d,\n' % self.LENGTH)
        if self.CURRENCY is not None:
            showIndent(outfile, level)
            outfile.write('CURRENCY=%s,\n' % self.gds_encode(quote_python(self.CURRENCY)))
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.INITIALAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('INITIALAMOUNT=%e,\n' % self.INITIALAMOUNT)
        if self.TYPE is not None:
            showIndent(outfile, level)
            outfile.write('TYPE=%s,\n' % self.gds_encode(quote_python(self.TYPE)))
        if self.ONUPDATE is not None:
            showIndent(outfile, level)
            outfile.write('ONUPDATE=%s,\n' % self.gds_encode(quote_python(self.ONUPDATE)))
        if self.ONDELETE is not None:
            showIndent(outfile, level)
            outfile.write('ONDELETE=%s,\n' % self.gds_encode(quote_python(self.ONDELETE)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
            # validate type NAME
            self.validate_NAME(self.NAME)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'PERIODTYPE':
            PERIODTYPE_ = child_.text
            PERIODTYPE_ = self.gds_validate_string(PERIODTYPE_, node, 'PERIODTYPE')
            self.PERIODTYPE = PERIODTYPE_
            # validate type PERIODTYPE
            self.validate_PERIODTYPE(self.PERIODTYPE)
        elif nodeName_ == 'LENGTH' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LENGTH')
            self.LENGTH = ival_
        elif nodeName_ == 'CURRENCY':
            CURRENCY_ = child_.text
            CURRENCY_ = self.gds_validate_string(CURRENCY_, node, 'CURRENCY')
            self.CURRENCY = CURRENCY_
            # validate type CURRENCY
            self.validate_CURRENCY(self.CURRENCY)
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'INITIALAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'INITIALAMOUNT')
            self.INITIALAMOUNT = fval_
        elif nodeName_ == 'TYPE':
            TYPE_ = child_.text
            TYPE_ = self.gds_validate_string(TYPE_, node, 'TYPE')
            self.TYPE = TYPE_
            # validate type TYPE
            self.validate_TYPE(self.TYPE)
        elif nodeName_ == 'ONUPDATE':
            ONUPDATE_ = child_.text
            ONUPDATE_ = self.gds_validate_string(ONUPDATE_, node, 'ONUPDATE')
            self.ONUPDATE = ONUPDATE_
            # validate type ONUPDATE
            self.validate_ONUPDATE(self.ONUPDATE)
        elif nodeName_ == 'ONDELETE':
            ONDELETE_ = child_.text
            ONDELETE_ = self.gds_validate_string(ONDELETE_, node, 'ONDELETE')
            self.ONDELETE = ONDELETE_
            # validate type ONDELETE
            self.validate_ONDELETE(self.ONDELETE)
    def sample_method(self):
        pass
# end class NEWSTOREDSUBSCRIPTIONINFO


class ADDSUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('STOREDSUBSCRIPTIONREF', ['STOREDSUBSCRIPTIONREF', 'xs:string'], 0, 1, {'ref': 'STOREDSUBSCRIPTIONREF', 'minOccurs': '0', 'name': 'STOREDSUBSCRIPTIONREF', 'type': 'xs:string'}, None),
        MemberSpec_('SECURECARDMERCHANTREF', ['SECURECARDMERCHANTREF', 'xs:string'], 0, 1, {'ref': 'SECURECARDMERCHANTREF', 'minOccurs': '0', 'name': 'SECURECARDMERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', 'xs:string', 0, 1, {'ref': 'CARDREFERENCE', 'minOccurs': '0', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('INITIALAMOUNT', 'xs:double', 0, 1, {'ref': 'INITIALAMOUNT', 'minOccurs': '0', 'name': 'INITIALAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('STARTDATE', ['STARTDATE', 'xs:string'], 0, 0, {'ref': 'STARTDATE', 'name': 'STARTDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ENDDATE', ['ENDDATE', 'xs:string'], 0, 1, {'ref': 'ENDDATE', 'minOccurs': '0', 'name': 'ENDDATE', 'type': 'xs:string'}, None),
        MemberSpec_('EDCCDECISION', ['EDCCDECISION', 'xs:string'], 0, 1, {'ref': 'EDCCDECISION', 'minOccurs': '0', 'name': 'EDCCDECISION', 'type': 'xs:string'}, None),
        MemberSpec_('NEWSTOREDSUBSCRIPTIONINFO', 'NEWSTOREDSUBSCRIPTIONINFO', 0, 1, {'ref': 'NEWSTOREDSUBSCRIPTIONINFO', 'minOccurs': '0', 'name': 'NEWSTOREDSUBSCRIPTIONINFO', 'type': 'NEWSTOREDSUBSCRIPTIONINFO'}, None),
        MemberSpec_('NOTIFICATIONLANGUAGE', ['NOTIFICATIONLANGUAGE', 'xs:string'], 0, 1, {'ref': 'NOTIFICATIONLANGUAGE', 'minOccurs': '0', 'name': 'NOTIFICATIONLANGUAGE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('LEVEL_3_DATA', 'LEVEL_3_DATA', 0, 1, {'ref': 'LEVEL_3_DATA', 'minOccurs': '0', 'name': 'LEVEL_3_DATA', 'type': 'LEVEL_3_DATA'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, STOREDSUBSCRIPTIONREF=None, SECURECARDMERCHANTREF=None, CARDREFERENCE=None, DATETIME=None, RECURRINGAMOUNT=None, INITIALAMOUNT=None, STARTDATE=None, ENDDATE=None, EDCCDECISION=None, NEWSTOREDSUBSCRIPTIONINFO=None, NOTIFICATIONLANGUAGE=None, HASH=None, LEVEL_2_DATA=None, LEVEL_3_DATA=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF
        self.validate_STOREDSUBSCRIPTIONREF(self.STOREDSUBSCRIPTIONREF)
        self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF
        self.validate_SECURECARDMERCHANTREF(self.SECURECARDMERCHANTREF)
        self.CARDREFERENCE = CARDREFERENCE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.INITIALAMOUNT = INITIALAMOUNT
        self.STARTDATE = STARTDATE
        self.validate_STARTDATE(self.STARTDATE)
        self.ENDDATE = ENDDATE
        self.validate_ENDDATE(self.ENDDATE)
        self.EDCCDECISION = EDCCDECISION
        self.validate_EDCCDECISION(self.EDCCDECISION)
        self.NEWSTOREDSUBSCRIPTIONINFO = NEWSTOREDSUBSCRIPTIONINFO
        self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
        self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.LEVEL_3_DATA = LEVEL_3_DATA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDSUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDSUBSCRIPTION.subclass:
            return ADDSUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return ADDSUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_STOREDSUBSCRIPTIONREF(self): return self.STOREDSUBSCRIPTIONREF
    def set_STOREDSUBSCRIPTIONREF(self, STOREDSUBSCRIPTIONREF): self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF
    def get_SECURECARDMERCHANTREF(self): return self.SECURECARDMERCHANTREF
    def set_SECURECARDMERCHANTREF(self, SECURECARDMERCHANTREF): self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_INITIALAMOUNT(self): return self.INITIALAMOUNT
    def set_INITIALAMOUNT(self, INITIALAMOUNT): self.INITIALAMOUNT = INITIALAMOUNT
    def get_STARTDATE(self): return self.STARTDATE
    def set_STARTDATE(self, STARTDATE): self.STARTDATE = STARTDATE
    def get_ENDDATE(self): return self.ENDDATE
    def set_ENDDATE(self, ENDDATE): self.ENDDATE = ENDDATE
    def get_EDCCDECISION(self): return self.EDCCDECISION
    def set_EDCCDECISION(self, EDCCDECISION): self.EDCCDECISION = EDCCDECISION
    def get_NEWSTOREDSUBSCRIPTIONINFO(self): return self.NEWSTOREDSUBSCRIPTIONINFO
    def set_NEWSTOREDSUBSCRIPTIONINFO(self, NEWSTOREDSUBSCRIPTIONINFO): self.NEWSTOREDSUBSCRIPTIONINFO = NEWSTOREDSUBSCRIPTIONINFO
    def get_NOTIFICATIONLANGUAGE(self): return self.NOTIFICATIONLANGUAGE
    def set_NOTIFICATIONLANGUAGE(self, NOTIFICATIONLANGUAGE): self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_LEVEL_3_DATA(self): return self.LEVEL_3_DATA
    def set_LEVEL_3_DATA(self, LEVEL_3_DATA): self.LEVEL_3_DATA = LEVEL_3_DATA
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_STOREDSUBSCRIPTIONREF(self, value):
        # Validate type STOREDSUBSCRIPTIONREF, a restriction on xs:string.
        pass
    def validate_SECURECARDMERCHANTREF(self, value):
        # Validate type SECURECARDMERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_STARTDATE(self, value):
        # Validate type STARTDATE, a restriction on xs:string.
        pass
    def validate_ENDDATE(self, value):
        # Validate type ENDDATE, a restriction on xs:string.
        pass
    def validate_EDCCDECISION(self, value):
        # Validate type EDCCDECISION, a restriction on xs:string.
        pass
    def validate_NOTIFICATIONLANGUAGE(self, value):
        # Validate type NOTIFICATIONLANGUAGE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.STOREDSUBSCRIPTIONREF is not None or
            self.SECURECARDMERCHANTREF is not None or
            self.CARDREFERENCE is not None or
            self.DATETIME is not None or
            self.RECURRINGAMOUNT is not None or
            self.INITIALAMOUNT is not None or
            self.STARTDATE is not None or
            self.ENDDATE is not None or
            self.EDCCDECISION is not None or
            self.NEWSTOREDSUBSCRIPTIONINFO is not None or
            self.NOTIFICATIONLANGUAGE is not None or
            self.HASH is not None or
            self.LEVEL_2_DATA is not None or
            self.LEVEL_3_DATA is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDSUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.STOREDSUBSCRIPTIONREF is not None:
            STOREDSUBSCRIPTIONREF_ = self.STOREDSUBSCRIPTIONREF
            etree_.SubElement(element, '{}STOREDSUBSCRIPTIONREF').text = self.gds_format_string(STOREDSUBSCRIPTIONREF_)
        if self.SECURECARDMERCHANTREF is not None:
            SECURECARDMERCHANTREF_ = self.SECURECARDMERCHANTREF
            etree_.SubElement(element, '{}SECURECARDMERCHANTREF').text = self.gds_format_string(SECURECARDMERCHANTREF_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.INITIALAMOUNT is not None:
            INITIALAMOUNT_ = self.INITIALAMOUNT
            etree_.SubElement(element, '{}INITIALAMOUNT').text = self.gds_format_double(INITIALAMOUNT_)
        if self.STARTDATE is not None:
            STARTDATE_ = self.STARTDATE
            etree_.SubElement(element, '{}STARTDATE').text = self.gds_format_string(STARTDATE_)
        if self.ENDDATE is not None:
            ENDDATE_ = self.ENDDATE
            etree_.SubElement(element, '{}ENDDATE').text = self.gds_format_string(ENDDATE_)
        if self.EDCCDECISION is not None:
            EDCCDECISION_ = self.EDCCDECISION
            etree_.SubElement(element, '{}EDCCDECISION').text = self.gds_format_string(EDCCDECISION_)
        if self.NEWSTOREDSUBSCRIPTIONINFO is not None:
            NEWSTOREDSUBSCRIPTIONINFO_ = self.NEWSTOREDSUBSCRIPTIONINFO
            NEWSTOREDSUBSCRIPTIONINFO_.to_etree(element, name_='NEWSTOREDSUBSCRIPTIONINFO', mapping_=mapping_)
        if self.NOTIFICATIONLANGUAGE is not None:
            NOTIFICATIONLANGUAGE_ = self.NOTIFICATIONLANGUAGE
            etree_.SubElement(element, '{}NOTIFICATIONLANGUAGE').text = self.gds_format_string(NOTIFICATIONLANGUAGE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.LEVEL_3_DATA is not None:
            LEVEL_3_DATA_ = self.LEVEL_3_DATA
            LEVEL_3_DATA_.to_etree(element, name_='LEVEL_3_DATA', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDSUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.STOREDSUBSCRIPTIONREF is not None:
            showIndent(outfile, level)
            outfile.write('STOREDSUBSCRIPTIONREF=%s,\n' % self.gds_encode(quote_python(self.STOREDSUBSCRIPTIONREF)))
        if self.SECURECARDMERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('SECURECARDMERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.SECURECARDMERCHANTREF)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.INITIALAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('INITIALAMOUNT=%e,\n' % self.INITIALAMOUNT)
        if self.STARTDATE is not None:
            showIndent(outfile, level)
            outfile.write('STARTDATE=%s,\n' % self.gds_encode(quote_python(self.STARTDATE)))
        if self.ENDDATE is not None:
            showIndent(outfile, level)
            outfile.write('ENDDATE=%s,\n' % self.gds_encode(quote_python(self.ENDDATE)))
        if self.EDCCDECISION is not None:
            showIndent(outfile, level)
            outfile.write('EDCCDECISION=%s,\n' % self.gds_encode(quote_python(self.EDCCDECISION)))
        if self.NEWSTOREDSUBSCRIPTIONINFO is not None:
            showIndent(outfile, level)
            outfile.write('NEWSTOREDSUBSCRIPTIONINFO=model_.NEWSTOREDSUBSCRIPTIONINFO(\n')
            self.NEWSTOREDSUBSCRIPTIONINFO.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NOTIFICATIONLANGUAGE is not None:
            showIndent(outfile, level)
            outfile.write('NOTIFICATIONLANGUAGE=%s,\n' % self.gds_encode(quote_python(self.NOTIFICATIONLANGUAGE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LEVEL_3_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_3_DATA=model_.LEVEL_3_DATA(\n')
            self.LEVEL_3_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'STOREDSUBSCRIPTIONREF':
            STOREDSUBSCRIPTIONREF_ = child_.text
            STOREDSUBSCRIPTIONREF_ = self.gds_validate_string(STOREDSUBSCRIPTIONREF_, node, 'STOREDSUBSCRIPTIONREF')
            self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF_
            # validate type STOREDSUBSCRIPTIONREF
            self.validate_STOREDSUBSCRIPTIONREF(self.STOREDSUBSCRIPTIONREF)
        elif nodeName_ == 'SECURECARDMERCHANTREF':
            SECURECARDMERCHANTREF_ = child_.text
            SECURECARDMERCHANTREF_ = self.gds_validate_string(SECURECARDMERCHANTREF_, node, 'SECURECARDMERCHANTREF')
            self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF_
            # validate type SECURECARDMERCHANTREF
            self.validate_SECURECARDMERCHANTREF(self.SECURECARDMERCHANTREF)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'INITIALAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'INITIALAMOUNT')
            self.INITIALAMOUNT = fval_
        elif nodeName_ == 'STARTDATE':
            STARTDATE_ = child_.text
            STARTDATE_ = self.gds_validate_string(STARTDATE_, node, 'STARTDATE')
            self.STARTDATE = STARTDATE_
            # validate type STARTDATE
            self.validate_STARTDATE(self.STARTDATE)
        elif nodeName_ == 'ENDDATE':
            ENDDATE_ = child_.text
            ENDDATE_ = self.gds_validate_string(ENDDATE_, node, 'ENDDATE')
            self.ENDDATE = ENDDATE_
            # validate type ENDDATE
            self.validate_ENDDATE(self.ENDDATE)
        elif nodeName_ == 'EDCCDECISION':
            EDCCDECISION_ = child_.text
            EDCCDECISION_ = self.gds_validate_string(EDCCDECISION_, node, 'EDCCDECISION')
            self.EDCCDECISION = EDCCDECISION_
            # validate type EDCCDECISION
            self.validate_EDCCDECISION(self.EDCCDECISION)
        elif nodeName_ == 'NEWSTOREDSUBSCRIPTIONINFO':
            obj_ = NEWSTOREDSUBSCRIPTIONINFO.factory()
            obj_.build(child_)
            self.NEWSTOREDSUBSCRIPTIONINFO = obj_
            obj_.original_tagname_ = 'NEWSTOREDSUBSCRIPTIONINFO'
        elif nodeName_ == 'NOTIFICATIONLANGUAGE':
            NOTIFICATIONLANGUAGE_ = child_.text
            NOTIFICATIONLANGUAGE_ = self.gds_validate_string(NOTIFICATIONLANGUAGE_, node, 'NOTIFICATIONLANGUAGE')
            self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE_
            # validate type NOTIFICATIONLANGUAGE
            self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'LEVEL_3_DATA':
            obj_ = LEVEL_3_DATA.factory()
            obj_.build(child_)
            self.LEVEL_3_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_3_DATA'
    def sample_method(self):
        pass
# end class ADDSUBSCRIPTION


class ADDSUBSCRIPTIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDSUBSCRIPTIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDSUBSCRIPTIONRESPONSE.subclass:
            return ADDSUBSCRIPTIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return ADDSUBSCRIPTIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADDSUBSCRIPTIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADDSUBSCRIPTIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class ADDSUBSCRIPTIONRESPONSE


class UPDATESUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('SECURECARDMERCHANTREF', ['SECURECARDMERCHANTREF', 'xs:string'], 0, 1, {'ref': 'SECURECARDMERCHANTREF', 'minOccurs': '0', 'name': 'SECURECARDMERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('CARDREFERENCE', 'xs:string', 0, 1, {'ref': 'CARDREFERENCE', 'minOccurs': '0', 'name': 'CARDREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('NAME', ['NAME', 'xs:string'], 0, 1, {'ref': 'NAME', 'minOccurs': '0', 'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('LENGTH', 'xs:unsignedInt', 0, 1, {'ref': 'LENGTH', 'minOccurs': '0', 'name': 'LENGTH', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('SKIPPERIODCOUNT', 'xs:unsignedInt', 0, 1, {'ref': 'SKIPPERIODCOUNT', 'minOccurs': '0', 'name': 'SKIPPERIODCOUNT', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('STARTDATE', ['STARTDATE', 'xs:string'], 0, 1, {'ref': 'STARTDATE', 'minOccurs': '0', 'name': 'STARTDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ENDDATE', ['ENDDATE', 'xs:string'], 0, 1, {'ref': 'ENDDATE', 'minOccurs': '0', 'name': 'ENDDATE', 'type': 'xs:string'}, None),
        MemberSpec_('EDCCDECISION', ['EDCCDECISION', 'xs:string'], 0, 1, {'ref': 'EDCCDECISION', 'minOccurs': '0', 'name': 'EDCCDECISION', 'type': 'xs:string'}, None),
        MemberSpec_('NOTIFICATIONLANGUAGE', ['NOTIFICATIONLANGUAGE', 'xs:string'], 0, 1, {'ref': 'NOTIFICATIONLANGUAGE', 'minOccurs': '0', 'name': 'NOTIFICATIONLANGUAGE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('LEVEL_2_DATA', 'LEVEL_2_DATA', 0, 1, {'ref': 'LEVEL_2_DATA', 'minOccurs': '0', 'name': 'LEVEL_2_DATA', 'type': 'LEVEL_2_DATA'}, None),
        MemberSpec_('LEVEL_3_DATA', 'LEVEL_3_DATA', 0, 1, {'ref': 'LEVEL_3_DATA', 'minOccurs': '0', 'name': 'LEVEL_3_DATA', 'type': 'LEVEL_3_DATA'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, SECURECARDMERCHANTREF=None, CARDREFERENCE=None, DATETIME=None, NAME=None, DESCRIPTION=None, LENGTH=None, SKIPPERIODCOUNT=None, RECURRINGAMOUNT=None, STARTDATE=None, ENDDATE=None, EDCCDECISION=None, NOTIFICATIONLANGUAGE=None, HASH=None, LEVEL_2_DATA=None, LEVEL_3_DATA=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF
        self.validate_SECURECARDMERCHANTREF(self.SECURECARDMERCHANTREF)
        self.CARDREFERENCE = CARDREFERENCE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.NAME = NAME
        self.validate_NAME(self.NAME)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.LENGTH = LENGTH
        self.SKIPPERIODCOUNT = SKIPPERIODCOUNT
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.STARTDATE = STARTDATE
        self.validate_STARTDATE(self.STARTDATE)
        self.ENDDATE = ENDDATE
        self.validate_ENDDATE(self.ENDDATE)
        self.EDCCDECISION = EDCCDECISION
        self.validate_EDCCDECISION(self.EDCCDECISION)
        self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
        self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.LEVEL_2_DATA = LEVEL_2_DATA
        self.LEVEL_3_DATA = LEVEL_3_DATA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATESUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATESUBSCRIPTION.subclass:
            return UPDATESUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return UPDATESUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_SECURECARDMERCHANTREF(self): return self.SECURECARDMERCHANTREF
    def set_SECURECARDMERCHANTREF(self, SECURECARDMERCHANTREF): self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF
    def get_CARDREFERENCE(self): return self.CARDREFERENCE
    def set_CARDREFERENCE(self, CARDREFERENCE): self.CARDREFERENCE = CARDREFERENCE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_LENGTH(self): return self.LENGTH
    def set_LENGTH(self, LENGTH): self.LENGTH = LENGTH
    def get_SKIPPERIODCOUNT(self): return self.SKIPPERIODCOUNT
    def set_SKIPPERIODCOUNT(self, SKIPPERIODCOUNT): self.SKIPPERIODCOUNT = SKIPPERIODCOUNT
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_STARTDATE(self): return self.STARTDATE
    def set_STARTDATE(self, STARTDATE): self.STARTDATE = STARTDATE
    def get_ENDDATE(self): return self.ENDDATE
    def set_ENDDATE(self, ENDDATE): self.ENDDATE = ENDDATE
    def get_EDCCDECISION(self): return self.EDCCDECISION
    def set_EDCCDECISION(self, EDCCDECISION): self.EDCCDECISION = EDCCDECISION
    def get_NOTIFICATIONLANGUAGE(self): return self.NOTIFICATIONLANGUAGE
    def set_NOTIFICATIONLANGUAGE(self, NOTIFICATIONLANGUAGE): self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_LEVEL_2_DATA(self): return self.LEVEL_2_DATA
    def set_LEVEL_2_DATA(self, LEVEL_2_DATA): self.LEVEL_2_DATA = LEVEL_2_DATA
    def get_LEVEL_3_DATA(self): return self.LEVEL_3_DATA
    def set_LEVEL_3_DATA(self, LEVEL_3_DATA): self.LEVEL_3_DATA = LEVEL_3_DATA
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_SECURECARDMERCHANTREF(self, value):
        # Validate type SECURECARDMERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_NAME(self, value):
        # Validate type NAME, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_STARTDATE(self, value):
        # Validate type STARTDATE, a restriction on xs:string.
        pass
    def validate_ENDDATE(self, value):
        # Validate type ENDDATE, a restriction on xs:string.
        pass
    def validate_EDCCDECISION(self, value):
        # Validate type EDCCDECISION, a restriction on xs:string.
        pass
    def validate_NOTIFICATIONLANGUAGE(self, value):
        # Validate type NOTIFICATIONLANGUAGE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.SECURECARDMERCHANTREF is not None or
            self.CARDREFERENCE is not None or
            self.DATETIME is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.LENGTH is not None or
            self.SKIPPERIODCOUNT is not None or
            self.RECURRINGAMOUNT is not None or
            self.STARTDATE is not None or
            self.ENDDATE is not None or
            self.EDCCDECISION is not None or
            self.NOTIFICATIONLANGUAGE is not None or
            self.HASH is not None or
            self.LEVEL_2_DATA is not None or
            self.LEVEL_3_DATA is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATESUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.SECURECARDMERCHANTREF is not None:
            SECURECARDMERCHANTREF_ = self.SECURECARDMERCHANTREF
            etree_.SubElement(element, '{}SECURECARDMERCHANTREF').text = self.gds_format_string(SECURECARDMERCHANTREF_)
        if self.CARDREFERENCE is not None:
            CARDREFERENCE_ = self.CARDREFERENCE
            etree_.SubElement(element, '{}CARDREFERENCE').text = self.gds_format_string(CARDREFERENCE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.LENGTH is not None:
            LENGTH_ = self.LENGTH
            etree_.SubElement(element, '{}LENGTH').text = self.gds_format_integer(LENGTH_)
        if self.SKIPPERIODCOUNT is not None:
            SKIPPERIODCOUNT_ = self.SKIPPERIODCOUNT
            etree_.SubElement(element, '{}SKIPPERIODCOUNT').text = self.gds_format_integer(SKIPPERIODCOUNT_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.STARTDATE is not None:
            STARTDATE_ = self.STARTDATE
            etree_.SubElement(element, '{}STARTDATE').text = self.gds_format_string(STARTDATE_)
        if self.ENDDATE is not None:
            ENDDATE_ = self.ENDDATE
            etree_.SubElement(element, '{}ENDDATE').text = self.gds_format_string(ENDDATE_)
        if self.EDCCDECISION is not None:
            EDCCDECISION_ = self.EDCCDECISION
            etree_.SubElement(element, '{}EDCCDECISION').text = self.gds_format_string(EDCCDECISION_)
        if self.NOTIFICATIONLANGUAGE is not None:
            NOTIFICATIONLANGUAGE_ = self.NOTIFICATIONLANGUAGE
            etree_.SubElement(element, '{}NOTIFICATIONLANGUAGE').text = self.gds_format_string(NOTIFICATIONLANGUAGE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.LEVEL_2_DATA is not None:
            LEVEL_2_DATA_ = self.LEVEL_2_DATA
            LEVEL_2_DATA_.to_etree(element, name_='LEVEL_2_DATA', mapping_=mapping_)
        if self.LEVEL_3_DATA is not None:
            LEVEL_3_DATA_ = self.LEVEL_3_DATA
            LEVEL_3_DATA_.to_etree(element, name_='LEVEL_3_DATA', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATESUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.SECURECARDMERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('SECURECARDMERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.SECURECARDMERCHANTREF)))
        if self.CARDREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('CARDREFERENCE=%s,\n' % self.gds_encode(quote_python(self.CARDREFERENCE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('LENGTH=%d,\n' % self.LENGTH)
        if self.SKIPPERIODCOUNT is not None:
            showIndent(outfile, level)
            outfile.write('SKIPPERIODCOUNT=%d,\n' % self.SKIPPERIODCOUNT)
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.STARTDATE is not None:
            showIndent(outfile, level)
            outfile.write('STARTDATE=%s,\n' % self.gds_encode(quote_python(self.STARTDATE)))
        if self.ENDDATE is not None:
            showIndent(outfile, level)
            outfile.write('ENDDATE=%s,\n' % self.gds_encode(quote_python(self.ENDDATE)))
        if self.EDCCDECISION is not None:
            showIndent(outfile, level)
            outfile.write('EDCCDECISION=%s,\n' % self.gds_encode(quote_python(self.EDCCDECISION)))
        if self.NOTIFICATIONLANGUAGE is not None:
            showIndent(outfile, level)
            outfile.write('NOTIFICATIONLANGUAGE=%s,\n' % self.gds_encode(quote_python(self.NOTIFICATIONLANGUAGE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.LEVEL_2_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_2_DATA=model_.LEVEL_2_DATA(\n')
            self.LEVEL_2_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LEVEL_3_DATA is not None:
            showIndent(outfile, level)
            outfile.write('LEVEL_3_DATA=model_.LEVEL_3_DATA(\n')
            self.LEVEL_3_DATA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'SECURECARDMERCHANTREF':
            SECURECARDMERCHANTREF_ = child_.text
            SECURECARDMERCHANTREF_ = self.gds_validate_string(SECURECARDMERCHANTREF_, node, 'SECURECARDMERCHANTREF')
            self.SECURECARDMERCHANTREF = SECURECARDMERCHANTREF_
            # validate type SECURECARDMERCHANTREF
            self.validate_SECURECARDMERCHANTREF(self.SECURECARDMERCHANTREF)
        elif nodeName_ == 'CARDREFERENCE':
            CARDREFERENCE_ = child_.text
            CARDREFERENCE_ = self.gds_validate_string(CARDREFERENCE_, node, 'CARDREFERENCE')
            self.CARDREFERENCE = CARDREFERENCE_
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
            # validate type NAME
            self.validate_NAME(self.NAME)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'LENGTH' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LENGTH')
            self.LENGTH = ival_
        elif nodeName_ == 'SKIPPERIODCOUNT' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SKIPPERIODCOUNT')
            self.SKIPPERIODCOUNT = ival_
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'STARTDATE':
            STARTDATE_ = child_.text
            STARTDATE_ = self.gds_validate_string(STARTDATE_, node, 'STARTDATE')
            self.STARTDATE = STARTDATE_
            # validate type STARTDATE
            self.validate_STARTDATE(self.STARTDATE)
        elif nodeName_ == 'ENDDATE':
            ENDDATE_ = child_.text
            ENDDATE_ = self.gds_validate_string(ENDDATE_, node, 'ENDDATE')
            self.ENDDATE = ENDDATE_
            # validate type ENDDATE
            self.validate_ENDDATE(self.ENDDATE)
        elif nodeName_ == 'EDCCDECISION':
            EDCCDECISION_ = child_.text
            EDCCDECISION_ = self.gds_validate_string(EDCCDECISION_, node, 'EDCCDECISION')
            self.EDCCDECISION = EDCCDECISION_
            # validate type EDCCDECISION
            self.validate_EDCCDECISION(self.EDCCDECISION)
        elif nodeName_ == 'NOTIFICATIONLANGUAGE':
            NOTIFICATIONLANGUAGE_ = child_.text
            NOTIFICATIONLANGUAGE_ = self.gds_validate_string(NOTIFICATIONLANGUAGE_, node, 'NOTIFICATIONLANGUAGE')
            self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE_
            # validate type NOTIFICATIONLANGUAGE
            self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'LEVEL_2_DATA':
            obj_ = LEVEL_2_DATA.factory()
            obj_.build(child_)
            self.LEVEL_2_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_2_DATA'
        elif nodeName_ == 'LEVEL_3_DATA':
            obj_ = LEVEL_3_DATA.factory()
            obj_.build(child_)
            self.LEVEL_3_DATA = obj_
            obj_.original_tagname_ = 'LEVEL_3_DATA'
    def sample_method(self):
        pass
# end class UPDATESUBSCRIPTION


class UPDATESUBSCRIPTIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATESUBSCRIPTIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATESUBSCRIPTIONRESPONSE.subclass:
            return UPDATESUBSCRIPTIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return UPDATESUBSCRIPTIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATESUBSCRIPTIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATESUBSCRIPTIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class UPDATESUBSCRIPTIONRESPONSE


class SUBSCRIPTIONREF(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUBSCRIPTIONREF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUBSCRIPTIONREF.subclass:
            return SUBSCRIPTIONREF.subclass(*args_, **kwargs_)
        else:
            return SUBSCRIPTIONREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SUBSCRIPTIONREF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SUBSCRIPTIONREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class SUBSCRIPTIONREF


class NOTIFICATIONLANGUAGE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NOTIFICATIONLANGUAGE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NOTIFICATIONLANGUAGE.subclass:
            return NOTIFICATIONLANGUAGE.subclass(*args_, **kwargs_)
        else:
            return NOTIFICATIONLANGUAGE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='NOTIFICATIONLANGUAGE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NOTIFICATIONLANGUAGE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class NOTIFICATIONLANGUAGE


class SUBSCRIPTIONPAYMENT(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('SUBSCRIPTIONREF', ['SUBSCRIPTIONREF', 'xs:string'], 0, 0, {'ref': 'SUBSCRIPTIONREF', 'name': 'SUBSCRIPTIONREF', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, AMOUNT=None, SUBSCRIPTIONREF=None, DESCRIPTION=None, EMAIL=None, DATETIME=None, HASH=None, CREDENTIALONFILE=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.SUBSCRIPTIONREF = SUBSCRIPTIONREF
        self.validate_SUBSCRIPTIONREF(self.SUBSCRIPTIONREF)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
        self.CREDENTIALONFILE = CREDENTIALONFILE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUBSCRIPTIONPAYMENT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUBSCRIPTIONPAYMENT.subclass:
            return SUBSCRIPTIONPAYMENT.subclass(*args_, **kwargs_)
        else:
            return SUBSCRIPTIONPAYMENT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_SUBSCRIPTIONREF(self): return self.SUBSCRIPTIONREF
    def set_SUBSCRIPTIONREF(self, SUBSCRIPTIONREF): self.SUBSCRIPTIONREF = SUBSCRIPTIONREF
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_SUBSCRIPTIONREF(self, value):
        # Validate type SUBSCRIPTIONREF, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.SUBSCRIPTIONREF is not None or
            self.DESCRIPTION is not None or
            self.EMAIL is not None or
            self.DATETIME is not None or
            self.HASH is not None or
            self.CREDENTIALONFILE is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SUBSCRIPTIONPAYMENT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.SUBSCRIPTIONREF is not None:
            SUBSCRIPTIONREF_ = self.SUBSCRIPTIONREF
            etree_.SubElement(element, '{}SUBSCRIPTIONREF').text = self.gds_format_string(SUBSCRIPTIONREF_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SUBSCRIPTIONPAYMENT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.SUBSCRIPTIONREF is not None:
            showIndent(outfile, level)
            outfile.write('SUBSCRIPTIONREF=%s,\n' % self.gds_encode(quote_python(self.SUBSCRIPTIONREF)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'SUBSCRIPTIONREF':
            SUBSCRIPTIONREF_ = child_.text
            SUBSCRIPTIONREF_ = self.gds_validate_string(SUBSCRIPTIONREF_, node, 'SUBSCRIPTIONREF')
            self.SUBSCRIPTIONREF = SUBSCRIPTIONREF_
            # validate type SUBSCRIPTIONREF
            self.validate_SUBSCRIPTIONREF(self.SUBSCRIPTIONREF)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
    def sample_method(self):
        pass
# end class SUBSCRIPTIONPAYMENT


class SUBSCRIPTIONPAYMENTRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('CREDENTIALONFILE', 'CREDENTIALONFILE', 0, 1, {'ref': 'CREDENTIALONFILE', 'minOccurs': '0', 'name': 'CREDENTIALONFILE', 'type': 'CREDENTIALONFILE'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, APPROVALCODE=None, CREDENTIALONFILE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.CREDENTIALONFILE = CREDENTIALONFILE
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUBSCRIPTIONPAYMENTRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUBSCRIPTIONPAYMENTRESPONSE.subclass:
            return SUBSCRIPTIONPAYMENTRESPONSE.subclass(*args_, **kwargs_)
        else:
            return SUBSCRIPTIONPAYMENTRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_CREDENTIALONFILE(self): return self.CREDENTIALONFILE
    def set_CREDENTIALONFILE(self, CREDENTIALONFILE): self.CREDENTIALONFILE = CREDENTIALONFILE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.APPROVALCODE is not None or
            self.CREDENTIALONFILE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SUBSCRIPTIONPAYMENTRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.CREDENTIALONFILE is not None:
            CREDENTIALONFILE_ = self.CREDENTIALONFILE
            CREDENTIALONFILE_.to_etree(element, name_='CREDENTIALONFILE', mapping_=mapping_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SUBSCRIPTIONPAYMENTRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.CREDENTIALONFILE is not None:
            showIndent(outfile, level)
            outfile.write('CREDENTIALONFILE=model_.CREDENTIALONFILE(\n')
            self.CREDENTIALONFILE.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'CREDENTIALONFILE':
            obj_ = CREDENTIALONFILE.factory()
            obj_.build(child_)
            self.CREDENTIALONFILE = obj_
            obj_.original_tagname_ = 'CREDENTIALONFILE'
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class SUBSCRIPTIONPAYMENTRESPONSE


class CARDDETAILS(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('CARDTYPE', ['CARDTYPE', 'xs:string'], 0, 0, {'ref': 'CARDTYPE', 'name': 'CARDTYPE', 'type': 'xs:string'}, None),
        MemberSpec_('CARDNUMBER', ['CARDNUMBER', 'xs:string'], 0, 0, {'ref': 'CARDNUMBER', 'name': 'CARDNUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('CARDEXPIRY', ['CARDEXPIRY', 'xs:string'], 0, 0, {'ref': 'CARDEXPIRY', 'name': 'CARDEXPIRY', 'type': 'xs:string'}, None),
        MemberSpec_('CARDHOLDERNAME', ['CARDHOLDERNAME', 'xs:string'], 0, 1, {'ref': 'CARDHOLDERNAME', 'minOccurs': '0', 'name': 'CARDHOLDERNAME', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CARDTYPE=None, CARDNUMBER=None, CARDEXPIRY=None, CARDHOLDERNAME=None):
        self.original_tagname_ = None
        self.CARDTYPE = CARDTYPE
        self.validate_CARDTYPE(self.CARDTYPE)
        self.CARDNUMBER = CARDNUMBER
        self.validate_CARDNUMBER(self.CARDNUMBER)
        self.CARDEXPIRY = CARDEXPIRY
        self.validate_CARDEXPIRY(self.CARDEXPIRY)
        self.CARDHOLDERNAME = CARDHOLDERNAME
        self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CARDDETAILS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CARDDETAILS.subclass:
            return CARDDETAILS.subclass(*args_, **kwargs_)
        else:
            return CARDDETAILS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CARDTYPE(self): return self.CARDTYPE
    def set_CARDTYPE(self, CARDTYPE): self.CARDTYPE = CARDTYPE
    def get_CARDNUMBER(self): return self.CARDNUMBER
    def set_CARDNUMBER(self, CARDNUMBER): self.CARDNUMBER = CARDNUMBER
    def get_CARDEXPIRY(self): return self.CARDEXPIRY
    def set_CARDEXPIRY(self, CARDEXPIRY): self.CARDEXPIRY = CARDEXPIRY
    def get_CARDHOLDERNAME(self): return self.CARDHOLDERNAME
    def set_CARDHOLDERNAME(self, CARDHOLDERNAME): self.CARDHOLDERNAME = CARDHOLDERNAME
    def validate_CARDTYPE(self, value):
        # Validate type CARDTYPE, a restriction on xs:string.
        pass
    def validate_CARDNUMBER(self, value):
        # Validate type CARDNUMBER, a restriction on xs:string.
        pass
    def validate_CARDEXPIRY(self, value):
        # Validate type CARDEXPIRY, a restriction on xs:string.
        pass
    def validate_CARDHOLDERNAME(self, value):
        # Validate type CARDHOLDERNAME, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.CARDTYPE is not None or
            self.CARDNUMBER is not None or
            self.CARDEXPIRY is not None or
            self.CARDHOLDERNAME is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CARDDETAILS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.CARDTYPE is not None:
            CARDTYPE_ = self.CARDTYPE
            etree_.SubElement(element, '{}CARDTYPE').text = self.gds_format_string(CARDTYPE_)
        if self.CARDNUMBER is not None:
            CARDNUMBER_ = self.CARDNUMBER
            etree_.SubElement(element, '{}CARDNUMBER').text = self.gds_format_string(CARDNUMBER_)
        if self.CARDEXPIRY is not None:
            CARDEXPIRY_ = self.CARDEXPIRY
            etree_.SubElement(element, '{}CARDEXPIRY').text = self.gds_format_string(CARDEXPIRY_)
        if self.CARDHOLDERNAME is not None:
            CARDHOLDERNAME_ = self.CARDHOLDERNAME
            etree_.SubElement(element, '{}CARDHOLDERNAME').text = self.gds_format_string(CARDHOLDERNAME_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CARDDETAILS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CARDTYPE is not None:
            showIndent(outfile, level)
            outfile.write('CARDTYPE=%s,\n' % self.gds_encode(quote_python(self.CARDTYPE)))
        if self.CARDNUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CARDNUMBER=%s,\n' % self.gds_encode(quote_python(self.CARDNUMBER)))
        if self.CARDEXPIRY is not None:
            showIndent(outfile, level)
            outfile.write('CARDEXPIRY=%s,\n' % self.gds_encode(quote_python(self.CARDEXPIRY)))
        if self.CARDHOLDERNAME is not None:
            showIndent(outfile, level)
            outfile.write('CARDHOLDERNAME=%s,\n' % self.gds_encode(quote_python(self.CARDHOLDERNAME)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CARDTYPE':
            CARDTYPE_ = child_.text
            CARDTYPE_ = self.gds_validate_string(CARDTYPE_, node, 'CARDTYPE')
            self.CARDTYPE = CARDTYPE_
            # validate type CARDTYPE
            self.validate_CARDTYPE(self.CARDTYPE)
        elif nodeName_ == 'CARDNUMBER':
            CARDNUMBER_ = child_.text
            CARDNUMBER_ = self.gds_validate_string(CARDNUMBER_, node, 'CARDNUMBER')
            self.CARDNUMBER = CARDNUMBER_
            # validate type CARDNUMBER
            self.validate_CARDNUMBER(self.CARDNUMBER)
        elif nodeName_ == 'CARDEXPIRY':
            CARDEXPIRY_ = child_.text
            CARDEXPIRY_ = self.gds_validate_string(CARDEXPIRY_, node, 'CARDEXPIRY')
            self.CARDEXPIRY = CARDEXPIRY_
            # validate type CARDEXPIRY
            self.validate_CARDEXPIRY(self.CARDEXPIRY)
        elif nodeName_ == 'CARDHOLDERNAME':
            CARDHOLDERNAME_ = child_.text
            CARDHOLDERNAME_ = self.gds_validate_string(CARDHOLDERNAME_, node, 'CARDHOLDERNAME')
            self.CARDHOLDERNAME = CARDHOLDERNAME_
            # validate type CARDHOLDERNAME
            self.validate_CARDHOLDERNAME(self.CARDHOLDERNAME)
    def sample_method(self):
        pass
# end class CARDDETAILS


class PROCESSINGTERMINAL(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PROCESSINGTERMINAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PROCESSINGTERMINAL.subclass:
            return PROCESSINGTERMINAL.subclass(*args_, **kwargs_)
        else:
            return PROCESSINGTERMINAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PROCESSINGTERMINAL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PROCESSINGTERMINAL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class PROCESSINGTERMINAL


class ACH_ACCOUNT(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_ACCOUNT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_ACCOUNT.subclass:
            return ACH_ACCOUNT.subclass(*args_, **kwargs_)
        else:
            return ACH_ACCOUNT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_ACCOUNT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_ACCOUNT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_ACCOUNT


class ACH_ACCOUNT_TYPE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_ACCOUNT_TYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_ACCOUNT_TYPE.subclass:
            return ACH_ACCOUNT_TYPE.subclass(*args_, **kwargs_)
        else:
            return ACH_ACCOUNT_TYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_ACCOUNT_TYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_ACCOUNT_TYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_ACCOUNT_TYPE


class ACH_FIRST_NAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_FIRST_NAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_FIRST_NAME.subclass:
            return ACH_FIRST_NAME.subclass(*args_, **kwargs_)
        else:
            return ACH_FIRST_NAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_FIRST_NAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_FIRST_NAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_FIRST_NAME


class ACH_LAST_NAME(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_LAST_NAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_LAST_NAME.subclass:
            return ACH_LAST_NAME.subclass(*args_, **kwargs_)
        else:
            return ACH_LAST_NAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_LAST_NAME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_LAST_NAME'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_LAST_NAME


class ACH_ADDRESS1(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_ADDRESS1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_ADDRESS1.subclass:
            return ACH_ADDRESS1.subclass(*args_, **kwargs_)
        else:
            return ACH_ADDRESS1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_ADDRESS1', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_ADDRESS1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_ADDRESS1


class ACH_ADDRESS2(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_ADDRESS2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_ADDRESS2.subclass:
            return ACH_ADDRESS2.subclass(*args_, **kwargs_)
        else:
            return ACH_ADDRESS2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_ADDRESS2', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_ADDRESS2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_ADDRESS2


class ACH_CITY(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_CITY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_CITY.subclass:
            return ACH_CITY.subclass(*args_, **kwargs_)
        else:
            return ACH_CITY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_CITY', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_CITY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_CITY


class ACH_STATE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_STATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_STATE.subclass:
            return ACH_STATE.subclass(*args_, **kwargs_)
        else:
            return ACH_STATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_STATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_STATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_STATE


class ACH_ZIP(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_ZIP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_ZIP.subclass:
            return ACH_ZIP.subclass(*args_, **kwargs_)
        else:
            return ACH_ZIP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_ZIP', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_ZIP'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_ZIP


class ACH_PHONE_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_PHONE_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_PHONE_NUMBER.subclass:
            return ACH_PHONE_NUMBER.subclass(*args_, **kwargs_)
        else:
            return ACH_PHONE_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_PHONE_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_PHONE_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_PHONE_NUMBER


class ACHREFERENCE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHREFERENCE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHREFERENCE.subclass:
            return ACHREFERENCE.subclass(*args_, **kwargs_)
        else:
            return ACHREFERENCE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHREFERENCE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHREFERENCE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACHREFERENCE


class ACH_SECURE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_SECURE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_SECURE.subclass:
            return ACH_SECURE.subclass(*args_, **kwargs_)
        else:
            return ACH_SECURE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_SECURE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_SECURE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_SECURE


class ACH_SEC_CODE(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_SEC_CODE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_SEC_CODE.subclass:
            return ACH_SEC_CODE.subclass(*args_, **kwargs_)
        else:
            return ACH_SEC_CODE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_SEC_CODE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_SEC_CODE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_SEC_CODE


class ACH_TERMINALID(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_TERMINALID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_TERMINALID.subclass:
            return ACH_TERMINALID.subclass(*args_, **kwargs_)
        else:
            return ACH_TERMINALID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_TERMINALID', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_TERMINALID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_TERMINALID


class ACH_CHECK_NUMBER(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_CHECK_NUMBER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_CHECK_NUMBER.subclass:
            return ACH_CHECK_NUMBER.subclass(*args_, **kwargs_)
        else:
            return ACH_CHECK_NUMBER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_CHECK_NUMBER', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_CHECK_NUMBER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_CHECK_NUMBER


class ACH_NOTIFICATION_URL(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_NOTIFICATION_URL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_NOTIFICATION_URL.subclass:
            return ACH_NOTIFICATION_URL.subclass(*args_, **kwargs_)
        else:
            return ACH_NOTIFICATION_URL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_NOTIFICATION_URL', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_NOTIFICATION_URL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def sample_method(self):
        pass
# end class ACH_NOTIFICATION_URL


class ACHSECUREREGISTRATION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_TYPE', ['ACCOUNT_TYPE', 'xs:string'], 0, 0, {'ref': 'ACCOUNT_TYPE', 'name': 'ACCOUNT_TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NUMBER', ['ACCOUNT_NUMBER', 'xs:string'], 0, 0, {'ref': 'ACCOUNT_NUMBER', 'name': 'ACCOUNT_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ROUTING_NUMBER', ['ROUTING_NUMBER', 'xs:string'], 0, 0, {'ref': 'ROUTING_NUMBER', 'name': 'ROUTING_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NAME', ['ACCOUNT_NAME', 'xs:string'], 0, 0, {'ref': 'ACCOUNT_NAME', 'name': 'ACCOUNT_NAME', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('IPADDRESS', ['IPADDRESS', 'xs:string'], 0, 1, {'ref': 'IPADDRESS', 'minOccurs': '0', 'name': 'IPADDRESS', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('DL_STATE', ['DL_STATE', 'xs:string'], 0, 1, {'ref': 'DL_STATE', 'minOccurs': '0', 'name': 'DL_STATE', 'type': 'xs:string'}, None),
        MemberSpec_('DL_NUMBER', ['DL_NUMBER', 'xs:string'], 0, 1, {'ref': 'DL_NUMBER', 'minOccurs': '0', 'name': 'DL_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, ACCOUNT_TYPE=None, ACCOUNT_NUMBER=None, ROUTING_NUMBER=None, ACCOUNT_NAME=None, ADDRESS1=None, ADDRESS2=None, CITY=None, REGION=None, POSTCODE=None, COUNTRY=None, PHONE=None, IPADDRESS=None, EMAIL=None, DL_STATE=None, DL_NUMBER=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.ACCOUNT_TYPE = ACCOUNT_TYPE
        self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
        self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        self.ROUTING_NUMBER = ROUTING_NUMBER
        self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        self.ACCOUNT_NAME = ACCOUNT_NAME
        self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.IPADDRESS = IPADDRESS
        self.validate_IPADDRESS(self.IPADDRESS)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.DL_STATE = DL_STATE
        self.validate_DL_STATE(self.DL_STATE)
        self.DL_NUMBER = DL_NUMBER
        self.validate_DL_NUMBER(self.DL_NUMBER)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECUREREGISTRATION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECUREREGISTRATION.subclass:
            return ACHSECUREREGISTRATION.subclass(*args_, **kwargs_)
        else:
            return ACHSECUREREGISTRATION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_ACCOUNT_TYPE(self): return self.ACCOUNT_TYPE
    def set_ACCOUNT_TYPE(self, ACCOUNT_TYPE): self.ACCOUNT_TYPE = ACCOUNT_TYPE
    def get_ACCOUNT_NUMBER(self): return self.ACCOUNT_NUMBER
    def set_ACCOUNT_NUMBER(self, ACCOUNT_NUMBER): self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
    def get_ROUTING_NUMBER(self): return self.ROUTING_NUMBER
    def set_ROUTING_NUMBER(self, ROUTING_NUMBER): self.ROUTING_NUMBER = ROUTING_NUMBER
    def get_ACCOUNT_NAME(self): return self.ACCOUNT_NAME
    def set_ACCOUNT_NAME(self, ACCOUNT_NAME): self.ACCOUNT_NAME = ACCOUNT_NAME
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_IPADDRESS(self): return self.IPADDRESS
    def set_IPADDRESS(self, IPADDRESS): self.IPADDRESS = IPADDRESS
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_DL_STATE(self): return self.DL_STATE
    def set_DL_STATE(self, DL_STATE): self.DL_STATE = DL_STATE
    def get_DL_NUMBER(self): return self.DL_NUMBER
    def set_DL_NUMBER(self, DL_NUMBER): self.DL_NUMBER = DL_NUMBER
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_ACCOUNT_TYPE(self, value):
        # Validate type ACCOUNT_TYPE, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NUMBER(self, value):
        # Validate type ACCOUNT_NUMBER, a restriction on xs:string.
        pass
    def validate_ROUTING_NUMBER(self, value):
        # Validate type ROUTING_NUMBER, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NAME(self, value):
        # Validate type ACCOUNT_NAME, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_IPADDRESS(self, value):
        # Validate type IPADDRESS, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_DL_STATE(self, value):
        # Validate type DL_STATE, a restriction on xs:string.
        pass
    def validate_DL_NUMBER(self, value):
        # Validate type DL_NUMBER, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.ACCOUNT_TYPE is not None or
            self.ACCOUNT_NUMBER is not None or
            self.ROUTING_NUMBER is not None or
            self.ACCOUNT_NAME is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.POSTCODE is not None or
            self.COUNTRY is not None or
            self.PHONE is not None or
            self.IPADDRESS is not None or
            self.EMAIL is not None or
            self.DL_STATE is not None or
            self.DL_NUMBER is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECUREREGISTRATION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.ACCOUNT_TYPE is not None:
            ACCOUNT_TYPE_ = self.ACCOUNT_TYPE
            etree_.SubElement(element, '{}ACCOUNT_TYPE').text = self.gds_format_string(ACCOUNT_TYPE_)
        if self.ACCOUNT_NUMBER is not None:
            ACCOUNT_NUMBER_ = self.ACCOUNT_NUMBER
            etree_.SubElement(element, '{}ACCOUNT_NUMBER').text = self.gds_format_string(ACCOUNT_NUMBER_)
        if self.ROUTING_NUMBER is not None:
            ROUTING_NUMBER_ = self.ROUTING_NUMBER
            etree_.SubElement(element, '{}ROUTING_NUMBER').text = self.gds_format_string(ROUTING_NUMBER_)
        if self.ACCOUNT_NAME is not None:
            ACCOUNT_NAME_ = self.ACCOUNT_NAME
            etree_.SubElement(element, '{}ACCOUNT_NAME').text = self.gds_format_string(ACCOUNT_NAME_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.IPADDRESS is not None:
            IPADDRESS_ = self.IPADDRESS
            etree_.SubElement(element, '{}IPADDRESS').text = self.gds_format_string(IPADDRESS_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.DL_STATE is not None:
            DL_STATE_ = self.DL_STATE
            etree_.SubElement(element, '{}DL_STATE').text = self.gds_format_string(DL_STATE_)
        if self.DL_NUMBER is not None:
            DL_NUMBER_ = self.DL_NUMBER
            etree_.SubElement(element, '{}DL_NUMBER').text = self.gds_format_string(DL_NUMBER_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECUREREGISTRATION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.ACCOUNT_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_TYPE=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_TYPE)))
        if self.ACCOUNT_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NUMBER)))
        if self.ROUTING_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ROUTING_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ROUTING_NUMBER)))
        if self.ACCOUNT_NAME is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NAME=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NAME)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.IPADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('IPADDRESS=%s,\n' % self.gds_encode(quote_python(self.IPADDRESS)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.DL_STATE is not None:
            showIndent(outfile, level)
            outfile.write('DL_STATE=%s,\n' % self.gds_encode(quote_python(self.DL_STATE)))
        if self.DL_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('DL_NUMBER=%s,\n' % self.gds_encode(quote_python(self.DL_NUMBER)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'ACCOUNT_TYPE':
            ACCOUNT_TYPE_ = child_.text
            ACCOUNT_TYPE_ = self.gds_validate_string(ACCOUNT_TYPE_, node, 'ACCOUNT_TYPE')
            self.ACCOUNT_TYPE = ACCOUNT_TYPE_
            # validate type ACCOUNT_TYPE
            self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        elif nodeName_ == 'ACCOUNT_NUMBER':
            ACCOUNT_NUMBER_ = child_.text
            ACCOUNT_NUMBER_ = self.gds_validate_string(ACCOUNT_NUMBER_, node, 'ACCOUNT_NUMBER')
            self.ACCOUNT_NUMBER = ACCOUNT_NUMBER_
            # validate type ACCOUNT_NUMBER
            self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        elif nodeName_ == 'ROUTING_NUMBER':
            ROUTING_NUMBER_ = child_.text
            ROUTING_NUMBER_ = self.gds_validate_string(ROUTING_NUMBER_, node, 'ROUTING_NUMBER')
            self.ROUTING_NUMBER = ROUTING_NUMBER_
            # validate type ROUTING_NUMBER
            self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        elif nodeName_ == 'ACCOUNT_NAME':
            ACCOUNT_NAME_ = child_.text
            ACCOUNT_NAME_ = self.gds_validate_string(ACCOUNT_NAME_, node, 'ACCOUNT_NAME')
            self.ACCOUNT_NAME = ACCOUNT_NAME_
            # validate type ACCOUNT_NAME
            self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'IPADDRESS':
            IPADDRESS_ = child_.text
            IPADDRESS_ = self.gds_validate_string(IPADDRESS_, node, 'IPADDRESS')
            self.IPADDRESS = IPADDRESS_
            # validate type IPADDRESS
            self.validate_IPADDRESS(self.IPADDRESS)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'DL_STATE':
            DL_STATE_ = child_.text
            DL_STATE_ = self.gds_validate_string(DL_STATE_, node, 'DL_STATE')
            self.DL_STATE = DL_STATE_
            # validate type DL_STATE
            self.validate_DL_STATE(self.DL_STATE)
        elif nodeName_ == 'DL_NUMBER':
            DL_NUMBER_ = child_.text
            DL_NUMBER_ = self.gds_validate_string(DL_NUMBER_, node, 'DL_NUMBER')
            self.DL_NUMBER = DL_NUMBER_
            # validate type DL_NUMBER
            self.validate_DL_NUMBER(self.DL_NUMBER)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class ACHSECUREREGISTRATION


class ACHSECUREREGISTRATIONRESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ACHREFERENCE', ['ACHREFERENCE', 'xs:string'], 0, 0, {'ref': 'ACHREFERENCE', 'name': 'ACHREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, ACHREFERENCE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.ACHREFERENCE = ACHREFERENCE
        self.validate_ACHREFERENCE(self.ACHREFERENCE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECUREREGISTRATIONRESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECUREREGISTRATIONRESPONSE.subclass:
            return ACHSECUREREGISTRATIONRESPONSE.subclass(*args_, **kwargs_)
        else:
            return ACHSECUREREGISTRATIONRESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_ACHREFERENCE(self): return self.ACHREFERENCE
    def set_ACHREFERENCE(self, ACHREFERENCE): self.ACHREFERENCE = ACHREFERENCE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_ACHREFERENCE(self, value):
        # Validate type ACHREFERENCE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.ACHREFERENCE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECUREREGISTRATIONRESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.ACHREFERENCE is not None:
            ACHREFERENCE_ = self.ACHREFERENCE
            etree_.SubElement(element, '{}ACHREFERENCE').text = self.gds_format_string(ACHREFERENCE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECUREREGISTRATIONRESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.ACHREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('ACHREFERENCE=%s,\n' % self.gds_encode(quote_python(self.ACHREFERENCE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'ACHREFERENCE':
            ACHREFERENCE_ = child_.text
            ACHREFERENCE_ = self.gds_validate_string(ACHREFERENCE_, node, 'ACHREFERENCE')
            self.ACHREFERENCE = ACHREFERENCE_
            # validate type ACHREFERENCE
            self.validate_ACHREFERENCE(self.ACHREFERENCE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class ACHSECUREREGISTRATIONRESPONSE


class ACHSECUREUPDATE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_TYPE', ['ACCOUNT_TYPE', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_TYPE', 'minOccurs': '0', 'name': 'ACCOUNT_TYPE', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NUMBER', ['ACCOUNT_NUMBER', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_NUMBER', 'minOccurs': '0', 'name': 'ACCOUNT_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ROUTING_NUMBER', ['ROUTING_NUMBER', 'xs:string'], 0, 1, {'ref': 'ROUTING_NUMBER', 'minOccurs': '0', 'name': 'ROUTING_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('ACCOUNT_NAME', ['ACCOUNT_NAME', 'xs:string'], 0, 1, {'ref': 'ACCOUNT_NAME', 'minOccurs': '0', 'name': 'ACCOUNT_NAME', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
        MemberSpec_('PHONE', ['PHONE', 'xs:string'], 0, 1, {'ref': 'PHONE', 'minOccurs': '0', 'name': 'PHONE', 'type': 'xs:string'}, None),
        MemberSpec_('IPADDRESS', ['IPADDRESS', 'xs:string'], 0, 1, {'ref': 'IPADDRESS', 'minOccurs': '0', 'name': 'IPADDRESS', 'type': 'xs:string'}, None),
        MemberSpec_('EMAIL', ['EMAIL', 'xs:string'], 0, 1, {'ref': 'EMAIL', 'minOccurs': '0', 'name': 'EMAIL', 'type': 'xs:string'}, None),
        MemberSpec_('DL_STATE', ['DL_STATE', 'xs:string'], 0, 1, {'ref': 'DL_STATE', 'minOccurs': '0', 'name': 'DL_STATE', 'type': 'xs:string'}, None),
        MemberSpec_('DL_NUMBER', ['DL_NUMBER', 'xs:string'], 0, 1, {'ref': 'DL_NUMBER', 'minOccurs': '0', 'name': 'DL_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, DATETIME=None, ACCOUNT_TYPE=None, ACCOUNT_NUMBER=None, ROUTING_NUMBER=None, ACCOUNT_NAME=None, ADDRESS1=None, ADDRESS2=None, CITY=None, REGION=None, POSTCODE=None, COUNTRY=None, PHONE=None, IPADDRESS=None, EMAIL=None, DL_STATE=None, DL_NUMBER=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.ACCOUNT_TYPE = ACCOUNT_TYPE
        self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
        self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        self.ROUTING_NUMBER = ROUTING_NUMBER
        self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        self.ACCOUNT_NAME = ACCOUNT_NAME
        self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
        self.PHONE = PHONE
        self.validate_PHONE(self.PHONE)
        self.IPADDRESS = IPADDRESS
        self.validate_IPADDRESS(self.IPADDRESS)
        self.EMAIL = EMAIL
        self.validate_EMAIL(self.EMAIL)
        self.DL_STATE = DL_STATE
        self.validate_DL_STATE(self.DL_STATE)
        self.DL_NUMBER = DL_NUMBER
        self.validate_DL_NUMBER(self.DL_NUMBER)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECUREUPDATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECUREUPDATE.subclass:
            return ACHSECUREUPDATE.subclass(*args_, **kwargs_)
        else:
            return ACHSECUREUPDATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_ACCOUNT_TYPE(self): return self.ACCOUNT_TYPE
    def set_ACCOUNT_TYPE(self, ACCOUNT_TYPE): self.ACCOUNT_TYPE = ACCOUNT_TYPE
    def get_ACCOUNT_NUMBER(self): return self.ACCOUNT_NUMBER
    def set_ACCOUNT_NUMBER(self, ACCOUNT_NUMBER): self.ACCOUNT_NUMBER = ACCOUNT_NUMBER
    def get_ROUTING_NUMBER(self): return self.ROUTING_NUMBER
    def set_ROUTING_NUMBER(self, ROUTING_NUMBER): self.ROUTING_NUMBER = ROUTING_NUMBER
    def get_ACCOUNT_NAME(self): return self.ACCOUNT_NAME
    def set_ACCOUNT_NAME(self, ACCOUNT_NAME): self.ACCOUNT_NAME = ACCOUNT_NAME
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_PHONE(self): return self.PHONE
    def set_PHONE(self, PHONE): self.PHONE = PHONE
    def get_IPADDRESS(self): return self.IPADDRESS
    def set_IPADDRESS(self, IPADDRESS): self.IPADDRESS = IPADDRESS
    def get_EMAIL(self): return self.EMAIL
    def set_EMAIL(self, EMAIL): self.EMAIL = EMAIL
    def get_DL_STATE(self): return self.DL_STATE
    def set_DL_STATE(self, DL_STATE): self.DL_STATE = DL_STATE
    def get_DL_NUMBER(self): return self.DL_NUMBER
    def set_DL_NUMBER(self, DL_NUMBER): self.DL_NUMBER = DL_NUMBER
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_ACCOUNT_TYPE(self, value):
        # Validate type ACCOUNT_TYPE, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NUMBER(self, value):
        # Validate type ACCOUNT_NUMBER, a restriction on xs:string.
        pass
    def validate_ROUTING_NUMBER(self, value):
        # Validate type ROUTING_NUMBER, a restriction on xs:string.
        pass
    def validate_ACCOUNT_NAME(self, value):
        # Validate type ACCOUNT_NAME, a restriction on xs:string.
        pass
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def validate_PHONE(self, value):
        # Validate type PHONE, a restriction on xs:string.
        pass
    def validate_IPADDRESS(self, value):
        # Validate type IPADDRESS, a restriction on xs:string.
        pass
    def validate_EMAIL(self, value):
        # Validate type EMAIL, a restriction on xs:string.
        pass
    def validate_DL_STATE(self, value):
        # Validate type DL_STATE, a restriction on xs:string.
        pass
    def validate_DL_NUMBER(self, value):
        # Validate type DL_NUMBER, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.DATETIME is not None or
            self.ACCOUNT_TYPE is not None or
            self.ACCOUNT_NUMBER is not None or
            self.ROUTING_NUMBER is not None or
            self.ACCOUNT_NAME is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.POSTCODE is not None or
            self.COUNTRY is not None or
            self.PHONE is not None or
            self.IPADDRESS is not None or
            self.EMAIL is not None or
            self.DL_STATE is not None or
            self.DL_NUMBER is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECUREUPDATE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.ACCOUNT_TYPE is not None:
            ACCOUNT_TYPE_ = self.ACCOUNT_TYPE
            etree_.SubElement(element, '{}ACCOUNT_TYPE').text = self.gds_format_string(ACCOUNT_TYPE_)
        if self.ACCOUNT_NUMBER is not None:
            ACCOUNT_NUMBER_ = self.ACCOUNT_NUMBER
            etree_.SubElement(element, '{}ACCOUNT_NUMBER').text = self.gds_format_string(ACCOUNT_NUMBER_)
        if self.ROUTING_NUMBER is not None:
            ROUTING_NUMBER_ = self.ROUTING_NUMBER
            etree_.SubElement(element, '{}ROUTING_NUMBER').text = self.gds_format_string(ROUTING_NUMBER_)
        if self.ACCOUNT_NAME is not None:
            ACCOUNT_NAME_ = self.ACCOUNT_NAME
            etree_.SubElement(element, '{}ACCOUNT_NAME').text = self.gds_format_string(ACCOUNT_NAME_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if self.PHONE is not None:
            PHONE_ = self.PHONE
            etree_.SubElement(element, '{}PHONE').text = self.gds_format_string(PHONE_)
        if self.IPADDRESS is not None:
            IPADDRESS_ = self.IPADDRESS
            etree_.SubElement(element, '{}IPADDRESS').text = self.gds_format_string(IPADDRESS_)
        if self.EMAIL is not None:
            EMAIL_ = self.EMAIL
            etree_.SubElement(element, '{}EMAIL').text = self.gds_format_string(EMAIL_)
        if self.DL_STATE is not None:
            DL_STATE_ = self.DL_STATE
            etree_.SubElement(element, '{}DL_STATE').text = self.gds_format_string(DL_STATE_)
        if self.DL_NUMBER is not None:
            DL_NUMBER_ = self.DL_NUMBER
            etree_.SubElement(element, '{}DL_NUMBER').text = self.gds_format_string(DL_NUMBER_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECUREUPDATE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.ACCOUNT_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_TYPE=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_TYPE)))
        if self.ACCOUNT_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NUMBER)))
        if self.ROUTING_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('ROUTING_NUMBER=%s,\n' % self.gds_encode(quote_python(self.ROUTING_NUMBER)))
        if self.ACCOUNT_NAME is not None:
            showIndent(outfile, level)
            outfile.write('ACCOUNT_NAME=%s,\n' % self.gds_encode(quote_python(self.ACCOUNT_NAME)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
        if self.PHONE is not None:
            showIndent(outfile, level)
            outfile.write('PHONE=%s,\n' % self.gds_encode(quote_python(self.PHONE)))
        if self.IPADDRESS is not None:
            showIndent(outfile, level)
            outfile.write('IPADDRESS=%s,\n' % self.gds_encode(quote_python(self.IPADDRESS)))
        if self.EMAIL is not None:
            showIndent(outfile, level)
            outfile.write('EMAIL=%s,\n' % self.gds_encode(quote_python(self.EMAIL)))
        if self.DL_STATE is not None:
            showIndent(outfile, level)
            outfile.write('DL_STATE=%s,\n' % self.gds_encode(quote_python(self.DL_STATE)))
        if self.DL_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('DL_NUMBER=%s,\n' % self.gds_encode(quote_python(self.DL_NUMBER)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'ACCOUNT_TYPE':
            ACCOUNT_TYPE_ = child_.text
            ACCOUNT_TYPE_ = self.gds_validate_string(ACCOUNT_TYPE_, node, 'ACCOUNT_TYPE')
            self.ACCOUNT_TYPE = ACCOUNT_TYPE_
            # validate type ACCOUNT_TYPE
            self.validate_ACCOUNT_TYPE(self.ACCOUNT_TYPE)
        elif nodeName_ == 'ACCOUNT_NUMBER':
            ACCOUNT_NUMBER_ = child_.text
            ACCOUNT_NUMBER_ = self.gds_validate_string(ACCOUNT_NUMBER_, node, 'ACCOUNT_NUMBER')
            self.ACCOUNT_NUMBER = ACCOUNT_NUMBER_
            # validate type ACCOUNT_NUMBER
            self.validate_ACCOUNT_NUMBER(self.ACCOUNT_NUMBER)
        elif nodeName_ == 'ROUTING_NUMBER':
            ROUTING_NUMBER_ = child_.text
            ROUTING_NUMBER_ = self.gds_validate_string(ROUTING_NUMBER_, node, 'ROUTING_NUMBER')
            self.ROUTING_NUMBER = ROUTING_NUMBER_
            # validate type ROUTING_NUMBER
            self.validate_ROUTING_NUMBER(self.ROUTING_NUMBER)
        elif nodeName_ == 'ACCOUNT_NAME':
            ACCOUNT_NAME_ = child_.text
            ACCOUNT_NAME_ = self.gds_validate_string(ACCOUNT_NAME_, node, 'ACCOUNT_NAME')
            self.ACCOUNT_NAME = ACCOUNT_NAME_
            # validate type ACCOUNT_NAME
            self.validate_ACCOUNT_NAME(self.ACCOUNT_NAME)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
        elif nodeName_ == 'PHONE':
            PHONE_ = child_.text
            PHONE_ = self.gds_validate_string(PHONE_, node, 'PHONE')
            self.PHONE = PHONE_
            # validate type PHONE
            self.validate_PHONE(self.PHONE)
        elif nodeName_ == 'IPADDRESS':
            IPADDRESS_ = child_.text
            IPADDRESS_ = self.gds_validate_string(IPADDRESS_, node, 'IPADDRESS')
            self.IPADDRESS = IPADDRESS_
            # validate type IPADDRESS
            self.validate_IPADDRESS(self.IPADDRESS)
        elif nodeName_ == 'EMAIL':
            EMAIL_ = child_.text
            EMAIL_ = self.gds_validate_string(EMAIL_, node, 'EMAIL')
            self.EMAIL = EMAIL_
            # validate type EMAIL
            self.validate_EMAIL(self.EMAIL)
        elif nodeName_ == 'DL_STATE':
            DL_STATE_ = child_.text
            DL_STATE_ = self.gds_validate_string(DL_STATE_, node, 'DL_STATE')
            self.DL_STATE = DL_STATE_
            # validate type DL_STATE
            self.validate_DL_STATE(self.DL_STATE)
        elif nodeName_ == 'DL_NUMBER':
            DL_NUMBER_ = child_.text
            DL_NUMBER_ = self.gds_validate_string(DL_NUMBER_, node, 'DL_NUMBER')
            self.DL_NUMBER = DL_NUMBER_
            # validate type DL_NUMBER
            self.validate_DL_NUMBER(self.DL_NUMBER)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class ACHSECUREUPDATE


class ACHSECUREUPDATERESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ACHREFERENCE', ['ACHREFERENCE', 'xs:string'], 0, 0, {'ref': 'ACHREFERENCE', 'name': 'ACHREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, ACHREFERENCE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.ACHREFERENCE = ACHREFERENCE
        self.validate_ACHREFERENCE(self.ACHREFERENCE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACHSECUREUPDATERESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACHSECUREUPDATERESPONSE.subclass:
            return ACHSECUREUPDATERESPONSE.subclass(*args_, **kwargs_)
        else:
            return ACHSECUREUPDATERESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_ACHREFERENCE(self): return self.ACHREFERENCE
    def set_ACHREFERENCE(self, ACHREFERENCE): self.ACHREFERENCE = ACHREFERENCE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_ACHREFERENCE(self, value):
        # Validate type ACHREFERENCE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.ACHREFERENCE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACHSECUREUPDATERESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.ACHREFERENCE is not None:
            ACHREFERENCE_ = self.ACHREFERENCE
            etree_.SubElement(element, '{}ACHREFERENCE').text = self.gds_format_string(ACHREFERENCE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACHSECUREUPDATERESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.ACHREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('ACHREFERENCE=%s,\n' % self.gds_encode(quote_python(self.ACHREFERENCE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'ACHREFERENCE':
            ACHREFERENCE_ = child_.text
            ACHREFERENCE_ = self.gds_validate_string(ACHREFERENCE_, node, 'ACHREFERENCE')
            self.ACHREFERENCE = ACHREFERENCE_
            # validate type ACHREFERENCE
            self.validate_ACHREFERENCE(self.ACHREFERENCE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class ACHSECUREUPDATERESPONSE


class ADD_ACH_SUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('STOREDSUBSCRIPTIONREF', ['STOREDSUBSCRIPTIONREF', 'xs:string'], 0, 1, {'ref': 'STOREDSUBSCRIPTIONREF', 'minOccurs': '0', 'name': 'STOREDSUBSCRIPTIONREF', 'type': 'xs:string'}, None),
        MemberSpec_('SECUREACHACCOUNTMERCHANTREF', ['SECUREACHACCOUNTMERCHANTREF', 'xs:string'], 0, 1, {'ref': 'SECUREACHACCOUNTMERCHANTREF', 'minOccurs': '0', 'name': 'SECUREACHACCOUNTMERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ACHREFERENCE', ['ACHREFERENCE', 'xs:string'], 0, 1, {'ref': 'ACHREFERENCE', 'minOccurs': '0', 'name': 'ACHREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('SEC_CODE', ['SEC_CODE', 'xs:string'], 0, 0, {'ref': 'SEC_CODE', 'name': 'SEC_CODE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('INITIALAMOUNT', 'xs:double', 0, 1, {'ref': 'INITIALAMOUNT', 'minOccurs': '0', 'name': 'INITIALAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('STARTDATE', ['STARTDATE', 'xs:string'], 0, 0, {'ref': 'STARTDATE', 'name': 'STARTDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ENDDATE', ['ENDDATE', 'xs:string'], 0, 1, {'ref': 'ENDDATE', 'minOccurs': '0', 'name': 'ENDDATE', 'type': 'xs:string'}, None),
        MemberSpec_('NEWSTOREDSUBSCRIPTIONINFO', 'NEWSTOREDSUBSCRIPTIONINFO', 0, 1, {'ref': 'NEWSTOREDSUBSCRIPTIONINFO', 'minOccurs': '0', 'name': 'NEWSTOREDSUBSCRIPTIONINFO', 'type': 'NEWSTOREDSUBSCRIPTIONINFO'}, None),
        MemberSpec_('NOTIFICATIONLANGUAGE', ['NOTIFICATIONLANGUAGE', 'xs:string'], 0, 1, {'ref': 'NOTIFICATIONLANGUAGE', 'minOccurs': '0', 'name': 'NOTIFICATIONLANGUAGE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, STOREDSUBSCRIPTIONREF=None, SECUREACHACCOUNTMERCHANTREF=None, ACHREFERENCE=None, SEC_CODE=None, DATETIME=None, RECURRINGAMOUNT=None, INITIALAMOUNT=None, STARTDATE=None, ENDDATE=None, NEWSTOREDSUBSCRIPTIONINFO=None, NOTIFICATIONLANGUAGE=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF
        self.validate_STOREDSUBSCRIPTIONREF(self.STOREDSUBSCRIPTIONREF)
        self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF
        self.validate_SECUREACHACCOUNTMERCHANTREF(self.SECUREACHACCOUNTMERCHANTREF)
        self.ACHREFERENCE = ACHREFERENCE
        self.validate_ACHREFERENCE(self.ACHREFERENCE)
        self.SEC_CODE = SEC_CODE
        self.validate_SEC_CODE(self.SEC_CODE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.INITIALAMOUNT = INITIALAMOUNT
        self.STARTDATE = STARTDATE
        self.validate_STARTDATE(self.STARTDATE)
        self.ENDDATE = ENDDATE
        self.validate_ENDDATE(self.ENDDATE)
        self.NEWSTOREDSUBSCRIPTIONINFO = NEWSTOREDSUBSCRIPTIONINFO
        self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
        self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADD_ACH_SUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADD_ACH_SUBSCRIPTION.subclass:
            return ADD_ACH_SUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return ADD_ACH_SUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_STOREDSUBSCRIPTIONREF(self): return self.STOREDSUBSCRIPTIONREF
    def set_STOREDSUBSCRIPTIONREF(self, STOREDSUBSCRIPTIONREF): self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF
    def get_SECUREACHACCOUNTMERCHANTREF(self): return self.SECUREACHACCOUNTMERCHANTREF
    def set_SECUREACHACCOUNTMERCHANTREF(self, SECUREACHACCOUNTMERCHANTREF): self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF
    def get_ACHREFERENCE(self): return self.ACHREFERENCE
    def set_ACHREFERENCE(self, ACHREFERENCE): self.ACHREFERENCE = ACHREFERENCE
    def get_SEC_CODE(self): return self.SEC_CODE
    def set_SEC_CODE(self, SEC_CODE): self.SEC_CODE = SEC_CODE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_INITIALAMOUNT(self): return self.INITIALAMOUNT
    def set_INITIALAMOUNT(self, INITIALAMOUNT): self.INITIALAMOUNT = INITIALAMOUNT
    def get_STARTDATE(self): return self.STARTDATE
    def set_STARTDATE(self, STARTDATE): self.STARTDATE = STARTDATE
    def get_ENDDATE(self): return self.ENDDATE
    def set_ENDDATE(self, ENDDATE): self.ENDDATE = ENDDATE
    def get_NEWSTOREDSUBSCRIPTIONINFO(self): return self.NEWSTOREDSUBSCRIPTIONINFO
    def set_NEWSTOREDSUBSCRIPTIONINFO(self, NEWSTOREDSUBSCRIPTIONINFO): self.NEWSTOREDSUBSCRIPTIONINFO = NEWSTOREDSUBSCRIPTIONINFO
    def get_NOTIFICATIONLANGUAGE(self): return self.NOTIFICATIONLANGUAGE
    def set_NOTIFICATIONLANGUAGE(self, NOTIFICATIONLANGUAGE): self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_STOREDSUBSCRIPTIONREF(self, value):
        # Validate type STOREDSUBSCRIPTIONREF, a restriction on xs:string.
        pass
    def validate_SECUREACHACCOUNTMERCHANTREF(self, value):
        # Validate type SECUREACHACCOUNTMERCHANTREF, a restriction on xs:string.
        pass
    def validate_ACHREFERENCE(self, value):
        # Validate type ACHREFERENCE, a restriction on xs:string.
        pass
    def validate_SEC_CODE(self, value):
        # Validate type SEC_CODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_STARTDATE(self, value):
        # Validate type STARTDATE, a restriction on xs:string.
        pass
    def validate_ENDDATE(self, value):
        # Validate type ENDDATE, a restriction on xs:string.
        pass
    def validate_NOTIFICATIONLANGUAGE(self, value):
        # Validate type NOTIFICATIONLANGUAGE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.STOREDSUBSCRIPTIONREF is not None or
            self.SECUREACHACCOUNTMERCHANTREF is not None or
            self.ACHREFERENCE is not None or
            self.SEC_CODE is not None or
            self.DATETIME is not None or
            self.RECURRINGAMOUNT is not None or
            self.INITIALAMOUNT is not None or
            self.STARTDATE is not None or
            self.ENDDATE is not None or
            self.NEWSTOREDSUBSCRIPTIONINFO is not None or
            self.NOTIFICATIONLANGUAGE is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADD_ACH_SUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.STOREDSUBSCRIPTIONREF is not None:
            STOREDSUBSCRIPTIONREF_ = self.STOREDSUBSCRIPTIONREF
            etree_.SubElement(element, '{}STOREDSUBSCRIPTIONREF').text = self.gds_format_string(STOREDSUBSCRIPTIONREF_)
        if self.SECUREACHACCOUNTMERCHANTREF is not None:
            SECUREACHACCOUNTMERCHANTREF_ = self.SECUREACHACCOUNTMERCHANTREF
            etree_.SubElement(element, '{}SECUREACHACCOUNTMERCHANTREF').text = self.gds_format_string(SECUREACHACCOUNTMERCHANTREF_)
        if self.ACHREFERENCE is not None:
            ACHREFERENCE_ = self.ACHREFERENCE
            etree_.SubElement(element, '{}ACHREFERENCE').text = self.gds_format_string(ACHREFERENCE_)
        if self.SEC_CODE is not None:
            SEC_CODE_ = self.SEC_CODE
            etree_.SubElement(element, '{}SEC_CODE').text = self.gds_format_string(SEC_CODE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.INITIALAMOUNT is not None:
            INITIALAMOUNT_ = self.INITIALAMOUNT
            etree_.SubElement(element, '{}INITIALAMOUNT').text = self.gds_format_double(INITIALAMOUNT_)
        if self.STARTDATE is not None:
            STARTDATE_ = self.STARTDATE
            etree_.SubElement(element, '{}STARTDATE').text = self.gds_format_string(STARTDATE_)
        if self.ENDDATE is not None:
            ENDDATE_ = self.ENDDATE
            etree_.SubElement(element, '{}ENDDATE').text = self.gds_format_string(ENDDATE_)
        if self.NEWSTOREDSUBSCRIPTIONINFO is not None:
            NEWSTOREDSUBSCRIPTIONINFO_ = self.NEWSTOREDSUBSCRIPTIONINFO
            NEWSTOREDSUBSCRIPTIONINFO_.to_etree(element, name_='NEWSTOREDSUBSCRIPTIONINFO', mapping_=mapping_)
        if self.NOTIFICATIONLANGUAGE is not None:
            NOTIFICATIONLANGUAGE_ = self.NOTIFICATIONLANGUAGE
            etree_.SubElement(element, '{}NOTIFICATIONLANGUAGE').text = self.gds_format_string(NOTIFICATIONLANGUAGE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADD_ACH_SUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.STOREDSUBSCRIPTIONREF is not None:
            showIndent(outfile, level)
            outfile.write('STOREDSUBSCRIPTIONREF=%s,\n' % self.gds_encode(quote_python(self.STOREDSUBSCRIPTIONREF)))
        if self.SECUREACHACCOUNTMERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('SECUREACHACCOUNTMERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.SECUREACHACCOUNTMERCHANTREF)))
        if self.ACHREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('ACHREFERENCE=%s,\n' % self.gds_encode(quote_python(self.ACHREFERENCE)))
        if self.SEC_CODE is not None:
            showIndent(outfile, level)
            outfile.write('SEC_CODE=%s,\n' % self.gds_encode(quote_python(self.SEC_CODE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.INITIALAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('INITIALAMOUNT=%e,\n' % self.INITIALAMOUNT)
        if self.STARTDATE is not None:
            showIndent(outfile, level)
            outfile.write('STARTDATE=%s,\n' % self.gds_encode(quote_python(self.STARTDATE)))
        if self.ENDDATE is not None:
            showIndent(outfile, level)
            outfile.write('ENDDATE=%s,\n' % self.gds_encode(quote_python(self.ENDDATE)))
        if self.NEWSTOREDSUBSCRIPTIONINFO is not None:
            showIndent(outfile, level)
            outfile.write('NEWSTOREDSUBSCRIPTIONINFO=model_.NEWSTOREDSUBSCRIPTIONINFO(\n')
            self.NEWSTOREDSUBSCRIPTIONINFO.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NOTIFICATIONLANGUAGE is not None:
            showIndent(outfile, level)
            outfile.write('NOTIFICATIONLANGUAGE=%s,\n' % self.gds_encode(quote_python(self.NOTIFICATIONLANGUAGE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'STOREDSUBSCRIPTIONREF':
            STOREDSUBSCRIPTIONREF_ = child_.text
            STOREDSUBSCRIPTIONREF_ = self.gds_validate_string(STOREDSUBSCRIPTIONREF_, node, 'STOREDSUBSCRIPTIONREF')
            self.STOREDSUBSCRIPTIONREF = STOREDSUBSCRIPTIONREF_
            # validate type STOREDSUBSCRIPTIONREF
            self.validate_STOREDSUBSCRIPTIONREF(self.STOREDSUBSCRIPTIONREF)
        elif nodeName_ == 'SECUREACHACCOUNTMERCHANTREF':
            SECUREACHACCOUNTMERCHANTREF_ = child_.text
            SECUREACHACCOUNTMERCHANTREF_ = self.gds_validate_string(SECUREACHACCOUNTMERCHANTREF_, node, 'SECUREACHACCOUNTMERCHANTREF')
            self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF_
            # validate type SECUREACHACCOUNTMERCHANTREF
            self.validate_SECUREACHACCOUNTMERCHANTREF(self.SECUREACHACCOUNTMERCHANTREF)
        elif nodeName_ == 'ACHREFERENCE':
            ACHREFERENCE_ = child_.text
            ACHREFERENCE_ = self.gds_validate_string(ACHREFERENCE_, node, 'ACHREFERENCE')
            self.ACHREFERENCE = ACHREFERENCE_
            # validate type ACHREFERENCE
            self.validate_ACHREFERENCE(self.ACHREFERENCE)
        elif nodeName_ == 'SEC_CODE':
            SEC_CODE_ = child_.text
            SEC_CODE_ = self.gds_validate_string(SEC_CODE_, node, 'SEC_CODE')
            self.SEC_CODE = SEC_CODE_
            # validate type SEC_CODE
            self.validate_SEC_CODE(self.SEC_CODE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'INITIALAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'INITIALAMOUNT')
            self.INITIALAMOUNT = fval_
        elif nodeName_ == 'STARTDATE':
            STARTDATE_ = child_.text
            STARTDATE_ = self.gds_validate_string(STARTDATE_, node, 'STARTDATE')
            self.STARTDATE = STARTDATE_
            # validate type STARTDATE
            self.validate_STARTDATE(self.STARTDATE)
        elif nodeName_ == 'ENDDATE':
            ENDDATE_ = child_.text
            ENDDATE_ = self.gds_validate_string(ENDDATE_, node, 'ENDDATE')
            self.ENDDATE = ENDDATE_
            # validate type ENDDATE
            self.validate_ENDDATE(self.ENDDATE)
        elif nodeName_ == 'NEWSTOREDSUBSCRIPTIONINFO':
            obj_ = NEWSTOREDSUBSCRIPTIONINFO.factory()
            obj_.build(child_)
            self.NEWSTOREDSUBSCRIPTIONINFO = obj_
            obj_.original_tagname_ = 'NEWSTOREDSUBSCRIPTIONINFO'
        elif nodeName_ == 'NOTIFICATIONLANGUAGE':
            NOTIFICATIONLANGUAGE_ = child_.text
            NOTIFICATIONLANGUAGE_ = self.gds_validate_string(NOTIFICATIONLANGUAGE_, node, 'NOTIFICATIONLANGUAGE')
            self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE_
            # validate type NOTIFICATIONLANGUAGE
            self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class ADD_ACH_SUBSCRIPTION


class ADD_ACH_SUBSCRIPTION_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADD_ACH_SUBSCRIPTION_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADD_ACH_SUBSCRIPTION_RESPONSE.subclass:
            return ADD_ACH_SUBSCRIPTION_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return ADD_ACH_SUBSCRIPTION_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ADD_ACH_SUBSCRIPTION_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ADD_ACH_SUBSCRIPTION_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class ADD_ACH_SUBSCRIPTION_RESPONSE


class UPDATE_ACH_SUBSCRIPTION(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('SECUREACHACCOUNTMERCHANTREF', ['SECUREACHACCOUNTMERCHANTREF', 'xs:string'], 0, 1, {'ref': 'SECUREACHACCOUNTMERCHANTREF', 'minOccurs': '0', 'name': 'SECUREACHACCOUNTMERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('ACHREFERENCE', ['ACHREFERENCE', 'xs:string'], 0, 1, {'ref': 'ACHREFERENCE', 'minOccurs': '0', 'name': 'ACHREFERENCE', 'type': 'xs:string'}, None),
        MemberSpec_('SEC_CODE', ['SEC_CODE', 'xs:string'], 0, 1, {'ref': 'SEC_CODE', 'minOccurs': '0', 'name': 'SEC_CODE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('NAME', ['NAME', 'xs:string'], 0, 1, {'ref': 'NAME', 'minOccurs': '0', 'name': 'NAME', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('LENGTH', 'xs:unsignedInt', 0, 1, {'ref': 'LENGTH', 'minOccurs': '0', 'name': 'LENGTH', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('SKIPPERIODCOUNT', 'xs:unsignedInt', 0, 1, {'ref': 'SKIPPERIODCOUNT', 'minOccurs': '0', 'name': 'SKIPPERIODCOUNT', 'type': 'xs:unsignedInt'}, None),
        MemberSpec_('RECURRINGAMOUNT', 'xs:double', 0, 1, {'ref': 'RECURRINGAMOUNT', 'minOccurs': '0', 'name': 'RECURRINGAMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('STARTDATE', ['STARTDATE', 'xs:string'], 0, 1, {'ref': 'STARTDATE', 'minOccurs': '0', 'name': 'STARTDATE', 'type': 'xs:string'}, None),
        MemberSpec_('ENDDATE', ['ENDDATE', 'xs:string'], 0, 1, {'ref': 'ENDDATE', 'minOccurs': '0', 'name': 'ENDDATE', 'type': 'xs:string'}, None),
        MemberSpec_('NOTIFICATIONLANGUAGE', ['NOTIFICATIONLANGUAGE', 'xs:string'], 0, 1, {'ref': 'NOTIFICATIONLANGUAGE', 'minOccurs': '0', 'name': 'NOTIFICATIONLANGUAGE', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, TERMINALID=None, SECUREACHACCOUNTMERCHANTREF=None, ACHREFERENCE=None, SEC_CODE=None, DATETIME=None, NAME=None, DESCRIPTION=None, LENGTH=None, SKIPPERIODCOUNT=None, RECURRINGAMOUNT=None, STARTDATE=None, ENDDATE=None, NOTIFICATIONLANGUAGE=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF
        self.validate_SECUREACHACCOUNTMERCHANTREF(self.SECUREACHACCOUNTMERCHANTREF)
        self.ACHREFERENCE = ACHREFERENCE
        self.validate_ACHREFERENCE(self.ACHREFERENCE)
        self.SEC_CODE = SEC_CODE
        self.validate_SEC_CODE(self.SEC_CODE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.NAME = NAME
        self.validate_NAME(self.NAME)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.LENGTH = LENGTH
        self.SKIPPERIODCOUNT = SKIPPERIODCOUNT
        self.RECURRINGAMOUNT = RECURRINGAMOUNT
        self.STARTDATE = STARTDATE
        self.validate_STARTDATE(self.STARTDATE)
        self.ENDDATE = ENDDATE
        self.validate_ENDDATE(self.ENDDATE)
        self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
        self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATE_ACH_SUBSCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATE_ACH_SUBSCRIPTION.subclass:
            return UPDATE_ACH_SUBSCRIPTION.subclass(*args_, **kwargs_)
        else:
            return UPDATE_ACH_SUBSCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_SECUREACHACCOUNTMERCHANTREF(self): return self.SECUREACHACCOUNTMERCHANTREF
    def set_SECUREACHACCOUNTMERCHANTREF(self, SECUREACHACCOUNTMERCHANTREF): self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF
    def get_ACHREFERENCE(self): return self.ACHREFERENCE
    def set_ACHREFERENCE(self, ACHREFERENCE): self.ACHREFERENCE = ACHREFERENCE
    def get_SEC_CODE(self): return self.SEC_CODE
    def set_SEC_CODE(self, SEC_CODE): self.SEC_CODE = SEC_CODE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_LENGTH(self): return self.LENGTH
    def set_LENGTH(self, LENGTH): self.LENGTH = LENGTH
    def get_SKIPPERIODCOUNT(self): return self.SKIPPERIODCOUNT
    def set_SKIPPERIODCOUNT(self, SKIPPERIODCOUNT): self.SKIPPERIODCOUNT = SKIPPERIODCOUNT
    def get_RECURRINGAMOUNT(self): return self.RECURRINGAMOUNT
    def set_RECURRINGAMOUNT(self, RECURRINGAMOUNT): self.RECURRINGAMOUNT = RECURRINGAMOUNT
    def get_STARTDATE(self): return self.STARTDATE
    def set_STARTDATE(self, STARTDATE): self.STARTDATE = STARTDATE
    def get_ENDDATE(self): return self.ENDDATE
    def set_ENDDATE(self, ENDDATE): self.ENDDATE = ENDDATE
    def get_NOTIFICATIONLANGUAGE(self): return self.NOTIFICATIONLANGUAGE
    def set_NOTIFICATIONLANGUAGE(self, NOTIFICATIONLANGUAGE): self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_SECUREACHACCOUNTMERCHANTREF(self, value):
        # Validate type SECUREACHACCOUNTMERCHANTREF, a restriction on xs:string.
        pass
    def validate_ACHREFERENCE(self, value):
        # Validate type ACHREFERENCE, a restriction on xs:string.
        pass
    def validate_SEC_CODE(self, value):
        # Validate type SEC_CODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_NAME(self, value):
        # Validate type NAME, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_STARTDATE(self, value):
        # Validate type STARTDATE, a restriction on xs:string.
        pass
    def validate_ENDDATE(self, value):
        # Validate type ENDDATE, a restriction on xs:string.
        pass
    def validate_NOTIFICATIONLANGUAGE(self, value):
        # Validate type NOTIFICATIONLANGUAGE, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.TERMINALID is not None or
            self.SECUREACHACCOUNTMERCHANTREF is not None or
            self.ACHREFERENCE is not None or
            self.SEC_CODE is not None or
            self.DATETIME is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.LENGTH is not None or
            self.SKIPPERIODCOUNT is not None or
            self.RECURRINGAMOUNT is not None or
            self.STARTDATE is not None or
            self.ENDDATE is not None or
            self.NOTIFICATIONLANGUAGE is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATE_ACH_SUBSCRIPTION', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.SECUREACHACCOUNTMERCHANTREF is not None:
            SECUREACHACCOUNTMERCHANTREF_ = self.SECUREACHACCOUNTMERCHANTREF
            etree_.SubElement(element, '{}SECUREACHACCOUNTMERCHANTREF').text = self.gds_format_string(SECUREACHACCOUNTMERCHANTREF_)
        if self.ACHREFERENCE is not None:
            ACHREFERENCE_ = self.ACHREFERENCE
            etree_.SubElement(element, '{}ACHREFERENCE').text = self.gds_format_string(ACHREFERENCE_)
        if self.SEC_CODE is not None:
            SEC_CODE_ = self.SEC_CODE
            etree_.SubElement(element, '{}SEC_CODE').text = self.gds_format_string(SEC_CODE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.NAME is not None:
            NAME_ = self.NAME
            etree_.SubElement(element, '{}NAME').text = self.gds_format_string(NAME_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.LENGTH is not None:
            LENGTH_ = self.LENGTH
            etree_.SubElement(element, '{}LENGTH').text = self.gds_format_integer(LENGTH_)
        if self.SKIPPERIODCOUNT is not None:
            SKIPPERIODCOUNT_ = self.SKIPPERIODCOUNT
            etree_.SubElement(element, '{}SKIPPERIODCOUNT').text = self.gds_format_integer(SKIPPERIODCOUNT_)
        if self.RECURRINGAMOUNT is not None:
            RECURRINGAMOUNT_ = self.RECURRINGAMOUNT
            etree_.SubElement(element, '{}RECURRINGAMOUNT').text = self.gds_format_double(RECURRINGAMOUNT_)
        if self.STARTDATE is not None:
            STARTDATE_ = self.STARTDATE
            etree_.SubElement(element, '{}STARTDATE').text = self.gds_format_string(STARTDATE_)
        if self.ENDDATE is not None:
            ENDDATE_ = self.ENDDATE
            etree_.SubElement(element, '{}ENDDATE').text = self.gds_format_string(ENDDATE_)
        if self.NOTIFICATIONLANGUAGE is not None:
            NOTIFICATIONLANGUAGE_ = self.NOTIFICATIONLANGUAGE
            etree_.SubElement(element, '{}NOTIFICATIONLANGUAGE').text = self.gds_format_string(NOTIFICATIONLANGUAGE_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATE_ACH_SUBSCRIPTION'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.SECUREACHACCOUNTMERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('SECUREACHACCOUNTMERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.SECUREACHACCOUNTMERCHANTREF)))
        if self.ACHREFERENCE is not None:
            showIndent(outfile, level)
            outfile.write('ACHREFERENCE=%s,\n' % self.gds_encode(quote_python(self.ACHREFERENCE)))
        if self.SEC_CODE is not None:
            showIndent(outfile, level)
            outfile.write('SEC_CODE=%s,\n' % self.gds_encode(quote_python(self.SEC_CODE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.NAME is not None:
            showIndent(outfile, level)
            outfile.write('NAME=%s,\n' % self.gds_encode(quote_python(self.NAME)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('LENGTH=%d,\n' % self.LENGTH)
        if self.SKIPPERIODCOUNT is not None:
            showIndent(outfile, level)
            outfile.write('SKIPPERIODCOUNT=%d,\n' % self.SKIPPERIODCOUNT)
        if self.RECURRINGAMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('RECURRINGAMOUNT=%e,\n' % self.RECURRINGAMOUNT)
        if self.STARTDATE is not None:
            showIndent(outfile, level)
            outfile.write('STARTDATE=%s,\n' % self.gds_encode(quote_python(self.STARTDATE)))
        if self.ENDDATE is not None:
            showIndent(outfile, level)
            outfile.write('ENDDATE=%s,\n' % self.gds_encode(quote_python(self.ENDDATE)))
        if self.NOTIFICATIONLANGUAGE is not None:
            showIndent(outfile, level)
            outfile.write('NOTIFICATIONLANGUAGE=%s,\n' % self.gds_encode(quote_python(self.NOTIFICATIONLANGUAGE)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'SECUREACHACCOUNTMERCHANTREF':
            SECUREACHACCOUNTMERCHANTREF_ = child_.text
            SECUREACHACCOUNTMERCHANTREF_ = self.gds_validate_string(SECUREACHACCOUNTMERCHANTREF_, node, 'SECUREACHACCOUNTMERCHANTREF')
            self.SECUREACHACCOUNTMERCHANTREF = SECUREACHACCOUNTMERCHANTREF_
            # validate type SECUREACHACCOUNTMERCHANTREF
            self.validate_SECUREACHACCOUNTMERCHANTREF(self.SECUREACHACCOUNTMERCHANTREF)
        elif nodeName_ == 'ACHREFERENCE':
            ACHREFERENCE_ = child_.text
            ACHREFERENCE_ = self.gds_validate_string(ACHREFERENCE_, node, 'ACHREFERENCE')
            self.ACHREFERENCE = ACHREFERENCE_
            # validate type ACHREFERENCE
            self.validate_ACHREFERENCE(self.ACHREFERENCE)
        elif nodeName_ == 'SEC_CODE':
            SEC_CODE_ = child_.text
            SEC_CODE_ = self.gds_validate_string(SEC_CODE_, node, 'SEC_CODE')
            self.SEC_CODE = SEC_CODE_
            # validate type SEC_CODE
            self.validate_SEC_CODE(self.SEC_CODE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
            # validate type NAME
            self.validate_NAME(self.NAME)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'LENGTH' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LENGTH')
            self.LENGTH = ival_
        elif nodeName_ == 'SKIPPERIODCOUNT' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SKIPPERIODCOUNT')
            self.SKIPPERIODCOUNT = ival_
        elif nodeName_ == 'RECURRINGAMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RECURRINGAMOUNT')
            self.RECURRINGAMOUNT = fval_
        elif nodeName_ == 'STARTDATE':
            STARTDATE_ = child_.text
            STARTDATE_ = self.gds_validate_string(STARTDATE_, node, 'STARTDATE')
            self.STARTDATE = STARTDATE_
            # validate type STARTDATE
            self.validate_STARTDATE(self.STARTDATE)
        elif nodeName_ == 'ENDDATE':
            ENDDATE_ = child_.text
            ENDDATE_ = self.gds_validate_string(ENDDATE_, node, 'ENDDATE')
            self.ENDDATE = ENDDATE_
            # validate type ENDDATE
            self.validate_ENDDATE(self.ENDDATE)
        elif nodeName_ == 'NOTIFICATIONLANGUAGE':
            NOTIFICATIONLANGUAGE_ = child_.text
            NOTIFICATIONLANGUAGE_ = self.gds_validate_string(NOTIFICATIONLANGUAGE_, node, 'NOTIFICATIONLANGUAGE')
            self.NOTIFICATIONLANGUAGE = NOTIFICATIONLANGUAGE_
            # validate type NOTIFICATIONLANGUAGE
            self.validate_NOTIFICATIONLANGUAGE(self.NOTIFICATIONLANGUAGE)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class UPDATE_ACH_SUBSCRIPTION


class UPDATE_ACH_SUBSCRIPTION_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('MERCHANTREF', ['MERCHANTREF', 'xs:string'], 0, 0, {'ref': 'MERCHANTREF', 'name': 'MERCHANTREF', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MERCHANTREF=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.MERCHANTREF = MERCHANTREF
        self.validate_MERCHANTREF(self.MERCHANTREF)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPDATE_ACH_SUBSCRIPTION_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPDATE_ACH_SUBSCRIPTION_RESPONSE.subclass:
            return UPDATE_ACH_SUBSCRIPTION_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return UPDATE_ACH_SUBSCRIPTION_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MERCHANTREF(self): return self.MERCHANTREF
    def set_MERCHANTREF(self, MERCHANTREF): self.MERCHANTREF = MERCHANTREF
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_MERCHANTREF(self, value):
        # Validate type MERCHANTREF, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MERCHANTREF is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UPDATE_ACH_SUBSCRIPTION_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MERCHANTREF is not None:
            MERCHANTREF_ = self.MERCHANTREF
            etree_.SubElement(element, '{}MERCHANTREF').text = self.gds_format_string(MERCHANTREF_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UPDATE_ACH_SUBSCRIPTION_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MERCHANTREF is not None:
            showIndent(outfile, level)
            outfile.write('MERCHANTREF=%s,\n' % self.gds_encode(quote_python(self.MERCHANTREF)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MERCHANTREF':
            MERCHANTREF_ = child_.text
            MERCHANTREF_ = self.gds_validate_string(MERCHANTREF_, node, 'MERCHANTREF')
            self.MERCHANTREF = MERCHANTREF_
            # validate type MERCHANTREF
            self.validate_MERCHANTREF(self.MERCHANTREF)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class UPDATE_ACH_SUBSCRIPTION_RESPONSE


class ACH_SUBSCRIPTION_PAYMENT(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ORDERID', ['ORDERID', 'xs:string'], 0, 0, {'ref': 'ORDERID', 'name': 'ORDERID', 'type': 'xs:string'}, None),
        MemberSpec_('TERMINALID', ['TERMINALID', 'xs:string'], 0, 0, {'ref': 'TERMINALID', 'name': 'TERMINALID', 'type': 'xs:string'}, None),
        MemberSpec_('AMOUNT', 'xs:double', 0, 0, {'ref': 'AMOUNT', 'name': 'AMOUNT', 'type': 'xs:double'}, None),
        MemberSpec_('SUBSCRIPTIONREF', ['SUBSCRIPTIONREF', 'xs:string'], 0, 0, {'ref': 'SUBSCRIPTIONREF', 'name': 'SUBSCRIPTIONREF', 'type': 'xs:string'}, None),
        MemberSpec_('SEC_CODE', ['SEC_CODE', 'xs:string'], 0, 0, {'ref': 'SEC_CODE', 'name': 'SEC_CODE', 'type': 'xs:string'}, None),
        MemberSpec_('CHECK_NUMBER', ['CHECK_NUMBER', 'xs:string'], 0, 1, {'ref': 'CHECK_NUMBER', 'minOccurs': '0', 'name': 'CHECK_NUMBER', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTION', 'xs:string'], 0, 1, {'ref': 'DESCRIPTION', 'minOccurs': '0', 'name': 'DESCRIPTION', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ORDERID=None, TERMINALID=None, AMOUNT=None, SUBSCRIPTIONREF=None, SEC_CODE=None, CHECK_NUMBER=None, DESCRIPTION=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.ORDERID = ORDERID
        self.validate_ORDERID(self.ORDERID)
        self.TERMINALID = TERMINALID
        self.validate_TERMINALID(self.TERMINALID)
        self.AMOUNT = AMOUNT
        self.SUBSCRIPTIONREF = SUBSCRIPTIONREF
        self.validate_SUBSCRIPTIONREF(self.SUBSCRIPTIONREF)
        self.SEC_CODE = SEC_CODE
        self.validate_SEC_CODE(self.SEC_CODE)
        self.CHECK_NUMBER = CHECK_NUMBER
        self.validate_CHECK_NUMBER(self.CHECK_NUMBER)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTION(self.DESCRIPTION)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_SUBSCRIPTION_PAYMENT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_SUBSCRIPTION_PAYMENT.subclass:
            return ACH_SUBSCRIPTION_PAYMENT.subclass(*args_, **kwargs_)
        else:
            return ACH_SUBSCRIPTION_PAYMENT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ORDERID(self): return self.ORDERID
    def set_ORDERID(self, ORDERID): self.ORDERID = ORDERID
    def get_TERMINALID(self): return self.TERMINALID
    def set_TERMINALID(self, TERMINALID): self.TERMINALID = TERMINALID
    def get_AMOUNT(self): return self.AMOUNT
    def set_AMOUNT(self, AMOUNT): self.AMOUNT = AMOUNT
    def get_SUBSCRIPTIONREF(self): return self.SUBSCRIPTIONREF
    def set_SUBSCRIPTIONREF(self, SUBSCRIPTIONREF): self.SUBSCRIPTIONREF = SUBSCRIPTIONREF
    def get_SEC_CODE(self): return self.SEC_CODE
    def set_SEC_CODE(self, SEC_CODE): self.SEC_CODE = SEC_CODE
    def get_CHECK_NUMBER(self): return self.CHECK_NUMBER
    def set_CHECK_NUMBER(self, CHECK_NUMBER): self.CHECK_NUMBER = CHECK_NUMBER
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_ORDERID(self, value):
        # Validate type ORDERID, a restriction on xs:string.
        pass
    def validate_TERMINALID(self, value):
        # Validate type TERMINALID, a restriction on xs:string.
        pass
    def validate_SUBSCRIPTIONREF(self, value):
        # Validate type SUBSCRIPTIONREF, a restriction on xs:string.
        pass
    def validate_SEC_CODE(self, value):
        # Validate type SEC_CODE, a restriction on xs:string.
        pass
    def validate_CHECK_NUMBER(self, value):
        # Validate type CHECK_NUMBER, a restriction on xs:string.
        pass
    def validate_DESCRIPTION(self, value):
        # Validate type DESCRIPTION, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ORDERID is not None or
            self.TERMINALID is not None or
            self.AMOUNT is not None or
            self.SUBSCRIPTIONREF is not None or
            self.SEC_CODE is not None or
            self.CHECK_NUMBER is not None or
            self.DESCRIPTION is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_SUBSCRIPTION_PAYMENT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ORDERID is not None:
            ORDERID_ = self.ORDERID
            etree_.SubElement(element, '{}ORDERID').text = self.gds_format_string(ORDERID_)
        if self.TERMINALID is not None:
            TERMINALID_ = self.TERMINALID
            etree_.SubElement(element, '{}TERMINALID').text = self.gds_format_string(TERMINALID_)
        if self.AMOUNT is not None:
            AMOUNT_ = self.AMOUNT
            etree_.SubElement(element, '{}AMOUNT').text = self.gds_format_double(AMOUNT_)
        if self.SUBSCRIPTIONREF is not None:
            SUBSCRIPTIONREF_ = self.SUBSCRIPTIONREF
            etree_.SubElement(element, '{}SUBSCRIPTIONREF').text = self.gds_format_string(SUBSCRIPTIONREF_)
        if self.SEC_CODE is not None:
            SEC_CODE_ = self.SEC_CODE
            etree_.SubElement(element, '{}SEC_CODE').text = self.gds_format_string(SEC_CODE_)
        if self.CHECK_NUMBER is not None:
            CHECK_NUMBER_ = self.CHECK_NUMBER
            etree_.SubElement(element, '{}CHECK_NUMBER').text = self.gds_format_string(CHECK_NUMBER_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_SUBSCRIPTION_PAYMENT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ORDERID is not None:
            showIndent(outfile, level)
            outfile.write('ORDERID=%s,\n' % self.gds_encode(quote_python(self.ORDERID)))
        if self.TERMINALID is not None:
            showIndent(outfile, level)
            outfile.write('TERMINALID=%s,\n' % self.gds_encode(quote_python(self.TERMINALID)))
        if self.AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('AMOUNT=%e,\n' % self.AMOUNT)
        if self.SUBSCRIPTIONREF is not None:
            showIndent(outfile, level)
            outfile.write('SUBSCRIPTIONREF=%s,\n' % self.gds_encode(quote_python(self.SUBSCRIPTIONREF)))
        if self.SEC_CODE is not None:
            showIndent(outfile, level)
            outfile.write('SEC_CODE=%s,\n' % self.gds_encode(quote_python(self.SEC_CODE)))
        if self.CHECK_NUMBER is not None:
            showIndent(outfile, level)
            outfile.write('CHECK_NUMBER=%s,\n' % self.gds_encode(quote_python(self.CHECK_NUMBER)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ORDERID':
            ORDERID_ = child_.text
            ORDERID_ = self.gds_validate_string(ORDERID_, node, 'ORDERID')
            self.ORDERID = ORDERID_
            # validate type ORDERID
            self.validate_ORDERID(self.ORDERID)
        elif nodeName_ == 'TERMINALID':
            TERMINALID_ = child_.text
            TERMINALID_ = self.gds_validate_string(TERMINALID_, node, 'TERMINALID')
            self.TERMINALID = TERMINALID_
            # validate type TERMINALID
            self.validate_TERMINALID(self.TERMINALID)
        elif nodeName_ == 'AMOUNT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AMOUNT')
            self.AMOUNT = fval_
        elif nodeName_ == 'SUBSCRIPTIONREF':
            SUBSCRIPTIONREF_ = child_.text
            SUBSCRIPTIONREF_ = self.gds_validate_string(SUBSCRIPTIONREF_, node, 'SUBSCRIPTIONREF')
            self.SUBSCRIPTIONREF = SUBSCRIPTIONREF_
            # validate type SUBSCRIPTIONREF
            self.validate_SUBSCRIPTIONREF(self.SUBSCRIPTIONREF)
        elif nodeName_ == 'SEC_CODE':
            SEC_CODE_ = child_.text
            SEC_CODE_ = self.gds_validate_string(SEC_CODE_, node, 'SEC_CODE')
            self.SEC_CODE = SEC_CODE_
            # validate type SEC_CODE
            self.validate_SEC_CODE(self.SEC_CODE)
        elif nodeName_ == 'CHECK_NUMBER':
            CHECK_NUMBER_ = child_.text
            CHECK_NUMBER_ = self.gds_validate_string(CHECK_NUMBER_, node, 'CHECK_NUMBER')
            self.CHECK_NUMBER = CHECK_NUMBER_
            # validate type CHECK_NUMBER
            self.validate_CHECK_NUMBER(self.CHECK_NUMBER)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTION
            self.validate_DESCRIPTION(self.DESCRIPTION)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class ACH_SUBSCRIPTION_PAYMENT


class ACH_SUBSCRIPTION_PAYMENT_RESPONSE(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('UNIQUEREF', 'xs:string', 0, 1, {'ref': 'UNIQUEREF', 'minOccurs': '0', 'maxOccurs': '1', 'name': 'UNIQUEREF', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSECODE', ['RESPONSECODE', 'xs:string'], 0, 0, {'ref': 'RESPONSECODE', 'name': 'RESPONSECODE', 'type': 'xs:string'}, None),
        MemberSpec_('RESPONSETEXT', ['RESPONSETEXT', 'xs:string'], 0, 0, {'ref': 'RESPONSETEXT', 'name': 'RESPONSETEXT', 'type': 'xs:string'}, None),
        MemberSpec_('APPROVALCODE', ['APPROVALCODE', 'xs:string'], 0, 0, {'ref': 'APPROVALCODE', 'name': 'APPROVALCODE', 'type': 'xs:string'}, None),
        MemberSpec_('DATETIME', ['DATETIME', 'xs:string'], 0, 0, {'ref': 'DATETIME', 'name': 'DATETIME', 'type': 'xs:string'}, None),
        MemberSpec_('HASH', ['HASH', 'xs:string'], 0, 0, {'ref': 'HASH', 'name': 'HASH', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UNIQUEREF=None, RESPONSECODE=None, RESPONSETEXT=None, APPROVALCODE=None, DATETIME=None, HASH=None):
        self.original_tagname_ = None
        self.UNIQUEREF = UNIQUEREF
        self.RESPONSECODE = RESPONSECODE
        self.validate_RESPONSECODE(self.RESPONSECODE)
        self.RESPONSETEXT = RESPONSETEXT
        self.validate_RESPONSETEXT(self.RESPONSETEXT)
        self.APPROVALCODE = APPROVALCODE
        self.validate_APPROVALCODE(self.APPROVALCODE)
        self.DATETIME = DATETIME
        self.validate_DATETIME(self.DATETIME)
        self.HASH = HASH
        self.validate_HASH(self.HASH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACH_SUBSCRIPTION_PAYMENT_RESPONSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACH_SUBSCRIPTION_PAYMENT_RESPONSE.subclass:
            return ACH_SUBSCRIPTION_PAYMENT_RESPONSE.subclass(*args_, **kwargs_)
        else:
            return ACH_SUBSCRIPTION_PAYMENT_RESPONSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UNIQUEREF(self): return self.UNIQUEREF
    def set_UNIQUEREF(self, UNIQUEREF): self.UNIQUEREF = UNIQUEREF
    def get_RESPONSECODE(self): return self.RESPONSECODE
    def set_RESPONSECODE(self, RESPONSECODE): self.RESPONSECODE = RESPONSECODE
    def get_RESPONSETEXT(self): return self.RESPONSETEXT
    def set_RESPONSETEXT(self, RESPONSETEXT): self.RESPONSETEXT = RESPONSETEXT
    def get_APPROVALCODE(self): return self.APPROVALCODE
    def set_APPROVALCODE(self, APPROVALCODE): self.APPROVALCODE = APPROVALCODE
    def get_DATETIME(self): return self.DATETIME
    def set_DATETIME(self, DATETIME): self.DATETIME = DATETIME
    def get_HASH(self): return self.HASH
    def set_HASH(self, HASH): self.HASH = HASH
    def validate_RESPONSECODE(self, value):
        # Validate type RESPONSECODE, a restriction on xs:string.
        pass
    def validate_RESPONSETEXT(self, value):
        # Validate type RESPONSETEXT, a restriction on xs:string.
        pass
    def validate_APPROVALCODE(self, value):
        # Validate type APPROVALCODE, a restriction on xs:string.
        pass
    def validate_DATETIME(self, value):
        # Validate type DATETIME, a restriction on xs:string.
        pass
    def validate_HASH(self, value):
        # Validate type HASH, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.UNIQUEREF is not None or
            self.RESPONSECODE is not None or
            self.RESPONSETEXT is not None or
            self.APPROVALCODE is not None or
            self.DATETIME is not None or
            self.HASH is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ACH_SUBSCRIPTION_PAYMENT_RESPONSE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UNIQUEREF is not None:
            UNIQUEREF_ = self.UNIQUEREF
            etree_.SubElement(element, '{}UNIQUEREF').text = self.gds_format_string(UNIQUEREF_)
        if self.RESPONSECODE is not None:
            RESPONSECODE_ = self.RESPONSECODE
            etree_.SubElement(element, '{}RESPONSECODE').text = self.gds_format_string(RESPONSECODE_)
        if self.RESPONSETEXT is not None:
            RESPONSETEXT_ = self.RESPONSETEXT
            etree_.SubElement(element, '{}RESPONSETEXT').text = self.gds_format_string(RESPONSETEXT_)
        if self.APPROVALCODE is not None:
            APPROVALCODE_ = self.APPROVALCODE
            etree_.SubElement(element, '{}APPROVALCODE').text = self.gds_format_string(APPROVALCODE_)
        if self.DATETIME is not None:
            DATETIME_ = self.DATETIME
            etree_.SubElement(element, '{}DATETIME').text = self.gds_format_string(DATETIME_)
        if self.HASH is not None:
            HASH_ = self.HASH
            etree_.SubElement(element, '{}HASH').text = self.gds_format_string(HASH_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ACH_SUBSCRIPTION_PAYMENT_RESPONSE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UNIQUEREF is not None:
            showIndent(outfile, level)
            outfile.write('UNIQUEREF=%s,\n' % self.gds_encode(quote_python(self.UNIQUEREF)))
        if self.RESPONSECODE is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSECODE=%s,\n' % self.gds_encode(quote_python(self.RESPONSECODE)))
        if self.RESPONSETEXT is not None:
            showIndent(outfile, level)
            outfile.write('RESPONSETEXT=%s,\n' % self.gds_encode(quote_python(self.RESPONSETEXT)))
        if self.APPROVALCODE is not None:
            showIndent(outfile, level)
            outfile.write('APPROVALCODE=%s,\n' % self.gds_encode(quote_python(self.APPROVALCODE)))
        if self.DATETIME is not None:
            showIndent(outfile, level)
            outfile.write('DATETIME=%s,\n' % self.gds_encode(quote_python(self.DATETIME)))
        if self.HASH is not None:
            showIndent(outfile, level)
            outfile.write('HASH=%s,\n' % self.gds_encode(quote_python(self.HASH)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UNIQUEREF':
            UNIQUEREF_ = child_.text
            UNIQUEREF_ = self.gds_validate_string(UNIQUEREF_, node, 'UNIQUEREF')
            self.UNIQUEREF = UNIQUEREF_
        elif nodeName_ == 'RESPONSECODE':
            RESPONSECODE_ = child_.text
            RESPONSECODE_ = self.gds_validate_string(RESPONSECODE_, node, 'RESPONSECODE')
            self.RESPONSECODE = RESPONSECODE_
            # validate type RESPONSECODE
            self.validate_RESPONSECODE(self.RESPONSECODE)
        elif nodeName_ == 'RESPONSETEXT':
            RESPONSETEXT_ = child_.text
            RESPONSETEXT_ = self.gds_validate_string(RESPONSETEXT_, node, 'RESPONSETEXT')
            self.RESPONSETEXT = RESPONSETEXT_
            # validate type RESPONSETEXT
            self.validate_RESPONSETEXT(self.RESPONSETEXT)
        elif nodeName_ == 'APPROVALCODE':
            APPROVALCODE_ = child_.text
            APPROVALCODE_ = self.gds_validate_string(APPROVALCODE_, node, 'APPROVALCODE')
            self.APPROVALCODE = APPROVALCODE_
            # validate type APPROVALCODE
            self.validate_APPROVALCODE(self.APPROVALCODE)
        elif nodeName_ == 'DATETIME':
            DATETIME_ = child_.text
            DATETIME_ = self.gds_validate_string(DATETIME_, node, 'DATETIME')
            self.DATETIME = DATETIME_
            # validate type DATETIME
            self.validate_DATETIME(self.DATETIME)
        elif nodeName_ == 'HASH':
            HASH_ = child_.text
            HASH_ = self.gds_validate_string(HASH_, node, 'HASH')
            self.HASH = HASH_
            # validate type HASH
            self.validate_HASH(self.HASH)
    def sample_method(self):
        pass
# end class ACH_SUBSCRIPTION_PAYMENT_RESPONSE


class SHIPPING_ADDRESSType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('FULL_NAME', ['FULL_NAMEType', 'xs:string'], 0, 1, {'name': 'FULL_NAME', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS1', ['ADDRESS1', 'xs:string'], 0, 1, {'ref': 'ADDRESS1', 'minOccurs': '0', 'name': 'ADDRESS1', 'type': 'xs:string'}, None),
        MemberSpec_('ADDRESS2', ['ADDRESS2', 'xs:string'], 0, 1, {'ref': 'ADDRESS2', 'minOccurs': '0', 'name': 'ADDRESS2', 'type': 'xs:string'}, None),
        MemberSpec_('CITY', ['CITY', 'xs:string'], 0, 1, {'ref': 'CITY', 'minOccurs': '0', 'name': 'CITY', 'type': 'xs:string'}, None),
        MemberSpec_('REGION', ['REGION', 'xs:string'], 0, 1, {'ref': 'REGION', 'minOccurs': '0', 'name': 'REGION', 'type': 'xs:string'}, None),
        MemberSpec_('POSTCODE', ['POSTCODE', 'xs:string'], 0, 1, {'ref': 'POSTCODE', 'minOccurs': '0', 'name': 'POSTCODE', 'type': 'xs:string'}, None),
        MemberSpec_('COUNTRY', ['COUNTRY', 'xs:string'], 0, 1, {'ref': 'COUNTRY', 'minOccurs': '0', 'name': 'COUNTRY', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, FULL_NAME=None, ADDRESS1=None, ADDRESS2=None, CITY=None, REGION=None, POSTCODE=None, COUNTRY=None):
        self.original_tagname_ = None
        self.FULL_NAME = FULL_NAME
        self.validate_FULL_NAMEType(self.FULL_NAME)
        self.ADDRESS1 = ADDRESS1
        self.validate_ADDRESS1(self.ADDRESS1)
        self.ADDRESS2 = ADDRESS2
        self.validate_ADDRESS2(self.ADDRESS2)
        self.CITY = CITY
        self.validate_CITY(self.CITY)
        self.REGION = REGION
        self.validate_REGION(self.REGION)
        self.POSTCODE = POSTCODE
        self.validate_POSTCODE(self.POSTCODE)
        self.COUNTRY = COUNTRY
        self.validate_COUNTRY(self.COUNTRY)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SHIPPING_ADDRESSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SHIPPING_ADDRESSType.subclass:
            return SHIPPING_ADDRESSType.subclass(*args_, **kwargs_)
        else:
            return SHIPPING_ADDRESSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FULL_NAME(self): return self.FULL_NAME
    def set_FULL_NAME(self, FULL_NAME): self.FULL_NAME = FULL_NAME
    def get_ADDRESS1(self): return self.ADDRESS1
    def set_ADDRESS1(self, ADDRESS1): self.ADDRESS1 = ADDRESS1
    def get_ADDRESS2(self): return self.ADDRESS2
    def set_ADDRESS2(self, ADDRESS2): self.ADDRESS2 = ADDRESS2
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_REGION(self): return self.REGION
    def set_REGION(self, REGION): self.REGION = REGION
    def get_POSTCODE(self): return self.POSTCODE
    def set_POSTCODE(self, POSTCODE): self.POSTCODE = POSTCODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def validate_FULL_NAMEType(self, value):
        # Validate type FULL_NAMEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on FULL_NAMEType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on FULL_NAMEType' % {"value" : value.encode("utf-8")} )
    def validate_ADDRESS1(self, value):
        # Validate type ADDRESS1, a restriction on xs:string.
        pass
    def validate_ADDRESS2(self, value):
        # Validate type ADDRESS2, a restriction on xs:string.
        pass
    def validate_CITY(self, value):
        # Validate type CITY, a restriction on xs:string.
        pass
    def validate_REGION(self, value):
        # Validate type REGION, a restriction on xs:string.
        pass
    def validate_POSTCODE(self, value):
        # Validate type POSTCODE, a restriction on xs:string.
        pass
    def validate_COUNTRY(self, value):
        # Validate type COUNTRY, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.FULL_NAME is not None or
            self.ADDRESS1 is not None or
            self.ADDRESS2 is not None or
            self.CITY is not None or
            self.REGION is not None or
            self.POSTCODE is not None or
            self.COUNTRY is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SHIPPING_ADDRESSType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.FULL_NAME is not None:
            FULL_NAME_ = self.FULL_NAME
            etree_.SubElement(element, '{}FULL_NAME').text = self.gds_format_string(FULL_NAME_)
        if self.ADDRESS1 is not None:
            ADDRESS1_ = self.ADDRESS1
            etree_.SubElement(element, '{}ADDRESS1').text = self.gds_format_string(ADDRESS1_)
        if self.ADDRESS2 is not None:
            ADDRESS2_ = self.ADDRESS2
            etree_.SubElement(element, '{}ADDRESS2').text = self.gds_format_string(ADDRESS2_)
        if self.CITY is not None:
            CITY_ = self.CITY
            etree_.SubElement(element, '{}CITY').text = self.gds_format_string(CITY_)
        if self.REGION is not None:
            REGION_ = self.REGION
            etree_.SubElement(element, '{}REGION').text = self.gds_format_string(REGION_)
        if self.POSTCODE is not None:
            POSTCODE_ = self.POSTCODE
            etree_.SubElement(element, '{}POSTCODE').text = self.gds_format_string(POSTCODE_)
        if self.COUNTRY is not None:
            COUNTRY_ = self.COUNTRY
            etree_.SubElement(element, '{}COUNTRY').text = self.gds_format_string(COUNTRY_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SHIPPING_ADDRESSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FULL_NAME is not None:
            showIndent(outfile, level)
            outfile.write('FULL_NAME=%s,\n' % self.gds_encode(quote_python(self.FULL_NAME)))
        if self.ADDRESS1 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS1=%s,\n' % self.gds_encode(quote_python(self.ADDRESS1)))
        if self.ADDRESS2 is not None:
            showIndent(outfile, level)
            outfile.write('ADDRESS2=%s,\n' % self.gds_encode(quote_python(self.ADDRESS2)))
        if self.CITY is not None:
            showIndent(outfile, level)
            outfile.write('CITY=%s,\n' % self.gds_encode(quote_python(self.CITY)))
        if self.REGION is not None:
            showIndent(outfile, level)
            outfile.write('REGION=%s,\n' % self.gds_encode(quote_python(self.REGION)))
        if self.POSTCODE is not None:
            showIndent(outfile, level)
            outfile.write('POSTCODE=%s,\n' % self.gds_encode(quote_python(self.POSTCODE)))
        if self.COUNTRY is not None:
            showIndent(outfile, level)
            outfile.write('COUNTRY=%s,\n' % self.gds_encode(quote_python(self.COUNTRY)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FULL_NAME':
            FULL_NAME_ = child_.text
            FULL_NAME_ = self.gds_validate_string(FULL_NAME_, node, 'FULL_NAME')
            self.FULL_NAME = FULL_NAME_
            # validate type FULL_NAMEType
            self.validate_FULL_NAMEType(self.FULL_NAME)
        elif nodeName_ == 'ADDRESS1':
            ADDRESS1_ = child_.text
            ADDRESS1_ = self.gds_validate_string(ADDRESS1_, node, 'ADDRESS1')
            self.ADDRESS1 = ADDRESS1_
            # validate type ADDRESS1
            self.validate_ADDRESS1(self.ADDRESS1)
        elif nodeName_ == 'ADDRESS2':
            ADDRESS2_ = child_.text
            ADDRESS2_ = self.gds_validate_string(ADDRESS2_, node, 'ADDRESS2')
            self.ADDRESS2 = ADDRESS2_
            # validate type ADDRESS2
            self.validate_ADDRESS2(self.ADDRESS2)
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
            # validate type CITY
            self.validate_CITY(self.CITY)
        elif nodeName_ == 'REGION':
            REGION_ = child_.text
            REGION_ = self.gds_validate_string(REGION_, node, 'REGION')
            self.REGION = REGION_
            # validate type REGION
            self.validate_REGION(self.REGION)
        elif nodeName_ == 'POSTCODE':
            POSTCODE_ = child_.text
            POSTCODE_ = self.gds_validate_string(POSTCODE_, node, 'POSTCODE')
            self.POSTCODE = POSTCODE_
            # validate type POSTCODE
            self.validate_POSTCODE(self.POSTCODE)
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
            # validate type COUNTRY
            self.validate_COUNTRY(self.COUNTRY)
    def sample_method(self):
        pass
# end class SHIPPING_ADDRESSType


class SUMMARYType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('TOTAL_DISCOUNT_AMOUNT', 'emptyDecimalAllowed', 0, 1, {'name': 'TOTAL_DISCOUNT_AMOUNT', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('TOTAL_FREIGHT_AMOUNT', 'emptyDecimalAllowed', 0, 1, {'name': 'TOTAL_FREIGHT_AMOUNT', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('TOTAL_DUTY_AMOUNT', 'emptyDecimalAllowed', 0, 1, {'name': 'TOTAL_DUTY_AMOUNT', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TOTAL_DISCOUNT_AMOUNT=None, TOTAL_FREIGHT_AMOUNT=None, TOTAL_DUTY_AMOUNT=None):
        self.original_tagname_ = None
        self.TOTAL_DISCOUNT_AMOUNT = TOTAL_DISCOUNT_AMOUNT
        self.validate_emptyDecimalAllowed(self.TOTAL_DISCOUNT_AMOUNT)
        self.TOTAL_FREIGHT_AMOUNT = TOTAL_FREIGHT_AMOUNT
        self.validate_emptyDecimalAllowed(self.TOTAL_FREIGHT_AMOUNT)
        self.TOTAL_DUTY_AMOUNT = TOTAL_DUTY_AMOUNT
        self.validate_emptyDecimalAllowed(self.TOTAL_DUTY_AMOUNT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUMMARYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUMMARYType.subclass:
            return SUMMARYType.subclass(*args_, **kwargs_)
        else:
            return SUMMARYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TOTAL_DISCOUNT_AMOUNT(self): return self.TOTAL_DISCOUNT_AMOUNT
    def set_TOTAL_DISCOUNT_AMOUNT(self, TOTAL_DISCOUNT_AMOUNT): self.TOTAL_DISCOUNT_AMOUNT = TOTAL_DISCOUNT_AMOUNT
    def get_TOTAL_FREIGHT_AMOUNT(self): return self.TOTAL_FREIGHT_AMOUNT
    def set_TOTAL_FREIGHT_AMOUNT(self, TOTAL_FREIGHT_AMOUNT): self.TOTAL_FREIGHT_AMOUNT = TOTAL_FREIGHT_AMOUNT
    def get_TOTAL_DUTY_AMOUNT(self): return self.TOTAL_DUTY_AMOUNT
    def set_TOTAL_DUTY_AMOUNT(self, TOTAL_DUTY_AMOUNT): self.TOTAL_DUTY_AMOUNT = TOTAL_DUTY_AMOUNT
    def validate_emptyDecimalAllowed(self, value):
        # Validate type emptyDecimalAllowed, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.TOTAL_DISCOUNT_AMOUNT is not None or
            self.TOTAL_FREIGHT_AMOUNT is not None or
            self.TOTAL_DUTY_AMOUNT is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SUMMARYType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TOTAL_DISCOUNT_AMOUNT is not None:
            TOTAL_DISCOUNT_AMOUNT_ = self.TOTAL_DISCOUNT_AMOUNT
            etree_.SubElement(element, '{}TOTAL_DISCOUNT_AMOUNT').text = self.gds_format_string(TOTAL_DISCOUNT_AMOUNT_)
        if self.TOTAL_FREIGHT_AMOUNT is not None:
            TOTAL_FREIGHT_AMOUNT_ = self.TOTAL_FREIGHT_AMOUNT
            etree_.SubElement(element, '{}TOTAL_FREIGHT_AMOUNT').text = self.gds_format_string(TOTAL_FREIGHT_AMOUNT_)
        if self.TOTAL_DUTY_AMOUNT is not None:
            TOTAL_DUTY_AMOUNT_ = self.TOTAL_DUTY_AMOUNT
            etree_.SubElement(element, '{}TOTAL_DUTY_AMOUNT').text = self.gds_format_string(TOTAL_DUTY_AMOUNT_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SUMMARYType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TOTAL_DISCOUNT_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TOTAL_DISCOUNT_AMOUNT=%s,\n' % self.gds_encode(quote_python(self.TOTAL_DISCOUNT_AMOUNT)))
        if self.TOTAL_FREIGHT_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TOTAL_FREIGHT_AMOUNT=%s,\n' % self.gds_encode(quote_python(self.TOTAL_FREIGHT_AMOUNT)))
        if self.TOTAL_DUTY_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TOTAL_DUTY_AMOUNT=%s,\n' % self.gds_encode(quote_python(self.TOTAL_DUTY_AMOUNT)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TOTAL_DISCOUNT_AMOUNT':
            TOTAL_DISCOUNT_AMOUNT_ = child_.text
            TOTAL_DISCOUNT_AMOUNT_ = self.gds_validate_string(TOTAL_DISCOUNT_AMOUNT_, node, 'TOTAL_DISCOUNT_AMOUNT')
            self.TOTAL_DISCOUNT_AMOUNT = TOTAL_DISCOUNT_AMOUNT_
            # validate type emptyDecimalAllowed
            self.validate_emptyDecimalAllowed(self.TOTAL_DISCOUNT_AMOUNT)
        elif nodeName_ == 'TOTAL_FREIGHT_AMOUNT':
            TOTAL_FREIGHT_AMOUNT_ = child_.text
            TOTAL_FREIGHT_AMOUNT_ = self.gds_validate_string(TOTAL_FREIGHT_AMOUNT_, node, 'TOTAL_FREIGHT_AMOUNT')
            self.TOTAL_FREIGHT_AMOUNT = TOTAL_FREIGHT_AMOUNT_
            # validate type emptyDecimalAllowed
            self.validate_emptyDecimalAllowed(self.TOTAL_FREIGHT_AMOUNT)
        elif nodeName_ == 'TOTAL_DUTY_AMOUNT':
            TOTAL_DUTY_AMOUNT_ = child_.text
            TOTAL_DUTY_AMOUNT_ = self.gds_validate_string(TOTAL_DUTY_AMOUNT_, node, 'TOTAL_DUTY_AMOUNT')
            self.TOTAL_DUTY_AMOUNT = TOTAL_DUTY_AMOUNT_
            # validate type emptyDecimalAllowed
            self.validate_emptyDecimalAllowed(self.TOTAL_DUTY_AMOUNT)
    def sample_method(self):
        pass
# end class SUMMARYType


class LINE_ITEMSType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('LINE_ITEM', 'LINE_ITEMType', 1, 1, {'name': 'LINE_ITEM', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'type': 'LINE_ITEMType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, LINE_ITEM=None):
        self.original_tagname_ = None
        if LINE_ITEM is None:
            self.LINE_ITEM = []
        else:
            self.LINE_ITEM = LINE_ITEM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LINE_ITEMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LINE_ITEMSType.subclass:
            return LINE_ITEMSType.subclass(*args_, **kwargs_)
        else:
            return LINE_ITEMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LINE_ITEM(self): return self.LINE_ITEM
    def set_LINE_ITEM(self, LINE_ITEM): self.LINE_ITEM = LINE_ITEM
    def add_LINE_ITEM(self, value): self.LINE_ITEM.append(value)
    def insert_LINE_ITEM_at(self, index, value): self.LINE_ITEM.insert(index, value)
    def replace_LINE_ITEM_at(self, index, value): self.LINE_ITEM[index] = value
    def hasContent_(self):
        if (
            self.LINE_ITEM
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LINE_ITEMSType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for LINE_ITEM_ in self.LINE_ITEM:
            LINE_ITEM_.to_etree(element, name_='LINE_ITEM', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LINE_ITEMSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LINE_ITEM=[\n')
        level += 1
        for LINE_ITEM_ in self.LINE_ITEM:
            showIndent(outfile, level)
            outfile.write('model_.LINE_ITEMType(\n')
            LINE_ITEM_.exportLiteral(outfile, level, name_='LINE_ITEMType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LINE_ITEM':
            obj_ = LINE_ITEMType.factory()
            obj_.build(child_)
            self.LINE_ITEM.append(obj_)
            obj_.original_tagname_ = 'LINE_ITEM'
    def sample_method(self):
        pass
# end class LINE_ITEMSType


class LINE_ITEMType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('COMMODITY_CODE', ['COMMODITY_CODEType', 'xs:string'], 0, 1, {'name': 'COMMODITY_CODE', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('PRODUCT_CODE', ['PRODUCT_CODEType', 'xs:string'], 0, 1, {'name': 'PRODUCT_CODE', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('DESCRIPTION', ['DESCRIPTIONType', 'xs:string'], 0, 1, {'name': 'DESCRIPTION', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('QUANTITY', 'xs:double', 0, 0, {'name': 'QUANTITY', 'type': 'xs:double'}, None),
        MemberSpec_('UNIT_OF_MEASURE', ['UNIT_OF_MEASUREType', 'xs:string'], 0, 1, {'name': 'UNIT_OF_MEASURE', 'minOccurs': '0', 'type': 'xs:string'}, None),
        MemberSpec_('UNIT_PRICE', ['UNIT_PRICEType', 'xs:decimal'], 0, 0, {'name': 'UNIT_PRICE', 'type': 'xs:decimal'}, None),
        MemberSpec_('DISCOUNT_RATE', ['DISCOUNT_RATEType', 'xs:double'], 0, 1, {'name': 'DISCOUNT_RATE', 'minOccurs': '0', 'type': 'xs:double'}, None),
        MemberSpec_('TAX_RATE', ['TAX_RATEType', 'xs:double'], 0, 1, {'name': 'TAX_RATE', 'minOccurs': '0', 'type': 'xs:double'}, None),
        MemberSpec_('TOTAL_AMOUNT', 'emptyDecimalAllowed', 0, 1, {'name': 'TOTAL_AMOUNT', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, COMMODITY_CODE=None, PRODUCT_CODE=None, DESCRIPTION=None, QUANTITY=None, UNIT_OF_MEASURE=None, UNIT_PRICE=None, DISCOUNT_RATE=None, TAX_RATE=None, TOTAL_AMOUNT=None):
        self.original_tagname_ = None
        self.COMMODITY_CODE = COMMODITY_CODE
        self.validate_COMMODITY_CODEType(self.COMMODITY_CODE)
        self.PRODUCT_CODE = PRODUCT_CODE
        self.validate_PRODUCT_CODEType(self.PRODUCT_CODE)
        self.DESCRIPTION = DESCRIPTION
        self.validate_DESCRIPTIONType(self.DESCRIPTION)
        self.QUANTITY = QUANTITY
        self.UNIT_OF_MEASURE = UNIT_OF_MEASURE
        self.validate_UNIT_OF_MEASUREType(self.UNIT_OF_MEASURE)
        self.UNIT_PRICE = UNIT_PRICE
        self.validate_UNIT_PRICEType(self.UNIT_PRICE)
        self.DISCOUNT_RATE = DISCOUNT_RATE
        self.validate_DISCOUNT_RATEType(self.DISCOUNT_RATE)
        self.TAX_RATE = TAX_RATE
        self.validate_TAX_RATEType(self.TAX_RATE)
        self.TOTAL_AMOUNT = TOTAL_AMOUNT
        self.validate_emptyDecimalAllowed(self.TOTAL_AMOUNT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LINE_ITEMType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LINE_ITEMType.subclass:
            return LINE_ITEMType.subclass(*args_, **kwargs_)
        else:
            return LINE_ITEMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_COMMODITY_CODE(self): return self.COMMODITY_CODE
    def set_COMMODITY_CODE(self, COMMODITY_CODE): self.COMMODITY_CODE = COMMODITY_CODE
    def get_PRODUCT_CODE(self): return self.PRODUCT_CODE
    def set_PRODUCT_CODE(self, PRODUCT_CODE): self.PRODUCT_CODE = PRODUCT_CODE
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_QUANTITY(self): return self.QUANTITY
    def set_QUANTITY(self, QUANTITY): self.QUANTITY = QUANTITY
    def get_UNIT_OF_MEASURE(self): return self.UNIT_OF_MEASURE
    def set_UNIT_OF_MEASURE(self, UNIT_OF_MEASURE): self.UNIT_OF_MEASURE = UNIT_OF_MEASURE
    def get_UNIT_PRICE(self): return self.UNIT_PRICE
    def set_UNIT_PRICE(self, UNIT_PRICE): self.UNIT_PRICE = UNIT_PRICE
    def get_DISCOUNT_RATE(self): return self.DISCOUNT_RATE
    def set_DISCOUNT_RATE(self, DISCOUNT_RATE): self.DISCOUNT_RATE = DISCOUNT_RATE
    def get_TAX_RATE(self): return self.TAX_RATE
    def set_TAX_RATE(self, TAX_RATE): self.TAX_RATE = TAX_RATE
    def get_TOTAL_AMOUNT(self): return self.TOTAL_AMOUNT
    def set_TOTAL_AMOUNT(self, TOTAL_AMOUNT): self.TOTAL_AMOUNT = TOTAL_AMOUNT
    def validate_COMMODITY_CODEType(self, value):
        # Validate type COMMODITY_CODEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on COMMODITY_CODEType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on COMMODITY_CODEType' % {"value" : value.encode("utf-8")} )
    def validate_PRODUCT_CODEType(self, value):
        # Validate type PRODUCT_CODEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PRODUCT_CODEType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PRODUCT_CODEType' % {"value" : value.encode("utf-8")} )
    def validate_DESCRIPTIONType(self, value):
        # Validate type DESCRIPTIONType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 250:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DESCRIPTIONType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DESCRIPTIONType' % {"value" : value.encode("utf-8")} )
    def validate_UNIT_OF_MEASUREType(self, value):
        # Validate type UNIT_OF_MEASUREType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on UNIT_OF_MEASUREType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on UNIT_OF_MEASUREType' % {"value" : value.encode("utf-8")} )
    def validate_UNIT_PRICEType(self, value):
        # Validate type UNIT_PRICEType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on UNIT_PRICEType' % {"value" : value} )
            if len(str(value)) >= 13:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on UNIT_PRICEType' % {"value" : value} )
    def validate_DISCOUNT_RATEType(self, value):
        # Validate type DISCOUNT_RATEType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on DISCOUNT_RATEType' % {"value" : value} )
            if value > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DISCOUNT_RATEType' % {"value" : value} )
    def validate_TAX_RATEType(self, value):
        # Validate type TAX_RATEType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on TAX_RATEType' % {"value" : value} )
            if value > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TAX_RATEType' % {"value" : value} )
    def validate_emptyDecimalAllowed(self, value):
        # Validate type emptyDecimalAllowed, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.COMMODITY_CODE is not None or
            self.PRODUCT_CODE is not None or
            self.DESCRIPTION is not None or
            self.QUANTITY is not None or
            self.UNIT_OF_MEASURE is not None or
            self.UNIT_PRICE is not None or
            self.DISCOUNT_RATE is not None or
            self.TAX_RATE is not None or
            self.TOTAL_AMOUNT is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LINE_ITEMType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.COMMODITY_CODE is not None:
            COMMODITY_CODE_ = self.COMMODITY_CODE
            etree_.SubElement(element, '{}COMMODITY_CODE').text = self.gds_format_string(COMMODITY_CODE_)
        if self.PRODUCT_CODE is not None:
            PRODUCT_CODE_ = self.PRODUCT_CODE
            etree_.SubElement(element, '{}PRODUCT_CODE').text = self.gds_format_string(PRODUCT_CODE_)
        if self.DESCRIPTION is not None:
            DESCRIPTION_ = self.DESCRIPTION
            etree_.SubElement(element, '{}DESCRIPTION').text = self.gds_format_string(DESCRIPTION_)
        if self.QUANTITY is not None:
            QUANTITY_ = self.QUANTITY
            etree_.SubElement(element, '{}QUANTITY').text = self.gds_format_double(QUANTITY_)
        if self.UNIT_OF_MEASURE is not None:
            UNIT_OF_MEASURE_ = self.UNIT_OF_MEASURE
            etree_.SubElement(element, '{}UNIT_OF_MEASURE').text = self.gds_format_string(UNIT_OF_MEASURE_)
        if self.UNIT_PRICE is not None:
            UNIT_PRICE_ = self.UNIT_PRICE
            etree_.SubElement(element, '{}UNIT_PRICE').text = self.gds_format_float(UNIT_PRICE_)
        if self.DISCOUNT_RATE is not None:
            DISCOUNT_RATE_ = self.DISCOUNT_RATE
            etree_.SubElement(element, '{}DISCOUNT_RATE').text = self.gds_format_double(DISCOUNT_RATE_)
        if self.TAX_RATE is not None:
            TAX_RATE_ = self.TAX_RATE
            etree_.SubElement(element, '{}TAX_RATE').text = self.gds_format_double(TAX_RATE_)
        if self.TOTAL_AMOUNT is not None:
            TOTAL_AMOUNT_ = self.TOTAL_AMOUNT
            etree_.SubElement(element, '{}TOTAL_AMOUNT').text = self.gds_format_string(TOTAL_AMOUNT_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LINE_ITEMType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.COMMODITY_CODE is not None:
            showIndent(outfile, level)
            outfile.write('COMMODITY_CODE=%s,\n' % self.gds_encode(quote_python(self.COMMODITY_CODE)))
        if self.PRODUCT_CODE is not None:
            showIndent(outfile, level)
            outfile.write('PRODUCT_CODE=%s,\n' % self.gds_encode(quote_python(self.PRODUCT_CODE)))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % self.gds_encode(quote_python(self.DESCRIPTION)))
        if self.QUANTITY is not None:
            showIndent(outfile, level)
            outfile.write('QUANTITY=%e,\n' % self.QUANTITY)
        if self.UNIT_OF_MEASURE is not None:
            showIndent(outfile, level)
            outfile.write('UNIT_OF_MEASURE=%s,\n' % self.gds_encode(quote_python(self.UNIT_OF_MEASURE)))
        if self.UNIT_PRICE is not None:
            showIndent(outfile, level)
            outfile.write('UNIT_PRICE=%f,\n' % self.UNIT_PRICE)
        if self.DISCOUNT_RATE is not None:
            showIndent(outfile, level)
            outfile.write('DISCOUNT_RATE=%e,\n' % self.DISCOUNT_RATE)
        if self.TAX_RATE is not None:
            showIndent(outfile, level)
            outfile.write('TAX_RATE=%e,\n' % self.TAX_RATE)
        if self.TOTAL_AMOUNT is not None:
            showIndent(outfile, level)
            outfile.write('TOTAL_AMOUNT=%s,\n' % self.gds_encode(quote_python(self.TOTAL_AMOUNT)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'COMMODITY_CODE':
            COMMODITY_CODE_ = child_.text
            COMMODITY_CODE_ = self.gds_validate_string(COMMODITY_CODE_, node, 'COMMODITY_CODE')
            self.COMMODITY_CODE = COMMODITY_CODE_
            # validate type COMMODITY_CODEType
            self.validate_COMMODITY_CODEType(self.COMMODITY_CODE)
        elif nodeName_ == 'PRODUCT_CODE':
            PRODUCT_CODE_ = child_.text
            PRODUCT_CODE_ = self.gds_validate_string(PRODUCT_CODE_, node, 'PRODUCT_CODE')
            self.PRODUCT_CODE = PRODUCT_CODE_
            # validate type PRODUCT_CODEType
            self.validate_PRODUCT_CODEType(self.PRODUCT_CODE)
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
            # validate type DESCRIPTIONType
            self.validate_DESCRIPTIONType(self.DESCRIPTION)
        elif nodeName_ == 'QUANTITY' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'QUANTITY')
            self.QUANTITY = fval_
        elif nodeName_ == 'UNIT_OF_MEASURE':
            UNIT_OF_MEASURE_ = child_.text
            UNIT_OF_MEASURE_ = self.gds_validate_string(UNIT_OF_MEASURE_, node, 'UNIT_OF_MEASURE')
            self.UNIT_OF_MEASURE = UNIT_OF_MEASURE_
            # validate type UNIT_OF_MEASUREType
            self.validate_UNIT_OF_MEASUREType(self.UNIT_OF_MEASURE)
        elif nodeName_ == 'UNIT_PRICE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'UNIT_PRICE')
            self.UNIT_PRICE = fval_
            # validate type UNIT_PRICEType
            self.validate_UNIT_PRICEType(self.UNIT_PRICE)
        elif nodeName_ == 'DISCOUNT_RATE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DISCOUNT_RATE')
            self.DISCOUNT_RATE = fval_
            # validate type DISCOUNT_RATEType
            self.validate_DISCOUNT_RATEType(self.DISCOUNT_RATE)
        elif nodeName_ == 'TAX_RATE' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TAX_RATE')
            self.TAX_RATE = fval_
            # validate type TAX_RATEType
            self.validate_TAX_RATEType(self.TAX_RATE)
        elif nodeName_ == 'TOTAL_AMOUNT':
            TOTAL_AMOUNT_ = child_.text
            TOTAL_AMOUNT_ = self.gds_validate_string(TOTAL_AMOUNT_, node, 'TOTAL_AMOUNT')
            self.TOTAL_AMOUNT = TOTAL_AMOUNT_
            # validate type emptyDecimalAllowed
            self.validate_emptyDecimalAllowed(self.TOTAL_AMOUNT)
    def sample_method(self):
        pass
# end class LINE_ITEMType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'xs_string'
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'xs_string'
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'xs_string'
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'xs_string'
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from payment_page import *\n\n')
        sys.stdout.write('import payment_page as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ACCOUNT_NAME",
    "ACCOUNT_NUMBER",
    "ACCOUNT_TYPE",
    "ACHREFERENCE",
    "ACHSECUREREGISTRATION",
    "ACHSECUREREGISTRATIONRESPONSE",
    "ACHSECUREUPDATE",
    "ACHSECUREUPDATERESPONSE",
    "ACH_ACCOUNT",
    "ACH_ACCOUNT_TYPE",
    "ACH_ADDRESS1",
    "ACH_ADDRESS2",
    "ACH_CHECK_NUMBER",
    "ACH_CITY",
    "ACH_FIRST_NAME",
    "ACH_LAST_NAME",
    "ACH_NOTIFICATION_URL",
    "ACH_PHONE_NUMBER",
    "ACH_SECURE",
    "ACH_SEC_CODE",
    "ACH_STATE",
    "ACH_SUBSCRIPTION_PAYMENT",
    "ACH_SUBSCRIPTION_PAYMENT_RESPONSE",
    "ACH_TERMINALID",
    "ACH_ZIP",
    "ADDRESS1",
    "ADDRESS2",
    "ADDSTOREDSUBSCRIPTION",
    "ADDSTOREDSUBSCRIPTIONRESPONSE",
    "ADDSUBSCRIPTION",
    "ADDSUBSCRIPTIONRESPONSE",
    "ADD_ACH_SUBSCRIPTION",
    "ADD_ACH_SUBSCRIPTION_RESPONSE",
    "APPROVALCODE",
    "AUTOREADY",
    "AVSRESPONSE",
    "BANKRESPONSECODE",
    "BILLTOFIRSTNAME",
    "BILLTOLASTNAME",
    "CARDDETAILS",
    "CARDEXPIRY",
    "CARDHOLDERNAME",
    "CARDNUMBER",
    "CARDTYPE",
    "CHECK_NUMBER",
    "CITY",
    "COUNTRY",
    "CREDENTIALONFILE",
    "CURRENCY",
    "CVVRESPONSE",
    "DATETIME",
    "DESCRIPTION",
    "DL_NUMBER",
    "DL_STATE",
    "EDCCDECISION",
    "EMAIL",
    "ENDDATE",
    "ERROR",
    "ERRORCODE",
    "ERRORSTRING",
    "HASH",
    "IPADDRESS",
    "LEVEL_2_DATA",
    "LEVEL_3_DATA",
    "LINE_ITEMSType",
    "LINE_ITEMType",
    "MERCHANTREF",
    "MOBILENUMBER",
    "NAME",
    "NEWSTOREDSUBSCRIPTIONINFO",
    "NOTIFICATIONLANGUAGE",
    "ONDELETE",
    "ONUPDATE",
    "ORDERID",
    "PAYMENTACH",
    "PAYMENTACHRESPONSE",
    "PAYMENTRESPONSE",
    "PAYMENTTYPE",
    "PERIODTYPE",
    "PHONE",
    "POSTCODE",
    "PREAUTH",
    "PREAUTHRESPONSE",
    "PROCESSINGTERMINAL",
    "PaymentPage",
    "RECEIPTPAGEURL",
    "REGION",
    "RESPONSECODE",
    "RESPONSETEXT",
    "ROUTING_NUMBER",
    "SECUREACHACCOUNTMERCHANTREF",
    "SECURECARDMERCHANTREF",
    "SECURECARDREFERENCE",
    "SECURECARDREGISTRATION",
    "SECURECARDREGISTRATIONRESPONSE",
    "SECURECARDUPDATE",
    "SECURECARDUPDATERESPONSE",
    "SEC_CODE",
    "SHIPPING_ADDRESSType",
    "STARTDATE",
    "STOREDSUBSCRIPTIONREF",
    "SUBSCRIPTIONPAYMENT",
    "SUBSCRIPTIONPAYMENTRESPONSE",
    "SUBSCRIPTIONREF",
    "SUMMARYType",
    "TERMINALID",
    "TERMINALTYPE",
    "TRANSACTIONTYPE",
    "TYPE",
    "UPDATESTOREDSUBSCRIPTION",
    "UPDATESTOREDSUBSCRIPTIONRESPONSE",
    "UPDATESUBSCRIPTION",
    "UPDATESUBSCRIPTIONRESPONSE",
    "UPDATE_ACH_SUBSCRIPTION",
    "UPDATE_ACH_SUBSCRIPTION_RESPONSE",
    "VALIDATIONURL"
]
