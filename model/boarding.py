#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated  by generateDS.py.
# Python 3.8.5 (default, Jan 27 2021, 15:41:15)  [GCC 9.3.0]
#
# Command line options:
#   ('--user-methods', 'boarding_user_methods')
#   ('--export', 'etree literal')
#   ('--use-getter-setter', 'new')
#   ('--no-dates', '')
#   ('--no-versions', '')
#   ('-f', '')
#   ('-o', 'boarding.py')
#
# Command line arguments:
#   boarding.xsd
#
# Command line:
#   /usr/local/bin/generateDS --user-methods="boarding_user_methods" --export="etree literal" --use-getter-setter="new" --no-dates --no-versions -f -o "boarding.py" boarding.xsd
#
# Current working directory (os.getcwd()):
#   model
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class apiAddressModeEnum(object):
    EXACT='EXACT'
    POSTAL='POSTAL'


class avsActionEnum(object):
    HIDE='HIDE'
    DISPLAY='DISPLAY'
    EDITABLE='EDITABLE'


class avsResponseEnum(object):
    MATCH='MATCH'
    PARTIAL_MATCH_ADDRESS='PARTIAL_MATCH_ADDRESS'
    PARTIAL_MATCH_ZIP_CODE='PARTIAL_MATCH_ZIP_CODE'
    NOT_MATCH='NOT_MATCH'
    ADDRESS_NOT_VERIFIED_OR_UNAVAILABLE='ADDRESS_NOT_VERIFIED_OR_UNAVAILABLE'
    SYSTEM_UNAVAILABLE='SYSTEM_UNAVAILABLE'
    NOT_SUPPORTED='NOT_SUPPORTED'
    ABSENT_OR_INVALID_AVS='ABSENT_OR_INVALID_AVS'
    F='F'
    W='W'
    X='X'


class cardUpdaterTypeEnum(object):
    DISABLED='DISABLED'
    GLOBAL_VAU='GLOBAL_VAU'
    GLOBAL_ABU='GLOBAL_ABU'
    EURO_ABU='EURO_ABU'
    ELAVONPOS_VAU='ELAVONPOS_VAU'
    ELAVONPOS_ABU='ELAVONPOS_ABU'


class cvvResponseEnum(object):
    MATCH='MATCH'
    NOT_MATCH='NOT_MATCH'
    NOT_PROCESSED='NOT_PROCESSED'
    ISSUER_NOT_CERTIFIED='ISSUER_NOT_CERTIFIED'


class fieldSetupEnum(object):
    HIDDEN='HIDDEN'
    OPTIONAL='OPTIONAL'
    MANDATORY='MANDATORY'
    READONLY='READONLY'


class industryCodeEnum(object):
    UNKNOWN='UNKNOWN'
    AUTORENTAL='AUTORENTAL'
    FINANCIAL='FINANCIAL'
    MARKETING='MARKETING'
    FOOD='FOOD'
    GROCERY='GROCERY'
    HOTEL='HOTEL'
    LIMITED='LIMITED'
    OIL='OIL'
    PASSENGER='PASSENGER'
    RETAIL='RETAIL'


class languageIndicatorEnum(object):
    ENGLISH='ENGLISH'


class levelDataEnum(object):
    STANDARD='STANDARD'
    LEVEL_II='LEVEL_II'
    LEVEL_III='LEVEL_III'


class limitScopeEnum(object):
    DAILY='DAILY'
    MONTHLY='MONTHLY'
    SINGLE_TRANSACTION='SINGLE_TRANSACTION'


class monthlyFeeTypeEnum(object):
    INCLUDED_TRANS='INCLUDED_TRANS'
    MINIMUM='MINIMUM'


class paymentVersionEnum(object):
    VERSION__1='VERSION_1'
    VERSION__2='VERSION_2'


class pricingTypeEnum(object):
    MERCHANT_LEVEL='MERCHANT_LEVEL'
    TERMINAL_LEVEL='TERMINAL_LEVEL'


class reimbursementAttributeEnum(object):
    ATTRIBUTE__0='ATTRIBUTE_0'
    ATTRIBUTE_W='ATTRIBUTE_W'
    ATTRIBUTE_X='ATTRIBUTE_X'
    ATTRIBUTE_Y='ATTRIBUTE_Y'
    ATTRIBUTE_Z='ATTRIBUTE_Z'


class standardTransactionClassificationEnum(object):
    ALL='ALL'
    COMPLETED='COMPLETED'


class terminalCapabilityEnum(object):
    MAG_STRIPE_READ_ONLY='MAG_STRIPE_READ_ONLY'
    MAG_STRIPE_AND_MANUAL_ENTRY='MAG_STRIPE_AND_MANUAL_ENTRY'
    MANUAL_ENTRY_ONLY='MANUAL_ENTRY_ONLY'
    EMV_INCLUDE_PROXIMITY='EMV_INCLUDE_PROXIMITY'
    EMV_DOES_NOT_INCLUDE_CONTACT='EMV_DOES_NOT_INCLUDE_CONTACT'


class terminalTypeDefaultEnum(object):
    MOTO='MOTO'
    CHP='CHP'


class userActiveStatusEnum(object):
    ACTIVE='ACTIVE'
    DESACTIVATED_BY_MERCHANT='DESACTIVATED_BY_MERCHANT'
    DESACTIVATED_BY_ADMIN='DESACTIVATED_BY_ADMIN'
    MERCHANT_DESACTIVATED='MERCHANT_DESACTIVATED'


class userLockedStatusEnum(object):
    ACTIVE='ACTIVE'
    LOCKED_BY_TOO_MANY_ATTEMPTS='LOCKED_BY_TOO_MANY_ATTEMPTS'
    LOCKED_BY_ADMIN='LOCKED_BY_ADMIN'
    LOCKED_BY_SELF='LOCKED_BY_SELF'


class merchant(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('merchantId', 'xs:string', 0, 1, {'name': 'merchantId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('gatewayHost', 'xs:string', 0, 1, {'name': 'gatewayHost', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('dbaName', 'xs:string', 0, 0, {'name': 'dbaName', 'type': 'xs:string'}, None),
        MemberSpec_('templateName', 'xs:string', 0, 1, {'name': 'templateName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('contact', 'xs:string', 0, 0, {'name': 'contact', 'type': 'xs:string'}, None),
        MemberSpec_('phone', 'xs:string', 0, 0, {'name': 'phone', 'type': 'xs:string'}, None),
        MemberSpec_('email', 'xs:string', 0, 0, {'name': 'email', 'type': 'xs:string'}, None),
        MemberSpec_('website', 'xs:string', 0, 1, {'name': 'website', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('city', 'xs:string', 0, 0, {'name': 'city', 'type': 'xs:string'}, None),
        MemberSpec_('mcc', 'xs:string', 0, 0, {'name': 'mcc', 'type': 'xs:string'}, None),
        MemberSpec_('address1', 'xs:string', 0, 0, {'name': 'address1', 'type': 'xs:string'}, None),
        MemberSpec_('address2', 'xs:string', 0, 0, {'name': 'address2', 'type': 'xs:string'}, None),
        MemberSpec_('address3', 'xs:string', 0, 1, {'name': 'address3', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('pricingType', ['pricingTypeEnum', 'xs:string'], 0, 1, {'name': 'pricingType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('country', 'xs:string', 0, 0, {'name': 'country', 'type': 'xs:string'}, None),
        MemberSpec_('merchantPortfolioUniqueId', 'xs:string', 0, 1, {'name': 'merchantPortfolioUniqueId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('partnerPortfolioUniqueId', 'xs:string', 0, 1, {'name': 'partnerPortfolioUniqueId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('deactivationDate', 'xs:dateTime', 0, 1, {'name': 'deactivationDate', 'type': 'xs:dateTime', 'minOccurs': '0'}, None),
        MemberSpec_('timeZone', 'xs:string', 0, 0, {'name': 'timeZone', 'type': 'xs:string'}, None),
        MemberSpec_('merchantPricing', 'pricing', 0, 1, {'ref': 'merchantPricing', 'minOccurs': '0', 'name': 'merchantPricing', 'type': 'merchantPricing'}, None),
        MemberSpec_('merchantGeneralSetup', 'merchantGeneralSetup', 0, 1, {'name': 'merchantGeneralSetup', 'type': 'merchantGeneralSetup', 'minOccurs': '0'}, None),
        MemberSpec_('merchantCustomSettings', 'merchantCustomSettings', 1, 1, {'name': 'merchantCustomSettings', 'type': 'merchantCustomSettings', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, merchantId=None, gatewayHost=None, dbaName=None, templateName=None, contact=None, phone=None, email=None, website=None, city=None, mcc=None, address1=None, address2=None, address3=None, pricingType=None, country=None, merchantPortfolioUniqueId=None, partnerPortfolioUniqueId=None, deactivationDate=None, timeZone=None, merchantPricing=None, merchantGeneralSetup=None, merchantCustomSettings=None):
        self.original_tagname_ = None
        self.merchantId = merchantId
        self.gatewayHost = gatewayHost
        self.dbaName = dbaName
        self.templateName = templateName
        self.contact = contact
        self.phone = phone
        self.email = email
        self.website = website
        self.city = city
        self.mcc = mcc
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.pricingType = pricingType
        self.validate_pricingTypeEnum(self.pricingType)
        self.country = country
        self.merchantPortfolioUniqueId = merchantPortfolioUniqueId
        self.partnerPortfolioUniqueId = partnerPortfolioUniqueId
        if isinstance(deactivationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(deactivationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = deactivationDate
        self.deactivationDate = initvalue_
        self.timeZone = timeZone
        self.merchantPricing = merchantPricing
        self.merchantGeneralSetup = merchantGeneralSetup
        if merchantCustomSettings is None:
            self.merchantCustomSettings = []
        else:
            self.merchantCustomSettings = merchantCustomSettings
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, merchant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if merchant.subclass:
            return merchant.subclass(*args_, **kwargs_)
        else:
            return merchant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_merchantId(self): return self.merchantId
    def set_merchantId(self, merchantId): self.merchantId = merchantId
    def get_gatewayHost(self): return self.gatewayHost
    def set_gatewayHost(self, gatewayHost): self.gatewayHost = gatewayHost
    def get_dbaName(self): return self.dbaName
    def set_dbaName(self, dbaName): self.dbaName = dbaName
    def get_templateName(self): return self.templateName
    def set_templateName(self, templateName): self.templateName = templateName
    def get_contact(self): return self.contact
    def set_contact(self, contact): self.contact = contact
    def get_phone(self): return self.phone
    def set_phone(self, phone): self.phone = phone
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def get_website(self): return self.website
    def set_website(self, website): self.website = website
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_mcc(self): return self.mcc
    def set_mcc(self, mcc): self.mcc = mcc
    def get_address1(self): return self.address1
    def set_address1(self, address1): self.address1 = address1
    def get_address2(self): return self.address2
    def set_address2(self, address2): self.address2 = address2
    def get_address3(self): return self.address3
    def set_address3(self, address3): self.address3 = address3
    def get_pricingType(self): return self.pricingType
    def set_pricingType(self, pricingType): self.pricingType = pricingType
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_merchantPortfolioUniqueId(self): return self.merchantPortfolioUniqueId
    def set_merchantPortfolioUniqueId(self, merchantPortfolioUniqueId): self.merchantPortfolioUniqueId = merchantPortfolioUniqueId
    def get_partnerPortfolioUniqueId(self): return self.partnerPortfolioUniqueId
    def set_partnerPortfolioUniqueId(self, partnerPortfolioUniqueId): self.partnerPortfolioUniqueId = partnerPortfolioUniqueId
    def get_deactivationDate(self): return self.deactivationDate
    def set_deactivationDate(self, deactivationDate): self.deactivationDate = deactivationDate
    def get_timeZone(self): return self.timeZone
    def set_timeZone(self, timeZone): self.timeZone = timeZone
    def get_merchantPricing(self): return self.merchantPricing
    def set_merchantPricing(self, merchantPricing): self.merchantPricing = merchantPricing
    def get_merchantGeneralSetup(self): return self.merchantGeneralSetup
    def set_merchantGeneralSetup(self, merchantGeneralSetup): self.merchantGeneralSetup = merchantGeneralSetup
    def get_merchantCustomSettings(self): return self.merchantCustomSettings
    def set_merchantCustomSettings(self, merchantCustomSettings): self.merchantCustomSettings = merchantCustomSettings
    def add_merchantCustomSettings(self, value): self.merchantCustomSettings.append(value)
    def insert_merchantCustomSettings_at(self, index, value): self.merchantCustomSettings.insert(index, value)
    def replace_merchantCustomSettings_at(self, index, value): self.merchantCustomSettings[index] = value
    def validate_pricingTypeEnum(self, value):
        # Validate type pricingTypeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MERCHANT_LEVEL', 'TERMINAL_LEVEL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on pricingTypeEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.merchantId is not None or
            self.gatewayHost is not None or
            self.dbaName is not None or
            self.templateName is not None or
            self.contact is not None or
            self.phone is not None or
            self.email is not None or
            self.website is not None or
            self.city is not None or
            self.mcc is not None or
            self.address1 is not None or
            self.address2 is not None or
            self.address3 is not None or
            self.pricingType is not None or
            self.country is not None or
            self.merchantPortfolioUniqueId is not None or
            self.partnerPortfolioUniqueId is not None or
            self.deactivationDate is not None or
            self.timeZone is not None or
            self.merchantPricing is not None or
            self.merchantGeneralSetup is not None or
            self.merchantCustomSettings
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='merchant', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.merchantId is not None:
            merchantId_ = self.merchantId
            etree_.SubElement(element, '{}merchantId').text = self.gds_format_string(merchantId_)
        if self.gatewayHost is not None:
            gatewayHost_ = self.gatewayHost
            etree_.SubElement(element, '{}gatewayHost').text = self.gds_format_string(gatewayHost_)
        if self.dbaName is not None:
            dbaName_ = self.dbaName
            etree_.SubElement(element, '{}dbaName').text = self.gds_format_string(dbaName_)
        if self.templateName is not None:
            templateName_ = self.templateName
            etree_.SubElement(element, '{}templateName').text = self.gds_format_string(templateName_)
        if self.contact is not None:
            contact_ = self.contact
            etree_.SubElement(element, '{}contact').text = self.gds_format_string(contact_)
        if self.phone is not None:
            phone_ = self.phone
            etree_.SubElement(element, '{}phone').text = self.gds_format_string(phone_)
        if self.email is not None:
            email_ = self.email
            etree_.SubElement(element, '{}email').text = self.gds_format_string(email_)
        if self.website is not None:
            website_ = self.website
            etree_.SubElement(element, '{}website').text = self.gds_format_string(website_)
        if self.city is not None:
            city_ = self.city
            etree_.SubElement(element, '{}city').text = self.gds_format_string(city_)
        if self.mcc is not None:
            mcc_ = self.mcc
            etree_.SubElement(element, '{}mcc').text = self.gds_format_string(mcc_)
        if self.address1 is not None:
            address1_ = self.address1
            etree_.SubElement(element, '{}address1').text = self.gds_format_string(address1_)
        if self.address2 is not None:
            address2_ = self.address2
            etree_.SubElement(element, '{}address2').text = self.gds_format_string(address2_)
        if self.address3 is not None:
            address3_ = self.address3
            etree_.SubElement(element, '{}address3').text = self.gds_format_string(address3_)
        if self.pricingType is not None:
            pricingType_ = self.pricingType
            etree_.SubElement(element, '{}pricingType').text = self.gds_format_string(pricingType_)
        if self.country is not None:
            country_ = self.country
            etree_.SubElement(element, '{}country').text = self.gds_format_string(country_)
        if self.merchantPortfolioUniqueId is not None:
            merchantPortfolioUniqueId_ = self.merchantPortfolioUniqueId
            etree_.SubElement(element, '{}merchantPortfolioUniqueId').text = self.gds_format_string(merchantPortfolioUniqueId_)
        if self.partnerPortfolioUniqueId is not None:
            partnerPortfolioUniqueId_ = self.partnerPortfolioUniqueId
            etree_.SubElement(element, '{}partnerPortfolioUniqueId').text = self.gds_format_string(partnerPortfolioUniqueId_)
        if self.deactivationDate is not None:
            deactivationDate_ = self.deactivationDate
            etree_.SubElement(element, '{}deactivationDate').text = self.gds_format_datetime(deactivationDate_)
        if self.timeZone is not None:
            timeZone_ = self.timeZone
            etree_.SubElement(element, '{}timeZone').text = self.gds_format_string(timeZone_)
        if self.merchantPricing is not None:
            merchantPricing_ = self.merchantPricing
            merchantPricing_.to_etree(element, name_='merchantPricing', mapping_=mapping_)
        if self.merchantGeneralSetup is not None:
            merchantGeneralSetup_ = self.merchantGeneralSetup
            merchantGeneralSetup_.to_etree(element, name_='merchantGeneralSetup', mapping_=mapping_)
        for merchantCustomSettings_ in self.merchantCustomSettings:
            merchantCustomSettings_.to_etree(element, name_='merchantCustomSettings', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='merchant'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.merchantId is not None:
            showIndent(outfile, level)
            outfile.write('merchantId=%s,\n' % self.gds_encode(quote_python(self.merchantId)))
        if self.gatewayHost is not None:
            showIndent(outfile, level)
            outfile.write('gatewayHost=%s,\n' % self.gds_encode(quote_python(self.gatewayHost)))
        if self.dbaName is not None:
            showIndent(outfile, level)
            outfile.write('dbaName=%s,\n' % self.gds_encode(quote_python(self.dbaName)))
        if self.templateName is not None:
            showIndent(outfile, level)
            outfile.write('templateName=%s,\n' % self.gds_encode(quote_python(self.templateName)))
        if self.contact is not None:
            showIndent(outfile, level)
            outfile.write('contact=%s,\n' % self.gds_encode(quote_python(self.contact)))
        if self.phone is not None:
            showIndent(outfile, level)
            outfile.write('phone=%s,\n' % self.gds_encode(quote_python(self.phone)))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('email=%s,\n' % self.gds_encode(quote_python(self.email)))
        if self.website is not None:
            showIndent(outfile, level)
            outfile.write('website=%s,\n' % self.gds_encode(quote_python(self.website)))
        if self.city is not None:
            showIndent(outfile, level)
            outfile.write('city=%s,\n' % self.gds_encode(quote_python(self.city)))
        if self.mcc is not None:
            showIndent(outfile, level)
            outfile.write('mcc=%s,\n' % self.gds_encode(quote_python(self.mcc)))
        if self.address1 is not None:
            showIndent(outfile, level)
            outfile.write('address1=%s,\n' % self.gds_encode(quote_python(self.address1)))
        if self.address2 is not None:
            showIndent(outfile, level)
            outfile.write('address2=%s,\n' % self.gds_encode(quote_python(self.address2)))
        if self.address3 is not None:
            showIndent(outfile, level)
            outfile.write('address3=%s,\n' % self.gds_encode(quote_python(self.address3)))
        if self.pricingType is not None:
            showIndent(outfile, level)
            outfile.write('pricingType=%s,\n' % self.gds_encode(quote_python(self.pricingType)))
        if self.country is not None:
            showIndent(outfile, level)
            outfile.write('country=%s,\n' % self.gds_encode(quote_python(self.country)))
        if self.merchantPortfolioUniqueId is not None:
            showIndent(outfile, level)
            outfile.write('merchantPortfolioUniqueId=%s,\n' % self.gds_encode(quote_python(self.merchantPortfolioUniqueId)))
        if self.partnerPortfolioUniqueId is not None:
            showIndent(outfile, level)
            outfile.write('partnerPortfolioUniqueId=%s,\n' % self.gds_encode(quote_python(self.partnerPortfolioUniqueId)))
        if self.deactivationDate is not None:
            showIndent(outfile, level)
            outfile.write('deactivationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.deactivationDate, input_name='deactivationDate'))
        if self.timeZone is not None:
            showIndent(outfile, level)
            outfile.write('timeZone=%s,\n' % self.gds_encode(quote_python(self.timeZone)))
        if self.merchantPricing is not None:
            showIndent(outfile, level)
            outfile.write('merchantPricing=model_.merchantPricing(\n')
            self.merchantPricing.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.merchantGeneralSetup is not None:
            showIndent(outfile, level)
            outfile.write('merchantGeneralSetup=model_.merchantGeneralSetup(\n')
            self.merchantGeneralSetup.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('merchantCustomSettings=[\n')
        level += 1
        for merchantCustomSettings_ in self.merchantCustomSettings:
            showIndent(outfile, level)
            outfile.write('model_.merchantCustomSettings(\n')
            merchantCustomSettings_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'merchantId':
            merchantId_ = child_.text
            merchantId_ = self.gds_validate_string(merchantId_, node, 'merchantId')
            self.merchantId = merchantId_
        elif nodeName_ == 'gatewayHost':
            gatewayHost_ = child_.text
            gatewayHost_ = self.gds_validate_string(gatewayHost_, node, 'gatewayHost')
            self.gatewayHost = gatewayHost_
        elif nodeName_ == 'dbaName':
            dbaName_ = child_.text
            dbaName_ = self.gds_validate_string(dbaName_, node, 'dbaName')
            self.dbaName = dbaName_
        elif nodeName_ == 'templateName':
            templateName_ = child_.text
            templateName_ = self.gds_validate_string(templateName_, node, 'templateName')
            self.templateName = templateName_
        elif nodeName_ == 'contact':
            contact_ = child_.text
            contact_ = self.gds_validate_string(contact_, node, 'contact')
            self.contact = contact_
        elif nodeName_ == 'phone':
            phone_ = child_.text
            phone_ = self.gds_validate_string(phone_, node, 'phone')
            self.phone = phone_
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
        elif nodeName_ == 'website':
            website_ = child_.text
            website_ = self.gds_validate_string(website_, node, 'website')
            self.website = website_
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
        elif nodeName_ == 'mcc':
            mcc_ = child_.text
            mcc_ = self.gds_validate_string(mcc_, node, 'mcc')
            self.mcc = mcc_
        elif nodeName_ == 'address1':
            address1_ = child_.text
            address1_ = self.gds_validate_string(address1_, node, 'address1')
            self.address1 = address1_
        elif nodeName_ == 'address2':
            address2_ = child_.text
            address2_ = self.gds_validate_string(address2_, node, 'address2')
            self.address2 = address2_
        elif nodeName_ == 'address3':
            address3_ = child_.text
            address3_ = self.gds_validate_string(address3_, node, 'address3')
            self.address3 = address3_
        elif nodeName_ == 'pricingType':
            pricingType_ = child_.text
            pricingType_ = self.gds_validate_string(pricingType_, node, 'pricingType')
            self.pricingType = pricingType_
            # validate type pricingTypeEnum
            self.validate_pricingTypeEnum(self.pricingType)
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
        elif nodeName_ == 'merchantPortfolioUniqueId':
            merchantPortfolioUniqueId_ = child_.text
            merchantPortfolioUniqueId_ = self.gds_validate_string(merchantPortfolioUniqueId_, node, 'merchantPortfolioUniqueId')
            self.merchantPortfolioUniqueId = merchantPortfolioUniqueId_
        elif nodeName_ == 'partnerPortfolioUniqueId':
            partnerPortfolioUniqueId_ = child_.text
            partnerPortfolioUniqueId_ = self.gds_validate_string(partnerPortfolioUniqueId_, node, 'partnerPortfolioUniqueId')
            self.partnerPortfolioUniqueId = partnerPortfolioUniqueId_
        elif nodeName_ == 'deactivationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.deactivationDate = dval_
        elif nodeName_ == 'timeZone':
            timeZone_ = child_.text
            timeZone_ = self.gds_validate_string(timeZone_, node, 'timeZone')
            self.timeZone = timeZone_
        elif nodeName_ == 'merchantPricing':
            obj_ = pricing.factory()
            obj_.build(child_)
            self.merchantPricing = obj_
            obj_.original_tagname_ = 'merchantPricing'
        elif nodeName_ == 'merchantGeneralSetup':
            obj_ = merchantGeneralSetup.factory()
            obj_.build(child_)
            self.merchantGeneralSetup = obj_
            obj_.original_tagname_ = 'merchantGeneralSetup'
        elif nodeName_ == 'merchantCustomSettings':
            obj_ = merchantCustomSettings.factory()
            obj_.build(child_)
            self.merchantCustomSettings.append(obj_)
            obj_.original_tagname_ = 'merchantCustomSettings'
    def sample_method(self):
        pass
# end class merchant


class pricing(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('monthlyFee', 'xs:double', 0, 0, {'name': 'monthlyFee', 'type': 'xs:double'}, None),
        MemberSpec_('monthlyFeeType', ['monthlyFeeTypeEnum', 'xs:string'], 0, 0, {'name': 'monthlyFeeType', 'type': 'xs:string'}, None),
        MemberSpec_('monthlyIncludedStandardTransactions', 'xs:int', 0, 0, {'name': 'monthlyIncludedStandardTransactions', 'type': 'xs:int'}, None),
        MemberSpec_('perStandardTxnFee', 'xs:double', 0, 0, {'name': 'perStandardTxnFee', 'type': 'xs:double'}, None),
        MemberSpec_('perThreedTxnFee', 'xs:double', 0, 0, {'name': 'perThreedTxnFee', 'type': 'xs:double'}, None),
        MemberSpec_('perEdccTxnFee', 'xs:double', 0, 0, {'name': 'perEdccTxnFee', 'type': 'xs:double'}, None),
        MemberSpec_('perSecureCardTxnFee', 'xs:double', 0, 0, {'name': 'perSecureCardTxnFee', 'type': 'xs:double'}, None),
        MemberSpec_('perSmsFee', 'xs:double', 0, 0, {'name': 'perSmsFee', 'type': 'xs:double'}, None),
        MemberSpec_('maxMindRequestFee', 'xs:double', 0, 0, {'name': 'maxMindRequestFee', 'type': 'xs:double'}, None),
        MemberSpec_('maxMindRejectionFee', 'xs:double', 0, 0, {'name': 'maxMindRejectionFee', 'type': 'xs:double'}, None),
        MemberSpec_('standardTransactionClassification', ['standardTransactionClassificationEnum', 'xs:string'], 0, 1, {'name': 'standardTransactionClassification', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, monthlyFee=None, monthlyFeeType=None, monthlyIncludedStandardTransactions=None, perStandardTxnFee=None, perThreedTxnFee=None, perEdccTxnFee=None, perSecureCardTxnFee=None, perSmsFee=None, maxMindRequestFee=None, maxMindRejectionFee=None, standardTransactionClassification=None):
        self.original_tagname_ = None
        self.monthlyFee = monthlyFee
        self.monthlyFeeType = monthlyFeeType
        self.validate_monthlyFeeTypeEnum(self.monthlyFeeType)
        self.monthlyIncludedStandardTransactions = monthlyIncludedStandardTransactions
        self.perStandardTxnFee = perStandardTxnFee
        self.perThreedTxnFee = perThreedTxnFee
        self.perEdccTxnFee = perEdccTxnFee
        self.perSecureCardTxnFee = perSecureCardTxnFee
        self.perSmsFee = perSmsFee
        self.maxMindRequestFee = maxMindRequestFee
        self.maxMindRejectionFee = maxMindRejectionFee
        self.standardTransactionClassification = standardTransactionClassification
        self.validate_standardTransactionClassificationEnum(self.standardTransactionClassification)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pricing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pricing.subclass:
            return pricing.subclass(*args_, **kwargs_)
        else:
            return pricing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monthlyFee(self): return self.monthlyFee
    def set_monthlyFee(self, monthlyFee): self.monthlyFee = monthlyFee
    def get_monthlyFeeType(self): return self.monthlyFeeType
    def set_monthlyFeeType(self, monthlyFeeType): self.monthlyFeeType = monthlyFeeType
    def get_monthlyIncludedStandardTransactions(self): return self.monthlyIncludedStandardTransactions
    def set_monthlyIncludedStandardTransactions(self, monthlyIncludedStandardTransactions): self.monthlyIncludedStandardTransactions = monthlyIncludedStandardTransactions
    def get_perStandardTxnFee(self): return self.perStandardTxnFee
    def set_perStandardTxnFee(self, perStandardTxnFee): self.perStandardTxnFee = perStandardTxnFee
    def get_perThreedTxnFee(self): return self.perThreedTxnFee
    def set_perThreedTxnFee(self, perThreedTxnFee): self.perThreedTxnFee = perThreedTxnFee
    def get_perEdccTxnFee(self): return self.perEdccTxnFee
    def set_perEdccTxnFee(self, perEdccTxnFee): self.perEdccTxnFee = perEdccTxnFee
    def get_perSecureCardTxnFee(self): return self.perSecureCardTxnFee
    def set_perSecureCardTxnFee(self, perSecureCardTxnFee): self.perSecureCardTxnFee = perSecureCardTxnFee
    def get_perSmsFee(self): return self.perSmsFee
    def set_perSmsFee(self, perSmsFee): self.perSmsFee = perSmsFee
    def get_maxMindRequestFee(self): return self.maxMindRequestFee
    def set_maxMindRequestFee(self, maxMindRequestFee): self.maxMindRequestFee = maxMindRequestFee
    def get_maxMindRejectionFee(self): return self.maxMindRejectionFee
    def set_maxMindRejectionFee(self, maxMindRejectionFee): self.maxMindRejectionFee = maxMindRejectionFee
    def get_standardTransactionClassification(self): return self.standardTransactionClassification
    def set_standardTransactionClassification(self, standardTransactionClassification): self.standardTransactionClassification = standardTransactionClassification
    def validate_monthlyFeeTypeEnum(self, value):
        # Validate type monthlyFeeTypeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['INCLUDED_TRANS', 'MINIMUM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on monthlyFeeTypeEnum' % {"value" : value.encode("utf-8")} )
    def validate_standardTransactionClassificationEnum(self, value):
        # Validate type standardTransactionClassificationEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ALL', 'COMPLETED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on standardTransactionClassificationEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.monthlyFee is not None or
            self.monthlyFeeType is not None or
            self.monthlyIncludedStandardTransactions is not None or
            self.perStandardTxnFee is not None or
            self.perThreedTxnFee is not None or
            self.perEdccTxnFee is not None or
            self.perSecureCardTxnFee is not None or
            self.perSmsFee is not None or
            self.maxMindRequestFee is not None or
            self.maxMindRejectionFee is not None or
            self.standardTransactionClassification is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='pricing', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.monthlyFee is not None:
            monthlyFee_ = self.monthlyFee
            etree_.SubElement(element, '{}monthlyFee').text = self.gds_format_double(monthlyFee_)
        if self.monthlyFeeType is not None:
            monthlyFeeType_ = self.monthlyFeeType
            etree_.SubElement(element, '{}monthlyFeeType').text = self.gds_format_string(monthlyFeeType_)
        if self.monthlyIncludedStandardTransactions is not None:
            monthlyIncludedStandardTransactions_ = self.monthlyIncludedStandardTransactions
            etree_.SubElement(element, '{}monthlyIncludedStandardTransactions').text = self.gds_format_integer(monthlyIncludedStandardTransactions_)
        if self.perStandardTxnFee is not None:
            perStandardTxnFee_ = self.perStandardTxnFee
            etree_.SubElement(element, '{}perStandardTxnFee').text = self.gds_format_double(perStandardTxnFee_)
        if self.perThreedTxnFee is not None:
            perThreedTxnFee_ = self.perThreedTxnFee
            etree_.SubElement(element, '{}perThreedTxnFee').text = self.gds_format_double(perThreedTxnFee_)
        if self.perEdccTxnFee is not None:
            perEdccTxnFee_ = self.perEdccTxnFee
            etree_.SubElement(element, '{}perEdccTxnFee').text = self.gds_format_double(perEdccTxnFee_)
        if self.perSecureCardTxnFee is not None:
            perSecureCardTxnFee_ = self.perSecureCardTxnFee
            etree_.SubElement(element, '{}perSecureCardTxnFee').text = self.gds_format_double(perSecureCardTxnFee_)
        if self.perSmsFee is not None:
            perSmsFee_ = self.perSmsFee
            etree_.SubElement(element, '{}perSmsFee').text = self.gds_format_double(perSmsFee_)
        if self.maxMindRequestFee is not None:
            maxMindRequestFee_ = self.maxMindRequestFee
            etree_.SubElement(element, '{}maxMindRequestFee').text = self.gds_format_double(maxMindRequestFee_)
        if self.maxMindRejectionFee is not None:
            maxMindRejectionFee_ = self.maxMindRejectionFee
            etree_.SubElement(element, '{}maxMindRejectionFee').text = self.gds_format_double(maxMindRejectionFee_)
        if self.standardTransactionClassification is not None:
            standardTransactionClassification_ = self.standardTransactionClassification
            etree_.SubElement(element, '{}standardTransactionClassification').text = self.gds_format_string(standardTransactionClassification_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='pricing'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.monthlyFee is not None:
            showIndent(outfile, level)
            outfile.write('monthlyFee=%e,\n' % self.monthlyFee)
        if self.monthlyFeeType is not None:
            showIndent(outfile, level)
            outfile.write('monthlyFeeType=%s,\n' % self.gds_encode(quote_python(self.monthlyFeeType)))
        if self.monthlyIncludedStandardTransactions is not None:
            showIndent(outfile, level)
            outfile.write('monthlyIncludedStandardTransactions=%d,\n' % self.monthlyIncludedStandardTransactions)
        if self.perStandardTxnFee is not None:
            showIndent(outfile, level)
            outfile.write('perStandardTxnFee=%e,\n' % self.perStandardTxnFee)
        if self.perThreedTxnFee is not None:
            showIndent(outfile, level)
            outfile.write('perThreedTxnFee=%e,\n' % self.perThreedTxnFee)
        if self.perEdccTxnFee is not None:
            showIndent(outfile, level)
            outfile.write('perEdccTxnFee=%e,\n' % self.perEdccTxnFee)
        if self.perSecureCardTxnFee is not None:
            showIndent(outfile, level)
            outfile.write('perSecureCardTxnFee=%e,\n' % self.perSecureCardTxnFee)
        if self.perSmsFee is not None:
            showIndent(outfile, level)
            outfile.write('perSmsFee=%e,\n' % self.perSmsFee)
        if self.maxMindRequestFee is not None:
            showIndent(outfile, level)
            outfile.write('maxMindRequestFee=%e,\n' % self.maxMindRequestFee)
        if self.maxMindRejectionFee is not None:
            showIndent(outfile, level)
            outfile.write('maxMindRejectionFee=%e,\n' % self.maxMindRejectionFee)
        if self.standardTransactionClassification is not None:
            showIndent(outfile, level)
            outfile.write('standardTransactionClassification=%s,\n' % self.gds_encode(quote_python(self.standardTransactionClassification)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monthlyFee' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'monthlyFee')
            self.monthlyFee = fval_
        elif nodeName_ == 'monthlyFeeType':
            monthlyFeeType_ = child_.text
            monthlyFeeType_ = self.gds_validate_string(monthlyFeeType_, node, 'monthlyFeeType')
            self.monthlyFeeType = monthlyFeeType_
            # validate type monthlyFeeTypeEnum
            self.validate_monthlyFeeTypeEnum(self.monthlyFeeType)
        elif nodeName_ == 'monthlyIncludedStandardTransactions' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyIncludedStandardTransactions')
            self.monthlyIncludedStandardTransactions = ival_
        elif nodeName_ == 'perStandardTxnFee' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'perStandardTxnFee')
            self.perStandardTxnFee = fval_
        elif nodeName_ == 'perThreedTxnFee' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'perThreedTxnFee')
            self.perThreedTxnFee = fval_
        elif nodeName_ == 'perEdccTxnFee' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'perEdccTxnFee')
            self.perEdccTxnFee = fval_
        elif nodeName_ == 'perSecureCardTxnFee' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'perSecureCardTxnFee')
            self.perSecureCardTxnFee = fval_
        elif nodeName_ == 'perSmsFee' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'perSmsFee')
            self.perSmsFee = fval_
        elif nodeName_ == 'maxMindRequestFee' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maxMindRequestFee')
            self.maxMindRequestFee = fval_
        elif nodeName_ == 'maxMindRejectionFee' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maxMindRejectionFee')
            self.maxMindRejectionFee = fval_
        elif nodeName_ == 'standardTransactionClassification':
            standardTransactionClassification_ = child_.text
            standardTransactionClassification_ = self.gds_validate_string(standardTransactionClassification_, node, 'standardTransactionClassification')
            self.standardTransactionClassification = standardTransactionClassification_
            # validate type standardTransactionClassificationEnum
            self.validate_standardTransactionClassificationEnum(self.standardTransactionClassification)
    def sample_method(self):
        pass
# end class pricing


class merchantGeneralSetup(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('shareAllSecureCards', 'xs:boolean', 0, 0, {'name': 'shareAllSecureCards', 'type': 'xs:boolean'}, None),
        MemberSpec_('shareCardsFromDeactivatedTerminals', 'xs:boolean', 0, 1, {'name': 'shareCardsFromDeactivatedTerminals', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('enableMerchantLevelLimits', 'xs:boolean', 0, 0, {'name': 'enableMerchantLevelLimits', 'type': 'xs:boolean'}, None),
        MemberSpec_('merchantLevelLimits', 'merchantLevelLimitsType', 0, 1, {'name': 'merchantLevelLimits', 'minOccurs': '0', 'type': 'merchantLevelLimitsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, shareAllSecureCards=None, shareCardsFromDeactivatedTerminals=None, enableMerchantLevelLimits=None, merchantLevelLimits=None):
        self.original_tagname_ = None
        self.shareAllSecureCards = shareAllSecureCards
        self.shareCardsFromDeactivatedTerminals = shareCardsFromDeactivatedTerminals
        self.enableMerchantLevelLimits = enableMerchantLevelLimits
        self.merchantLevelLimits = merchantLevelLimits
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, merchantGeneralSetup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if merchantGeneralSetup.subclass:
            return merchantGeneralSetup.subclass(*args_, **kwargs_)
        else:
            return merchantGeneralSetup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_shareAllSecureCards(self): return self.shareAllSecureCards
    def set_shareAllSecureCards(self, shareAllSecureCards): self.shareAllSecureCards = shareAllSecureCards
    def get_shareCardsFromDeactivatedTerminals(self): return self.shareCardsFromDeactivatedTerminals
    def set_shareCardsFromDeactivatedTerminals(self, shareCardsFromDeactivatedTerminals): self.shareCardsFromDeactivatedTerminals = shareCardsFromDeactivatedTerminals
    def get_enableMerchantLevelLimits(self): return self.enableMerchantLevelLimits
    def set_enableMerchantLevelLimits(self, enableMerchantLevelLimits): self.enableMerchantLevelLimits = enableMerchantLevelLimits
    def get_merchantLevelLimits(self): return self.merchantLevelLimits
    def set_merchantLevelLimits(self, merchantLevelLimits): self.merchantLevelLimits = merchantLevelLimits
    def hasContent_(self):
        if (
            self.shareAllSecureCards is not None or
            self.shareCardsFromDeactivatedTerminals is not None or
            self.enableMerchantLevelLimits is not None or
            self.merchantLevelLimits is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='merchantGeneralSetup', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.shareAllSecureCards is not None:
            shareAllSecureCards_ = self.shareAllSecureCards
            etree_.SubElement(element, '{}shareAllSecureCards').text = self.gds_format_boolean(shareAllSecureCards_)
        if self.shareCardsFromDeactivatedTerminals is not None:
            shareCardsFromDeactivatedTerminals_ = self.shareCardsFromDeactivatedTerminals
            etree_.SubElement(element, '{}shareCardsFromDeactivatedTerminals').text = self.gds_format_boolean(shareCardsFromDeactivatedTerminals_)
        if self.enableMerchantLevelLimits is not None:
            enableMerchantLevelLimits_ = self.enableMerchantLevelLimits
            etree_.SubElement(element, '{}enableMerchantLevelLimits').text = self.gds_format_boolean(enableMerchantLevelLimits_)
        if self.merchantLevelLimits is not None:
            merchantLevelLimits_ = self.merchantLevelLimits
            merchantLevelLimits_.to_etree(element, name_='merchantLevelLimits', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='merchantGeneralSetup'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.shareAllSecureCards is not None:
            showIndent(outfile, level)
            outfile.write('shareAllSecureCards=%s,\n' % self.shareAllSecureCards)
        if self.shareCardsFromDeactivatedTerminals is not None:
            showIndent(outfile, level)
            outfile.write('shareCardsFromDeactivatedTerminals=%s,\n' % self.shareCardsFromDeactivatedTerminals)
        if self.enableMerchantLevelLimits is not None:
            showIndent(outfile, level)
            outfile.write('enableMerchantLevelLimits=%s,\n' % self.enableMerchantLevelLimits)
        if self.merchantLevelLimits is not None:
            showIndent(outfile, level)
            outfile.write('merchantLevelLimits=model_.merchantLevelLimitsType(\n')
            self.merchantLevelLimits.exportLiteral(outfile, level, name_='merchantLevelLimits')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'shareAllSecureCards':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'shareAllSecureCards')
            self.shareAllSecureCards = ival_
        elif nodeName_ == 'shareCardsFromDeactivatedTerminals':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'shareCardsFromDeactivatedTerminals')
            self.shareCardsFromDeactivatedTerminals = ival_
        elif nodeName_ == 'enableMerchantLevelLimits':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableMerchantLevelLimits')
            self.enableMerchantLevelLimits = ival_
        elif nodeName_ == 'merchantLevelLimits':
            obj_ = merchantLevelLimitsType.factory()
            obj_.build(child_)
            self.merchantLevelLimits = obj_
            obj_.original_tagname_ = 'merchantLevelLimits'
    def sample_method(self):
        pass
# end class merchantGeneralSetup


class volumeLimit(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('limitScope', ['limitScopeEnum', 'xs:string'], 0, 0, {'name': 'limitScope', 'type': 'xs:string'}, None),
        MemberSpec_('limitThreshold', 'xs:int', 0, 0, {'name': 'limitThreshold', 'type': 'xs:int'}, None),
        MemberSpec_('withoutCvvOnly', 'xs:boolean', 0, 1, {'name': 'withoutCvvOnly', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('withoutAvsOnly', 'xs:boolean', 0, 1, {'name': 'withoutAvsOnly', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, limitScope=None, limitThreshold=None, withoutCvvOnly=None, withoutAvsOnly=None, extensiontype_=None):
        self.original_tagname_ = None
        self.limitScope = limitScope
        self.validate_limitScopeEnum(self.limitScope)
        self.limitThreshold = limitThreshold
        self.withoutCvvOnly = withoutCvvOnly
        self.withoutAvsOnly = withoutAvsOnly
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, volumeLimit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if volumeLimit.subclass:
            return volumeLimit.subclass(*args_, **kwargs_)
        else:
            return volumeLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_limitScope(self): return self.limitScope
    def set_limitScope(self, limitScope): self.limitScope = limitScope
    def get_limitThreshold(self): return self.limitThreshold
    def set_limitThreshold(self, limitThreshold): self.limitThreshold = limitThreshold
    def get_withoutCvvOnly(self): return self.withoutCvvOnly
    def set_withoutCvvOnly(self, withoutCvvOnly): self.withoutCvvOnly = withoutCvvOnly
    def get_withoutAvsOnly(self): return self.withoutAvsOnly
    def set_withoutAvsOnly(self, withoutAvsOnly): self.withoutAvsOnly = withoutAvsOnly
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_limitScopeEnum(self, value):
        # Validate type limitScopeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DAILY', 'MONTHLY', 'SINGLE_TRANSACTION']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on limitScopeEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.limitScope is not None or
            self.limitThreshold is not None or
            self.withoutCvvOnly is not None or
            self.withoutAvsOnly is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='volumeLimit', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.limitScope is not None:
            limitScope_ = self.limitScope
            etree_.SubElement(element, '{}limitScope').text = self.gds_format_string(limitScope_)
        if self.limitThreshold is not None:
            limitThreshold_ = self.limitThreshold
            etree_.SubElement(element, '{}limitThreshold').text = self.gds_format_integer(limitThreshold_)
        if self.withoutCvvOnly is not None:
            withoutCvvOnly_ = self.withoutCvvOnly
            etree_.SubElement(element, '{}withoutCvvOnly').text = self.gds_format_boolean(withoutCvvOnly_)
        if self.withoutAvsOnly is not None:
            withoutAvsOnly_ = self.withoutAvsOnly
            etree_.SubElement(element, '{}withoutAvsOnly').text = self.gds_format_boolean(withoutAvsOnly_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='volumeLimit'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.limitScope is not None:
            showIndent(outfile, level)
            outfile.write('limitScope=%s,\n' % self.gds_encode(quote_python(self.limitScope)))
        if self.limitThreshold is not None:
            showIndent(outfile, level)
            outfile.write('limitThreshold=%d,\n' % self.limitThreshold)
        if self.withoutCvvOnly is not None:
            showIndent(outfile, level)
            outfile.write('withoutCvvOnly=%s,\n' % self.withoutCvvOnly)
        if self.withoutAvsOnly is not None:
            showIndent(outfile, level)
            outfile.write('withoutAvsOnly=%s,\n' % self.withoutAvsOnly)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'limitScope':
            limitScope_ = child_.text
            limitScope_ = self.gds_validate_string(limitScope_, node, 'limitScope')
            self.limitScope = limitScope_
            # validate type limitScopeEnum
            self.validate_limitScopeEnum(self.limitScope)
        elif nodeName_ == 'limitThreshold' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'limitThreshold')
            self.limitThreshold = ival_
        elif nodeName_ == 'withoutCvvOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'withoutCvvOnly')
            self.withoutCvvOnly = ival_
        elif nodeName_ == 'withoutAvsOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'withoutAvsOnly')
            self.withoutAvsOnly = ival_
    def sample_method(self):
        pass
# end class volumeLimit


class merchantCustomSettings(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('value', 'xs:string', 0, 1, {'name': 'value', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.original_tagname_ = None
        self.name = name
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, merchantCustomSettings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if merchantCustomSettings.subclass:
            return merchantCustomSettings.subclass(*args_, **kwargs_)
        else:
            return merchantCustomSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='merchantCustomSettings', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{}name').text = self.gds_format_string(name_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{}value').text = self.gds_format_string(value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='merchantCustomSettings'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % self.gds_encode(quote_python(self.name)))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % self.gds_encode(quote_python(self.value)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
    def sample_method(self):
        pass
# end class merchantCustomSettings


class user(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('userId', 'xs:string', 0, 1, {'name': 'userId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('userName', 'xs:string', 0, 0, {'name': 'userName', 'type': 'xs:string'}, None),
        MemberSpec_('merchantId', 'xs:string', 0, 0, {'name': 'merchantId', 'type': 'xs:string'}, None),
        MemberSpec_('userEmail', 'xs:string', 0, 0, {'name': 'userEmail', 'type': 'xs:string'}, None),
        MemberSpec_('timeZone', 'xs:string', 0, 0, {'name': 'timeZone', 'type': 'xs:string'}, None),
        MemberSpec_('allowTerminalSetup', 'xs:boolean', 0, 0, {'name': 'allowTerminalSetup', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowPaymentPageLayout', 'xs:boolean', 0, 0, {'name': 'allowPaymentPageLayout', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowRefund', 'xs:boolean', 0, 0, {'name': 'allowRefund', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowUnreferencedRefunds', 'xs:boolean', 0, 0, {'name': 'allowUnreferencedRefunds', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowVirtualTerminal', 'xs:boolean', 0, 0, {'name': 'allowVirtualTerminal', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowChpOnVt', 'xs:boolean', 0, 1, {'name': 'allowChpOnVt', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowUserSetup', 'xs:boolean', 0, 0, {'name': 'allowUserSetup', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowOpenBatch', 'xs:boolean', 0, 0, {'name': 'allowOpenBatch', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowClosedBatch', 'xs:boolean', 0, 0, {'name': 'allowClosedBatch', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowBulkPaymentsResults', 'xs:boolean', 0, 0, {'name': 'allowBulkPaymentsResults', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowBilling', 'xs:boolean', 0, 0, {'name': 'allowBilling', 'type': 'xs:boolean'}, None),
        MemberSpec_('lockedStatus', ['userLockedStatusEnum', 'xs:string'], 0, 1, {'name': 'lockedStatus', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('activeStatus', ['userActiveStatusEnum', 'xs:string'], 0, 1, {'name': 'activeStatus', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowPreauth', 'xs:boolean', 0, 0, {'name': 'allowPreauth', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowSecureCards', 'xs:boolean', 0, 0, {'name': 'allowSecureCards', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowSubscriptions', 'xs:boolean', 0, 0, {'name': 'allowSubscriptions', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowDashboard', 'xs:boolean', 0, 0, {'name': 'allowDashboard', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowAchjhtransactions', 'xs:boolean', 0, 0, {'name': 'allowAchjhtransactions', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowAchiptransactions', 'xs:boolean', 0, 0, {'name': 'allowAchiptransactions', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowPartialCaptures', 'xs:boolean', 0, 0, {'name': 'allowPartialCaptures', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowScheduledReport', 'xs:boolean', 0, 1, {'name': 'allowScheduledReport', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowApiKeyManagement', 'xs:boolean', 0, 1, {'name': 'allowApiKeyManagement', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('userProcessingTerminals', 'userProcessingTerminalsType', 0, 1, {'name': 'userProcessingTerminals', 'minOccurs': '0', 'type': 'userProcessingTerminalsType'}, None),
        MemberSpec_('templateName', 'xs:string', 0, 1, {'name': 'templateName', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, userId=None, userName=None, merchantId=None, userEmail=None, timeZone=None, allowTerminalSetup=None, allowPaymentPageLayout=None, allowRefund=None, allowUnreferencedRefunds=None, allowVirtualTerminal=None, allowChpOnVt=None, allowUserSetup=None, allowOpenBatch=None, allowClosedBatch=None, allowBulkPaymentsResults=None, allowBilling=None, lockedStatus=None, activeStatus=None, allowPreauth=None, allowSecureCards=None, allowSubscriptions=None, allowDashboard=None, allowAchjhtransactions=None, allowAchiptransactions=None, allowPartialCaptures=None, allowScheduledReport=None, allowApiKeyManagement=None, userProcessingTerminals=None, templateName=None):
        self.original_tagname_ = None
        self.userId = userId
        self.userName = userName
        self.merchantId = merchantId
        self.userEmail = userEmail
        self.timeZone = timeZone
        self.allowTerminalSetup = allowTerminalSetup
        self.allowPaymentPageLayout = allowPaymentPageLayout
        self.allowRefund = allowRefund
        self.allowUnreferencedRefunds = allowUnreferencedRefunds
        self.allowVirtualTerminal = allowVirtualTerminal
        self.allowChpOnVt = allowChpOnVt
        self.allowUserSetup = allowUserSetup
        self.allowOpenBatch = allowOpenBatch
        self.allowClosedBatch = allowClosedBatch
        self.allowBulkPaymentsResults = allowBulkPaymentsResults
        self.allowBilling = allowBilling
        self.lockedStatus = lockedStatus
        self.validate_userLockedStatusEnum(self.lockedStatus)
        self.activeStatus = activeStatus
        self.validate_userActiveStatusEnum(self.activeStatus)
        self.allowPreauth = allowPreauth
        self.allowSecureCards = allowSecureCards
        self.allowSubscriptions = allowSubscriptions
        self.allowDashboard = allowDashboard
        self.allowAchjhtransactions = allowAchjhtransactions
        self.allowAchiptransactions = allowAchiptransactions
        self.allowPartialCaptures = allowPartialCaptures
        self.allowScheduledReport = allowScheduledReport
        self.allowApiKeyManagement = allowApiKeyManagement
        self.userProcessingTerminals = userProcessingTerminals
        self.templateName = templateName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, user)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if user.subclass:
            return user.subclass(*args_, **kwargs_)
        else:
            return user(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_userId(self): return self.userId
    def set_userId(self, userId): self.userId = userId
    def get_userName(self): return self.userName
    def set_userName(self, userName): self.userName = userName
    def get_merchantId(self): return self.merchantId
    def set_merchantId(self, merchantId): self.merchantId = merchantId
    def get_userEmail(self): return self.userEmail
    def set_userEmail(self, userEmail): self.userEmail = userEmail
    def get_timeZone(self): return self.timeZone
    def set_timeZone(self, timeZone): self.timeZone = timeZone
    def get_allowTerminalSetup(self): return self.allowTerminalSetup
    def set_allowTerminalSetup(self, allowTerminalSetup): self.allowTerminalSetup = allowTerminalSetup
    def get_allowPaymentPageLayout(self): return self.allowPaymentPageLayout
    def set_allowPaymentPageLayout(self, allowPaymentPageLayout): self.allowPaymentPageLayout = allowPaymentPageLayout
    def get_allowRefund(self): return self.allowRefund
    def set_allowRefund(self, allowRefund): self.allowRefund = allowRefund
    def get_allowUnreferencedRefunds(self): return self.allowUnreferencedRefunds
    def set_allowUnreferencedRefunds(self, allowUnreferencedRefunds): self.allowUnreferencedRefunds = allowUnreferencedRefunds
    def get_allowVirtualTerminal(self): return self.allowVirtualTerminal
    def set_allowVirtualTerminal(self, allowVirtualTerminal): self.allowVirtualTerminal = allowVirtualTerminal
    def get_allowChpOnVt(self): return self.allowChpOnVt
    def set_allowChpOnVt(self, allowChpOnVt): self.allowChpOnVt = allowChpOnVt
    def get_allowUserSetup(self): return self.allowUserSetup
    def set_allowUserSetup(self, allowUserSetup): self.allowUserSetup = allowUserSetup
    def get_allowOpenBatch(self): return self.allowOpenBatch
    def set_allowOpenBatch(self, allowOpenBatch): self.allowOpenBatch = allowOpenBatch
    def get_allowClosedBatch(self): return self.allowClosedBatch
    def set_allowClosedBatch(self, allowClosedBatch): self.allowClosedBatch = allowClosedBatch
    def get_allowBulkPaymentsResults(self): return self.allowBulkPaymentsResults
    def set_allowBulkPaymentsResults(self, allowBulkPaymentsResults): self.allowBulkPaymentsResults = allowBulkPaymentsResults
    def get_allowBilling(self): return self.allowBilling
    def set_allowBilling(self, allowBilling): self.allowBilling = allowBilling
    def get_lockedStatus(self): return self.lockedStatus
    def set_lockedStatus(self, lockedStatus): self.lockedStatus = lockedStatus
    def get_activeStatus(self): return self.activeStatus
    def set_activeStatus(self, activeStatus): self.activeStatus = activeStatus
    def get_allowPreauth(self): return self.allowPreauth
    def set_allowPreauth(self, allowPreauth): self.allowPreauth = allowPreauth
    def get_allowSecureCards(self): return self.allowSecureCards
    def set_allowSecureCards(self, allowSecureCards): self.allowSecureCards = allowSecureCards
    def get_allowSubscriptions(self): return self.allowSubscriptions
    def set_allowSubscriptions(self, allowSubscriptions): self.allowSubscriptions = allowSubscriptions
    def get_allowDashboard(self): return self.allowDashboard
    def set_allowDashboard(self, allowDashboard): self.allowDashboard = allowDashboard
    def get_allowAchjhtransactions(self): return self.allowAchjhtransactions
    def set_allowAchjhtransactions(self, allowAchjhtransactions): self.allowAchjhtransactions = allowAchjhtransactions
    def get_allowAchiptransactions(self): return self.allowAchiptransactions
    def set_allowAchiptransactions(self, allowAchiptransactions): self.allowAchiptransactions = allowAchiptransactions
    def get_allowPartialCaptures(self): return self.allowPartialCaptures
    def set_allowPartialCaptures(self, allowPartialCaptures): self.allowPartialCaptures = allowPartialCaptures
    def get_allowScheduledReport(self): return self.allowScheduledReport
    def set_allowScheduledReport(self, allowScheduledReport): self.allowScheduledReport = allowScheduledReport
    def get_allowApiKeyManagement(self): return self.allowApiKeyManagement
    def set_allowApiKeyManagement(self, allowApiKeyManagement): self.allowApiKeyManagement = allowApiKeyManagement
    def get_userProcessingTerminals(self): return self.userProcessingTerminals
    def set_userProcessingTerminals(self, userProcessingTerminals): self.userProcessingTerminals = userProcessingTerminals
    def get_templateName(self): return self.templateName
    def set_templateName(self, templateName): self.templateName = templateName
    def validate_userLockedStatusEnum(self, value):
        # Validate type userLockedStatusEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACTIVE', 'LOCKED_BY_TOO_MANY_ATTEMPTS', 'LOCKED_BY_ADMIN', 'LOCKED_BY_SELF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on userLockedStatusEnum' % {"value" : value.encode("utf-8")} )
    def validate_userActiveStatusEnum(self, value):
        # Validate type userActiveStatusEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACTIVE', 'DESACTIVATED_BY_MERCHANT', 'DESACTIVATED_BY_ADMIN', 'MERCHANT_DESACTIVATED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on userActiveStatusEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userId is not None or
            self.userName is not None or
            self.merchantId is not None or
            self.userEmail is not None or
            self.timeZone is not None or
            self.allowTerminalSetup is not None or
            self.allowPaymentPageLayout is not None or
            self.allowRefund is not None or
            self.allowUnreferencedRefunds is not None or
            self.allowVirtualTerminal is not None or
            self.allowChpOnVt is not None or
            self.allowUserSetup is not None or
            self.allowOpenBatch is not None or
            self.allowClosedBatch is not None or
            self.allowBulkPaymentsResults is not None or
            self.allowBilling is not None or
            self.lockedStatus is not None or
            self.activeStatus is not None or
            self.allowPreauth is not None or
            self.allowSecureCards is not None or
            self.allowSubscriptions is not None or
            self.allowDashboard is not None or
            self.allowAchjhtransactions is not None or
            self.allowAchiptransactions is not None or
            self.allowPartialCaptures is not None or
            self.allowScheduledReport is not None or
            self.allowApiKeyManagement is not None or
            self.userProcessingTerminals is not None or
            self.templateName is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='user', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.userId is not None:
            userId_ = self.userId
            etree_.SubElement(element, '{}userId').text = self.gds_format_string(userId_)
        if self.userName is not None:
            userName_ = self.userName
            etree_.SubElement(element, '{}userName').text = self.gds_format_string(userName_)
        if self.merchantId is not None:
            merchantId_ = self.merchantId
            etree_.SubElement(element, '{}merchantId').text = self.gds_format_string(merchantId_)
        if self.userEmail is not None:
            userEmail_ = self.userEmail
            etree_.SubElement(element, '{}userEmail').text = self.gds_format_string(userEmail_)
        if self.timeZone is not None:
            timeZone_ = self.timeZone
            etree_.SubElement(element, '{}timeZone').text = self.gds_format_string(timeZone_)
        if self.allowTerminalSetup is not None:
            allowTerminalSetup_ = self.allowTerminalSetup
            etree_.SubElement(element, '{}allowTerminalSetup').text = self.gds_format_boolean(allowTerminalSetup_)
        if self.allowPaymentPageLayout is not None:
            allowPaymentPageLayout_ = self.allowPaymentPageLayout
            etree_.SubElement(element, '{}allowPaymentPageLayout').text = self.gds_format_boolean(allowPaymentPageLayout_)
        if self.allowRefund is not None:
            allowRefund_ = self.allowRefund
            etree_.SubElement(element, '{}allowRefund').text = self.gds_format_boolean(allowRefund_)
        if self.allowUnreferencedRefunds is not None:
            allowUnreferencedRefunds_ = self.allowUnreferencedRefunds
            etree_.SubElement(element, '{}allowUnreferencedRefunds').text = self.gds_format_boolean(allowUnreferencedRefunds_)
        if self.allowVirtualTerminal is not None:
            allowVirtualTerminal_ = self.allowVirtualTerminal
            etree_.SubElement(element, '{}allowVirtualTerminal').text = self.gds_format_boolean(allowVirtualTerminal_)
        if self.allowChpOnVt is not None:
            allowChpOnVt_ = self.allowChpOnVt
            etree_.SubElement(element, '{}allowChpOnVt').text = self.gds_format_boolean(allowChpOnVt_)
        if self.allowUserSetup is not None:
            allowUserSetup_ = self.allowUserSetup
            etree_.SubElement(element, '{}allowUserSetup').text = self.gds_format_boolean(allowUserSetup_)
        if self.allowOpenBatch is not None:
            allowOpenBatch_ = self.allowOpenBatch
            etree_.SubElement(element, '{}allowOpenBatch').text = self.gds_format_boolean(allowOpenBatch_)
        if self.allowClosedBatch is not None:
            allowClosedBatch_ = self.allowClosedBatch
            etree_.SubElement(element, '{}allowClosedBatch').text = self.gds_format_boolean(allowClosedBatch_)
        if self.allowBulkPaymentsResults is not None:
            allowBulkPaymentsResults_ = self.allowBulkPaymentsResults
            etree_.SubElement(element, '{}allowBulkPaymentsResults').text = self.gds_format_boolean(allowBulkPaymentsResults_)
        if self.allowBilling is not None:
            allowBilling_ = self.allowBilling
            etree_.SubElement(element, '{}allowBilling').text = self.gds_format_boolean(allowBilling_)
        if self.lockedStatus is not None:
            lockedStatus_ = self.lockedStatus
            etree_.SubElement(element, '{}lockedStatus').text = self.gds_format_string(lockedStatus_)
        if self.activeStatus is not None:
            activeStatus_ = self.activeStatus
            etree_.SubElement(element, '{}activeStatus').text = self.gds_format_string(activeStatus_)
        if self.allowPreauth is not None:
            allowPreauth_ = self.allowPreauth
            etree_.SubElement(element, '{}allowPreauth').text = self.gds_format_boolean(allowPreauth_)
        if self.allowSecureCards is not None:
            allowSecureCards_ = self.allowSecureCards
            etree_.SubElement(element, '{}allowSecureCards').text = self.gds_format_boolean(allowSecureCards_)
        if self.allowSubscriptions is not None:
            allowSubscriptions_ = self.allowSubscriptions
            etree_.SubElement(element, '{}allowSubscriptions').text = self.gds_format_boolean(allowSubscriptions_)
        if self.allowDashboard is not None:
            allowDashboard_ = self.allowDashboard
            etree_.SubElement(element, '{}allowDashboard').text = self.gds_format_boolean(allowDashboard_)
        if self.allowAchjhtransactions is not None:
            allowAchjhtransactions_ = self.allowAchjhtransactions
            etree_.SubElement(element, '{}allowAchjhtransactions').text = self.gds_format_boolean(allowAchjhtransactions_)
        if self.allowAchiptransactions is not None:
            allowAchiptransactions_ = self.allowAchiptransactions
            etree_.SubElement(element, '{}allowAchiptransactions').text = self.gds_format_boolean(allowAchiptransactions_)
        if self.allowPartialCaptures is not None:
            allowPartialCaptures_ = self.allowPartialCaptures
            etree_.SubElement(element, '{}allowPartialCaptures').text = self.gds_format_boolean(allowPartialCaptures_)
        if self.allowScheduledReport is not None:
            allowScheduledReport_ = self.allowScheduledReport
            etree_.SubElement(element, '{}allowScheduledReport').text = self.gds_format_boolean(allowScheduledReport_)
        if self.allowApiKeyManagement is not None:
            allowApiKeyManagement_ = self.allowApiKeyManagement
            etree_.SubElement(element, '{}allowApiKeyManagement').text = self.gds_format_boolean(allowApiKeyManagement_)
        if self.userProcessingTerminals is not None:
            userProcessingTerminals_ = self.userProcessingTerminals
            userProcessingTerminals_.to_etree(element, name_='userProcessingTerminals', mapping_=mapping_)
        if self.templateName is not None:
            templateName_ = self.templateName
            etree_.SubElement(element, '{}templateName').text = self.gds_format_string(templateName_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='user'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.userId is not None:
            showIndent(outfile, level)
            outfile.write('userId=%s,\n' % self.gds_encode(quote_python(self.userId)))
        if self.userName is not None:
            showIndent(outfile, level)
            outfile.write('userName=%s,\n' % self.gds_encode(quote_python(self.userName)))
        if self.merchantId is not None:
            showIndent(outfile, level)
            outfile.write('merchantId=%s,\n' % self.gds_encode(quote_python(self.merchantId)))
        if self.userEmail is not None:
            showIndent(outfile, level)
            outfile.write('userEmail=%s,\n' % self.gds_encode(quote_python(self.userEmail)))
        if self.timeZone is not None:
            showIndent(outfile, level)
            outfile.write('timeZone=%s,\n' % self.gds_encode(quote_python(self.timeZone)))
        if self.allowTerminalSetup is not None:
            showIndent(outfile, level)
            outfile.write('allowTerminalSetup=%s,\n' % self.allowTerminalSetup)
        if self.allowPaymentPageLayout is not None:
            showIndent(outfile, level)
            outfile.write('allowPaymentPageLayout=%s,\n' % self.allowPaymentPageLayout)
        if self.allowRefund is not None:
            showIndent(outfile, level)
            outfile.write('allowRefund=%s,\n' % self.allowRefund)
        if self.allowUnreferencedRefunds is not None:
            showIndent(outfile, level)
            outfile.write('allowUnreferencedRefunds=%s,\n' % self.allowUnreferencedRefunds)
        if self.allowVirtualTerminal is not None:
            showIndent(outfile, level)
            outfile.write('allowVirtualTerminal=%s,\n' % self.allowVirtualTerminal)
        if self.allowChpOnVt is not None:
            showIndent(outfile, level)
            outfile.write('allowChpOnVt=%s,\n' % self.allowChpOnVt)
        if self.allowUserSetup is not None:
            showIndent(outfile, level)
            outfile.write('allowUserSetup=%s,\n' % self.allowUserSetup)
        if self.allowOpenBatch is not None:
            showIndent(outfile, level)
            outfile.write('allowOpenBatch=%s,\n' % self.allowOpenBatch)
        if self.allowClosedBatch is not None:
            showIndent(outfile, level)
            outfile.write('allowClosedBatch=%s,\n' % self.allowClosedBatch)
        if self.allowBulkPaymentsResults is not None:
            showIndent(outfile, level)
            outfile.write('allowBulkPaymentsResults=%s,\n' % self.allowBulkPaymentsResults)
        if self.allowBilling is not None:
            showIndent(outfile, level)
            outfile.write('allowBilling=%s,\n' % self.allowBilling)
        if self.lockedStatus is not None:
            showIndent(outfile, level)
            outfile.write('lockedStatus=%s,\n' % self.gds_encode(quote_python(self.lockedStatus)))
        if self.activeStatus is not None:
            showIndent(outfile, level)
            outfile.write('activeStatus=%s,\n' % self.gds_encode(quote_python(self.activeStatus)))
        if self.allowPreauth is not None:
            showIndent(outfile, level)
            outfile.write('allowPreauth=%s,\n' % self.allowPreauth)
        if self.allowSecureCards is not None:
            showIndent(outfile, level)
            outfile.write('allowSecureCards=%s,\n' % self.allowSecureCards)
        if self.allowSubscriptions is not None:
            showIndent(outfile, level)
            outfile.write('allowSubscriptions=%s,\n' % self.allowSubscriptions)
        if self.allowDashboard is not None:
            showIndent(outfile, level)
            outfile.write('allowDashboard=%s,\n' % self.allowDashboard)
        if self.allowAchjhtransactions is not None:
            showIndent(outfile, level)
            outfile.write('allowAchjhtransactions=%s,\n' % self.allowAchjhtransactions)
        if self.allowAchiptransactions is not None:
            showIndent(outfile, level)
            outfile.write('allowAchiptransactions=%s,\n' % self.allowAchiptransactions)
        if self.allowPartialCaptures is not None:
            showIndent(outfile, level)
            outfile.write('allowPartialCaptures=%s,\n' % self.allowPartialCaptures)
        if self.allowScheduledReport is not None:
            showIndent(outfile, level)
            outfile.write('allowScheduledReport=%s,\n' % self.allowScheduledReport)
        if self.allowApiKeyManagement is not None:
            showIndent(outfile, level)
            outfile.write('allowApiKeyManagement=%s,\n' % self.allowApiKeyManagement)
        if self.userProcessingTerminals is not None:
            showIndent(outfile, level)
            outfile.write('userProcessingTerminals=model_.userProcessingTerminalsType(\n')
            self.userProcessingTerminals.exportLiteral(outfile, level, name_='userProcessingTerminals')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.templateName is not None:
            showIndent(outfile, level)
            outfile.write('templateName=%s,\n' % self.gds_encode(quote_python(self.templateName)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userId':
            userId_ = child_.text
            userId_ = self.gds_validate_string(userId_, node, 'userId')
            self.userId = userId_
        elif nodeName_ == 'userName':
            userName_ = child_.text
            userName_ = self.gds_validate_string(userName_, node, 'userName')
            self.userName = userName_
        elif nodeName_ == 'merchantId':
            merchantId_ = child_.text
            merchantId_ = self.gds_validate_string(merchantId_, node, 'merchantId')
            self.merchantId = merchantId_
        elif nodeName_ == 'userEmail':
            userEmail_ = child_.text
            userEmail_ = self.gds_validate_string(userEmail_, node, 'userEmail')
            self.userEmail = userEmail_
        elif nodeName_ == 'timeZone':
            timeZone_ = child_.text
            timeZone_ = self.gds_validate_string(timeZone_, node, 'timeZone')
            self.timeZone = timeZone_
        elif nodeName_ == 'allowTerminalSetup':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowTerminalSetup')
            self.allowTerminalSetup = ival_
        elif nodeName_ == 'allowPaymentPageLayout':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowPaymentPageLayout')
            self.allowPaymentPageLayout = ival_
        elif nodeName_ == 'allowRefund':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowRefund')
            self.allowRefund = ival_
        elif nodeName_ == 'allowUnreferencedRefunds':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowUnreferencedRefunds')
            self.allowUnreferencedRefunds = ival_
        elif nodeName_ == 'allowVirtualTerminal':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowVirtualTerminal')
            self.allowVirtualTerminal = ival_
        elif nodeName_ == 'allowChpOnVt':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowChpOnVt')
            self.allowChpOnVt = ival_
        elif nodeName_ == 'allowUserSetup':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowUserSetup')
            self.allowUserSetup = ival_
        elif nodeName_ == 'allowOpenBatch':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowOpenBatch')
            self.allowOpenBatch = ival_
        elif nodeName_ == 'allowClosedBatch':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowClosedBatch')
            self.allowClosedBatch = ival_
        elif nodeName_ == 'allowBulkPaymentsResults':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowBulkPaymentsResults')
            self.allowBulkPaymentsResults = ival_
        elif nodeName_ == 'allowBilling':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowBilling')
            self.allowBilling = ival_
        elif nodeName_ == 'lockedStatus':
            lockedStatus_ = child_.text
            lockedStatus_ = self.gds_validate_string(lockedStatus_, node, 'lockedStatus')
            self.lockedStatus = lockedStatus_
            # validate type userLockedStatusEnum
            self.validate_userLockedStatusEnum(self.lockedStatus)
        elif nodeName_ == 'activeStatus':
            activeStatus_ = child_.text
            activeStatus_ = self.gds_validate_string(activeStatus_, node, 'activeStatus')
            self.activeStatus = activeStatus_
            # validate type userActiveStatusEnum
            self.validate_userActiveStatusEnum(self.activeStatus)
        elif nodeName_ == 'allowPreauth':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowPreauth')
            self.allowPreauth = ival_
        elif nodeName_ == 'allowSecureCards':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowSecureCards')
            self.allowSecureCards = ival_
        elif nodeName_ == 'allowSubscriptions':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowSubscriptions')
            self.allowSubscriptions = ival_
        elif nodeName_ == 'allowDashboard':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowDashboard')
            self.allowDashboard = ival_
        elif nodeName_ == 'allowAchjhtransactions':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowAchjhtransactions')
            self.allowAchjhtransactions = ival_
        elif nodeName_ == 'allowAchiptransactions':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowAchiptransactions')
            self.allowAchiptransactions = ival_
        elif nodeName_ == 'allowPartialCaptures':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowPartialCaptures')
            self.allowPartialCaptures = ival_
        elif nodeName_ == 'allowScheduledReport':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowScheduledReport')
            self.allowScheduledReport = ival_
        elif nodeName_ == 'allowApiKeyManagement':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowApiKeyManagement')
            self.allowApiKeyManagement = ival_
        elif nodeName_ == 'userProcessingTerminals':
            obj_ = userProcessingTerminalsType.factory()
            obj_.build(child_)
            self.userProcessingTerminals = obj_
            obj_.original_tagname_ = 'userProcessingTerminals'
        elif nodeName_ == 'templateName':
            templateName_ = child_.text
            templateName_ = self.gds_validate_string(templateName_, node, 'templateName')
            self.templateName = templateName_
    def sample_method(self):
        pass
# end class user


class merchantPortfolio(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('merchantPortfolioId', 'xs:string', 0, 1, {'name': 'merchantPortfolioId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('name', 'xs:string', 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('contactName', 'xs:string', 0, 0, {'name': 'contactName', 'type': 'xs:string'}, None),
        MemberSpec_('contactPhone', 'xs:string', 0, 0, {'name': 'contactPhone', 'type': 'xs:string'}, None),
        MemberSpec_('contactEmail', 'xs:string', 0, 0, {'name': 'contactEmail', 'type': 'xs:string'}, None),
        MemberSpec_('deactivationDate', 'xs:dateTime', 0, 1, {'name': 'deactivationDate', 'type': 'xs:dateTime', 'minOccurs': '0'}, None),
        MemberSpec_('enableSecureCardUniqueness', 'xs:boolean', 0, 0, {'name': 'enableSecureCardUniqueness', 'type': 'xs:boolean'}, None),
        MemberSpec_('enableSecureCardAutoSharing', 'xs:boolean', 0, 0, {'name': 'enableSecureCardAutoSharing', 'type': 'xs:boolean'}, None),
        MemberSpec_('shareCardsFromDeactivatedTerminals', 'xs:boolean', 0, 1, {'name': 'shareCardsFromDeactivatedTerminals', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('enableSecureCardAutoRegistration', 'xs:boolean', 0, 0, {'name': 'enableSecureCardAutoRegistration', 'type': 'xs:boolean'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, merchantPortfolioId=None, name=None, contactName=None, contactPhone=None, contactEmail=None, deactivationDate=None, enableSecureCardUniqueness=None, enableSecureCardAutoSharing=None, shareCardsFromDeactivatedTerminals=None, enableSecureCardAutoRegistration=None):
        self.original_tagname_ = None
        self.merchantPortfolioId = merchantPortfolioId
        self.name = name
        self.contactName = contactName
        self.contactPhone = contactPhone
        self.contactEmail = contactEmail
        if isinstance(deactivationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(deactivationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = deactivationDate
        self.deactivationDate = initvalue_
        self.enableSecureCardUniqueness = enableSecureCardUniqueness
        self.enableSecureCardAutoSharing = enableSecureCardAutoSharing
        self.shareCardsFromDeactivatedTerminals = shareCardsFromDeactivatedTerminals
        self.enableSecureCardAutoRegistration = enableSecureCardAutoRegistration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, merchantPortfolio)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if merchantPortfolio.subclass:
            return merchantPortfolio.subclass(*args_, **kwargs_)
        else:
            return merchantPortfolio(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_merchantPortfolioId(self): return self.merchantPortfolioId
    def set_merchantPortfolioId(self, merchantPortfolioId): self.merchantPortfolioId = merchantPortfolioId
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_contactName(self): return self.contactName
    def set_contactName(self, contactName): self.contactName = contactName
    def get_contactPhone(self): return self.contactPhone
    def set_contactPhone(self, contactPhone): self.contactPhone = contactPhone
    def get_contactEmail(self): return self.contactEmail
    def set_contactEmail(self, contactEmail): self.contactEmail = contactEmail
    def get_deactivationDate(self): return self.deactivationDate
    def set_deactivationDate(self, deactivationDate): self.deactivationDate = deactivationDate
    def get_enableSecureCardUniqueness(self): return self.enableSecureCardUniqueness
    def set_enableSecureCardUniqueness(self, enableSecureCardUniqueness): self.enableSecureCardUniqueness = enableSecureCardUniqueness
    def get_enableSecureCardAutoSharing(self): return self.enableSecureCardAutoSharing
    def set_enableSecureCardAutoSharing(self, enableSecureCardAutoSharing): self.enableSecureCardAutoSharing = enableSecureCardAutoSharing
    def get_shareCardsFromDeactivatedTerminals(self): return self.shareCardsFromDeactivatedTerminals
    def set_shareCardsFromDeactivatedTerminals(self, shareCardsFromDeactivatedTerminals): self.shareCardsFromDeactivatedTerminals = shareCardsFromDeactivatedTerminals
    def get_enableSecureCardAutoRegistration(self): return self.enableSecureCardAutoRegistration
    def set_enableSecureCardAutoRegistration(self, enableSecureCardAutoRegistration): self.enableSecureCardAutoRegistration = enableSecureCardAutoRegistration
    def hasContent_(self):
        if (
            self.merchantPortfolioId is not None or
            self.name is not None or
            self.contactName is not None or
            self.contactPhone is not None or
            self.contactEmail is not None or
            self.deactivationDate is not None or
            self.enableSecureCardUniqueness is not None or
            self.enableSecureCardAutoSharing is not None or
            self.shareCardsFromDeactivatedTerminals is not None or
            self.enableSecureCardAutoRegistration is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='merchantPortfolio', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.merchantPortfolioId is not None:
            merchantPortfolioId_ = self.merchantPortfolioId
            etree_.SubElement(element, '{}merchantPortfolioId').text = self.gds_format_string(merchantPortfolioId_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{}name').text = self.gds_format_string(name_)
        if self.contactName is not None:
            contactName_ = self.contactName
            etree_.SubElement(element, '{}contactName').text = self.gds_format_string(contactName_)
        if self.contactPhone is not None:
            contactPhone_ = self.contactPhone
            etree_.SubElement(element, '{}contactPhone').text = self.gds_format_string(contactPhone_)
        if self.contactEmail is not None:
            contactEmail_ = self.contactEmail
            etree_.SubElement(element, '{}contactEmail').text = self.gds_format_string(contactEmail_)
        if self.deactivationDate is not None:
            deactivationDate_ = self.deactivationDate
            etree_.SubElement(element, '{}deactivationDate').text = self.gds_format_datetime(deactivationDate_)
        if self.enableSecureCardUniqueness is not None:
            enableSecureCardUniqueness_ = self.enableSecureCardUniqueness
            etree_.SubElement(element, '{}enableSecureCardUniqueness').text = self.gds_format_boolean(enableSecureCardUniqueness_)
        if self.enableSecureCardAutoSharing is not None:
            enableSecureCardAutoSharing_ = self.enableSecureCardAutoSharing
            etree_.SubElement(element, '{}enableSecureCardAutoSharing').text = self.gds_format_boolean(enableSecureCardAutoSharing_)
        if self.shareCardsFromDeactivatedTerminals is not None:
            shareCardsFromDeactivatedTerminals_ = self.shareCardsFromDeactivatedTerminals
            etree_.SubElement(element, '{}shareCardsFromDeactivatedTerminals').text = self.gds_format_boolean(shareCardsFromDeactivatedTerminals_)
        if self.enableSecureCardAutoRegistration is not None:
            enableSecureCardAutoRegistration_ = self.enableSecureCardAutoRegistration
            etree_.SubElement(element, '{}enableSecureCardAutoRegistration').text = self.gds_format_boolean(enableSecureCardAutoRegistration_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='merchantPortfolio'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.merchantPortfolioId is not None:
            showIndent(outfile, level)
            outfile.write('merchantPortfolioId=%s,\n' % self.gds_encode(quote_python(self.merchantPortfolioId)))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % self.gds_encode(quote_python(self.name)))
        if self.contactName is not None:
            showIndent(outfile, level)
            outfile.write('contactName=%s,\n' % self.gds_encode(quote_python(self.contactName)))
        if self.contactPhone is not None:
            showIndent(outfile, level)
            outfile.write('contactPhone=%s,\n' % self.gds_encode(quote_python(self.contactPhone)))
        if self.contactEmail is not None:
            showIndent(outfile, level)
            outfile.write('contactEmail=%s,\n' % self.gds_encode(quote_python(self.contactEmail)))
        if self.deactivationDate is not None:
            showIndent(outfile, level)
            outfile.write('deactivationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.deactivationDate, input_name='deactivationDate'))
        if self.enableSecureCardUniqueness is not None:
            showIndent(outfile, level)
            outfile.write('enableSecureCardUniqueness=%s,\n' % self.enableSecureCardUniqueness)
        if self.enableSecureCardAutoSharing is not None:
            showIndent(outfile, level)
            outfile.write('enableSecureCardAutoSharing=%s,\n' % self.enableSecureCardAutoSharing)
        if self.shareCardsFromDeactivatedTerminals is not None:
            showIndent(outfile, level)
            outfile.write('shareCardsFromDeactivatedTerminals=%s,\n' % self.shareCardsFromDeactivatedTerminals)
        if self.enableSecureCardAutoRegistration is not None:
            showIndent(outfile, level)
            outfile.write('enableSecureCardAutoRegistration=%s,\n' % self.enableSecureCardAutoRegistration)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'merchantPortfolioId':
            merchantPortfolioId_ = child_.text
            merchantPortfolioId_ = self.gds_validate_string(merchantPortfolioId_, node, 'merchantPortfolioId')
            self.merchantPortfolioId = merchantPortfolioId_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'contactName':
            contactName_ = child_.text
            contactName_ = self.gds_validate_string(contactName_, node, 'contactName')
            self.contactName = contactName_
        elif nodeName_ == 'contactPhone':
            contactPhone_ = child_.text
            contactPhone_ = self.gds_validate_string(contactPhone_, node, 'contactPhone')
            self.contactPhone = contactPhone_
        elif nodeName_ == 'contactEmail':
            contactEmail_ = child_.text
            contactEmail_ = self.gds_validate_string(contactEmail_, node, 'contactEmail')
            self.contactEmail = contactEmail_
        elif nodeName_ == 'deactivationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.deactivationDate = dval_
        elif nodeName_ == 'enableSecureCardUniqueness':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableSecureCardUniqueness')
            self.enableSecureCardUniqueness = ival_
        elif nodeName_ == 'enableSecureCardAutoSharing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableSecureCardAutoSharing')
            self.enableSecureCardAutoSharing = ival_
        elif nodeName_ == 'shareCardsFromDeactivatedTerminals':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'shareCardsFromDeactivatedTerminals')
            self.shareCardsFromDeactivatedTerminals = ival_
        elif nodeName_ == 'enableSecureCardAutoRegistration':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableSecureCardAutoRegistration')
            self.enableSecureCardAutoRegistration = ival_
    def sample_method(self):
        pass
# end class merchantPortfolio


class partnerPortfolio(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('partnerPortfolioId', 'xs:string', 0, 1, {'name': 'partnerPortfolioId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('name', 'xs:string', 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('contactName', 'xs:string', 0, 0, {'name': 'contactName', 'type': 'xs:string'}, None),
        MemberSpec_('contactPhone', 'xs:string', 0, 0, {'name': 'contactPhone', 'type': 'xs:string'}, None),
        MemberSpec_('contactEmail', 'xs:string', 0, 0, {'name': 'contactEmail', 'type': 'xs:string'}, None),
        MemberSpec_('percentage', 'xs:int', 0, 0, {'name': 'percentage', 'type': 'xs:int'}, None),
        MemberSpec_('bankName', 'xs:string', 0, 1, {'name': 'bankName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('bankAddress', 'xs:string', 0, 1, {'name': 'bankAddress', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('bankBIC', 'xs:string', 0, 1, {'name': 'bankBIC', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('bankIBAN', 'xs:string', 0, 1, {'name': 'bankIBAN', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('bankSortCode', 'xs:string', 0, 1, {'name': 'bankSortCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('bankAccountNumber', 'xs:string', 0, 1, {'name': 'bankAccountNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('reportingEmailAddress', 'xs:string', 0, 1, {'name': 'reportingEmailAddress', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('deactivationDate', 'xs:dateTime', 0, 1, {'name': 'deactivationDate', 'type': 'xs:dateTime', 'minOccurs': '0'}, None),
        MemberSpec_('gateway', 'xs:string', 0, 1, {'name': 'gateway', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowPayFac', 'xs:boolean', 0, 0, {'name': 'allowPayFac', 'type': 'xs:boolean'}, None),
        MemberSpec_('payFacBank', 'xs:string', 0, 1, {'name': 'payFacBank', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('payFacIdentifier', 'xs:string', 0, 1, {'name': 'payFacIdentifier', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('payFacName', 'xs:string', 0, 1, {'name': 'payFacName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('payFacIdentifierMC', 'xs:string', 0, 1, {'name': 'payFacIdentifierMC', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('payFacIdentifierVisa', 'xs:string', 0, 1, {'name': 'payFacIdentifierVisa', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('payFacIdentifierDiscover', 'xs:string', 0, 1, {'name': 'payFacIdentifierDiscover', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, partnerPortfolioId=None, name=None, contactName=None, contactPhone=None, contactEmail=None, percentage=None, bankName=None, bankAddress=None, bankBIC=None, bankIBAN=None, bankSortCode=None, bankAccountNumber=None, reportingEmailAddress=None, deactivationDate=None, gateway=None, allowPayFac=None, payFacBank=None, payFacIdentifier=None, payFacName=None, payFacIdentifierMC=None, payFacIdentifierVisa=None, payFacIdentifierDiscover=None):
        self.original_tagname_ = None
        self.partnerPortfolioId = partnerPortfolioId
        self.name = name
        self.contactName = contactName
        self.contactPhone = contactPhone
        self.contactEmail = contactEmail
        self.percentage = percentage
        self.bankName = bankName
        self.bankAddress = bankAddress
        self.bankBIC = bankBIC
        self.bankIBAN = bankIBAN
        self.bankSortCode = bankSortCode
        self.bankAccountNumber = bankAccountNumber
        self.reportingEmailAddress = reportingEmailAddress
        if isinstance(deactivationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(deactivationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = deactivationDate
        self.deactivationDate = initvalue_
        self.gateway = gateway
        self.allowPayFac = allowPayFac
        self.payFacBank = payFacBank
        self.payFacIdentifier = payFacIdentifier
        self.payFacName = payFacName
        self.payFacIdentifierMC = payFacIdentifierMC
        self.payFacIdentifierVisa = payFacIdentifierVisa
        self.payFacIdentifierDiscover = payFacIdentifierDiscover
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, partnerPortfolio)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if partnerPortfolio.subclass:
            return partnerPortfolio.subclass(*args_, **kwargs_)
        else:
            return partnerPortfolio(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partnerPortfolioId(self): return self.partnerPortfolioId
    def set_partnerPortfolioId(self, partnerPortfolioId): self.partnerPortfolioId = partnerPortfolioId
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_contactName(self): return self.contactName
    def set_contactName(self, contactName): self.contactName = contactName
    def get_contactPhone(self): return self.contactPhone
    def set_contactPhone(self, contactPhone): self.contactPhone = contactPhone
    def get_contactEmail(self): return self.contactEmail
    def set_contactEmail(self, contactEmail): self.contactEmail = contactEmail
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_bankName(self): return self.bankName
    def set_bankName(self, bankName): self.bankName = bankName
    def get_bankAddress(self): return self.bankAddress
    def set_bankAddress(self, bankAddress): self.bankAddress = bankAddress
    def get_bankBIC(self): return self.bankBIC
    def set_bankBIC(self, bankBIC): self.bankBIC = bankBIC
    def get_bankIBAN(self): return self.bankIBAN
    def set_bankIBAN(self, bankIBAN): self.bankIBAN = bankIBAN
    def get_bankSortCode(self): return self.bankSortCode
    def set_bankSortCode(self, bankSortCode): self.bankSortCode = bankSortCode
    def get_bankAccountNumber(self): return self.bankAccountNumber
    def set_bankAccountNumber(self, bankAccountNumber): self.bankAccountNumber = bankAccountNumber
    def get_reportingEmailAddress(self): return self.reportingEmailAddress
    def set_reportingEmailAddress(self, reportingEmailAddress): self.reportingEmailAddress = reportingEmailAddress
    def get_deactivationDate(self): return self.deactivationDate
    def set_deactivationDate(self, deactivationDate): self.deactivationDate = deactivationDate
    def get_gateway(self): return self.gateway
    def set_gateway(self, gateway): self.gateway = gateway
    def get_allowPayFac(self): return self.allowPayFac
    def set_allowPayFac(self, allowPayFac): self.allowPayFac = allowPayFac
    def get_payFacBank(self): return self.payFacBank
    def set_payFacBank(self, payFacBank): self.payFacBank = payFacBank
    def get_payFacIdentifier(self): return self.payFacIdentifier
    def set_payFacIdentifier(self, payFacIdentifier): self.payFacIdentifier = payFacIdentifier
    def get_payFacName(self): return self.payFacName
    def set_payFacName(self, payFacName): self.payFacName = payFacName
    def get_payFacIdentifierMC(self): return self.payFacIdentifierMC
    def set_payFacIdentifierMC(self, payFacIdentifierMC): self.payFacIdentifierMC = payFacIdentifierMC
    def get_payFacIdentifierVisa(self): return self.payFacIdentifierVisa
    def set_payFacIdentifierVisa(self, payFacIdentifierVisa): self.payFacIdentifierVisa = payFacIdentifierVisa
    def get_payFacIdentifierDiscover(self): return self.payFacIdentifierDiscover
    def set_payFacIdentifierDiscover(self, payFacIdentifierDiscover): self.payFacIdentifierDiscover = payFacIdentifierDiscover
    def hasContent_(self):
        if (
            self.partnerPortfolioId is not None or
            self.name is not None or
            self.contactName is not None or
            self.contactPhone is not None or
            self.contactEmail is not None or
            self.percentage is not None or
            self.bankName is not None or
            self.bankAddress is not None or
            self.bankBIC is not None or
            self.bankIBAN is not None or
            self.bankSortCode is not None or
            self.bankAccountNumber is not None or
            self.reportingEmailAddress is not None or
            self.deactivationDate is not None or
            self.gateway is not None or
            self.allowPayFac is not None or
            self.payFacBank is not None or
            self.payFacIdentifier is not None or
            self.payFacName is not None or
            self.payFacIdentifierMC is not None or
            self.payFacIdentifierVisa is not None or
            self.payFacIdentifierDiscover is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='partnerPortfolio', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.partnerPortfolioId is not None:
            partnerPortfolioId_ = self.partnerPortfolioId
            etree_.SubElement(element, '{}partnerPortfolioId').text = self.gds_format_string(partnerPortfolioId_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{}name').text = self.gds_format_string(name_)
        if self.contactName is not None:
            contactName_ = self.contactName
            etree_.SubElement(element, '{}contactName').text = self.gds_format_string(contactName_)
        if self.contactPhone is not None:
            contactPhone_ = self.contactPhone
            etree_.SubElement(element, '{}contactPhone').text = self.gds_format_string(contactPhone_)
        if self.contactEmail is not None:
            contactEmail_ = self.contactEmail
            etree_.SubElement(element, '{}contactEmail').text = self.gds_format_string(contactEmail_)
        if self.percentage is not None:
            percentage_ = self.percentage
            etree_.SubElement(element, '{}percentage').text = self.gds_format_integer(percentage_)
        if self.bankName is not None:
            bankName_ = self.bankName
            etree_.SubElement(element, '{}bankName').text = self.gds_format_string(bankName_)
        if self.bankAddress is not None:
            bankAddress_ = self.bankAddress
            etree_.SubElement(element, '{}bankAddress').text = self.gds_format_string(bankAddress_)
        if self.bankBIC is not None:
            bankBIC_ = self.bankBIC
            etree_.SubElement(element, '{}bankBIC').text = self.gds_format_string(bankBIC_)
        if self.bankIBAN is not None:
            bankIBAN_ = self.bankIBAN
            etree_.SubElement(element, '{}bankIBAN').text = self.gds_format_string(bankIBAN_)
        if self.bankSortCode is not None:
            bankSortCode_ = self.bankSortCode
            etree_.SubElement(element, '{}bankSortCode').text = self.gds_format_string(bankSortCode_)
        if self.bankAccountNumber is not None:
            bankAccountNumber_ = self.bankAccountNumber
            etree_.SubElement(element, '{}bankAccountNumber').text = self.gds_format_string(bankAccountNumber_)
        if self.reportingEmailAddress is not None:
            reportingEmailAddress_ = self.reportingEmailAddress
            etree_.SubElement(element, '{}reportingEmailAddress').text = self.gds_format_string(reportingEmailAddress_)
        if self.deactivationDate is not None:
            deactivationDate_ = self.deactivationDate
            etree_.SubElement(element, '{}deactivationDate').text = self.gds_format_datetime(deactivationDate_)
        if self.gateway is not None:
            gateway_ = self.gateway
            etree_.SubElement(element, '{}gateway').text = self.gds_format_string(gateway_)
        if self.allowPayFac is not None:
            allowPayFac_ = self.allowPayFac
            etree_.SubElement(element, '{}allowPayFac').text = self.gds_format_boolean(allowPayFac_)
        if self.payFacBank is not None:
            payFacBank_ = self.payFacBank
            etree_.SubElement(element, '{}payFacBank').text = self.gds_format_string(payFacBank_)
        if self.payFacIdentifier is not None:
            payFacIdentifier_ = self.payFacIdentifier
            etree_.SubElement(element, '{}payFacIdentifier').text = self.gds_format_string(payFacIdentifier_)
        if self.payFacName is not None:
            payFacName_ = self.payFacName
            etree_.SubElement(element, '{}payFacName').text = self.gds_format_string(payFacName_)
        if self.payFacIdentifierMC is not None:
            payFacIdentifierMC_ = self.payFacIdentifierMC
            etree_.SubElement(element, '{}payFacIdentifierMC').text = self.gds_format_string(payFacIdentifierMC_)
        if self.payFacIdentifierVisa is not None:
            payFacIdentifierVisa_ = self.payFacIdentifierVisa
            etree_.SubElement(element, '{}payFacIdentifierVisa').text = self.gds_format_string(payFacIdentifierVisa_)
        if self.payFacIdentifierDiscover is not None:
            payFacIdentifierDiscover_ = self.payFacIdentifierDiscover
            etree_.SubElement(element, '{}payFacIdentifierDiscover').text = self.gds_format_string(payFacIdentifierDiscover_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='partnerPortfolio'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.partnerPortfolioId is not None:
            showIndent(outfile, level)
            outfile.write('partnerPortfolioId=%s,\n' % self.gds_encode(quote_python(self.partnerPortfolioId)))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % self.gds_encode(quote_python(self.name)))
        if self.contactName is not None:
            showIndent(outfile, level)
            outfile.write('contactName=%s,\n' % self.gds_encode(quote_python(self.contactName)))
        if self.contactPhone is not None:
            showIndent(outfile, level)
            outfile.write('contactPhone=%s,\n' % self.gds_encode(quote_python(self.contactPhone)))
        if self.contactEmail is not None:
            showIndent(outfile, level)
            outfile.write('contactEmail=%s,\n' % self.gds_encode(quote_python(self.contactEmail)))
        if self.percentage is not None:
            showIndent(outfile, level)
            outfile.write('percentage=%d,\n' % self.percentage)
        if self.bankName is not None:
            showIndent(outfile, level)
            outfile.write('bankName=%s,\n' % self.gds_encode(quote_python(self.bankName)))
        if self.bankAddress is not None:
            showIndent(outfile, level)
            outfile.write('bankAddress=%s,\n' % self.gds_encode(quote_python(self.bankAddress)))
        if self.bankBIC is not None:
            showIndent(outfile, level)
            outfile.write('bankBIC=%s,\n' % self.gds_encode(quote_python(self.bankBIC)))
        if self.bankIBAN is not None:
            showIndent(outfile, level)
            outfile.write('bankIBAN=%s,\n' % self.gds_encode(quote_python(self.bankIBAN)))
        if self.bankSortCode is not None:
            showIndent(outfile, level)
            outfile.write('bankSortCode=%s,\n' % self.gds_encode(quote_python(self.bankSortCode)))
        if self.bankAccountNumber is not None:
            showIndent(outfile, level)
            outfile.write('bankAccountNumber=%s,\n' % self.gds_encode(quote_python(self.bankAccountNumber)))
        if self.reportingEmailAddress is not None:
            showIndent(outfile, level)
            outfile.write('reportingEmailAddress=%s,\n' % self.gds_encode(quote_python(self.reportingEmailAddress)))
        if self.deactivationDate is not None:
            showIndent(outfile, level)
            outfile.write('deactivationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.deactivationDate, input_name='deactivationDate'))
        if self.gateway is not None:
            showIndent(outfile, level)
            outfile.write('gateway=%s,\n' % self.gds_encode(quote_python(self.gateway)))
        if self.allowPayFac is not None:
            showIndent(outfile, level)
            outfile.write('allowPayFac=%s,\n' % self.allowPayFac)
        if self.payFacBank is not None:
            showIndent(outfile, level)
            outfile.write('payFacBank=%s,\n' % self.gds_encode(quote_python(self.payFacBank)))
        if self.payFacIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('payFacIdentifier=%s,\n' % self.gds_encode(quote_python(self.payFacIdentifier)))
        if self.payFacName is not None:
            showIndent(outfile, level)
            outfile.write('payFacName=%s,\n' % self.gds_encode(quote_python(self.payFacName)))
        if self.payFacIdentifierMC is not None:
            showIndent(outfile, level)
            outfile.write('payFacIdentifierMC=%s,\n' % self.gds_encode(quote_python(self.payFacIdentifierMC)))
        if self.payFacIdentifierVisa is not None:
            showIndent(outfile, level)
            outfile.write('payFacIdentifierVisa=%s,\n' % self.gds_encode(quote_python(self.payFacIdentifierVisa)))
        if self.payFacIdentifierDiscover is not None:
            showIndent(outfile, level)
            outfile.write('payFacIdentifierDiscover=%s,\n' % self.gds_encode(quote_python(self.payFacIdentifierDiscover)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partnerPortfolioId':
            partnerPortfolioId_ = child_.text
            partnerPortfolioId_ = self.gds_validate_string(partnerPortfolioId_, node, 'partnerPortfolioId')
            self.partnerPortfolioId = partnerPortfolioId_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'contactName':
            contactName_ = child_.text
            contactName_ = self.gds_validate_string(contactName_, node, 'contactName')
            self.contactName = contactName_
        elif nodeName_ == 'contactPhone':
            contactPhone_ = child_.text
            contactPhone_ = self.gds_validate_string(contactPhone_, node, 'contactPhone')
            self.contactPhone = contactPhone_
        elif nodeName_ == 'contactEmail':
            contactEmail_ = child_.text
            contactEmail_ = self.gds_validate_string(contactEmail_, node, 'contactEmail')
            self.contactEmail = contactEmail_
        elif nodeName_ == 'percentage' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'percentage')
            self.percentage = ival_
        elif nodeName_ == 'bankName':
            bankName_ = child_.text
            bankName_ = self.gds_validate_string(bankName_, node, 'bankName')
            self.bankName = bankName_
        elif nodeName_ == 'bankAddress':
            bankAddress_ = child_.text
            bankAddress_ = self.gds_validate_string(bankAddress_, node, 'bankAddress')
            self.bankAddress = bankAddress_
        elif nodeName_ == 'bankBIC':
            bankBIC_ = child_.text
            bankBIC_ = self.gds_validate_string(bankBIC_, node, 'bankBIC')
            self.bankBIC = bankBIC_
        elif nodeName_ == 'bankIBAN':
            bankIBAN_ = child_.text
            bankIBAN_ = self.gds_validate_string(bankIBAN_, node, 'bankIBAN')
            self.bankIBAN = bankIBAN_
        elif nodeName_ == 'bankSortCode':
            bankSortCode_ = child_.text
            bankSortCode_ = self.gds_validate_string(bankSortCode_, node, 'bankSortCode')
            self.bankSortCode = bankSortCode_
        elif nodeName_ == 'bankAccountNumber':
            bankAccountNumber_ = child_.text
            bankAccountNumber_ = self.gds_validate_string(bankAccountNumber_, node, 'bankAccountNumber')
            self.bankAccountNumber = bankAccountNumber_
        elif nodeName_ == 'reportingEmailAddress':
            reportingEmailAddress_ = child_.text
            reportingEmailAddress_ = self.gds_validate_string(reportingEmailAddress_, node, 'reportingEmailAddress')
            self.reportingEmailAddress = reportingEmailAddress_
        elif nodeName_ == 'deactivationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.deactivationDate = dval_
        elif nodeName_ == 'gateway':
            gateway_ = child_.text
            gateway_ = self.gds_validate_string(gateway_, node, 'gateway')
            self.gateway = gateway_
        elif nodeName_ == 'allowPayFac':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowPayFac')
            self.allowPayFac = ival_
        elif nodeName_ == 'payFacBank':
            payFacBank_ = child_.text
            payFacBank_ = self.gds_validate_string(payFacBank_, node, 'payFacBank')
            self.payFacBank = payFacBank_
        elif nodeName_ == 'payFacIdentifier':
            payFacIdentifier_ = child_.text
            payFacIdentifier_ = self.gds_validate_string(payFacIdentifier_, node, 'payFacIdentifier')
            self.payFacIdentifier = payFacIdentifier_
        elif nodeName_ == 'payFacName':
            payFacName_ = child_.text
            payFacName_ = self.gds_validate_string(payFacName_, node, 'payFacName')
            self.payFacName = payFacName_
        elif nodeName_ == 'payFacIdentifierMC':
            payFacIdentifierMC_ = child_.text
            payFacIdentifierMC_ = self.gds_validate_string(payFacIdentifierMC_, node, 'payFacIdentifierMC')
            self.payFacIdentifierMC = payFacIdentifierMC_
        elif nodeName_ == 'payFacIdentifierVisa':
            payFacIdentifierVisa_ = child_.text
            payFacIdentifierVisa_ = self.gds_validate_string(payFacIdentifierVisa_, node, 'payFacIdentifierVisa')
            self.payFacIdentifierVisa = payFacIdentifierVisa_
        elif nodeName_ == 'payFacIdentifierDiscover':
            payFacIdentifierDiscover_ = child_.text
            payFacIdentifierDiscover_ = self.gds_validate_string(payFacIdentifierDiscover_, node, 'payFacIdentifierDiscover')
            self.payFacIdentifierDiscover = payFacIdentifierDiscover_
    def sample_method(self):
        pass
# end class partnerPortfolio


class serviceError(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('code', 'xs:string', 0, 1, {'name': 'code', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('message', 'xs:string', 0, 1, {'name': 'message', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('validationErrors', 'validationErrorsType', 0, 1, {'name': 'validationErrors', 'minOccurs': '0', 'type': 'validationErrorsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, code=None, message=None, validationErrors=None):
        self.original_tagname_ = None
        self.code = code
        self.message = message
        self.validationErrors = validationErrors
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serviceError)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serviceError.subclass:
            return serviceError.subclass(*args_, **kwargs_)
        else:
            return serviceError(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_validationErrors(self): return self.validationErrors
    def set_validationErrors(self, validationErrors): self.validationErrors = validationErrors
    def hasContent_(self):
        if (
            self.code is not None or
            self.message is not None or
            self.validationErrors is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='serviceError', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.code is not None:
            code_ = self.code
            etree_.SubElement(element, '{}code').text = self.gds_format_string(code_)
        if self.message is not None:
            message_ = self.message
            etree_.SubElement(element, '{}message').text = self.gds_format_string(message_)
        if self.validationErrors is not None:
            validationErrors_ = self.validationErrors
            validationErrors_.to_etree(element, name_='validationErrors', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='serviceError'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.code is not None:
            showIndent(outfile, level)
            outfile.write('code=%s,\n' % self.gds_encode(quote_python(self.code)))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % self.gds_encode(quote_python(self.message)))
        if self.validationErrors is not None:
            showIndent(outfile, level)
            outfile.write('validationErrors=model_.validationErrorsType(\n')
            self.validationErrors.exportLiteral(outfile, level, name_='validationErrors')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            code_ = child_.text
            code_ = self.gds_validate_string(code_, node, 'code')
            self.code = code_
        elif nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
        elif nodeName_ == 'validationErrors':
            obj_ = validationErrorsType.factory()
            obj_.build(child_)
            self.validationErrors = obj_
            obj_.original_tagname_ = 'validationErrors'
    def sample_method(self):
        pass
# end class serviceError


class validationError(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('code', 'xs:string', 0, 1, {'name': 'code', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('message', 'xs:string', 0, 1, {'name': 'message', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('target', 'xs:string', 0, 1, {'name': 'target', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, code=None, message=None, target=None):
        self.original_tagname_ = None
        self.code = code
        self.message = message
        self.target = target
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, validationError)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if validationError.subclass:
            return validationError.subclass(*args_, **kwargs_)
        else:
            return validationError(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def hasContent_(self):
        if (
            self.code is not None or
            self.message is not None or
            self.target is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='validationError', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.code is not None:
            code_ = self.code
            etree_.SubElement(element, '{}code').text = self.gds_format_string(code_)
        if self.message is not None:
            message_ = self.message
            etree_.SubElement(element, '{}message').text = self.gds_format_string(message_)
        if self.target is not None:
            target_ = self.target
            etree_.SubElement(element, '{}target').text = self.gds_format_string(target_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='validationError'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.code is not None:
            showIndent(outfile, level)
            outfile.write('code=%s,\n' % self.gds_encode(quote_python(self.code)))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % self.gds_encode(quote_python(self.message)))
        if self.target is not None:
            showIndent(outfile, level)
            outfile.write('target=%s,\n' % self.gds_encode(quote_python(self.target)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            code_ = child_.text
            code_ = self.gds_validate_string(code_, node, 'code')
            self.code = code_
        elif nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
        elif nodeName_ == 'target':
            target_ = child_.text
            target_ = self.gds_validate_string(target_, node, 'target')
            self.target = target_
    def sample_method(self):
        pass
# end class validationError


class terminal(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('templateName', 'xs:string', 0, 1, {'name': 'templateName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('terminalNumber', 'xs:string', 0, 0, {'name': 'terminalNumber', 'type': 'xs:string'}, None),
        MemberSpec_('acquirer', 'xs:string', 0, 1, {'name': 'acquirer', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('groupBank', 'xs:string', 0, 1, {'name': 'groupBank', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('country', 'xs:string', 0, 0, {'name': 'country', 'type': 'xs:string'}, None),
        MemberSpec_('timeZone', 'xs:string', 0, 0, {'name': 'timeZone', 'type': 'xs:string'}, None),
        MemberSpec_('useTerminalAddress', 'xs:boolean', 0, 0, {'name': 'useTerminalAddress', 'type': 'xs:boolean'}, None),
        MemberSpec_('city', 'xs:string', 0, 1, {'name': 'city', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('address1', 'xs:string', 0, 1, {'name': 'address1', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('address2', 'xs:string', 0, 1, {'name': 'address2', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('address3', 'xs:string', 0, 1, {'name': 'address3', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('contactPhone', 'xs:string', 0, 1, {'name': 'contactPhone', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('merchantId', 'xs:string', 0, 0, {'name': 'merchantId', 'type': 'xs:string'}, None),
        MemberSpec_('secret', 'xs:string', 0, 1, {'name': 'secret', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('payFacSubMerchantIdentifier', 'xs:string', 0, 1, {'name': 'payFacSubMerchantIdentifier', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('payFacSubMerchantName', 'xs:string', 0, 1, {'name': 'payFacSubMerchantName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('bankSettings', 'terminalBankSettings', 0, 1, {'name': 'bankSettings', 'type': 'terminalBankSettings', 'minOccurs': '0'}, None),
        MemberSpec_('additionalSettings', 'additionalTerminalSettings', 0, 1, {'ref': 'additionalSettings', 'minOccurs': '0', 'name': 'additionalSettings', 'type': 'additionalSettings'}, None),
        MemberSpec_('features', 'terminalFeatures', 0, 1, {'ref': 'features', 'minOccurs': '0', 'name': 'features', 'type': 'features'}, None),
        MemberSpec_('terminalLimits', 'terminalLimits', 0, 1, {'name': 'terminalLimits', 'type': 'terminalLimits', 'minOccurs': '0'}, None),
        MemberSpec_('receiptsNotification', 'terminalReceiptsNotification', 0, 1, {'name': 'receiptsNotification', 'type': 'terminalReceiptsNotification', 'minOccurs': '0'}, None),
        MemberSpec_('securityFraud', 'terminalSecurityFraud', 0, 1, {'name': 'securityFraud', 'type': 'terminalSecurityFraud', 'minOccurs': '0'}, None),
        MemberSpec_('achSettings', 'terminalAchSettings', 0, 1, {'name': 'achSettings', 'type': 'terminalAchSettings', 'minOccurs': '0'}, None),
        MemberSpec_('unionPayProcessing', 'terminalUnionPayProcessing', 0, 1, {'name': 'unionPayProcessing', 'type': 'terminalUnionPayProcessing', 'minOccurs': '0'}, None),
        MemberSpec_('integration', 'terminalIntegration', 0, 1, {'name': 'integration', 'type': 'terminalIntegration', 'minOccurs': '0'}, None),
        MemberSpec_('cards', 'cardsType', 0, 1, {'name': 'cards', 'minOccurs': '0', 'type': 'cardsType'}, None),
        MemberSpec_('threeDsCards', 'threeDsCardsType', 0, 1, {'name': 'threeDsCards', 'minOccurs': '0', 'type': 'threeDsCardsType'}, None),
        MemberSpec_('deactivationDate', 'xs:dateTime', 0, 1, {'name': 'deactivationDate', 'type': 'xs:dateTime', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, templateName=None, terminalNumber=None, acquirer=None, groupBank=None, country=None, timeZone=None, useTerminalAddress=None, city=None, address1=None, address2=None, address3=None, contactPhone=None, merchantId=None, secret=None, payFacSubMerchantIdentifier=None, payFacSubMerchantName=None, bankSettings=None, additionalSettings=None, features=None, terminalLimits=None, receiptsNotification=None, securityFraud=None, achSettings=None, unionPayProcessing=None, integration=None, cards=None, threeDsCards=None, deactivationDate=None):
        self.original_tagname_ = None
        self.templateName = templateName
        self.terminalNumber = terminalNumber
        self.acquirer = acquirer
        self.groupBank = groupBank
        self.country = country
        self.timeZone = timeZone
        self.useTerminalAddress = useTerminalAddress
        self.city = city
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.contactPhone = contactPhone
        self.merchantId = merchantId
        self.secret = secret
        self.payFacSubMerchantIdentifier = payFacSubMerchantIdentifier
        self.payFacSubMerchantName = payFacSubMerchantName
        self.bankSettings = bankSettings
        self.additionalSettings = additionalSettings
        self.features = features
        self.terminalLimits = terminalLimits
        self.receiptsNotification = receiptsNotification
        self.securityFraud = securityFraud
        self.achSettings = achSettings
        self.unionPayProcessing = unionPayProcessing
        self.integration = integration
        self.cards = cards
        self.threeDsCards = threeDsCards
        if isinstance(deactivationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(deactivationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = deactivationDate
        self.deactivationDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminal.subclass:
            return terminal.subclass(*args_, **kwargs_)
        else:
            return terminal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_templateName(self): return self.templateName
    def set_templateName(self, templateName): self.templateName = templateName
    def get_terminalNumber(self): return self.terminalNumber
    def set_terminalNumber(self, terminalNumber): self.terminalNumber = terminalNumber
    def get_acquirer(self): return self.acquirer
    def set_acquirer(self, acquirer): self.acquirer = acquirer
    def get_groupBank(self): return self.groupBank
    def set_groupBank(self, groupBank): self.groupBank = groupBank
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_timeZone(self): return self.timeZone
    def set_timeZone(self, timeZone): self.timeZone = timeZone
    def get_useTerminalAddress(self): return self.useTerminalAddress
    def set_useTerminalAddress(self, useTerminalAddress): self.useTerminalAddress = useTerminalAddress
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_address1(self): return self.address1
    def set_address1(self, address1): self.address1 = address1
    def get_address2(self): return self.address2
    def set_address2(self, address2): self.address2 = address2
    def get_address3(self): return self.address3
    def set_address3(self, address3): self.address3 = address3
    def get_contactPhone(self): return self.contactPhone
    def set_contactPhone(self, contactPhone): self.contactPhone = contactPhone
    def get_merchantId(self): return self.merchantId
    def set_merchantId(self, merchantId): self.merchantId = merchantId
    def get_secret(self): return self.secret
    def set_secret(self, secret): self.secret = secret
    def get_payFacSubMerchantIdentifier(self): return self.payFacSubMerchantIdentifier
    def set_payFacSubMerchantIdentifier(self, payFacSubMerchantIdentifier): self.payFacSubMerchantIdentifier = payFacSubMerchantIdentifier
    def get_payFacSubMerchantName(self): return self.payFacSubMerchantName
    def set_payFacSubMerchantName(self, payFacSubMerchantName): self.payFacSubMerchantName = payFacSubMerchantName
    def get_bankSettings(self): return self.bankSettings
    def set_bankSettings(self, bankSettings): self.bankSettings = bankSettings
    def get_additionalSettings(self): return self.additionalSettings
    def set_additionalSettings(self, additionalSettings): self.additionalSettings = additionalSettings
    def get_features(self): return self.features
    def set_features(self, features): self.features = features
    def get_terminalLimits(self): return self.terminalLimits
    def set_terminalLimits(self, terminalLimits): self.terminalLimits = terminalLimits
    def get_receiptsNotification(self): return self.receiptsNotification
    def set_receiptsNotification(self, receiptsNotification): self.receiptsNotification = receiptsNotification
    def get_securityFraud(self): return self.securityFraud
    def set_securityFraud(self, securityFraud): self.securityFraud = securityFraud
    def get_achSettings(self): return self.achSettings
    def set_achSettings(self, achSettings): self.achSettings = achSettings
    def get_unionPayProcessing(self): return self.unionPayProcessing
    def set_unionPayProcessing(self, unionPayProcessing): self.unionPayProcessing = unionPayProcessing
    def get_integration(self): return self.integration
    def set_integration(self, integration): self.integration = integration
    def get_cards(self): return self.cards
    def set_cards(self, cards): self.cards = cards
    def get_threeDsCards(self): return self.threeDsCards
    def set_threeDsCards(self, threeDsCards): self.threeDsCards = threeDsCards
    def get_deactivationDate(self): return self.deactivationDate
    def set_deactivationDate(self, deactivationDate): self.deactivationDate = deactivationDate
    def hasContent_(self):
        if (
            self.templateName is not None or
            self.terminalNumber is not None or
            self.acquirer is not None or
            self.groupBank is not None or
            self.country is not None or
            self.timeZone is not None or
            self.useTerminalAddress is not None or
            self.city is not None or
            self.address1 is not None or
            self.address2 is not None or
            self.address3 is not None or
            self.contactPhone is not None or
            self.merchantId is not None or
            self.secret is not None or
            self.payFacSubMerchantIdentifier is not None or
            self.payFacSubMerchantName is not None or
            self.bankSettings is not None or
            self.additionalSettings is not None or
            self.features is not None or
            self.terminalLimits is not None or
            self.receiptsNotification is not None or
            self.securityFraud is not None or
            self.achSettings is not None or
            self.unionPayProcessing is not None or
            self.integration is not None or
            self.cards is not None or
            self.threeDsCards is not None or
            self.deactivationDate is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminal', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.templateName is not None:
            templateName_ = self.templateName
            etree_.SubElement(element, '{}templateName').text = self.gds_format_string(templateName_)
        if self.terminalNumber is not None:
            terminalNumber_ = self.terminalNumber
            etree_.SubElement(element, '{}terminalNumber').text = self.gds_format_string(terminalNumber_)
        if self.acquirer is not None:
            acquirer_ = self.acquirer
            etree_.SubElement(element, '{}acquirer').text = self.gds_format_string(acquirer_)
        if self.groupBank is not None:
            groupBank_ = self.groupBank
            etree_.SubElement(element, '{}groupBank').text = self.gds_format_string(groupBank_)
        if self.country is not None:
            country_ = self.country
            etree_.SubElement(element, '{}country').text = self.gds_format_string(country_)
        if self.timeZone is not None:
            timeZone_ = self.timeZone
            etree_.SubElement(element, '{}timeZone').text = self.gds_format_string(timeZone_)
        if self.useTerminalAddress is not None:
            useTerminalAddress_ = self.useTerminalAddress
            etree_.SubElement(element, '{}useTerminalAddress').text = self.gds_format_boolean(useTerminalAddress_)
        if self.city is not None:
            city_ = self.city
            etree_.SubElement(element, '{}city').text = self.gds_format_string(city_)
        if self.address1 is not None:
            address1_ = self.address1
            etree_.SubElement(element, '{}address1').text = self.gds_format_string(address1_)
        if self.address2 is not None:
            address2_ = self.address2
            etree_.SubElement(element, '{}address2').text = self.gds_format_string(address2_)
        if self.address3 is not None:
            address3_ = self.address3
            etree_.SubElement(element, '{}address3').text = self.gds_format_string(address3_)
        if self.contactPhone is not None:
            contactPhone_ = self.contactPhone
            etree_.SubElement(element, '{}contactPhone').text = self.gds_format_string(contactPhone_)
        if self.merchantId is not None:
            merchantId_ = self.merchantId
            etree_.SubElement(element, '{}merchantId').text = self.gds_format_string(merchantId_)
        if self.secret is not None:
            secret_ = self.secret
            etree_.SubElement(element, '{}secret').text = self.gds_format_string(secret_)
        if self.payFacSubMerchantIdentifier is not None:
            payFacSubMerchantIdentifier_ = self.payFacSubMerchantIdentifier
            etree_.SubElement(element, '{}payFacSubMerchantIdentifier').text = self.gds_format_string(payFacSubMerchantIdentifier_)
        if self.payFacSubMerchantName is not None:
            payFacSubMerchantName_ = self.payFacSubMerchantName
            etree_.SubElement(element, '{}payFacSubMerchantName').text = self.gds_format_string(payFacSubMerchantName_)
        if self.bankSettings is not None:
            bankSettings_ = self.bankSettings
            bankSettings_.to_etree(element, name_='bankSettings', mapping_=mapping_)
        if self.additionalSettings is not None:
            additionalSettings_ = self.additionalSettings
            additionalSettings_.to_etree(element, name_='additionalSettings', mapping_=mapping_)
        if self.features is not None:
            features_ = self.features
            features_.to_etree(element, name_='features', mapping_=mapping_)
        if self.terminalLimits is not None:
            terminalLimits_ = self.terminalLimits
            terminalLimits_.to_etree(element, name_='terminalLimits', mapping_=mapping_)
        if self.receiptsNotification is not None:
            receiptsNotification_ = self.receiptsNotification
            receiptsNotification_.to_etree(element, name_='receiptsNotification', mapping_=mapping_)
        if self.securityFraud is not None:
            securityFraud_ = self.securityFraud
            securityFraud_.to_etree(element, name_='securityFraud', mapping_=mapping_)
        if self.achSettings is not None:
            achSettings_ = self.achSettings
            achSettings_.to_etree(element, name_='achSettings', mapping_=mapping_)
        if self.unionPayProcessing is not None:
            unionPayProcessing_ = self.unionPayProcessing
            unionPayProcessing_.to_etree(element, name_='unionPayProcessing', mapping_=mapping_)
        if self.integration is not None:
            integration_ = self.integration
            integration_.to_etree(element, name_='integration', mapping_=mapping_)
        if self.cards is not None:
            cards_ = self.cards
            cards_.to_etree(element, name_='cards', mapping_=mapping_)
        if self.threeDsCards is not None:
            threeDsCards_ = self.threeDsCards
            threeDsCards_.to_etree(element, name_='threeDsCards', mapping_=mapping_)
        if self.deactivationDate is not None:
            deactivationDate_ = self.deactivationDate
            etree_.SubElement(element, '{}deactivationDate').text = self.gds_format_datetime(deactivationDate_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminal'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.templateName is not None:
            showIndent(outfile, level)
            outfile.write('templateName=%s,\n' % self.gds_encode(quote_python(self.templateName)))
        if self.terminalNumber is not None:
            showIndent(outfile, level)
            outfile.write('terminalNumber=%s,\n' % self.gds_encode(quote_python(self.terminalNumber)))
        if self.acquirer is not None:
            showIndent(outfile, level)
            outfile.write('acquirer=%s,\n' % self.gds_encode(quote_python(self.acquirer)))
        if self.groupBank is not None:
            showIndent(outfile, level)
            outfile.write('groupBank=%s,\n' % self.gds_encode(quote_python(self.groupBank)))
        if self.country is not None:
            showIndent(outfile, level)
            outfile.write('country=%s,\n' % self.gds_encode(quote_python(self.country)))
        if self.timeZone is not None:
            showIndent(outfile, level)
            outfile.write('timeZone=%s,\n' % self.gds_encode(quote_python(self.timeZone)))
        if self.useTerminalAddress is not None:
            showIndent(outfile, level)
            outfile.write('useTerminalAddress=%s,\n' % self.useTerminalAddress)
        if self.city is not None:
            showIndent(outfile, level)
            outfile.write('city=%s,\n' % self.gds_encode(quote_python(self.city)))
        if self.address1 is not None:
            showIndent(outfile, level)
            outfile.write('address1=%s,\n' % self.gds_encode(quote_python(self.address1)))
        if self.address2 is not None:
            showIndent(outfile, level)
            outfile.write('address2=%s,\n' % self.gds_encode(quote_python(self.address2)))
        if self.address3 is not None:
            showIndent(outfile, level)
            outfile.write('address3=%s,\n' % self.gds_encode(quote_python(self.address3)))
        if self.contactPhone is not None:
            showIndent(outfile, level)
            outfile.write('contactPhone=%s,\n' % self.gds_encode(quote_python(self.contactPhone)))
        if self.merchantId is not None:
            showIndent(outfile, level)
            outfile.write('merchantId=%s,\n' % self.gds_encode(quote_python(self.merchantId)))
        if self.secret is not None:
            showIndent(outfile, level)
            outfile.write('secret=%s,\n' % self.gds_encode(quote_python(self.secret)))
        if self.payFacSubMerchantIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('payFacSubMerchantIdentifier=%s,\n' % self.gds_encode(quote_python(self.payFacSubMerchantIdentifier)))
        if self.payFacSubMerchantName is not None:
            showIndent(outfile, level)
            outfile.write('payFacSubMerchantName=%s,\n' % self.gds_encode(quote_python(self.payFacSubMerchantName)))
        if self.bankSettings is not None:
            showIndent(outfile, level)
            outfile.write('bankSettings=model_.terminalBankSettings(\n')
            self.bankSettings.exportLiteral(outfile, level, name_='bankSettings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.additionalSettings is not None:
            showIndent(outfile, level)
            outfile.write('additionalSettings=model_.additionalSettings(\n')
            self.additionalSettings.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.features is not None:
            showIndent(outfile, level)
            outfile.write('features=model_.features(\n')
            self.features.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.terminalLimits is not None:
            showIndent(outfile, level)
            outfile.write('terminalLimits=model_.terminalLimits(\n')
            self.terminalLimits.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.receiptsNotification is not None:
            showIndent(outfile, level)
            outfile.write('receiptsNotification=model_.terminalReceiptsNotification(\n')
            self.receiptsNotification.exportLiteral(outfile, level, name_='receiptsNotification')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.securityFraud is not None:
            showIndent(outfile, level)
            outfile.write('securityFraud=model_.terminalSecurityFraud(\n')
            self.securityFraud.exportLiteral(outfile, level, name_='securityFraud')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.achSettings is not None:
            showIndent(outfile, level)
            outfile.write('achSettings=model_.terminalAchSettings(\n')
            self.achSettings.exportLiteral(outfile, level, name_='achSettings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.unionPayProcessing is not None:
            showIndent(outfile, level)
            outfile.write('unionPayProcessing=model_.terminalUnionPayProcessing(\n')
            self.unionPayProcessing.exportLiteral(outfile, level, name_='unionPayProcessing')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.integration is not None:
            showIndent(outfile, level)
            outfile.write('integration=model_.terminalIntegration(\n')
            self.integration.exportLiteral(outfile, level, name_='integration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cards is not None:
            showIndent(outfile, level)
            outfile.write('cards=model_.cardsType(\n')
            self.cards.exportLiteral(outfile, level, name_='cards')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.threeDsCards is not None:
            showIndent(outfile, level)
            outfile.write('threeDsCards=model_.threeDsCardsType(\n')
            self.threeDsCards.exportLiteral(outfile, level, name_='threeDsCards')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deactivationDate is not None:
            showIndent(outfile, level)
            outfile.write('deactivationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.deactivationDate, input_name='deactivationDate'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'templateName':
            templateName_ = child_.text
            templateName_ = self.gds_validate_string(templateName_, node, 'templateName')
            self.templateName = templateName_
        elif nodeName_ == 'terminalNumber':
            terminalNumber_ = child_.text
            terminalNumber_ = self.gds_validate_string(terminalNumber_, node, 'terminalNumber')
            self.terminalNumber = terminalNumber_
        elif nodeName_ == 'acquirer':
            acquirer_ = child_.text
            acquirer_ = self.gds_validate_string(acquirer_, node, 'acquirer')
            self.acquirer = acquirer_
        elif nodeName_ == 'groupBank':
            groupBank_ = child_.text
            groupBank_ = self.gds_validate_string(groupBank_, node, 'groupBank')
            self.groupBank = groupBank_
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
        elif nodeName_ == 'timeZone':
            timeZone_ = child_.text
            timeZone_ = self.gds_validate_string(timeZone_, node, 'timeZone')
            self.timeZone = timeZone_
        elif nodeName_ == 'useTerminalAddress':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'useTerminalAddress')
            self.useTerminalAddress = ival_
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
        elif nodeName_ == 'address1':
            address1_ = child_.text
            address1_ = self.gds_validate_string(address1_, node, 'address1')
            self.address1 = address1_
        elif nodeName_ == 'address2':
            address2_ = child_.text
            address2_ = self.gds_validate_string(address2_, node, 'address2')
            self.address2 = address2_
        elif nodeName_ == 'address3':
            address3_ = child_.text
            address3_ = self.gds_validate_string(address3_, node, 'address3')
            self.address3 = address3_
        elif nodeName_ == 'contactPhone':
            contactPhone_ = child_.text
            contactPhone_ = self.gds_validate_string(contactPhone_, node, 'contactPhone')
            self.contactPhone = contactPhone_
        elif nodeName_ == 'merchantId':
            merchantId_ = child_.text
            merchantId_ = self.gds_validate_string(merchantId_, node, 'merchantId')
            self.merchantId = merchantId_
        elif nodeName_ == 'secret':
            secret_ = child_.text
            secret_ = self.gds_validate_string(secret_, node, 'secret')
            self.secret = secret_
        elif nodeName_ == 'payFacSubMerchantIdentifier':
            payFacSubMerchantIdentifier_ = child_.text
            payFacSubMerchantIdentifier_ = self.gds_validate_string(payFacSubMerchantIdentifier_, node, 'payFacSubMerchantIdentifier')
            self.payFacSubMerchantIdentifier = payFacSubMerchantIdentifier_
        elif nodeName_ == 'payFacSubMerchantName':
            payFacSubMerchantName_ = child_.text
            payFacSubMerchantName_ = self.gds_validate_string(payFacSubMerchantName_, node, 'payFacSubMerchantName')
            self.payFacSubMerchantName = payFacSubMerchantName_
        elif nodeName_ == 'bankSettings':
            obj_ = terminalBankSettings.factory()
            obj_.build(child_)
            self.bankSettings = obj_
            obj_.original_tagname_ = 'bankSettings'
        elif nodeName_ == 'additionalSettings':
            obj_ = additionalTerminalSettings.factory()
            obj_.build(child_)
            self.additionalSettings = obj_
            obj_.original_tagname_ = 'additionalSettings'
        elif nodeName_ == 'features':
            obj_ = terminalFeatures.factory()
            obj_.build(child_)
            self.features = obj_
            obj_.original_tagname_ = 'features'
        elif nodeName_ == 'terminalLimits':
            obj_ = terminalLimits.factory()
            obj_.build(child_)
            self.terminalLimits = obj_
            obj_.original_tagname_ = 'terminalLimits'
        elif nodeName_ == 'receiptsNotification':
            obj_ = terminalReceiptsNotification.factory()
            obj_.build(child_)
            self.receiptsNotification = obj_
            obj_.original_tagname_ = 'receiptsNotification'
        elif nodeName_ == 'securityFraud':
            obj_ = terminalSecurityFraud.factory()
            obj_.build(child_)
            self.securityFraud = obj_
            obj_.original_tagname_ = 'securityFraud'
        elif nodeName_ == 'achSettings':
            obj_ = terminalAchSettings.factory()
            obj_.build(child_)
            self.achSettings = obj_
            obj_.original_tagname_ = 'achSettings'
        elif nodeName_ == 'unionPayProcessing':
            obj_ = terminalUnionPayProcessing.factory()
            obj_.build(child_)
            self.unionPayProcessing = obj_
            obj_.original_tagname_ = 'unionPayProcessing'
        elif nodeName_ == 'integration':
            obj_ = terminalIntegration.factory()
            obj_.build(child_)
            self.integration = obj_
            obj_.original_tagname_ = 'integration'
        elif nodeName_ == 'cards':
            obj_ = cardsType.factory()
            obj_.build(child_)
            self.cards = obj_
            obj_.original_tagname_ = 'cards'
        elif nodeName_ == 'threeDsCards':
            obj_ = threeDsCardsType.factory()
            obj_.build(child_)
            self.threeDsCards = obj_
            obj_.original_tagname_ = 'threeDsCards'
        elif nodeName_ == 'deactivationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.deactivationDate = dval_
    def sample_method(self):
        pass
# end class terminal


class terminalBankSettings(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('currency', 'xs:string', 0, 1, {'name': 'currency', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowMulticurrency', 'xs:boolean', 0, 1, {'name': 'allowMulticurrency', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowEmcp', 'xs:boolean', 0, 1, {'name': 'allowEmcp', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('edccProvider', 'xs:string', 0, 1, {'name': 'edccProvider', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('currencies', 'currenciesType', 0, 1, {'name': 'currencies', 'minOccurs': '0', 'type': 'currenciesType'}, None),
        MemberSpec_('allowMoto', 'xs:boolean', 0, 0, {'name': 'allowMoto', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowInternet', 'xs:boolean', 0, 0, {'name': 'allowInternet', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowRecurring', 'xs:boolean', 0, 1, {'name': 'allowRecurring', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowPreAuth', 'xs:boolean', 0, 1, {'name': 'allowPreAuth', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('bankCompanyId', 'xs:string', 0, 1, {'name': 'bankCompanyId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowCHP', 'xs:boolean', 0, 1, {'name': 'allowCHP', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('terminalTypeDefault', ['terminalTypeDefaultEnum', 'xs:string'], 0, 1, {'name': 'terminalTypeDefault', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('thirdPartyCertificationNumber', 'xs:string', 0, 1, {'name': 'thirdPartyCertificationNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('enableAutomaticSettle', 'xs:boolean', 0, 1, {'name': 'enableAutomaticSettle', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('batchTime', 'xs:string', 0, 1, {'name': 'batchTime', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'name': 'displayName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowEditDisplayName', 'xs:boolean', 0, 1, {'name': 'allowEditDisplayName', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('forceUniqueOrder', 'xs:boolean', 0, 1, {'name': 'forceUniqueOrder', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('bankTerminalId', 'xs:string', 0, 1, {'name': 'bankTerminalId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('bankMerchantId', 'xs:string', 0, 1, {'name': 'bankMerchantId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('bankPassword', 'xs:string', 0, 1, {'name': 'bankPassword', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('frontEndGroupId', 'xs:string', 0, 1, {'name': 'frontEndGroupId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('terminalCapability', ['terminalCapabilityEnum', 'xs:string'], 0, 1, {'name': 'terminalCapability', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('customerServiceEmail', 'xs:string', 0, 1, {'name': 'customerServiceEmail', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('customerServiceUrl', 'xs:string', 0, 1, {'name': 'customerServiceUrl', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('customerServicePhone', 'xs:string', 0, 1, {'name': 'customerServicePhone', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('referenceCodeOrderIdOnly', 'xs:boolean', 0, 1, {'name': 'referenceCodeOrderIdOnly', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('cyberSourcePublicKey', 'xs:string', 0, 1, {'name': 'cyberSourcePublicKey', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('nmiDefaultCardholderEmail', 'xs:string', 0, 1, {'name': 'nmiDefaultCardholderEmail', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('fcsId', 'xs:string', 0, 1, {'name': 'fcsId', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, currency=None, allowMulticurrency=None, allowEmcp=None, edccProvider=None, currencies=None, allowMoto=None, allowInternet=None, allowRecurring=None, allowPreAuth=None, bankCompanyId=None, allowCHP=None, terminalTypeDefault=None, thirdPartyCertificationNumber=None, enableAutomaticSettle=None, batchTime=None, displayName=None, allowEditDisplayName=None, forceUniqueOrder=None, bankTerminalId=None, bankMerchantId=None, bankPassword=None, frontEndGroupId=None, terminalCapability=None, customerServiceEmail=None, customerServiceUrl=None, customerServicePhone=None, referenceCodeOrderIdOnly=None, cyberSourcePublicKey=None, nmiDefaultCardholderEmail=None, fcsId=None):
        self.original_tagname_ = None
        self.currency = currency
        self.allowMulticurrency = allowMulticurrency
        self.allowEmcp = allowEmcp
        self.edccProvider = edccProvider
        self.currencies = currencies
        self.allowMoto = allowMoto
        self.allowInternet = allowInternet
        self.allowRecurring = allowRecurring
        self.allowPreAuth = allowPreAuth
        self.bankCompanyId = bankCompanyId
        self.allowCHP = allowCHP
        self.terminalTypeDefault = terminalTypeDefault
        self.validate_terminalTypeDefaultEnum(self.terminalTypeDefault)
        self.thirdPartyCertificationNumber = thirdPartyCertificationNumber
        self.enableAutomaticSettle = enableAutomaticSettle
        self.batchTime = batchTime
        self.displayName = displayName
        self.allowEditDisplayName = allowEditDisplayName
        self.forceUniqueOrder = forceUniqueOrder
        self.bankTerminalId = bankTerminalId
        self.bankMerchantId = bankMerchantId
        self.bankPassword = bankPassword
        self.frontEndGroupId = frontEndGroupId
        self.terminalCapability = terminalCapability
        self.validate_terminalCapabilityEnum(self.terminalCapability)
        self.customerServiceEmail = customerServiceEmail
        self.customerServiceUrl = customerServiceUrl
        self.customerServicePhone = customerServicePhone
        self.referenceCodeOrderIdOnly = referenceCodeOrderIdOnly
        self.cyberSourcePublicKey = cyberSourcePublicKey
        self.nmiDefaultCardholderEmail = nmiDefaultCardholderEmail
        self.fcsId = fcsId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalBankSettings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalBankSettings.subclass:
            return terminalBankSettings.subclass(*args_, **kwargs_)
        else:
            return terminalBankSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_allowMulticurrency(self): return self.allowMulticurrency
    def set_allowMulticurrency(self, allowMulticurrency): self.allowMulticurrency = allowMulticurrency
    def get_allowEmcp(self): return self.allowEmcp
    def set_allowEmcp(self, allowEmcp): self.allowEmcp = allowEmcp
    def get_edccProvider(self): return self.edccProvider
    def set_edccProvider(self, edccProvider): self.edccProvider = edccProvider
    def get_currencies(self): return self.currencies
    def set_currencies(self, currencies): self.currencies = currencies
    def get_allowMoto(self): return self.allowMoto
    def set_allowMoto(self, allowMoto): self.allowMoto = allowMoto
    def get_allowInternet(self): return self.allowInternet
    def set_allowInternet(self, allowInternet): self.allowInternet = allowInternet
    def get_allowRecurring(self): return self.allowRecurring
    def set_allowRecurring(self, allowRecurring): self.allowRecurring = allowRecurring
    def get_allowPreAuth(self): return self.allowPreAuth
    def set_allowPreAuth(self, allowPreAuth): self.allowPreAuth = allowPreAuth
    def get_bankCompanyId(self): return self.bankCompanyId
    def set_bankCompanyId(self, bankCompanyId): self.bankCompanyId = bankCompanyId
    def get_allowCHP(self): return self.allowCHP
    def set_allowCHP(self, allowCHP): self.allowCHP = allowCHP
    def get_terminalTypeDefault(self): return self.terminalTypeDefault
    def set_terminalTypeDefault(self, terminalTypeDefault): self.terminalTypeDefault = terminalTypeDefault
    def get_thirdPartyCertificationNumber(self): return self.thirdPartyCertificationNumber
    def set_thirdPartyCertificationNumber(self, thirdPartyCertificationNumber): self.thirdPartyCertificationNumber = thirdPartyCertificationNumber
    def get_enableAutomaticSettle(self): return self.enableAutomaticSettle
    def set_enableAutomaticSettle(self, enableAutomaticSettle): self.enableAutomaticSettle = enableAutomaticSettle
    def get_batchTime(self): return self.batchTime
    def set_batchTime(self, batchTime): self.batchTime = batchTime
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_allowEditDisplayName(self): return self.allowEditDisplayName
    def set_allowEditDisplayName(self, allowEditDisplayName): self.allowEditDisplayName = allowEditDisplayName
    def get_forceUniqueOrder(self): return self.forceUniqueOrder
    def set_forceUniqueOrder(self, forceUniqueOrder): self.forceUniqueOrder = forceUniqueOrder
    def get_bankTerminalId(self): return self.bankTerminalId
    def set_bankTerminalId(self, bankTerminalId): self.bankTerminalId = bankTerminalId
    def get_bankMerchantId(self): return self.bankMerchantId
    def set_bankMerchantId(self, bankMerchantId): self.bankMerchantId = bankMerchantId
    def get_bankPassword(self): return self.bankPassword
    def set_bankPassword(self, bankPassword): self.bankPassword = bankPassword
    def get_frontEndGroupId(self): return self.frontEndGroupId
    def set_frontEndGroupId(self, frontEndGroupId): self.frontEndGroupId = frontEndGroupId
    def get_terminalCapability(self): return self.terminalCapability
    def set_terminalCapability(self, terminalCapability): self.terminalCapability = terminalCapability
    def get_customerServiceEmail(self): return self.customerServiceEmail
    def set_customerServiceEmail(self, customerServiceEmail): self.customerServiceEmail = customerServiceEmail
    def get_customerServiceUrl(self): return self.customerServiceUrl
    def set_customerServiceUrl(self, customerServiceUrl): self.customerServiceUrl = customerServiceUrl
    def get_customerServicePhone(self): return self.customerServicePhone
    def set_customerServicePhone(self, customerServicePhone): self.customerServicePhone = customerServicePhone
    def get_referenceCodeOrderIdOnly(self): return self.referenceCodeOrderIdOnly
    def set_referenceCodeOrderIdOnly(self, referenceCodeOrderIdOnly): self.referenceCodeOrderIdOnly = referenceCodeOrderIdOnly
    def get_cyberSourcePublicKey(self): return self.cyberSourcePublicKey
    def set_cyberSourcePublicKey(self, cyberSourcePublicKey): self.cyberSourcePublicKey = cyberSourcePublicKey
    def get_nmiDefaultCardholderEmail(self): return self.nmiDefaultCardholderEmail
    def set_nmiDefaultCardholderEmail(self, nmiDefaultCardholderEmail): self.nmiDefaultCardholderEmail = nmiDefaultCardholderEmail
    def get_fcsId(self): return self.fcsId
    def set_fcsId(self, fcsId): self.fcsId = fcsId
    def validate_terminalTypeDefaultEnum(self, value):
        # Validate type terminalTypeDefaultEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MOTO', 'CHP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on terminalTypeDefaultEnum' % {"value" : value.encode("utf-8")} )
    def validate_terminalCapabilityEnum(self, value):
        # Validate type terminalCapabilityEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MAG_STRIPE_READ_ONLY', 'MAG_STRIPE_AND_MANUAL_ENTRY', 'MANUAL_ENTRY_ONLY', 'EMV_INCLUDE_PROXIMITY', 'EMV_DOES_NOT_INCLUDE_CONTACT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on terminalCapabilityEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.currency is not None or
            self.allowMulticurrency is not None or
            self.allowEmcp is not None or
            self.edccProvider is not None or
            self.currencies is not None or
            self.allowMoto is not None or
            self.allowInternet is not None or
            self.allowRecurring is not None or
            self.allowPreAuth is not None or
            self.bankCompanyId is not None or
            self.allowCHP is not None or
            self.terminalTypeDefault is not None or
            self.thirdPartyCertificationNumber is not None or
            self.enableAutomaticSettle is not None or
            self.batchTime is not None or
            self.displayName is not None or
            self.allowEditDisplayName is not None or
            self.forceUniqueOrder is not None or
            self.bankTerminalId is not None or
            self.bankMerchantId is not None or
            self.bankPassword is not None or
            self.frontEndGroupId is not None or
            self.terminalCapability is not None or
            self.customerServiceEmail is not None or
            self.customerServiceUrl is not None or
            self.customerServicePhone is not None or
            self.referenceCodeOrderIdOnly is not None or
            self.cyberSourcePublicKey is not None or
            self.nmiDefaultCardholderEmail is not None or
            self.fcsId is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalBankSettings', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.currency is not None:
            currency_ = self.currency
            etree_.SubElement(element, '{}currency').text = self.gds_format_string(currency_)
        if self.allowMulticurrency is not None:
            allowMulticurrency_ = self.allowMulticurrency
            etree_.SubElement(element, '{}allowMulticurrency').text = self.gds_format_boolean(allowMulticurrency_)
        if self.allowEmcp is not None:
            allowEmcp_ = self.allowEmcp
            etree_.SubElement(element, '{}allowEmcp').text = self.gds_format_boolean(allowEmcp_)
        if self.edccProvider is not None:
            edccProvider_ = self.edccProvider
            etree_.SubElement(element, '{}edccProvider').text = self.gds_format_string(edccProvider_)
        if self.currencies is not None:
            currencies_ = self.currencies
            currencies_.to_etree(element, name_='currencies', mapping_=mapping_)
        if self.allowMoto is not None:
            allowMoto_ = self.allowMoto
            etree_.SubElement(element, '{}allowMoto').text = self.gds_format_boolean(allowMoto_)
        if self.allowInternet is not None:
            allowInternet_ = self.allowInternet
            etree_.SubElement(element, '{}allowInternet').text = self.gds_format_boolean(allowInternet_)
        if self.allowRecurring is not None:
            allowRecurring_ = self.allowRecurring
            etree_.SubElement(element, '{}allowRecurring').text = self.gds_format_boolean(allowRecurring_)
        if self.allowPreAuth is not None:
            allowPreAuth_ = self.allowPreAuth
            etree_.SubElement(element, '{}allowPreAuth').text = self.gds_format_boolean(allowPreAuth_)
        if self.bankCompanyId is not None:
            bankCompanyId_ = self.bankCompanyId
            etree_.SubElement(element, '{}bankCompanyId').text = self.gds_format_string(bankCompanyId_)
        if self.allowCHP is not None:
            allowCHP_ = self.allowCHP
            etree_.SubElement(element, '{}allowCHP').text = self.gds_format_boolean(allowCHP_)
        if self.terminalTypeDefault is not None:
            terminalTypeDefault_ = self.terminalTypeDefault
            etree_.SubElement(element, '{}terminalTypeDefault').text = self.gds_format_string(terminalTypeDefault_)
        if self.thirdPartyCertificationNumber is not None:
            thirdPartyCertificationNumber_ = self.thirdPartyCertificationNumber
            etree_.SubElement(element, '{}thirdPartyCertificationNumber').text = self.gds_format_string(thirdPartyCertificationNumber_)
        if self.enableAutomaticSettle is not None:
            enableAutomaticSettle_ = self.enableAutomaticSettle
            etree_.SubElement(element, '{}enableAutomaticSettle').text = self.gds_format_boolean(enableAutomaticSettle_)
        if self.batchTime is not None:
            batchTime_ = self.batchTime
            etree_.SubElement(element, '{}batchTime').text = self.gds_format_string(batchTime_)
        if self.displayName is not None:
            displayName_ = self.displayName
            etree_.SubElement(element, '{}displayName').text = self.gds_format_string(displayName_)
        if self.allowEditDisplayName is not None:
            allowEditDisplayName_ = self.allowEditDisplayName
            etree_.SubElement(element, '{}allowEditDisplayName').text = self.gds_format_boolean(allowEditDisplayName_)
        if self.forceUniqueOrder is not None:
            forceUniqueOrder_ = self.forceUniqueOrder
            etree_.SubElement(element, '{}forceUniqueOrder').text = self.gds_format_boolean(forceUniqueOrder_)
        if self.bankTerminalId is not None:
            bankTerminalId_ = self.bankTerminalId
            etree_.SubElement(element, '{}bankTerminalId').text = self.gds_format_string(bankTerminalId_)
        if self.bankMerchantId is not None:
            bankMerchantId_ = self.bankMerchantId
            etree_.SubElement(element, '{}bankMerchantId').text = self.gds_format_string(bankMerchantId_)
        if self.bankPassword is not None:
            bankPassword_ = self.bankPassword
            etree_.SubElement(element, '{}bankPassword').text = self.gds_format_string(bankPassword_)
        if self.frontEndGroupId is not None:
            frontEndGroupId_ = self.frontEndGroupId
            etree_.SubElement(element, '{}frontEndGroupId').text = self.gds_format_string(frontEndGroupId_)
        if self.terminalCapability is not None:
            terminalCapability_ = self.terminalCapability
            etree_.SubElement(element, '{}terminalCapability').text = self.gds_format_string(terminalCapability_)
        if self.customerServiceEmail is not None:
            customerServiceEmail_ = self.customerServiceEmail
            etree_.SubElement(element, '{}customerServiceEmail').text = self.gds_format_string(customerServiceEmail_)
        if self.customerServiceUrl is not None:
            customerServiceUrl_ = self.customerServiceUrl
            etree_.SubElement(element, '{}customerServiceUrl').text = self.gds_format_string(customerServiceUrl_)
        if self.customerServicePhone is not None:
            customerServicePhone_ = self.customerServicePhone
            etree_.SubElement(element, '{}customerServicePhone').text = self.gds_format_string(customerServicePhone_)
        if self.referenceCodeOrderIdOnly is not None:
            referenceCodeOrderIdOnly_ = self.referenceCodeOrderIdOnly
            etree_.SubElement(element, '{}referenceCodeOrderIdOnly').text = self.gds_format_boolean(referenceCodeOrderIdOnly_)
        if self.cyberSourcePublicKey is not None:
            cyberSourcePublicKey_ = self.cyberSourcePublicKey
            etree_.SubElement(element, '{}cyberSourcePublicKey').text = self.gds_format_string(cyberSourcePublicKey_)
        if self.nmiDefaultCardholderEmail is not None:
            nmiDefaultCardholderEmail_ = self.nmiDefaultCardholderEmail
            etree_.SubElement(element, '{}nmiDefaultCardholderEmail').text = self.gds_format_string(nmiDefaultCardholderEmail_)
        if self.fcsId is not None:
            fcsId_ = self.fcsId
            etree_.SubElement(element, '{}fcsId').text = self.gds_format_string(fcsId_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalBankSettings'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=%s,\n' % self.gds_encode(quote_python(self.currency)))
        if self.allowMulticurrency is not None:
            showIndent(outfile, level)
            outfile.write('allowMulticurrency=%s,\n' % self.allowMulticurrency)
        if self.allowEmcp is not None:
            showIndent(outfile, level)
            outfile.write('allowEmcp=%s,\n' % self.allowEmcp)
        if self.edccProvider is not None:
            showIndent(outfile, level)
            outfile.write('edccProvider=%s,\n' % self.gds_encode(quote_python(self.edccProvider)))
        if self.currencies is not None:
            showIndent(outfile, level)
            outfile.write('currencies=model_.currenciesType(\n')
            self.currencies.exportLiteral(outfile, level, name_='currencies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.allowMoto is not None:
            showIndent(outfile, level)
            outfile.write('allowMoto=%s,\n' % self.allowMoto)
        if self.allowInternet is not None:
            showIndent(outfile, level)
            outfile.write('allowInternet=%s,\n' % self.allowInternet)
        if self.allowRecurring is not None:
            showIndent(outfile, level)
            outfile.write('allowRecurring=%s,\n' % self.allowRecurring)
        if self.allowPreAuth is not None:
            showIndent(outfile, level)
            outfile.write('allowPreAuth=%s,\n' % self.allowPreAuth)
        if self.bankCompanyId is not None:
            showIndent(outfile, level)
            outfile.write('bankCompanyId=%s,\n' % self.gds_encode(quote_python(self.bankCompanyId)))
        if self.allowCHP is not None:
            showIndent(outfile, level)
            outfile.write('allowCHP=%s,\n' % self.allowCHP)
        if self.terminalTypeDefault is not None:
            showIndent(outfile, level)
            outfile.write('terminalTypeDefault=%s,\n' % self.gds_encode(quote_python(self.terminalTypeDefault)))
        if self.thirdPartyCertificationNumber is not None:
            showIndent(outfile, level)
            outfile.write('thirdPartyCertificationNumber=%s,\n' % self.gds_encode(quote_python(self.thirdPartyCertificationNumber)))
        if self.enableAutomaticSettle is not None:
            showIndent(outfile, level)
            outfile.write('enableAutomaticSettle=%s,\n' % self.enableAutomaticSettle)
        if self.batchTime is not None:
            showIndent(outfile, level)
            outfile.write('batchTime=%s,\n' % self.gds_encode(quote_python(self.batchTime)))
        if self.displayName is not None:
            showIndent(outfile, level)
            outfile.write('displayName=%s,\n' % self.gds_encode(quote_python(self.displayName)))
        if self.allowEditDisplayName is not None:
            showIndent(outfile, level)
            outfile.write('allowEditDisplayName=%s,\n' % self.allowEditDisplayName)
        if self.forceUniqueOrder is not None:
            showIndent(outfile, level)
            outfile.write('forceUniqueOrder=%s,\n' % self.forceUniqueOrder)
        if self.bankTerminalId is not None:
            showIndent(outfile, level)
            outfile.write('bankTerminalId=%s,\n' % self.gds_encode(quote_python(self.bankTerminalId)))
        if self.bankMerchantId is not None:
            showIndent(outfile, level)
            outfile.write('bankMerchantId=%s,\n' % self.gds_encode(quote_python(self.bankMerchantId)))
        if self.bankPassword is not None:
            showIndent(outfile, level)
            outfile.write('bankPassword=%s,\n' % self.gds_encode(quote_python(self.bankPassword)))
        if self.frontEndGroupId is not None:
            showIndent(outfile, level)
            outfile.write('frontEndGroupId=%s,\n' % self.gds_encode(quote_python(self.frontEndGroupId)))
        if self.terminalCapability is not None:
            showIndent(outfile, level)
            outfile.write('terminalCapability=%s,\n' % self.gds_encode(quote_python(self.terminalCapability)))
        if self.customerServiceEmail is not None:
            showIndent(outfile, level)
            outfile.write('customerServiceEmail=%s,\n' % self.gds_encode(quote_python(self.customerServiceEmail)))
        if self.customerServiceUrl is not None:
            showIndent(outfile, level)
            outfile.write('customerServiceUrl=%s,\n' % self.gds_encode(quote_python(self.customerServiceUrl)))
        if self.customerServicePhone is not None:
            showIndent(outfile, level)
            outfile.write('customerServicePhone=%s,\n' % self.gds_encode(quote_python(self.customerServicePhone)))
        if self.referenceCodeOrderIdOnly is not None:
            showIndent(outfile, level)
            outfile.write('referenceCodeOrderIdOnly=%s,\n' % self.referenceCodeOrderIdOnly)
        if self.cyberSourcePublicKey is not None:
            showIndent(outfile, level)
            outfile.write('cyberSourcePublicKey=%s,\n' % self.gds_encode(quote_python(self.cyberSourcePublicKey)))
        if self.nmiDefaultCardholderEmail is not None:
            showIndent(outfile, level)
            outfile.write('nmiDefaultCardholderEmail=%s,\n' % self.gds_encode(quote_python(self.nmiDefaultCardholderEmail)))
        if self.fcsId is not None:
            showIndent(outfile, level)
            outfile.write('fcsId=%s,\n' % self.gds_encode(quote_python(self.fcsId)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            currency_ = child_.text
            currency_ = self.gds_validate_string(currency_, node, 'currency')
            self.currency = currency_
        elif nodeName_ == 'allowMulticurrency':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowMulticurrency')
            self.allowMulticurrency = ival_
        elif nodeName_ == 'allowEmcp':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowEmcp')
            self.allowEmcp = ival_
        elif nodeName_ == 'edccProvider':
            edccProvider_ = child_.text
            edccProvider_ = self.gds_validate_string(edccProvider_, node, 'edccProvider')
            self.edccProvider = edccProvider_
        elif nodeName_ == 'currencies':
            obj_ = currenciesType.factory()
            obj_.build(child_)
            self.currencies = obj_
            obj_.original_tagname_ = 'currencies'
        elif nodeName_ == 'allowMoto':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowMoto')
            self.allowMoto = ival_
        elif nodeName_ == 'allowInternet':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowInternet')
            self.allowInternet = ival_
        elif nodeName_ == 'allowRecurring':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowRecurring')
            self.allowRecurring = ival_
        elif nodeName_ == 'allowPreAuth':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowPreAuth')
            self.allowPreAuth = ival_
        elif nodeName_ == 'bankCompanyId':
            bankCompanyId_ = child_.text
            bankCompanyId_ = self.gds_validate_string(bankCompanyId_, node, 'bankCompanyId')
            self.bankCompanyId = bankCompanyId_
        elif nodeName_ == 'allowCHP':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowCHP')
            self.allowCHP = ival_
        elif nodeName_ == 'terminalTypeDefault':
            terminalTypeDefault_ = child_.text
            terminalTypeDefault_ = self.gds_validate_string(terminalTypeDefault_, node, 'terminalTypeDefault')
            self.terminalTypeDefault = terminalTypeDefault_
            # validate type terminalTypeDefaultEnum
            self.validate_terminalTypeDefaultEnum(self.terminalTypeDefault)
        elif nodeName_ == 'thirdPartyCertificationNumber':
            thirdPartyCertificationNumber_ = child_.text
            thirdPartyCertificationNumber_ = self.gds_validate_string(thirdPartyCertificationNumber_, node, 'thirdPartyCertificationNumber')
            self.thirdPartyCertificationNumber = thirdPartyCertificationNumber_
        elif nodeName_ == 'enableAutomaticSettle':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableAutomaticSettle')
            self.enableAutomaticSettle = ival_
        elif nodeName_ == 'batchTime':
            batchTime_ = child_.text
            batchTime_ = self.gds_validate_string(batchTime_, node, 'batchTime')
            self.batchTime = batchTime_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'allowEditDisplayName':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowEditDisplayName')
            self.allowEditDisplayName = ival_
        elif nodeName_ == 'forceUniqueOrder':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'forceUniqueOrder')
            self.forceUniqueOrder = ival_
        elif nodeName_ == 'bankTerminalId':
            bankTerminalId_ = child_.text
            bankTerminalId_ = self.gds_validate_string(bankTerminalId_, node, 'bankTerminalId')
            self.bankTerminalId = bankTerminalId_
        elif nodeName_ == 'bankMerchantId':
            bankMerchantId_ = child_.text
            bankMerchantId_ = self.gds_validate_string(bankMerchantId_, node, 'bankMerchantId')
            self.bankMerchantId = bankMerchantId_
        elif nodeName_ == 'bankPassword':
            bankPassword_ = child_.text
            bankPassword_ = self.gds_validate_string(bankPassword_, node, 'bankPassword')
            self.bankPassword = bankPassword_
        elif nodeName_ == 'frontEndGroupId':
            frontEndGroupId_ = child_.text
            frontEndGroupId_ = self.gds_validate_string(frontEndGroupId_, node, 'frontEndGroupId')
            self.frontEndGroupId = frontEndGroupId_
        elif nodeName_ == 'terminalCapability':
            terminalCapability_ = child_.text
            terminalCapability_ = self.gds_validate_string(terminalCapability_, node, 'terminalCapability')
            self.terminalCapability = terminalCapability_
            # validate type terminalCapabilityEnum
            self.validate_terminalCapabilityEnum(self.terminalCapability)
        elif nodeName_ == 'customerServiceEmail':
            customerServiceEmail_ = child_.text
            customerServiceEmail_ = self.gds_validate_string(customerServiceEmail_, node, 'customerServiceEmail')
            self.customerServiceEmail = customerServiceEmail_
        elif nodeName_ == 'customerServiceUrl':
            customerServiceUrl_ = child_.text
            customerServiceUrl_ = self.gds_validate_string(customerServiceUrl_, node, 'customerServiceUrl')
            self.customerServiceUrl = customerServiceUrl_
        elif nodeName_ == 'customerServicePhone':
            customerServicePhone_ = child_.text
            customerServicePhone_ = self.gds_validate_string(customerServicePhone_, node, 'customerServicePhone')
            self.customerServicePhone = customerServicePhone_
        elif nodeName_ == 'referenceCodeOrderIdOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'referenceCodeOrderIdOnly')
            self.referenceCodeOrderIdOnly = ival_
        elif nodeName_ == 'cyberSourcePublicKey':
            cyberSourcePublicKey_ = child_.text
            cyberSourcePublicKey_ = self.gds_validate_string(cyberSourcePublicKey_, node, 'cyberSourcePublicKey')
            self.cyberSourcePublicKey = cyberSourcePublicKey_
        elif nodeName_ == 'nmiDefaultCardholderEmail':
            nmiDefaultCardholderEmail_ = child_.text
            nmiDefaultCardholderEmail_ = self.gds_validate_string(nmiDefaultCardholderEmail_, node, 'nmiDefaultCardholderEmail')
            self.nmiDefaultCardholderEmail = nmiDefaultCardholderEmail_
        elif nodeName_ == 'fcsId':
            fcsId_ = child_.text
            fcsId_ = self.gds_validate_string(fcsId_, node, 'fcsId')
            self.fcsId = fcsId_
    def sample_method(self):
        pass
# end class terminalBankSettings


class additionalTerminalSettings(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('agentBankNumber', 'xs:string', 0, 1, {'name': 'agentBankNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('terminalIdNumber', 'xs:string', 0, 1, {'name': 'terminalIdNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('agentChainNumber', 'xs:string', 0, 1, {'name': 'agentChainNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('acqInstitutionIdCode', 'xs:string', 0, 1, {'name': 'acqInstitutionIdCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('storeNumber', 'xs:string', 0, 1, {'name': 'storeNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('merchantName', 'xs:string', 0, 1, {'name': 'merchantName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('merchantLocalPhoneNum', 'xs:string', 0, 1, {'name': 'merchantLocalPhoneNum', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('postalCode', 'xs:string', 0, 1, {'name': 'postalCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('merchantCity', 'xs:string', 0, 1, {'name': 'merchantCity', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('markUpPercentage', 'xs:string', 0, 1, {'name': 'markUpPercentage', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('canadianRegion', 'xs:string', 0, 1, {'name': 'canadianRegion', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('usState', 'xs:string', 0, 1, {'name': 'usState', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('abaNumber', 'xs:string', 0, 1, {'name': 'abaNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('settlementAgentNo', 'xs:string', 0, 1, {'name': 'settlementAgentNo', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('industryCode', ['industryCodeEnum', 'xs:string'], 0, 1, {'name': 'industryCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('languageIndicator', ['languageIndicatorEnum', 'xs:string'], 0, 1, {'name': 'languageIndicator', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('authenticationCode', 'xs:string', 0, 1, {'name': 'authenticationCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('acquirerBin', 'xs:string', 0, 1, {'name': 'acquirerBin', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('dstObserved', 'xs:boolean', 0, 1, {'name': 'dstObserved', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('timeZoneOffset', 'xs:int', 0, 1, {'name': 'timeZoneOffset', 'type': 'xs:int', 'minOccurs': '0'}, None),
        MemberSpec_('sharingGroup', 'xs:string', 0, 1, {'name': 'sharingGroup', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowLevel2Data', 'xs:boolean', 0, 1, {'name': 'allowLevel2Data', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('reimbursementAttribute', ['reimbursementAttributeEnum', 'xs:string'], 0, 1, {'name': 'reimbursementAttribute', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardholderSvcPhoneNumber', 'xs:string', 0, 1, {'name': 'cardholderSvcPhoneNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('merchantLocationNumber', 'xs:string', 0, 1, {'name': 'merchantLocationNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cityCode', 'xs:string', 0, 1, {'name': 'cityCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, agentBankNumber=None, terminalIdNumber=None, agentChainNumber=None, acqInstitutionIdCode=None, storeNumber=None, merchantName=None, merchantLocalPhoneNum=None, postalCode=None, merchantCity=None, markUpPercentage=None, canadianRegion=None, usState=None, abaNumber=None, settlementAgentNo=None, industryCode=None, languageIndicator=None, authenticationCode=None, acquirerBin=None, dstObserved=None, timeZoneOffset=None, sharingGroup=None, allowLevel2Data=None, reimbursementAttribute=None, cardholderSvcPhoneNumber=None, merchantLocationNumber=None, cityCode=None):
        self.original_tagname_ = None
        self.agentBankNumber = agentBankNumber
        self.terminalIdNumber = terminalIdNumber
        self.agentChainNumber = agentChainNumber
        self.acqInstitutionIdCode = acqInstitutionIdCode
        self.storeNumber = storeNumber
        self.merchantName = merchantName
        self.merchantLocalPhoneNum = merchantLocalPhoneNum
        self.postalCode = postalCode
        self.merchantCity = merchantCity
        self.markUpPercentage = markUpPercentage
        self.canadianRegion = canadianRegion
        self.usState = usState
        self.abaNumber = abaNumber
        self.settlementAgentNo = settlementAgentNo
        self.industryCode = industryCode
        self.validate_industryCodeEnum(self.industryCode)
        self.languageIndicator = languageIndicator
        self.validate_languageIndicatorEnum(self.languageIndicator)
        self.authenticationCode = authenticationCode
        self.acquirerBin = acquirerBin
        self.dstObserved = dstObserved
        self.timeZoneOffset = timeZoneOffset
        self.sharingGroup = sharingGroup
        self.allowLevel2Data = allowLevel2Data
        self.reimbursementAttribute = reimbursementAttribute
        self.validate_reimbursementAttributeEnum(self.reimbursementAttribute)
        self.cardholderSvcPhoneNumber = cardholderSvcPhoneNumber
        self.merchantLocationNumber = merchantLocationNumber
        self.cityCode = cityCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, additionalTerminalSettings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if additionalTerminalSettings.subclass:
            return additionalTerminalSettings.subclass(*args_, **kwargs_)
        else:
            return additionalTerminalSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agentBankNumber(self): return self.agentBankNumber
    def set_agentBankNumber(self, agentBankNumber): self.agentBankNumber = agentBankNumber
    def get_terminalIdNumber(self): return self.terminalIdNumber
    def set_terminalIdNumber(self, terminalIdNumber): self.terminalIdNumber = terminalIdNumber
    def get_agentChainNumber(self): return self.agentChainNumber
    def set_agentChainNumber(self, agentChainNumber): self.agentChainNumber = agentChainNumber
    def get_acqInstitutionIdCode(self): return self.acqInstitutionIdCode
    def set_acqInstitutionIdCode(self, acqInstitutionIdCode): self.acqInstitutionIdCode = acqInstitutionIdCode
    def get_storeNumber(self): return self.storeNumber
    def set_storeNumber(self, storeNumber): self.storeNumber = storeNumber
    def get_merchantName(self): return self.merchantName
    def set_merchantName(self, merchantName): self.merchantName = merchantName
    def get_merchantLocalPhoneNum(self): return self.merchantLocalPhoneNum
    def set_merchantLocalPhoneNum(self, merchantLocalPhoneNum): self.merchantLocalPhoneNum = merchantLocalPhoneNum
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def get_merchantCity(self): return self.merchantCity
    def set_merchantCity(self, merchantCity): self.merchantCity = merchantCity
    def get_markUpPercentage(self): return self.markUpPercentage
    def set_markUpPercentage(self, markUpPercentage): self.markUpPercentage = markUpPercentage
    def get_canadianRegion(self): return self.canadianRegion
    def set_canadianRegion(self, canadianRegion): self.canadianRegion = canadianRegion
    def get_usState(self): return self.usState
    def set_usState(self, usState): self.usState = usState
    def get_abaNumber(self): return self.abaNumber
    def set_abaNumber(self, abaNumber): self.abaNumber = abaNumber
    def get_settlementAgentNo(self): return self.settlementAgentNo
    def set_settlementAgentNo(self, settlementAgentNo): self.settlementAgentNo = settlementAgentNo
    def get_industryCode(self): return self.industryCode
    def set_industryCode(self, industryCode): self.industryCode = industryCode
    def get_languageIndicator(self): return self.languageIndicator
    def set_languageIndicator(self, languageIndicator): self.languageIndicator = languageIndicator
    def get_authenticationCode(self): return self.authenticationCode
    def set_authenticationCode(self, authenticationCode): self.authenticationCode = authenticationCode
    def get_acquirerBin(self): return self.acquirerBin
    def set_acquirerBin(self, acquirerBin): self.acquirerBin = acquirerBin
    def get_dstObserved(self): return self.dstObserved
    def set_dstObserved(self, dstObserved): self.dstObserved = dstObserved
    def get_timeZoneOffset(self): return self.timeZoneOffset
    def set_timeZoneOffset(self, timeZoneOffset): self.timeZoneOffset = timeZoneOffset
    def get_sharingGroup(self): return self.sharingGroup
    def set_sharingGroup(self, sharingGroup): self.sharingGroup = sharingGroup
    def get_allowLevel2Data(self): return self.allowLevel2Data
    def set_allowLevel2Data(self, allowLevel2Data): self.allowLevel2Data = allowLevel2Data
    def get_reimbursementAttribute(self): return self.reimbursementAttribute
    def set_reimbursementAttribute(self, reimbursementAttribute): self.reimbursementAttribute = reimbursementAttribute
    def get_cardholderSvcPhoneNumber(self): return self.cardholderSvcPhoneNumber
    def set_cardholderSvcPhoneNumber(self, cardholderSvcPhoneNumber): self.cardholderSvcPhoneNumber = cardholderSvcPhoneNumber
    def get_merchantLocationNumber(self): return self.merchantLocationNumber
    def set_merchantLocationNumber(self, merchantLocationNumber): self.merchantLocationNumber = merchantLocationNumber
    def get_cityCode(self): return self.cityCode
    def set_cityCode(self, cityCode): self.cityCode = cityCode
    def validate_industryCodeEnum(self, value):
        # Validate type industryCodeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['UNKNOWN', 'AUTORENTAL', 'FINANCIAL', 'MARKETING', 'FOOD', 'GROCERY', 'HOTEL', 'LIMITED', 'OIL', 'PASSENGER', 'RETAIL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on industryCodeEnum' % {"value" : value.encode("utf-8")} )
    def validate_languageIndicatorEnum(self, value):
        # Validate type languageIndicatorEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ENGLISH']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on languageIndicatorEnum' % {"value" : value.encode("utf-8")} )
    def validate_reimbursementAttributeEnum(self, value):
        # Validate type reimbursementAttributeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ATTRIBUTE_0', 'ATTRIBUTE_W', 'ATTRIBUTE_X', 'ATTRIBUTE_Y', 'ATTRIBUTE_Z']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on reimbursementAttributeEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.agentBankNumber is not None or
            self.terminalIdNumber is not None or
            self.agentChainNumber is not None or
            self.acqInstitutionIdCode is not None or
            self.storeNumber is not None or
            self.merchantName is not None or
            self.merchantLocalPhoneNum is not None or
            self.postalCode is not None or
            self.merchantCity is not None or
            self.markUpPercentage is not None or
            self.canadianRegion is not None or
            self.usState is not None or
            self.abaNumber is not None or
            self.settlementAgentNo is not None or
            self.industryCode is not None or
            self.languageIndicator is not None or
            self.authenticationCode is not None or
            self.acquirerBin is not None or
            self.dstObserved is not None or
            self.timeZoneOffset is not None or
            self.sharingGroup is not None or
            self.allowLevel2Data is not None or
            self.reimbursementAttribute is not None or
            self.cardholderSvcPhoneNumber is not None or
            self.merchantLocationNumber is not None or
            self.cityCode is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='additionalTerminalSettings', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.agentBankNumber is not None:
            agentBankNumber_ = self.agentBankNumber
            etree_.SubElement(element, '{}agentBankNumber').text = self.gds_format_string(agentBankNumber_)
        if self.terminalIdNumber is not None:
            terminalIdNumber_ = self.terminalIdNumber
            etree_.SubElement(element, '{}terminalIdNumber').text = self.gds_format_string(terminalIdNumber_)
        if self.agentChainNumber is not None:
            agentChainNumber_ = self.agentChainNumber
            etree_.SubElement(element, '{}agentChainNumber').text = self.gds_format_string(agentChainNumber_)
        if self.acqInstitutionIdCode is not None:
            acqInstitutionIdCode_ = self.acqInstitutionIdCode
            etree_.SubElement(element, '{}acqInstitutionIdCode').text = self.gds_format_string(acqInstitutionIdCode_)
        if self.storeNumber is not None:
            storeNumber_ = self.storeNumber
            etree_.SubElement(element, '{}storeNumber').text = self.gds_format_string(storeNumber_)
        if self.merchantName is not None:
            merchantName_ = self.merchantName
            etree_.SubElement(element, '{}merchantName').text = self.gds_format_string(merchantName_)
        if self.merchantLocalPhoneNum is not None:
            merchantLocalPhoneNum_ = self.merchantLocalPhoneNum
            etree_.SubElement(element, '{}merchantLocalPhoneNum').text = self.gds_format_string(merchantLocalPhoneNum_)
        if self.postalCode is not None:
            postalCode_ = self.postalCode
            etree_.SubElement(element, '{}postalCode').text = self.gds_format_string(postalCode_)
        if self.merchantCity is not None:
            merchantCity_ = self.merchantCity
            etree_.SubElement(element, '{}merchantCity').text = self.gds_format_string(merchantCity_)
        if self.markUpPercentage is not None:
            markUpPercentage_ = self.markUpPercentage
            etree_.SubElement(element, '{}markUpPercentage').text = self.gds_format_string(markUpPercentage_)
        if self.canadianRegion is not None:
            canadianRegion_ = self.canadianRegion
            etree_.SubElement(element, '{}canadianRegion').text = self.gds_format_string(canadianRegion_)
        if self.usState is not None:
            usState_ = self.usState
            etree_.SubElement(element, '{}usState').text = self.gds_format_string(usState_)
        if self.abaNumber is not None:
            abaNumber_ = self.abaNumber
            etree_.SubElement(element, '{}abaNumber').text = self.gds_format_string(abaNumber_)
        if self.settlementAgentNo is not None:
            settlementAgentNo_ = self.settlementAgentNo
            etree_.SubElement(element, '{}settlementAgentNo').text = self.gds_format_string(settlementAgentNo_)
        if self.industryCode is not None:
            industryCode_ = self.industryCode
            etree_.SubElement(element, '{}industryCode').text = self.gds_format_string(industryCode_)
        if self.languageIndicator is not None:
            languageIndicator_ = self.languageIndicator
            etree_.SubElement(element, '{}languageIndicator').text = self.gds_format_string(languageIndicator_)
        if self.authenticationCode is not None:
            authenticationCode_ = self.authenticationCode
            etree_.SubElement(element, '{}authenticationCode').text = self.gds_format_string(authenticationCode_)
        if self.acquirerBin is not None:
            acquirerBin_ = self.acquirerBin
            etree_.SubElement(element, '{}acquirerBin').text = self.gds_format_string(acquirerBin_)
        if self.dstObserved is not None:
            dstObserved_ = self.dstObserved
            etree_.SubElement(element, '{}dstObserved').text = self.gds_format_boolean(dstObserved_)
        if self.timeZoneOffset is not None:
            timeZoneOffset_ = self.timeZoneOffset
            etree_.SubElement(element, '{}timeZoneOffset').text = self.gds_format_integer(timeZoneOffset_)
        if self.sharingGroup is not None:
            sharingGroup_ = self.sharingGroup
            etree_.SubElement(element, '{}sharingGroup').text = self.gds_format_string(sharingGroup_)
        if self.allowLevel2Data is not None:
            allowLevel2Data_ = self.allowLevel2Data
            etree_.SubElement(element, '{}allowLevel2Data').text = self.gds_format_boolean(allowLevel2Data_)
        if self.reimbursementAttribute is not None:
            reimbursementAttribute_ = self.reimbursementAttribute
            etree_.SubElement(element, '{}reimbursementAttribute').text = self.gds_format_string(reimbursementAttribute_)
        if self.cardholderSvcPhoneNumber is not None:
            cardholderSvcPhoneNumber_ = self.cardholderSvcPhoneNumber
            etree_.SubElement(element, '{}cardholderSvcPhoneNumber').text = self.gds_format_string(cardholderSvcPhoneNumber_)
        if self.merchantLocationNumber is not None:
            merchantLocationNumber_ = self.merchantLocationNumber
            etree_.SubElement(element, '{}merchantLocationNumber').text = self.gds_format_string(merchantLocationNumber_)
        if self.cityCode is not None:
            cityCode_ = self.cityCode
            etree_.SubElement(element, '{}cityCode').text = self.gds_format_string(cityCode_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='additionalTerminalSettings'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.agentBankNumber is not None:
            showIndent(outfile, level)
            outfile.write('agentBankNumber=%s,\n' % self.gds_encode(quote_python(self.agentBankNumber)))
        if self.terminalIdNumber is not None:
            showIndent(outfile, level)
            outfile.write('terminalIdNumber=%s,\n' % self.gds_encode(quote_python(self.terminalIdNumber)))
        if self.agentChainNumber is not None:
            showIndent(outfile, level)
            outfile.write('agentChainNumber=%s,\n' % self.gds_encode(quote_python(self.agentChainNumber)))
        if self.acqInstitutionIdCode is not None:
            showIndent(outfile, level)
            outfile.write('acqInstitutionIdCode=%s,\n' % self.gds_encode(quote_python(self.acqInstitutionIdCode)))
        if self.storeNumber is not None:
            showIndent(outfile, level)
            outfile.write('storeNumber=%s,\n' % self.gds_encode(quote_python(self.storeNumber)))
        if self.merchantName is not None:
            showIndent(outfile, level)
            outfile.write('merchantName=%s,\n' % self.gds_encode(quote_python(self.merchantName)))
        if self.merchantLocalPhoneNum is not None:
            showIndent(outfile, level)
            outfile.write('merchantLocalPhoneNum=%s,\n' % self.gds_encode(quote_python(self.merchantLocalPhoneNum)))
        if self.postalCode is not None:
            showIndent(outfile, level)
            outfile.write('postalCode=%s,\n' % self.gds_encode(quote_python(self.postalCode)))
        if self.merchantCity is not None:
            showIndent(outfile, level)
            outfile.write('merchantCity=%s,\n' % self.gds_encode(quote_python(self.merchantCity)))
        if self.markUpPercentage is not None:
            showIndent(outfile, level)
            outfile.write('markUpPercentage=%s,\n' % self.gds_encode(quote_python(self.markUpPercentage)))
        if self.canadianRegion is not None:
            showIndent(outfile, level)
            outfile.write('canadianRegion=%s,\n' % self.gds_encode(quote_python(self.canadianRegion)))
        if self.usState is not None:
            showIndent(outfile, level)
            outfile.write('usState=%s,\n' % self.gds_encode(quote_python(self.usState)))
        if self.abaNumber is not None:
            showIndent(outfile, level)
            outfile.write('abaNumber=%s,\n' % self.gds_encode(quote_python(self.abaNumber)))
        if self.settlementAgentNo is not None:
            showIndent(outfile, level)
            outfile.write('settlementAgentNo=%s,\n' % self.gds_encode(quote_python(self.settlementAgentNo)))
        if self.industryCode is not None:
            showIndent(outfile, level)
            outfile.write('industryCode=%s,\n' % self.gds_encode(quote_python(self.industryCode)))
        if self.languageIndicator is not None:
            showIndent(outfile, level)
            outfile.write('languageIndicator=%s,\n' % self.gds_encode(quote_python(self.languageIndicator)))
        if self.authenticationCode is not None:
            showIndent(outfile, level)
            outfile.write('authenticationCode=%s,\n' % self.gds_encode(quote_python(self.authenticationCode)))
        if self.acquirerBin is not None:
            showIndent(outfile, level)
            outfile.write('acquirerBin=%s,\n' % self.gds_encode(quote_python(self.acquirerBin)))
        if self.dstObserved is not None:
            showIndent(outfile, level)
            outfile.write('dstObserved=%s,\n' % self.dstObserved)
        if self.timeZoneOffset is not None:
            showIndent(outfile, level)
            outfile.write('timeZoneOffset=%d,\n' % self.timeZoneOffset)
        if self.sharingGroup is not None:
            showIndent(outfile, level)
            outfile.write('sharingGroup=%s,\n' % self.gds_encode(quote_python(self.sharingGroup)))
        if self.allowLevel2Data is not None:
            showIndent(outfile, level)
            outfile.write('allowLevel2Data=%s,\n' % self.allowLevel2Data)
        if self.reimbursementAttribute is not None:
            showIndent(outfile, level)
            outfile.write('reimbursementAttribute=%s,\n' % self.gds_encode(quote_python(self.reimbursementAttribute)))
        if self.cardholderSvcPhoneNumber is not None:
            showIndent(outfile, level)
            outfile.write('cardholderSvcPhoneNumber=%s,\n' % self.gds_encode(quote_python(self.cardholderSvcPhoneNumber)))
        if self.merchantLocationNumber is not None:
            showIndent(outfile, level)
            outfile.write('merchantLocationNumber=%s,\n' % self.gds_encode(quote_python(self.merchantLocationNumber)))
        if self.cityCode is not None:
            showIndent(outfile, level)
            outfile.write('cityCode=%s,\n' % self.gds_encode(quote_python(self.cityCode)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'agentBankNumber':
            agentBankNumber_ = child_.text
            agentBankNumber_ = self.gds_validate_string(agentBankNumber_, node, 'agentBankNumber')
            self.agentBankNumber = agentBankNumber_
        elif nodeName_ == 'terminalIdNumber':
            terminalIdNumber_ = child_.text
            terminalIdNumber_ = self.gds_validate_string(terminalIdNumber_, node, 'terminalIdNumber')
            self.terminalIdNumber = terminalIdNumber_
        elif nodeName_ == 'agentChainNumber':
            agentChainNumber_ = child_.text
            agentChainNumber_ = self.gds_validate_string(agentChainNumber_, node, 'agentChainNumber')
            self.agentChainNumber = agentChainNumber_
        elif nodeName_ == 'acqInstitutionIdCode':
            acqInstitutionIdCode_ = child_.text
            acqInstitutionIdCode_ = self.gds_validate_string(acqInstitutionIdCode_, node, 'acqInstitutionIdCode')
            self.acqInstitutionIdCode = acqInstitutionIdCode_
        elif nodeName_ == 'storeNumber':
            storeNumber_ = child_.text
            storeNumber_ = self.gds_validate_string(storeNumber_, node, 'storeNumber')
            self.storeNumber = storeNumber_
        elif nodeName_ == 'merchantName':
            merchantName_ = child_.text
            merchantName_ = self.gds_validate_string(merchantName_, node, 'merchantName')
            self.merchantName = merchantName_
        elif nodeName_ == 'merchantLocalPhoneNum':
            merchantLocalPhoneNum_ = child_.text
            merchantLocalPhoneNum_ = self.gds_validate_string(merchantLocalPhoneNum_, node, 'merchantLocalPhoneNum')
            self.merchantLocalPhoneNum = merchantLocalPhoneNum_
        elif nodeName_ == 'postalCode':
            postalCode_ = child_.text
            postalCode_ = self.gds_validate_string(postalCode_, node, 'postalCode')
            self.postalCode = postalCode_
        elif nodeName_ == 'merchantCity':
            merchantCity_ = child_.text
            merchantCity_ = self.gds_validate_string(merchantCity_, node, 'merchantCity')
            self.merchantCity = merchantCity_
        elif nodeName_ == 'markUpPercentage':
            markUpPercentage_ = child_.text
            markUpPercentage_ = self.gds_validate_string(markUpPercentage_, node, 'markUpPercentage')
            self.markUpPercentage = markUpPercentage_
        elif nodeName_ == 'canadianRegion':
            canadianRegion_ = child_.text
            canadianRegion_ = self.gds_validate_string(canadianRegion_, node, 'canadianRegion')
            self.canadianRegion = canadianRegion_
        elif nodeName_ == 'usState':
            usState_ = child_.text
            usState_ = self.gds_validate_string(usState_, node, 'usState')
            self.usState = usState_
        elif nodeName_ == 'abaNumber':
            abaNumber_ = child_.text
            abaNumber_ = self.gds_validate_string(abaNumber_, node, 'abaNumber')
            self.abaNumber = abaNumber_
        elif nodeName_ == 'settlementAgentNo':
            settlementAgentNo_ = child_.text
            settlementAgentNo_ = self.gds_validate_string(settlementAgentNo_, node, 'settlementAgentNo')
            self.settlementAgentNo = settlementAgentNo_
        elif nodeName_ == 'industryCode':
            industryCode_ = child_.text
            industryCode_ = self.gds_validate_string(industryCode_, node, 'industryCode')
            self.industryCode = industryCode_
            # validate type industryCodeEnum
            self.validate_industryCodeEnum(self.industryCode)
        elif nodeName_ == 'languageIndicator':
            languageIndicator_ = child_.text
            languageIndicator_ = self.gds_validate_string(languageIndicator_, node, 'languageIndicator')
            self.languageIndicator = languageIndicator_
            # validate type languageIndicatorEnum
            self.validate_languageIndicatorEnum(self.languageIndicator)
        elif nodeName_ == 'authenticationCode':
            authenticationCode_ = child_.text
            authenticationCode_ = self.gds_validate_string(authenticationCode_, node, 'authenticationCode')
            self.authenticationCode = authenticationCode_
        elif nodeName_ == 'acquirerBin':
            acquirerBin_ = child_.text
            acquirerBin_ = self.gds_validate_string(acquirerBin_, node, 'acquirerBin')
            self.acquirerBin = acquirerBin_
        elif nodeName_ == 'dstObserved':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'dstObserved')
            self.dstObserved = ival_
        elif nodeName_ == 'timeZoneOffset' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeZoneOffset')
            self.timeZoneOffset = ival_
        elif nodeName_ == 'sharingGroup':
            sharingGroup_ = child_.text
            sharingGroup_ = self.gds_validate_string(sharingGroup_, node, 'sharingGroup')
            self.sharingGroup = sharingGroup_
        elif nodeName_ == 'allowLevel2Data':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowLevel2Data')
            self.allowLevel2Data = ival_
        elif nodeName_ == 'reimbursementAttribute':
            reimbursementAttribute_ = child_.text
            reimbursementAttribute_ = self.gds_validate_string(reimbursementAttribute_, node, 'reimbursementAttribute')
            self.reimbursementAttribute = reimbursementAttribute_
            # validate type reimbursementAttributeEnum
            self.validate_reimbursementAttributeEnum(self.reimbursementAttribute)
        elif nodeName_ == 'cardholderSvcPhoneNumber':
            cardholderSvcPhoneNumber_ = child_.text
            cardholderSvcPhoneNumber_ = self.gds_validate_string(cardholderSvcPhoneNumber_, node, 'cardholderSvcPhoneNumber')
            self.cardholderSvcPhoneNumber = cardholderSvcPhoneNumber_
        elif nodeName_ == 'merchantLocationNumber':
            merchantLocationNumber_ = child_.text
            merchantLocationNumber_ = self.gds_validate_string(merchantLocationNumber_, node, 'merchantLocationNumber')
            self.merchantLocationNumber = merchantLocationNumber_
        elif nodeName_ == 'cityCode':
            cityCode_ = child_.text
            cityCode_ = self.gds_validate_string(cityCode_, node, 'cityCode')
            self.cityCode = cityCode_
    def sample_method(self):
        pass
# end class additionalTerminalSettings


class terminalFeatures(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('allowSecurecards', 'xs:boolean', 0, 0, {'name': 'allowSecurecards', 'type': 'xs:boolean'}, None),
        MemberSpec_('validateScSecurity', 'xs:boolean', 0, 1, {'name': 'validateScSecurity', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('forceScValidation', 'xs:boolean', 0, 1, {'name': 'forceScValidation', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowHppScStorage', 'xs:boolean', 0, 1, {'name': 'allowHppScStorage', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('storeHppScAutomatically', 'xs:boolean', 0, 1, {'name': 'storeHppScAutomatically', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('secureCardHostedPageEmailFieldSetup', ['fieldSetupEnum', 'xs:string'], 0, 1, {'name': 'secureCardHostedPageEmailFieldSetup', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowSubscriptions', 'xs:boolean', 0, 0, {'name': 'allowSubscriptions', 'type': 'xs:boolean'}, None),
        MemberSpec_('subscriptionSkipFailedAttempts', 'xs:boolean', 0, 1, {'name': 'subscriptionSkipFailedAttempts', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('subscriptionMaxWaitForPaymentDays', 'xs:int', 0, 1, {'name': 'subscriptionMaxWaitForPaymentDays', 'type': 'xs:int', 'minOccurs': '0'}, None),
        MemberSpec_('subscriptionMaxMissedPeriods', 'xs:int', 0, 1, {'name': 'subscriptionMaxMissedPeriods', 'type': 'xs:int', 'minOccurs': '0'}, None),
        MemberSpec_('subscriptionPaymentNotificationDays', 'xs:int', 0, 1, {'name': 'subscriptionPaymentNotificationDays', 'type': 'xs:int', 'minOccurs': '0'}, None),
        MemberSpec_('subscriptionMissedPeriodsNotification', 'xs:int', 0, 1, {'name': 'subscriptionMissedPeriodsNotification', 'type': 'xs:int', 'minOccurs': '0'}, None),
        MemberSpec_('subscriptionRepeatNotificationDays', 'xs:int', 0, 1, {'name': 'subscriptionRepeatNotificationDays', 'type': 'xs:int', 'minOccurs': '0'}, None),
        MemberSpec_('subscriptionAuthMaxAttempts', 'xs:int', 0, 1, {'name': 'subscriptionAuthMaxAttempts', 'type': 'xs:int', 'minOccurs': '0'}, None),
        MemberSpec_('vauType', ['cardUpdaterTypeEnum', 'xs:string'], 0, 1, {'name': 'vauType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('vauMerchantId', 'xs:string', 0, 1, {'name': 'vauMerchantId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('abuType', ['cardUpdaterTypeEnum', 'xs:string'], 0, 1, {'name': 'abuType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('abuMerchantId', 'xs:string', 0, 1, {'name': 'abuMerchantId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowDashboard', 'xs:boolean', 0, 1, {'name': 'allowDashboard', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowBulkpayment', 'xs:boolean', 0, 1, {'name': 'allowBulkpayment', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowVtAutoOrderId', 'xs:boolean', 0, 0, {'name': 'allowVtAutoOrderId', 'type': 'xs:boolean'}, None),
        MemberSpec_('enableDecryptx', 'xs:boolean', 0, 1, {'name': 'enableDecryptx', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowPartialCaptures', 'xs:boolean', 0, 1, {'name': 'allowPartialCaptures', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowScheduledReport', 'xs:boolean', 0, 1, {'name': 'allowScheduledReport', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('enableAccountUpdaterBackgroundNotifications', 'xs:boolean', 0, 0, {'name': 'enableAccountUpdaterBackgroundNotifications', 'type': 'xs:boolean'}, None),
        MemberSpec_('accountUpdaterBackgroundNotificationUrl', 'xs:string', 0, 1, {'name': 'accountUpdaterBackgroundNotificationUrl', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowAmexOptBlueParticipation', 'xs:boolean', 0, 1, {'name': 'allowAmexOptBlueParticipation', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('industryServiceEstablishment', 'xs:string', 0, 1, {'name': 'industryServiceEstablishment', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('merchantStreetAddress', 'xs:string', 0, 1, {'name': 'merchantStreetAddress', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowDynamicDescriptor', 'xs:boolean', 0, 1, {'name': 'allowDynamicDescriptor', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('prefixDynamicDescriptor', 'xs:string', 0, 1, {'name': 'prefixDynamicDescriptor', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('defaultDynamicDescriptor', 'xs:string', 0, 1, {'name': 'defaultDynamicDescriptor', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowEnhancedData', 'xs:boolean', 0, 1, {'name': 'allowEnhancedData', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('txnDataLevel', ['levelDataEnum', 'xs:string'], 0, 1, {'name': 'txnDataLevel', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('apiShippingAddressMode', ['apiAddressModeEnum', 'xs:string'], 0, 1, {'name': 'apiShippingAddressMode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('enableTemplateAutofill', 'xs:boolean', 0, 1, {'name': 'enableTemplateAutofill', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('merchantTaxId', 'xs:string', 0, 1, {'name': 'merchantTaxId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('merchantTypeCode', 'xs:string', 0, 1, {'name': 'merchantTypeCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowCredoraxDynamicDescriptor', 'xs:boolean', 0, 1, {'name': 'allowCredoraxDynamicDescriptor', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('credoraxDynamicDescriptorPrefix', 'xs:string', 0, 1, {'name': 'credoraxDynamicDescriptorPrefix', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('credoraxDynamicDescriptorSuffix', 'xs:string', 0, 1, {'name': 'credoraxDynamicDescriptorSuffix', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('googlePayEnabled', 'xs:boolean', 0, 0, {'name': 'googlePayEnabled', 'type': 'xs:boolean'}, None),
        MemberSpec_('applePayEnabled', 'xs:boolean', 0, 1, {'name': 'applePayEnabled', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('appleStoreName', 'xs:string', 0, 1, {'name': 'appleStoreName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('isPayFacAllowed', 'xs:boolean', 0, 1, {'name': 'isPayFacAllowed', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowPaymentLink', 'xs:boolean', 0, 1, {'name': 'allowPaymentLink', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowPayLink', 'xs:boolean', 0, 1, {'name': 'allowPayLink', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('useNetHsm', 'xs:boolean', 0, 1, {'name': 'useNetHsm', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('payLinkLogoUrl', 'xs:string', 0, 1, {'name': 'payLinkLogoUrl', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('payLinkFooterNotes', 'xs:string', 0, 1, {'name': 'payLinkFooterNotes', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowAcquiring', 'xs:boolean', 0, 1, {'name': 'allowAcquiring', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowShopify', 'xs:boolean', 0, 1, {'name': 'allowShopify', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('shopifyPassword', 'xs:string', 0, 1, {'name': 'shopifyPassword', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowSurcharge', 'xs:boolean', 0, 1, {'name': 'allowSurcharge', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('surchargePercent', 'xs:double', 0, 1, {'name': 'surchargePercent', 'type': 'xs:double', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, allowSecurecards=None, validateScSecurity=None, forceScValidation=None, allowHppScStorage=None, storeHppScAutomatically=None, secureCardHostedPageEmailFieldSetup=None, allowSubscriptions=None, subscriptionSkipFailedAttempts=None, subscriptionMaxWaitForPaymentDays=None, subscriptionMaxMissedPeriods=None, subscriptionPaymentNotificationDays=None, subscriptionMissedPeriodsNotification=None, subscriptionRepeatNotificationDays=None, subscriptionAuthMaxAttempts=None, vauType=None, vauMerchantId=None, abuType=None, abuMerchantId=None, allowDashboard=None, allowBulkpayment=None, allowVtAutoOrderId=None, enableDecryptx=None, allowPartialCaptures=None, allowScheduledReport=None, enableAccountUpdaterBackgroundNotifications=None, accountUpdaterBackgroundNotificationUrl=None, allowAmexOptBlueParticipation=None, industryServiceEstablishment=None, merchantStreetAddress=None, allowDynamicDescriptor=None, prefixDynamicDescriptor=None, defaultDynamicDescriptor=None, allowEnhancedData=None, txnDataLevel=None, apiShippingAddressMode=None, enableTemplateAutofill=None, merchantTaxId=None, merchantTypeCode=None, allowCredoraxDynamicDescriptor=None, credoraxDynamicDescriptorPrefix=None, credoraxDynamicDescriptorSuffix=None, googlePayEnabled=None, applePayEnabled=None, appleStoreName=None, isPayFacAllowed=None, allowPaymentLink=None, allowPayLink=None, useNetHsm=None, payLinkLogoUrl=None, payLinkFooterNotes=None, allowAcquiring=None, allowShopify=None, shopifyPassword=None, allowSurcharge=None, surchargePercent=None):
        self.original_tagname_ = None
        self.allowSecurecards = allowSecurecards
        self.validateScSecurity = validateScSecurity
        self.forceScValidation = forceScValidation
        self.allowHppScStorage = allowHppScStorage
        self.storeHppScAutomatically = storeHppScAutomatically
        self.secureCardHostedPageEmailFieldSetup = secureCardHostedPageEmailFieldSetup
        self.validate_fieldSetupEnum(self.secureCardHostedPageEmailFieldSetup)
        self.allowSubscriptions = allowSubscriptions
        self.subscriptionSkipFailedAttempts = subscriptionSkipFailedAttempts
        self.subscriptionMaxWaitForPaymentDays = subscriptionMaxWaitForPaymentDays
        self.subscriptionMaxMissedPeriods = subscriptionMaxMissedPeriods
        self.subscriptionPaymentNotificationDays = subscriptionPaymentNotificationDays
        self.subscriptionMissedPeriodsNotification = subscriptionMissedPeriodsNotification
        self.subscriptionRepeatNotificationDays = subscriptionRepeatNotificationDays
        self.subscriptionAuthMaxAttempts = subscriptionAuthMaxAttempts
        self.vauType = vauType
        self.validate_cardUpdaterTypeEnum(self.vauType)
        self.vauMerchantId = vauMerchantId
        self.abuType = abuType
        self.validate_cardUpdaterTypeEnum(self.abuType)
        self.abuMerchantId = abuMerchantId
        self.allowDashboard = allowDashboard
        self.allowBulkpayment = allowBulkpayment
        self.allowVtAutoOrderId = allowVtAutoOrderId
        self.enableDecryptx = enableDecryptx
        self.allowPartialCaptures = allowPartialCaptures
        self.allowScheduledReport = allowScheduledReport
        self.enableAccountUpdaterBackgroundNotifications = enableAccountUpdaterBackgroundNotifications
        self.accountUpdaterBackgroundNotificationUrl = accountUpdaterBackgroundNotificationUrl
        self.allowAmexOptBlueParticipation = allowAmexOptBlueParticipation
        self.industryServiceEstablishment = industryServiceEstablishment
        self.merchantStreetAddress = merchantStreetAddress
        self.allowDynamicDescriptor = allowDynamicDescriptor
        self.prefixDynamicDescriptor = prefixDynamicDescriptor
        self.defaultDynamicDescriptor = defaultDynamicDescriptor
        self.allowEnhancedData = allowEnhancedData
        self.txnDataLevel = txnDataLevel
        self.validate_levelDataEnum(self.txnDataLevel)
        self.apiShippingAddressMode = apiShippingAddressMode
        self.validate_apiAddressModeEnum(self.apiShippingAddressMode)
        self.enableTemplateAutofill = enableTemplateAutofill
        self.merchantTaxId = merchantTaxId
        self.merchantTypeCode = merchantTypeCode
        self.allowCredoraxDynamicDescriptor = allowCredoraxDynamicDescriptor
        self.credoraxDynamicDescriptorPrefix = credoraxDynamicDescriptorPrefix
        self.credoraxDynamicDescriptorSuffix = credoraxDynamicDescriptorSuffix
        self.googlePayEnabled = googlePayEnabled
        self.applePayEnabled = applePayEnabled
        self.appleStoreName = appleStoreName
        self.isPayFacAllowed = isPayFacAllowed
        self.allowPaymentLink = allowPaymentLink
        self.allowPayLink = allowPayLink
        self.useNetHsm = useNetHsm
        self.payLinkLogoUrl = payLinkLogoUrl
        self.payLinkFooterNotes = payLinkFooterNotes
        self.allowAcquiring = allowAcquiring
        self.allowShopify = allowShopify
        self.shopifyPassword = shopifyPassword
        self.allowSurcharge = allowSurcharge
        self.surchargePercent = surchargePercent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalFeatures)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalFeatures.subclass:
            return terminalFeatures.subclass(*args_, **kwargs_)
        else:
            return terminalFeatures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allowSecurecards(self): return self.allowSecurecards
    def set_allowSecurecards(self, allowSecurecards): self.allowSecurecards = allowSecurecards
    def get_validateScSecurity(self): return self.validateScSecurity
    def set_validateScSecurity(self, validateScSecurity): self.validateScSecurity = validateScSecurity
    def get_forceScValidation(self): return self.forceScValidation
    def set_forceScValidation(self, forceScValidation): self.forceScValidation = forceScValidation
    def get_allowHppScStorage(self): return self.allowHppScStorage
    def set_allowHppScStorage(self, allowHppScStorage): self.allowHppScStorage = allowHppScStorage
    def get_storeHppScAutomatically(self): return self.storeHppScAutomatically
    def set_storeHppScAutomatically(self, storeHppScAutomatically): self.storeHppScAutomatically = storeHppScAutomatically
    def get_secureCardHostedPageEmailFieldSetup(self): return self.secureCardHostedPageEmailFieldSetup
    def set_secureCardHostedPageEmailFieldSetup(self, secureCardHostedPageEmailFieldSetup): self.secureCardHostedPageEmailFieldSetup = secureCardHostedPageEmailFieldSetup
    def get_allowSubscriptions(self): return self.allowSubscriptions
    def set_allowSubscriptions(self, allowSubscriptions): self.allowSubscriptions = allowSubscriptions
    def get_subscriptionSkipFailedAttempts(self): return self.subscriptionSkipFailedAttempts
    def set_subscriptionSkipFailedAttempts(self, subscriptionSkipFailedAttempts): self.subscriptionSkipFailedAttempts = subscriptionSkipFailedAttempts
    def get_subscriptionMaxWaitForPaymentDays(self): return self.subscriptionMaxWaitForPaymentDays
    def set_subscriptionMaxWaitForPaymentDays(self, subscriptionMaxWaitForPaymentDays): self.subscriptionMaxWaitForPaymentDays = subscriptionMaxWaitForPaymentDays
    def get_subscriptionMaxMissedPeriods(self): return self.subscriptionMaxMissedPeriods
    def set_subscriptionMaxMissedPeriods(self, subscriptionMaxMissedPeriods): self.subscriptionMaxMissedPeriods = subscriptionMaxMissedPeriods
    def get_subscriptionPaymentNotificationDays(self): return self.subscriptionPaymentNotificationDays
    def set_subscriptionPaymentNotificationDays(self, subscriptionPaymentNotificationDays): self.subscriptionPaymentNotificationDays = subscriptionPaymentNotificationDays
    def get_subscriptionMissedPeriodsNotification(self): return self.subscriptionMissedPeriodsNotification
    def set_subscriptionMissedPeriodsNotification(self, subscriptionMissedPeriodsNotification): self.subscriptionMissedPeriodsNotification = subscriptionMissedPeriodsNotification
    def get_subscriptionRepeatNotificationDays(self): return self.subscriptionRepeatNotificationDays
    def set_subscriptionRepeatNotificationDays(self, subscriptionRepeatNotificationDays): self.subscriptionRepeatNotificationDays = subscriptionRepeatNotificationDays
    def get_subscriptionAuthMaxAttempts(self): return self.subscriptionAuthMaxAttempts
    def set_subscriptionAuthMaxAttempts(self, subscriptionAuthMaxAttempts): self.subscriptionAuthMaxAttempts = subscriptionAuthMaxAttempts
    def get_vauType(self): return self.vauType
    def set_vauType(self, vauType): self.vauType = vauType
    def get_vauMerchantId(self): return self.vauMerchantId
    def set_vauMerchantId(self, vauMerchantId): self.vauMerchantId = vauMerchantId
    def get_abuType(self): return self.abuType
    def set_abuType(self, abuType): self.abuType = abuType
    def get_abuMerchantId(self): return self.abuMerchantId
    def set_abuMerchantId(self, abuMerchantId): self.abuMerchantId = abuMerchantId
    def get_allowDashboard(self): return self.allowDashboard
    def set_allowDashboard(self, allowDashboard): self.allowDashboard = allowDashboard
    def get_allowBulkpayment(self): return self.allowBulkpayment
    def set_allowBulkpayment(self, allowBulkpayment): self.allowBulkpayment = allowBulkpayment
    def get_allowVtAutoOrderId(self): return self.allowVtAutoOrderId
    def set_allowVtAutoOrderId(self, allowVtAutoOrderId): self.allowVtAutoOrderId = allowVtAutoOrderId
    def get_enableDecryptx(self): return self.enableDecryptx
    def set_enableDecryptx(self, enableDecryptx): self.enableDecryptx = enableDecryptx
    def get_allowPartialCaptures(self): return self.allowPartialCaptures
    def set_allowPartialCaptures(self, allowPartialCaptures): self.allowPartialCaptures = allowPartialCaptures
    def get_allowScheduledReport(self): return self.allowScheduledReport
    def set_allowScheduledReport(self, allowScheduledReport): self.allowScheduledReport = allowScheduledReport
    def get_enableAccountUpdaterBackgroundNotifications(self): return self.enableAccountUpdaterBackgroundNotifications
    def set_enableAccountUpdaterBackgroundNotifications(self, enableAccountUpdaterBackgroundNotifications): self.enableAccountUpdaterBackgroundNotifications = enableAccountUpdaterBackgroundNotifications
    def get_accountUpdaterBackgroundNotificationUrl(self): return self.accountUpdaterBackgroundNotificationUrl
    def set_accountUpdaterBackgroundNotificationUrl(self, accountUpdaterBackgroundNotificationUrl): self.accountUpdaterBackgroundNotificationUrl = accountUpdaterBackgroundNotificationUrl
    def get_allowAmexOptBlueParticipation(self): return self.allowAmexOptBlueParticipation
    def set_allowAmexOptBlueParticipation(self, allowAmexOptBlueParticipation): self.allowAmexOptBlueParticipation = allowAmexOptBlueParticipation
    def get_industryServiceEstablishment(self): return self.industryServiceEstablishment
    def set_industryServiceEstablishment(self, industryServiceEstablishment): self.industryServiceEstablishment = industryServiceEstablishment
    def get_merchantStreetAddress(self): return self.merchantStreetAddress
    def set_merchantStreetAddress(self, merchantStreetAddress): self.merchantStreetAddress = merchantStreetAddress
    def get_allowDynamicDescriptor(self): return self.allowDynamicDescriptor
    def set_allowDynamicDescriptor(self, allowDynamicDescriptor): self.allowDynamicDescriptor = allowDynamicDescriptor
    def get_prefixDynamicDescriptor(self): return self.prefixDynamicDescriptor
    def set_prefixDynamicDescriptor(self, prefixDynamicDescriptor): self.prefixDynamicDescriptor = prefixDynamicDescriptor
    def get_defaultDynamicDescriptor(self): return self.defaultDynamicDescriptor
    def set_defaultDynamicDescriptor(self, defaultDynamicDescriptor): self.defaultDynamicDescriptor = defaultDynamicDescriptor
    def get_allowEnhancedData(self): return self.allowEnhancedData
    def set_allowEnhancedData(self, allowEnhancedData): self.allowEnhancedData = allowEnhancedData
    def get_txnDataLevel(self): return self.txnDataLevel
    def set_txnDataLevel(self, txnDataLevel): self.txnDataLevel = txnDataLevel
    def get_apiShippingAddressMode(self): return self.apiShippingAddressMode
    def set_apiShippingAddressMode(self, apiShippingAddressMode): self.apiShippingAddressMode = apiShippingAddressMode
    def get_enableTemplateAutofill(self): return self.enableTemplateAutofill
    def set_enableTemplateAutofill(self, enableTemplateAutofill): self.enableTemplateAutofill = enableTemplateAutofill
    def get_merchantTaxId(self): return self.merchantTaxId
    def set_merchantTaxId(self, merchantTaxId): self.merchantTaxId = merchantTaxId
    def get_merchantTypeCode(self): return self.merchantTypeCode
    def set_merchantTypeCode(self, merchantTypeCode): self.merchantTypeCode = merchantTypeCode
    def get_allowCredoraxDynamicDescriptor(self): return self.allowCredoraxDynamicDescriptor
    def set_allowCredoraxDynamicDescriptor(self, allowCredoraxDynamicDescriptor): self.allowCredoraxDynamicDescriptor = allowCredoraxDynamicDescriptor
    def get_credoraxDynamicDescriptorPrefix(self): return self.credoraxDynamicDescriptorPrefix
    def set_credoraxDynamicDescriptorPrefix(self, credoraxDynamicDescriptorPrefix): self.credoraxDynamicDescriptorPrefix = credoraxDynamicDescriptorPrefix
    def get_credoraxDynamicDescriptorSuffix(self): return self.credoraxDynamicDescriptorSuffix
    def set_credoraxDynamicDescriptorSuffix(self, credoraxDynamicDescriptorSuffix): self.credoraxDynamicDescriptorSuffix = credoraxDynamicDescriptorSuffix
    def get_googlePayEnabled(self): return self.googlePayEnabled
    def set_googlePayEnabled(self, googlePayEnabled): self.googlePayEnabled = googlePayEnabled
    def get_applePayEnabled(self): return self.applePayEnabled
    def set_applePayEnabled(self, applePayEnabled): self.applePayEnabled = applePayEnabled
    def get_appleStoreName(self): return self.appleStoreName
    def set_appleStoreName(self, appleStoreName): self.appleStoreName = appleStoreName
    def get_isPayFacAllowed(self): return self.isPayFacAllowed
    def set_isPayFacAllowed(self, isPayFacAllowed): self.isPayFacAllowed = isPayFacAllowed
    def get_allowPaymentLink(self): return self.allowPaymentLink
    def set_allowPaymentLink(self, allowPaymentLink): self.allowPaymentLink = allowPaymentLink
    def get_allowPayLink(self): return self.allowPayLink
    def set_allowPayLink(self, allowPayLink): self.allowPayLink = allowPayLink
    def get_useNetHsm(self): return self.useNetHsm
    def set_useNetHsm(self, useNetHsm): self.useNetHsm = useNetHsm
    def get_payLinkLogoUrl(self): return self.payLinkLogoUrl
    def set_payLinkLogoUrl(self, payLinkLogoUrl): self.payLinkLogoUrl = payLinkLogoUrl
    def get_payLinkFooterNotes(self): return self.payLinkFooterNotes
    def set_payLinkFooterNotes(self, payLinkFooterNotes): self.payLinkFooterNotes = payLinkFooterNotes
    def get_allowAcquiring(self): return self.allowAcquiring
    def set_allowAcquiring(self, allowAcquiring): self.allowAcquiring = allowAcquiring
    def get_allowShopify(self): return self.allowShopify
    def set_allowShopify(self, allowShopify): self.allowShopify = allowShopify
    def get_shopifyPassword(self): return self.shopifyPassword
    def set_shopifyPassword(self, shopifyPassword): self.shopifyPassword = shopifyPassword
    def get_allowSurcharge(self): return self.allowSurcharge
    def set_allowSurcharge(self, allowSurcharge): self.allowSurcharge = allowSurcharge
    def get_surchargePercent(self): return self.surchargePercent
    def set_surchargePercent(self, surchargePercent): self.surchargePercent = surchargePercent
    def validate_fieldSetupEnum(self, value):
        # Validate type fieldSetupEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['HIDDEN', 'OPTIONAL', 'MANDATORY', 'READONLY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on fieldSetupEnum' % {"value" : value.encode("utf-8")} )
    def validate_cardUpdaterTypeEnum(self, value):
        # Validate type cardUpdaterTypeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DISABLED', 'GLOBAL_VAU', 'GLOBAL_ABU', 'EURO_ABU', 'ELAVONPOS_VAU', 'ELAVONPOS_ABU']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cardUpdaterTypeEnum' % {"value" : value.encode("utf-8")} )
    def validate_levelDataEnum(self, value):
        # Validate type levelDataEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['STANDARD', 'LEVEL_II', 'LEVEL_III']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on levelDataEnum' % {"value" : value.encode("utf-8")} )
    def validate_apiAddressModeEnum(self, value):
        # Validate type apiAddressModeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EXACT', 'POSTAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on apiAddressModeEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.allowSecurecards is not None or
            self.validateScSecurity is not None or
            self.forceScValidation is not None or
            self.allowHppScStorage is not None or
            self.storeHppScAutomatically is not None or
            self.secureCardHostedPageEmailFieldSetup is not None or
            self.allowSubscriptions is not None or
            self.subscriptionSkipFailedAttempts is not None or
            self.subscriptionMaxWaitForPaymentDays is not None or
            self.subscriptionMaxMissedPeriods is not None or
            self.subscriptionPaymentNotificationDays is not None or
            self.subscriptionMissedPeriodsNotification is not None or
            self.subscriptionRepeatNotificationDays is not None or
            self.subscriptionAuthMaxAttempts is not None or
            self.vauType is not None or
            self.vauMerchantId is not None or
            self.abuType is not None or
            self.abuMerchantId is not None or
            self.allowDashboard is not None or
            self.allowBulkpayment is not None or
            self.allowVtAutoOrderId is not None or
            self.enableDecryptx is not None or
            self.allowPartialCaptures is not None or
            self.allowScheduledReport is not None or
            self.enableAccountUpdaterBackgroundNotifications is not None or
            self.accountUpdaterBackgroundNotificationUrl is not None or
            self.allowAmexOptBlueParticipation is not None or
            self.industryServiceEstablishment is not None or
            self.merchantStreetAddress is not None or
            self.allowDynamicDescriptor is not None or
            self.prefixDynamicDescriptor is not None or
            self.defaultDynamicDescriptor is not None or
            self.allowEnhancedData is not None or
            self.txnDataLevel is not None or
            self.apiShippingAddressMode is not None or
            self.enableTemplateAutofill is not None or
            self.merchantTaxId is not None or
            self.merchantTypeCode is not None or
            self.allowCredoraxDynamicDescriptor is not None or
            self.credoraxDynamicDescriptorPrefix is not None or
            self.credoraxDynamicDescriptorSuffix is not None or
            self.googlePayEnabled is not None or
            self.applePayEnabled is not None or
            self.appleStoreName is not None or
            self.isPayFacAllowed is not None or
            self.allowPaymentLink is not None or
            self.allowPayLink is not None or
            self.useNetHsm is not None or
            self.payLinkLogoUrl is not None or
            self.payLinkFooterNotes is not None or
            self.allowAcquiring is not None or
            self.allowShopify is not None or
            self.shopifyPassword is not None or
            self.allowSurcharge is not None or
            self.surchargePercent is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalFeatures', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.allowSecurecards is not None:
            allowSecurecards_ = self.allowSecurecards
            etree_.SubElement(element, '{}allowSecurecards').text = self.gds_format_boolean(allowSecurecards_)
        if self.validateScSecurity is not None:
            validateScSecurity_ = self.validateScSecurity
            etree_.SubElement(element, '{}validateScSecurity').text = self.gds_format_boolean(validateScSecurity_)
        if self.forceScValidation is not None:
            forceScValidation_ = self.forceScValidation
            etree_.SubElement(element, '{}forceScValidation').text = self.gds_format_boolean(forceScValidation_)
        if self.allowHppScStorage is not None:
            allowHppScStorage_ = self.allowHppScStorage
            etree_.SubElement(element, '{}allowHppScStorage').text = self.gds_format_boolean(allowHppScStorage_)
        if self.storeHppScAutomatically is not None:
            storeHppScAutomatically_ = self.storeHppScAutomatically
            etree_.SubElement(element, '{}storeHppScAutomatically').text = self.gds_format_boolean(storeHppScAutomatically_)
        if self.secureCardHostedPageEmailFieldSetup is not None:
            secureCardHostedPageEmailFieldSetup_ = self.secureCardHostedPageEmailFieldSetup
            etree_.SubElement(element, '{}secureCardHostedPageEmailFieldSetup').text = self.gds_format_string(secureCardHostedPageEmailFieldSetup_)
        if self.allowSubscriptions is not None:
            allowSubscriptions_ = self.allowSubscriptions
            etree_.SubElement(element, '{}allowSubscriptions').text = self.gds_format_boolean(allowSubscriptions_)
        if self.subscriptionSkipFailedAttempts is not None:
            subscriptionSkipFailedAttempts_ = self.subscriptionSkipFailedAttempts
            etree_.SubElement(element, '{}subscriptionSkipFailedAttempts').text = self.gds_format_boolean(subscriptionSkipFailedAttempts_)
        if self.subscriptionMaxWaitForPaymentDays is not None:
            subscriptionMaxWaitForPaymentDays_ = self.subscriptionMaxWaitForPaymentDays
            etree_.SubElement(element, '{}subscriptionMaxWaitForPaymentDays').text = self.gds_format_integer(subscriptionMaxWaitForPaymentDays_)
        if self.subscriptionMaxMissedPeriods is not None:
            subscriptionMaxMissedPeriods_ = self.subscriptionMaxMissedPeriods
            etree_.SubElement(element, '{}subscriptionMaxMissedPeriods').text = self.gds_format_integer(subscriptionMaxMissedPeriods_)
        if self.subscriptionPaymentNotificationDays is not None:
            subscriptionPaymentNotificationDays_ = self.subscriptionPaymentNotificationDays
            etree_.SubElement(element, '{}subscriptionPaymentNotificationDays').text = self.gds_format_integer(subscriptionPaymentNotificationDays_)
        if self.subscriptionMissedPeriodsNotification is not None:
            subscriptionMissedPeriodsNotification_ = self.subscriptionMissedPeriodsNotification
            etree_.SubElement(element, '{}subscriptionMissedPeriodsNotification').text = self.gds_format_integer(subscriptionMissedPeriodsNotification_)
        if self.subscriptionRepeatNotificationDays is not None:
            subscriptionRepeatNotificationDays_ = self.subscriptionRepeatNotificationDays
            etree_.SubElement(element, '{}subscriptionRepeatNotificationDays').text = self.gds_format_integer(subscriptionRepeatNotificationDays_)
        if self.subscriptionAuthMaxAttempts is not None:
            subscriptionAuthMaxAttempts_ = self.subscriptionAuthMaxAttempts
            etree_.SubElement(element, '{}subscriptionAuthMaxAttempts').text = self.gds_format_integer(subscriptionAuthMaxAttempts_)
        if self.vauType is not None:
            vauType_ = self.vauType
            etree_.SubElement(element, '{}vauType').text = self.gds_format_string(vauType_)
        if self.vauMerchantId is not None:
            vauMerchantId_ = self.vauMerchantId
            etree_.SubElement(element, '{}vauMerchantId').text = self.gds_format_string(vauMerchantId_)
        if self.abuType is not None:
            abuType_ = self.abuType
            etree_.SubElement(element, '{}abuType').text = self.gds_format_string(abuType_)
        if self.abuMerchantId is not None:
            abuMerchantId_ = self.abuMerchantId
            etree_.SubElement(element, '{}abuMerchantId').text = self.gds_format_string(abuMerchantId_)
        if self.allowDashboard is not None:
            allowDashboard_ = self.allowDashboard
            etree_.SubElement(element, '{}allowDashboard').text = self.gds_format_boolean(allowDashboard_)
        if self.allowBulkpayment is not None:
            allowBulkpayment_ = self.allowBulkpayment
            etree_.SubElement(element, '{}allowBulkpayment').text = self.gds_format_boolean(allowBulkpayment_)
        if self.allowVtAutoOrderId is not None:
            allowVtAutoOrderId_ = self.allowVtAutoOrderId
            etree_.SubElement(element, '{}allowVtAutoOrderId').text = self.gds_format_boolean(allowVtAutoOrderId_)
        if self.enableDecryptx is not None:
            enableDecryptx_ = self.enableDecryptx
            etree_.SubElement(element, '{}enableDecryptx').text = self.gds_format_boolean(enableDecryptx_)
        if self.allowPartialCaptures is not None:
            allowPartialCaptures_ = self.allowPartialCaptures
            etree_.SubElement(element, '{}allowPartialCaptures').text = self.gds_format_boolean(allowPartialCaptures_)
        if self.allowScheduledReport is not None:
            allowScheduledReport_ = self.allowScheduledReport
            etree_.SubElement(element, '{}allowScheduledReport').text = self.gds_format_boolean(allowScheduledReport_)
        if self.enableAccountUpdaterBackgroundNotifications is not None:
            enableAccountUpdaterBackgroundNotifications_ = self.enableAccountUpdaterBackgroundNotifications
            etree_.SubElement(element, '{}enableAccountUpdaterBackgroundNotifications').text = self.gds_format_boolean(enableAccountUpdaterBackgroundNotifications_)
        if self.accountUpdaterBackgroundNotificationUrl is not None:
            accountUpdaterBackgroundNotificationUrl_ = self.accountUpdaterBackgroundNotificationUrl
            etree_.SubElement(element, '{}accountUpdaterBackgroundNotificationUrl').text = self.gds_format_string(accountUpdaterBackgroundNotificationUrl_)
        if self.allowAmexOptBlueParticipation is not None:
            allowAmexOptBlueParticipation_ = self.allowAmexOptBlueParticipation
            etree_.SubElement(element, '{}allowAmexOptBlueParticipation').text = self.gds_format_boolean(allowAmexOptBlueParticipation_)
        if self.industryServiceEstablishment is not None:
            industryServiceEstablishment_ = self.industryServiceEstablishment
            etree_.SubElement(element, '{}industryServiceEstablishment').text = self.gds_format_string(industryServiceEstablishment_)
        if self.merchantStreetAddress is not None:
            merchantStreetAddress_ = self.merchantStreetAddress
            etree_.SubElement(element, '{}merchantStreetAddress').text = self.gds_format_string(merchantStreetAddress_)
        if self.allowDynamicDescriptor is not None:
            allowDynamicDescriptor_ = self.allowDynamicDescriptor
            etree_.SubElement(element, '{}allowDynamicDescriptor').text = self.gds_format_boolean(allowDynamicDescriptor_)
        if self.prefixDynamicDescriptor is not None:
            prefixDynamicDescriptor_ = self.prefixDynamicDescriptor
            etree_.SubElement(element, '{}prefixDynamicDescriptor').text = self.gds_format_string(prefixDynamicDescriptor_)
        if self.defaultDynamicDescriptor is not None:
            defaultDynamicDescriptor_ = self.defaultDynamicDescriptor
            etree_.SubElement(element, '{}defaultDynamicDescriptor').text = self.gds_format_string(defaultDynamicDescriptor_)
        if self.allowEnhancedData is not None:
            allowEnhancedData_ = self.allowEnhancedData
            etree_.SubElement(element, '{}allowEnhancedData').text = self.gds_format_boolean(allowEnhancedData_)
        if self.txnDataLevel is not None:
            txnDataLevel_ = self.txnDataLevel
            etree_.SubElement(element, '{}txnDataLevel').text = self.gds_format_string(txnDataLevel_)
        if self.apiShippingAddressMode is not None:
            apiShippingAddressMode_ = self.apiShippingAddressMode
            etree_.SubElement(element, '{}apiShippingAddressMode').text = self.gds_format_string(apiShippingAddressMode_)
        if self.enableTemplateAutofill is not None:
            enableTemplateAutofill_ = self.enableTemplateAutofill
            etree_.SubElement(element, '{}enableTemplateAutofill').text = self.gds_format_boolean(enableTemplateAutofill_)
        if self.merchantTaxId is not None:
            merchantTaxId_ = self.merchantTaxId
            etree_.SubElement(element, '{}merchantTaxId').text = self.gds_format_string(merchantTaxId_)
        if self.merchantTypeCode is not None:
            merchantTypeCode_ = self.merchantTypeCode
            etree_.SubElement(element, '{}merchantTypeCode').text = self.gds_format_string(merchantTypeCode_)
        if self.allowCredoraxDynamicDescriptor is not None:
            allowCredoraxDynamicDescriptor_ = self.allowCredoraxDynamicDescriptor
            etree_.SubElement(element, '{}allowCredoraxDynamicDescriptor').text = self.gds_format_boolean(allowCredoraxDynamicDescriptor_)
        if self.credoraxDynamicDescriptorPrefix is not None:
            credoraxDynamicDescriptorPrefix_ = self.credoraxDynamicDescriptorPrefix
            etree_.SubElement(element, '{}credoraxDynamicDescriptorPrefix').text = self.gds_format_string(credoraxDynamicDescriptorPrefix_)
        if self.credoraxDynamicDescriptorSuffix is not None:
            credoraxDynamicDescriptorSuffix_ = self.credoraxDynamicDescriptorSuffix
            etree_.SubElement(element, '{}credoraxDynamicDescriptorSuffix').text = self.gds_format_string(credoraxDynamicDescriptorSuffix_)
        if self.googlePayEnabled is not None:
            googlePayEnabled_ = self.googlePayEnabled
            etree_.SubElement(element, '{}googlePayEnabled').text = self.gds_format_boolean(googlePayEnabled_)
        if self.applePayEnabled is not None:
            applePayEnabled_ = self.applePayEnabled
            etree_.SubElement(element, '{}applePayEnabled').text = self.gds_format_boolean(applePayEnabled_)
        if self.appleStoreName is not None:
            appleStoreName_ = self.appleStoreName
            etree_.SubElement(element, '{}appleStoreName').text = self.gds_format_string(appleStoreName_)
        if self.isPayFacAllowed is not None:
            isPayFacAllowed_ = self.isPayFacAllowed
            etree_.SubElement(element, '{}isPayFacAllowed').text = self.gds_format_boolean(isPayFacAllowed_)
        if self.allowPaymentLink is not None:
            allowPaymentLink_ = self.allowPaymentLink
            etree_.SubElement(element, '{}allowPaymentLink').text = self.gds_format_boolean(allowPaymentLink_)
        if self.allowPayLink is not None:
            allowPayLink_ = self.allowPayLink
            etree_.SubElement(element, '{}allowPayLink').text = self.gds_format_boolean(allowPayLink_)
        if self.useNetHsm is not None:
            useNetHsm_ = self.useNetHsm
            etree_.SubElement(element, '{}useNetHsm').text = self.gds_format_boolean(useNetHsm_)
        if self.payLinkLogoUrl is not None:
            payLinkLogoUrl_ = self.payLinkLogoUrl
            etree_.SubElement(element, '{}payLinkLogoUrl').text = self.gds_format_string(payLinkLogoUrl_)
        if self.payLinkFooterNotes is not None:
            payLinkFooterNotes_ = self.payLinkFooterNotes
            etree_.SubElement(element, '{}payLinkFooterNotes').text = self.gds_format_string(payLinkFooterNotes_)
        if self.allowAcquiring is not None:
            allowAcquiring_ = self.allowAcquiring
            etree_.SubElement(element, '{}allowAcquiring').text = self.gds_format_boolean(allowAcquiring_)
        if self.allowShopify is not None:
            allowShopify_ = self.allowShopify
            etree_.SubElement(element, '{}allowShopify').text = self.gds_format_boolean(allowShopify_)
        if self.shopifyPassword is not None:
            shopifyPassword_ = self.shopifyPassword
            etree_.SubElement(element, '{}shopifyPassword').text = self.gds_format_string(shopifyPassword_)
        if self.allowSurcharge is not None:
            allowSurcharge_ = self.allowSurcharge
            etree_.SubElement(element, '{}allowSurcharge').text = self.gds_format_boolean(allowSurcharge_)
        if self.surchargePercent is not None:
            surchargePercent_ = self.surchargePercent
            etree_.SubElement(element, '{}surchargePercent').text = self.gds_format_double(surchargePercent_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalFeatures'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.allowSecurecards is not None:
            showIndent(outfile, level)
            outfile.write('allowSecurecards=%s,\n' % self.allowSecurecards)
        if self.validateScSecurity is not None:
            showIndent(outfile, level)
            outfile.write('validateScSecurity=%s,\n' % self.validateScSecurity)
        if self.forceScValidation is not None:
            showIndent(outfile, level)
            outfile.write('forceScValidation=%s,\n' % self.forceScValidation)
        if self.allowHppScStorage is not None:
            showIndent(outfile, level)
            outfile.write('allowHppScStorage=%s,\n' % self.allowHppScStorage)
        if self.storeHppScAutomatically is not None:
            showIndent(outfile, level)
            outfile.write('storeHppScAutomatically=%s,\n' % self.storeHppScAutomatically)
        if self.secureCardHostedPageEmailFieldSetup is not None:
            showIndent(outfile, level)
            outfile.write('secureCardHostedPageEmailFieldSetup=%s,\n' % self.gds_encode(quote_python(self.secureCardHostedPageEmailFieldSetup)))
        if self.allowSubscriptions is not None:
            showIndent(outfile, level)
            outfile.write('allowSubscriptions=%s,\n' % self.allowSubscriptions)
        if self.subscriptionSkipFailedAttempts is not None:
            showIndent(outfile, level)
            outfile.write('subscriptionSkipFailedAttempts=%s,\n' % self.subscriptionSkipFailedAttempts)
        if self.subscriptionMaxWaitForPaymentDays is not None:
            showIndent(outfile, level)
            outfile.write('subscriptionMaxWaitForPaymentDays=%d,\n' % self.subscriptionMaxWaitForPaymentDays)
        if self.subscriptionMaxMissedPeriods is not None:
            showIndent(outfile, level)
            outfile.write('subscriptionMaxMissedPeriods=%d,\n' % self.subscriptionMaxMissedPeriods)
        if self.subscriptionPaymentNotificationDays is not None:
            showIndent(outfile, level)
            outfile.write('subscriptionPaymentNotificationDays=%d,\n' % self.subscriptionPaymentNotificationDays)
        if self.subscriptionMissedPeriodsNotification is not None:
            showIndent(outfile, level)
            outfile.write('subscriptionMissedPeriodsNotification=%d,\n' % self.subscriptionMissedPeriodsNotification)
        if self.subscriptionRepeatNotificationDays is not None:
            showIndent(outfile, level)
            outfile.write('subscriptionRepeatNotificationDays=%d,\n' % self.subscriptionRepeatNotificationDays)
        if self.subscriptionAuthMaxAttempts is not None:
            showIndent(outfile, level)
            outfile.write('subscriptionAuthMaxAttempts=%d,\n' % self.subscriptionAuthMaxAttempts)
        if self.vauType is not None:
            showIndent(outfile, level)
            outfile.write('vauType=%s,\n' % self.gds_encode(quote_python(self.vauType)))
        if self.vauMerchantId is not None:
            showIndent(outfile, level)
            outfile.write('vauMerchantId=%s,\n' % self.gds_encode(quote_python(self.vauMerchantId)))
        if self.abuType is not None:
            showIndent(outfile, level)
            outfile.write('abuType=%s,\n' % self.gds_encode(quote_python(self.abuType)))
        if self.abuMerchantId is not None:
            showIndent(outfile, level)
            outfile.write('abuMerchantId=%s,\n' % self.gds_encode(quote_python(self.abuMerchantId)))
        if self.allowDashboard is not None:
            showIndent(outfile, level)
            outfile.write('allowDashboard=%s,\n' % self.allowDashboard)
        if self.allowBulkpayment is not None:
            showIndent(outfile, level)
            outfile.write('allowBulkpayment=%s,\n' % self.allowBulkpayment)
        if self.allowVtAutoOrderId is not None:
            showIndent(outfile, level)
            outfile.write('allowVtAutoOrderId=%s,\n' % self.allowVtAutoOrderId)
        if self.enableDecryptx is not None:
            showIndent(outfile, level)
            outfile.write('enableDecryptx=%s,\n' % self.enableDecryptx)
        if self.allowPartialCaptures is not None:
            showIndent(outfile, level)
            outfile.write('allowPartialCaptures=%s,\n' % self.allowPartialCaptures)
        if self.allowScheduledReport is not None:
            showIndent(outfile, level)
            outfile.write('allowScheduledReport=%s,\n' % self.allowScheduledReport)
        if self.enableAccountUpdaterBackgroundNotifications is not None:
            showIndent(outfile, level)
            outfile.write('enableAccountUpdaterBackgroundNotifications=%s,\n' % self.enableAccountUpdaterBackgroundNotifications)
        if self.accountUpdaterBackgroundNotificationUrl is not None:
            showIndent(outfile, level)
            outfile.write('accountUpdaterBackgroundNotificationUrl=%s,\n' % self.gds_encode(quote_python(self.accountUpdaterBackgroundNotificationUrl)))
        if self.allowAmexOptBlueParticipation is not None:
            showIndent(outfile, level)
            outfile.write('allowAmexOptBlueParticipation=%s,\n' % self.allowAmexOptBlueParticipation)
        if self.industryServiceEstablishment is not None:
            showIndent(outfile, level)
            outfile.write('industryServiceEstablishment=%s,\n' % self.gds_encode(quote_python(self.industryServiceEstablishment)))
        if self.merchantStreetAddress is not None:
            showIndent(outfile, level)
            outfile.write('merchantStreetAddress=%s,\n' % self.gds_encode(quote_python(self.merchantStreetAddress)))
        if self.allowDynamicDescriptor is not None:
            showIndent(outfile, level)
            outfile.write('allowDynamicDescriptor=%s,\n' % self.allowDynamicDescriptor)
        if self.prefixDynamicDescriptor is not None:
            showIndent(outfile, level)
            outfile.write('prefixDynamicDescriptor=%s,\n' % self.gds_encode(quote_python(self.prefixDynamicDescriptor)))
        if self.defaultDynamicDescriptor is not None:
            showIndent(outfile, level)
            outfile.write('defaultDynamicDescriptor=%s,\n' % self.gds_encode(quote_python(self.defaultDynamicDescriptor)))
        if self.allowEnhancedData is not None:
            showIndent(outfile, level)
            outfile.write('allowEnhancedData=%s,\n' % self.allowEnhancedData)
        if self.txnDataLevel is not None:
            showIndent(outfile, level)
            outfile.write('txnDataLevel=%s,\n' % self.gds_encode(quote_python(self.txnDataLevel)))
        if self.apiShippingAddressMode is not None:
            showIndent(outfile, level)
            outfile.write('apiShippingAddressMode=%s,\n' % self.gds_encode(quote_python(self.apiShippingAddressMode)))
        if self.enableTemplateAutofill is not None:
            showIndent(outfile, level)
            outfile.write('enableTemplateAutofill=%s,\n' % self.enableTemplateAutofill)
        if self.merchantTaxId is not None:
            showIndent(outfile, level)
            outfile.write('merchantTaxId=%s,\n' % self.gds_encode(quote_python(self.merchantTaxId)))
        if self.merchantTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('merchantTypeCode=%s,\n' % self.gds_encode(quote_python(self.merchantTypeCode)))
        if self.allowCredoraxDynamicDescriptor is not None:
            showIndent(outfile, level)
            outfile.write('allowCredoraxDynamicDescriptor=%s,\n' % self.allowCredoraxDynamicDescriptor)
        if self.credoraxDynamicDescriptorPrefix is not None:
            showIndent(outfile, level)
            outfile.write('credoraxDynamicDescriptorPrefix=%s,\n' % self.gds_encode(quote_python(self.credoraxDynamicDescriptorPrefix)))
        if self.credoraxDynamicDescriptorSuffix is not None:
            showIndent(outfile, level)
            outfile.write('credoraxDynamicDescriptorSuffix=%s,\n' % self.gds_encode(quote_python(self.credoraxDynamicDescriptorSuffix)))
        if self.googlePayEnabled is not None:
            showIndent(outfile, level)
            outfile.write('googlePayEnabled=%s,\n' % self.googlePayEnabled)
        if self.applePayEnabled is not None:
            showIndent(outfile, level)
            outfile.write('applePayEnabled=%s,\n' % self.applePayEnabled)
        if self.appleStoreName is not None:
            showIndent(outfile, level)
            outfile.write('appleStoreName=%s,\n' % self.gds_encode(quote_python(self.appleStoreName)))
        if self.isPayFacAllowed is not None:
            showIndent(outfile, level)
            outfile.write('isPayFacAllowed=%s,\n' % self.isPayFacAllowed)
        if self.allowPaymentLink is not None:
            showIndent(outfile, level)
            outfile.write('allowPaymentLink=%s,\n' % self.allowPaymentLink)
        if self.allowPayLink is not None:
            showIndent(outfile, level)
            outfile.write('allowPayLink=%s,\n' % self.allowPayLink)
        if self.useNetHsm is not None:
            showIndent(outfile, level)
            outfile.write('useNetHsm=%s,\n' % self.useNetHsm)
        if self.payLinkLogoUrl is not None:
            showIndent(outfile, level)
            outfile.write('payLinkLogoUrl=%s,\n' % self.gds_encode(quote_python(self.payLinkLogoUrl)))
        if self.payLinkFooterNotes is not None:
            showIndent(outfile, level)
            outfile.write('payLinkFooterNotes=%s,\n' % self.gds_encode(quote_python(self.payLinkFooterNotes)))
        if self.allowAcquiring is not None:
            showIndent(outfile, level)
            outfile.write('allowAcquiring=%s,\n' % self.allowAcquiring)
        if self.allowShopify is not None:
            showIndent(outfile, level)
            outfile.write('allowShopify=%s,\n' % self.allowShopify)
        if self.shopifyPassword is not None:
            showIndent(outfile, level)
            outfile.write('shopifyPassword=%s,\n' % self.gds_encode(quote_python(self.shopifyPassword)))
        if self.allowSurcharge is not None:
            showIndent(outfile, level)
            outfile.write('allowSurcharge=%s,\n' % self.allowSurcharge)
        if self.surchargePercent is not None:
            showIndent(outfile, level)
            outfile.write('surchargePercent=%e,\n' % self.surchargePercent)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allowSecurecards':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowSecurecards')
            self.allowSecurecards = ival_
        elif nodeName_ == 'validateScSecurity':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'validateScSecurity')
            self.validateScSecurity = ival_
        elif nodeName_ == 'forceScValidation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'forceScValidation')
            self.forceScValidation = ival_
        elif nodeName_ == 'allowHppScStorage':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowHppScStorage')
            self.allowHppScStorage = ival_
        elif nodeName_ == 'storeHppScAutomatically':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'storeHppScAutomatically')
            self.storeHppScAutomatically = ival_
        elif nodeName_ == 'secureCardHostedPageEmailFieldSetup':
            secureCardHostedPageEmailFieldSetup_ = child_.text
            secureCardHostedPageEmailFieldSetup_ = self.gds_validate_string(secureCardHostedPageEmailFieldSetup_, node, 'secureCardHostedPageEmailFieldSetup')
            self.secureCardHostedPageEmailFieldSetup = secureCardHostedPageEmailFieldSetup_
            # validate type fieldSetupEnum
            self.validate_fieldSetupEnum(self.secureCardHostedPageEmailFieldSetup)
        elif nodeName_ == 'allowSubscriptions':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowSubscriptions')
            self.allowSubscriptions = ival_
        elif nodeName_ == 'subscriptionSkipFailedAttempts':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'subscriptionSkipFailedAttempts')
            self.subscriptionSkipFailedAttempts = ival_
        elif nodeName_ == 'subscriptionMaxWaitForPaymentDays' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'subscriptionMaxWaitForPaymentDays')
            self.subscriptionMaxWaitForPaymentDays = ival_
        elif nodeName_ == 'subscriptionMaxMissedPeriods' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'subscriptionMaxMissedPeriods')
            self.subscriptionMaxMissedPeriods = ival_
        elif nodeName_ == 'subscriptionPaymentNotificationDays' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'subscriptionPaymentNotificationDays')
            self.subscriptionPaymentNotificationDays = ival_
        elif nodeName_ == 'subscriptionMissedPeriodsNotification' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'subscriptionMissedPeriodsNotification')
            self.subscriptionMissedPeriodsNotification = ival_
        elif nodeName_ == 'subscriptionRepeatNotificationDays' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'subscriptionRepeatNotificationDays')
            self.subscriptionRepeatNotificationDays = ival_
        elif nodeName_ == 'subscriptionAuthMaxAttempts' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'subscriptionAuthMaxAttempts')
            self.subscriptionAuthMaxAttempts = ival_
        elif nodeName_ == 'vauType':
            vauType_ = child_.text
            vauType_ = self.gds_validate_string(vauType_, node, 'vauType')
            self.vauType = vauType_
            # validate type cardUpdaterTypeEnum
            self.validate_cardUpdaterTypeEnum(self.vauType)
        elif nodeName_ == 'vauMerchantId':
            vauMerchantId_ = child_.text
            vauMerchantId_ = self.gds_validate_string(vauMerchantId_, node, 'vauMerchantId')
            self.vauMerchantId = vauMerchantId_
        elif nodeName_ == 'abuType':
            abuType_ = child_.text
            abuType_ = self.gds_validate_string(abuType_, node, 'abuType')
            self.abuType = abuType_
            # validate type cardUpdaterTypeEnum
            self.validate_cardUpdaterTypeEnum(self.abuType)
        elif nodeName_ == 'abuMerchantId':
            abuMerchantId_ = child_.text
            abuMerchantId_ = self.gds_validate_string(abuMerchantId_, node, 'abuMerchantId')
            self.abuMerchantId = abuMerchantId_
        elif nodeName_ == 'allowDashboard':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowDashboard')
            self.allowDashboard = ival_
        elif nodeName_ == 'allowBulkpayment':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowBulkpayment')
            self.allowBulkpayment = ival_
        elif nodeName_ == 'allowVtAutoOrderId':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowVtAutoOrderId')
            self.allowVtAutoOrderId = ival_
        elif nodeName_ == 'enableDecryptx':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableDecryptx')
            self.enableDecryptx = ival_
        elif nodeName_ == 'allowPartialCaptures':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowPartialCaptures')
            self.allowPartialCaptures = ival_
        elif nodeName_ == 'allowScheduledReport':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowScheduledReport')
            self.allowScheduledReport = ival_
        elif nodeName_ == 'enableAccountUpdaterBackgroundNotifications':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableAccountUpdaterBackgroundNotifications')
            self.enableAccountUpdaterBackgroundNotifications = ival_
        elif nodeName_ == 'accountUpdaterBackgroundNotificationUrl':
            accountUpdaterBackgroundNotificationUrl_ = child_.text
            accountUpdaterBackgroundNotificationUrl_ = self.gds_validate_string(accountUpdaterBackgroundNotificationUrl_, node, 'accountUpdaterBackgroundNotificationUrl')
            self.accountUpdaterBackgroundNotificationUrl = accountUpdaterBackgroundNotificationUrl_
        elif nodeName_ == 'allowAmexOptBlueParticipation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowAmexOptBlueParticipation')
            self.allowAmexOptBlueParticipation = ival_
        elif nodeName_ == 'industryServiceEstablishment':
            industryServiceEstablishment_ = child_.text
            industryServiceEstablishment_ = self.gds_validate_string(industryServiceEstablishment_, node, 'industryServiceEstablishment')
            self.industryServiceEstablishment = industryServiceEstablishment_
        elif nodeName_ == 'merchantStreetAddress':
            merchantStreetAddress_ = child_.text
            merchantStreetAddress_ = self.gds_validate_string(merchantStreetAddress_, node, 'merchantStreetAddress')
            self.merchantStreetAddress = merchantStreetAddress_
        elif nodeName_ == 'allowDynamicDescriptor':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowDynamicDescriptor')
            self.allowDynamicDescriptor = ival_
        elif nodeName_ == 'prefixDynamicDescriptor':
            prefixDynamicDescriptor_ = child_.text
            prefixDynamicDescriptor_ = self.gds_validate_string(prefixDynamicDescriptor_, node, 'prefixDynamicDescriptor')
            self.prefixDynamicDescriptor = prefixDynamicDescriptor_
        elif nodeName_ == 'defaultDynamicDescriptor':
            defaultDynamicDescriptor_ = child_.text
            defaultDynamicDescriptor_ = self.gds_validate_string(defaultDynamicDescriptor_, node, 'defaultDynamicDescriptor')
            self.defaultDynamicDescriptor = defaultDynamicDescriptor_
        elif nodeName_ == 'allowEnhancedData':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowEnhancedData')
            self.allowEnhancedData = ival_
        elif nodeName_ == 'txnDataLevel':
            txnDataLevel_ = child_.text
            txnDataLevel_ = self.gds_validate_string(txnDataLevel_, node, 'txnDataLevel')
            self.txnDataLevel = txnDataLevel_
            # validate type levelDataEnum
            self.validate_levelDataEnum(self.txnDataLevel)
        elif nodeName_ == 'apiShippingAddressMode':
            apiShippingAddressMode_ = child_.text
            apiShippingAddressMode_ = self.gds_validate_string(apiShippingAddressMode_, node, 'apiShippingAddressMode')
            self.apiShippingAddressMode = apiShippingAddressMode_
            # validate type apiAddressModeEnum
            self.validate_apiAddressModeEnum(self.apiShippingAddressMode)
        elif nodeName_ == 'enableTemplateAutofill':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableTemplateAutofill')
            self.enableTemplateAutofill = ival_
        elif nodeName_ == 'merchantTaxId':
            merchantTaxId_ = child_.text
            merchantTaxId_ = self.gds_validate_string(merchantTaxId_, node, 'merchantTaxId')
            self.merchantTaxId = merchantTaxId_
        elif nodeName_ == 'merchantTypeCode':
            merchantTypeCode_ = child_.text
            merchantTypeCode_ = self.gds_validate_string(merchantTypeCode_, node, 'merchantTypeCode')
            self.merchantTypeCode = merchantTypeCode_
        elif nodeName_ == 'allowCredoraxDynamicDescriptor':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowCredoraxDynamicDescriptor')
            self.allowCredoraxDynamicDescriptor = ival_
        elif nodeName_ == 'credoraxDynamicDescriptorPrefix':
            credoraxDynamicDescriptorPrefix_ = child_.text
            credoraxDynamicDescriptorPrefix_ = self.gds_validate_string(credoraxDynamicDescriptorPrefix_, node, 'credoraxDynamicDescriptorPrefix')
            self.credoraxDynamicDescriptorPrefix = credoraxDynamicDescriptorPrefix_
        elif nodeName_ == 'credoraxDynamicDescriptorSuffix':
            credoraxDynamicDescriptorSuffix_ = child_.text
            credoraxDynamicDescriptorSuffix_ = self.gds_validate_string(credoraxDynamicDescriptorSuffix_, node, 'credoraxDynamicDescriptorSuffix')
            self.credoraxDynamicDescriptorSuffix = credoraxDynamicDescriptorSuffix_
        elif nodeName_ == 'googlePayEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'googlePayEnabled')
            self.googlePayEnabled = ival_
        elif nodeName_ == 'applePayEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'applePayEnabled')
            self.applePayEnabled = ival_
        elif nodeName_ == 'appleStoreName':
            appleStoreName_ = child_.text
            appleStoreName_ = self.gds_validate_string(appleStoreName_, node, 'appleStoreName')
            self.appleStoreName = appleStoreName_
        elif nodeName_ == 'isPayFacAllowed':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isPayFacAllowed')
            self.isPayFacAllowed = ival_
        elif nodeName_ == 'allowPaymentLink':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowPaymentLink')
            self.allowPaymentLink = ival_
        elif nodeName_ == 'allowPayLink':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowPayLink')
            self.allowPayLink = ival_
        elif nodeName_ == 'useNetHsm':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'useNetHsm')
            self.useNetHsm = ival_
        elif nodeName_ == 'payLinkLogoUrl':
            payLinkLogoUrl_ = child_.text
            payLinkLogoUrl_ = self.gds_validate_string(payLinkLogoUrl_, node, 'payLinkLogoUrl')
            self.payLinkLogoUrl = payLinkLogoUrl_
        elif nodeName_ == 'payLinkFooterNotes':
            payLinkFooterNotes_ = child_.text
            payLinkFooterNotes_ = self.gds_validate_string(payLinkFooterNotes_, node, 'payLinkFooterNotes')
            self.payLinkFooterNotes = payLinkFooterNotes_
        elif nodeName_ == 'allowAcquiring':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowAcquiring')
            self.allowAcquiring = ival_
        elif nodeName_ == 'allowShopify':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowShopify')
            self.allowShopify = ival_
        elif nodeName_ == 'shopifyPassword':
            shopifyPassword_ = child_.text
            shopifyPassword_ = self.gds_validate_string(shopifyPassword_, node, 'shopifyPassword')
            self.shopifyPassword = shopifyPassword_
        elif nodeName_ == 'allowSurcharge':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowSurcharge')
            self.allowSurcharge = ival_
        elif nodeName_ == 'surchargePercent' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'surchargePercent')
            self.surchargePercent = fval_
    def sample_method(self):
        pass
# end class terminalFeatures


class terminalLimits(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('enableTerminalLevelLimits', 'xs:boolean', 0, 0, {'name': 'enableTerminalLevelLimits', 'type': 'xs:boolean'}, None),
        MemberSpec_('terminalLevelLimits', 'terminalLevelLimitsType', 0, 1, {'name': 'terminalLevelLimits', 'minOccurs': '0', 'type': 'terminalLevelLimitsType'}, None),
        MemberSpec_('enableCardLevelLimits', 'xs:boolean', 0, 0, {'name': 'enableCardLevelLimits', 'type': 'xs:boolean'}, None),
        MemberSpec_('cardLevelLimits', 'cardLevelLimitsType', 0, 1, {'name': 'cardLevelLimits', 'minOccurs': '0', 'type': 'cardLevelLimitsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, enableTerminalLevelLimits=None, terminalLevelLimits=None, enableCardLevelLimits=None, cardLevelLimits=None):
        self.original_tagname_ = None
        self.enableTerminalLevelLimits = enableTerminalLevelLimits
        self.terminalLevelLimits = terminalLevelLimits
        self.enableCardLevelLimits = enableCardLevelLimits
        self.cardLevelLimits = cardLevelLimits
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalLimits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalLimits.subclass:
            return terminalLimits.subclass(*args_, **kwargs_)
        else:
            return terminalLimits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enableTerminalLevelLimits(self): return self.enableTerminalLevelLimits
    def set_enableTerminalLevelLimits(self, enableTerminalLevelLimits): self.enableTerminalLevelLimits = enableTerminalLevelLimits
    def get_terminalLevelLimits(self): return self.terminalLevelLimits
    def set_terminalLevelLimits(self, terminalLevelLimits): self.terminalLevelLimits = terminalLevelLimits
    def get_enableCardLevelLimits(self): return self.enableCardLevelLimits
    def set_enableCardLevelLimits(self, enableCardLevelLimits): self.enableCardLevelLimits = enableCardLevelLimits
    def get_cardLevelLimits(self): return self.cardLevelLimits
    def set_cardLevelLimits(self, cardLevelLimits): self.cardLevelLimits = cardLevelLimits
    def hasContent_(self):
        if (
            self.enableTerminalLevelLimits is not None or
            self.terminalLevelLimits is not None or
            self.enableCardLevelLimits is not None or
            self.cardLevelLimits is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalLimits', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.enableTerminalLevelLimits is not None:
            enableTerminalLevelLimits_ = self.enableTerminalLevelLimits
            etree_.SubElement(element, '{}enableTerminalLevelLimits').text = self.gds_format_boolean(enableTerminalLevelLimits_)
        if self.terminalLevelLimits is not None:
            terminalLevelLimits_ = self.terminalLevelLimits
            terminalLevelLimits_.to_etree(element, name_='terminalLevelLimits', mapping_=mapping_)
        if self.enableCardLevelLimits is not None:
            enableCardLevelLimits_ = self.enableCardLevelLimits
            etree_.SubElement(element, '{}enableCardLevelLimits').text = self.gds_format_boolean(enableCardLevelLimits_)
        if self.cardLevelLimits is not None:
            cardLevelLimits_ = self.cardLevelLimits
            cardLevelLimits_.to_etree(element, name_='cardLevelLimits', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalLimits'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.enableTerminalLevelLimits is not None:
            showIndent(outfile, level)
            outfile.write('enableTerminalLevelLimits=%s,\n' % self.enableTerminalLevelLimits)
        if self.terminalLevelLimits is not None:
            showIndent(outfile, level)
            outfile.write('terminalLevelLimits=model_.terminalLevelLimitsType(\n')
            self.terminalLevelLimits.exportLiteral(outfile, level, name_='terminalLevelLimits')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.enableCardLevelLimits is not None:
            showIndent(outfile, level)
            outfile.write('enableCardLevelLimits=%s,\n' % self.enableCardLevelLimits)
        if self.cardLevelLimits is not None:
            showIndent(outfile, level)
            outfile.write('cardLevelLimits=model_.cardLevelLimitsType(\n')
            self.cardLevelLimits.exportLiteral(outfile, level, name_='cardLevelLimits')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enableTerminalLevelLimits':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableTerminalLevelLimits')
            self.enableTerminalLevelLimits = ival_
        elif nodeName_ == 'terminalLevelLimits':
            obj_ = terminalLevelLimitsType.factory()
            obj_.build(child_)
            self.terminalLevelLimits = obj_
            obj_.original_tagname_ = 'terminalLevelLimits'
        elif nodeName_ == 'enableCardLevelLimits':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableCardLevelLimits')
            self.enableCardLevelLimits = ival_
        elif nodeName_ == 'cardLevelLimits':
            obj_ = cardLevelLimitsType.factory()
            obj_.build(child_)
            self.cardLevelLimits = obj_
            obj_.original_tagname_ = 'cardLevelLimits'
    def sample_method(self):
        pass
# end class terminalLimits


class terminalLevelLimit(volumeLimit):
    member_data_items_ = [
        MemberSpec_('currentValue', 'xs:double', 0, 1, {'name': 'currentValue', 'type': 'xs:double', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = volumeLimit
    def __init__(self, limitScope=None, limitThreshold=None, withoutCvvOnly=None, withoutAvsOnly=None, currentValue=None):
        self.original_tagname_ = None
        super(terminalLevelLimit, self).__init__(limitScope, limitThreshold, withoutCvvOnly, withoutAvsOnly, )
        self.currentValue = currentValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalLevelLimit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalLevelLimit.subclass:
            return terminalLevelLimit.subclass(*args_, **kwargs_)
        else:
            return terminalLevelLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currentValue(self): return self.currentValue
    def set_currentValue(self, currentValue): self.currentValue = currentValue
    def hasContent_(self):
        if (
            self.currentValue is not None or
            super(terminalLevelLimit, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalLevelLimit', mapping_=None):
        element = super(terminalLevelLimit, self).to_etree(parent_element, name_, mapping_)
        if self.currentValue is not None:
            currentValue_ = self.currentValue
            etree_.SubElement(element, '{}currentValue').text = self.gds_format_double(currentValue_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalLevelLimit'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(terminalLevelLimit, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(terminalLevelLimit, self).exportLiteralChildren(outfile, level, name_)
        if self.currentValue is not None:
            showIndent(outfile, level)
            outfile.write('currentValue=%e,\n' % self.currentValue)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(terminalLevelLimit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currentValue' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'currentValue')
            self.currentValue = fval_
        super(terminalLevelLimit, self).buildChildren(child_, node, nodeName_, True)
    def sample_method(self):
        pass
# end class terminalLevelLimit


class cardLevelLimit(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('card', 'xs:string', 0, 1, {'name': 'card', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('limits', 'limitsType', 0, 1, {'name': 'limits', 'minOccurs': '0', 'type': 'limitsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, card=None, limits=None):
        self.original_tagname_ = None
        self.card = card
        self.limits = limits
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardLevelLimit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardLevelLimit.subclass:
            return cardLevelLimit.subclass(*args_, **kwargs_)
        else:
            return cardLevelLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_card(self): return self.card
    def set_card(self, card): self.card = card
    def get_limits(self): return self.limits
    def set_limits(self, limits): self.limits = limits
    def hasContent_(self):
        if (
            self.card is not None or
            self.limits is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='cardLevelLimit', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.card is not None:
            card_ = self.card
            etree_.SubElement(element, '{}card').text = self.gds_format_string(card_)
        if self.limits is not None:
            limits_ = self.limits
            limits_.to_etree(element, name_='limits', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='cardLevelLimit'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.card is not None:
            showIndent(outfile, level)
            outfile.write('card=%s,\n' % self.gds_encode(quote_python(self.card)))
        if self.limits is not None:
            showIndent(outfile, level)
            outfile.write('limits=model_.limitsType(\n')
            self.limits.exportLiteral(outfile, level, name_='limits')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'card':
            card_ = child_.text
            card_ = self.gds_validate_string(card_, node, 'card')
            self.card = card_
        elif nodeName_ == 'limits':
            obj_ = limitsType.factory()
            obj_.build(child_)
            self.limits = obj_
            obj_.original_tagname_ = 'limits'
    def sample_method(self):
        pass
# end class cardLevelLimit


class cardVolumeLimit(volumeLimit):
    member_data_items_ = [
        MemberSpec_('currentValue', 'xs:double', 0, 1, {'name': 'currentValue', 'type': 'xs:double', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = volumeLimit
    def __init__(self, limitScope=None, limitThreshold=None, withoutCvvOnly=None, withoutAvsOnly=None, currentValue=None):
        self.original_tagname_ = None
        super(cardVolumeLimit, self).__init__(limitScope, limitThreshold, withoutCvvOnly, withoutAvsOnly, )
        self.currentValue = currentValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardVolumeLimit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardVolumeLimit.subclass:
            return cardVolumeLimit.subclass(*args_, **kwargs_)
        else:
            return cardVolumeLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currentValue(self): return self.currentValue
    def set_currentValue(self, currentValue): self.currentValue = currentValue
    def hasContent_(self):
        if (
            self.currentValue is not None or
            super(cardVolumeLimit, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='cardVolumeLimit', mapping_=None):
        element = super(cardVolumeLimit, self).to_etree(parent_element, name_, mapping_)
        if self.currentValue is not None:
            currentValue_ = self.currentValue
            etree_.SubElement(element, '{}currentValue').text = self.gds_format_double(currentValue_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='cardVolumeLimit'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(cardVolumeLimit, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cardVolumeLimit, self).exportLiteralChildren(outfile, level, name_)
        if self.currentValue is not None:
            showIndent(outfile, level)
            outfile.write('currentValue=%e,\n' % self.currentValue)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(cardVolumeLimit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currentValue' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'currentValue')
            self.currentValue = fval_
        super(cardVolumeLimit, self).buildChildren(child_, node, nodeName_, True)
    def sample_method(self):
        pass
# end class cardVolumeLimit


class terminalReceiptsNotification(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('disableReceipts', 'xs:boolean', 0, 0, {'name': 'disableReceipts', 'type': 'xs:boolean'}, None),
        MemberSpec_('notificationEmail', 'xs:string', 0, 1, {'name': 'notificationEmail', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('enableEmailCardHolderReceipt', 'xs:boolean', 0, 0, {'name': 'enableEmailCardHolderReceipt', 'type': 'xs:boolean'}, None),
        MemberSpec_('cardHolderEmailReceiptResponseCodes', 'xs:string', 0, 1, {'name': 'cardHolderEmailReceiptResponseCodes', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('transactionTypesEmail', 'xs:string', 0, 1, {'name': 'transactionTypesEmail', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('enableSMSCardHolderReceipt', 'xs:boolean', 0, 0, {'name': 'enableSMSCardHolderReceipt', 'type': 'xs:boolean'}, None),
        MemberSpec_('cardHolderSMSReceiptResponseCodes', 'xs:string', 0, 1, {'name': 'cardHolderSMSReceiptResponseCodes', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('transactionTypesSMS', 'xs:string', 0, 1, {'name': 'transactionTypesSMS', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('showEmailOnvt', 'xs:boolean', 0, 0, {'name': 'showEmailOnvt', 'type': 'xs:boolean'}, None),
        MemberSpec_('merchantSupportEmail', 'xs:string', 0, 1, {'name': 'merchantSupportEmail', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('enableAccountUpdaterBackgroundNotificationFailureEmails', 'xs:boolean', 0, 0, {'name': 'enableAccountUpdaterBackgroundNotificationFailureEmails', 'type': 'xs:boolean'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, disableReceipts=None, notificationEmail=None, enableEmailCardHolderReceipt=None, cardHolderEmailReceiptResponseCodes=None, transactionTypesEmail=None, enableSMSCardHolderReceipt=None, cardHolderSMSReceiptResponseCodes=None, transactionTypesSMS=None, showEmailOnvt=None, merchantSupportEmail=None, enableAccountUpdaterBackgroundNotificationFailureEmails=None):
        self.original_tagname_ = None
        self.disableReceipts = disableReceipts
        self.notificationEmail = notificationEmail
        self.enableEmailCardHolderReceipt = enableEmailCardHolderReceipt
        self.cardHolderEmailReceiptResponseCodes = cardHolderEmailReceiptResponseCodes
        self.transactionTypesEmail = transactionTypesEmail
        self.enableSMSCardHolderReceipt = enableSMSCardHolderReceipt
        self.cardHolderSMSReceiptResponseCodes = cardHolderSMSReceiptResponseCodes
        self.transactionTypesSMS = transactionTypesSMS
        self.showEmailOnvt = showEmailOnvt
        self.merchantSupportEmail = merchantSupportEmail
        self.enableAccountUpdaterBackgroundNotificationFailureEmails = enableAccountUpdaterBackgroundNotificationFailureEmails
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalReceiptsNotification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalReceiptsNotification.subclass:
            return terminalReceiptsNotification.subclass(*args_, **kwargs_)
        else:
            return terminalReceiptsNotification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disableReceipts(self): return self.disableReceipts
    def set_disableReceipts(self, disableReceipts): self.disableReceipts = disableReceipts
    def get_notificationEmail(self): return self.notificationEmail
    def set_notificationEmail(self, notificationEmail): self.notificationEmail = notificationEmail
    def get_enableEmailCardHolderReceipt(self): return self.enableEmailCardHolderReceipt
    def set_enableEmailCardHolderReceipt(self, enableEmailCardHolderReceipt): self.enableEmailCardHolderReceipt = enableEmailCardHolderReceipt
    def get_cardHolderEmailReceiptResponseCodes(self): return self.cardHolderEmailReceiptResponseCodes
    def set_cardHolderEmailReceiptResponseCodes(self, cardHolderEmailReceiptResponseCodes): self.cardHolderEmailReceiptResponseCodes = cardHolderEmailReceiptResponseCodes
    def get_transactionTypesEmail(self): return self.transactionTypesEmail
    def set_transactionTypesEmail(self, transactionTypesEmail): self.transactionTypesEmail = transactionTypesEmail
    def get_enableSMSCardHolderReceipt(self): return self.enableSMSCardHolderReceipt
    def set_enableSMSCardHolderReceipt(self, enableSMSCardHolderReceipt): self.enableSMSCardHolderReceipt = enableSMSCardHolderReceipt
    def get_cardHolderSMSReceiptResponseCodes(self): return self.cardHolderSMSReceiptResponseCodes
    def set_cardHolderSMSReceiptResponseCodes(self, cardHolderSMSReceiptResponseCodes): self.cardHolderSMSReceiptResponseCodes = cardHolderSMSReceiptResponseCodes
    def get_transactionTypesSMS(self): return self.transactionTypesSMS
    def set_transactionTypesSMS(self, transactionTypesSMS): self.transactionTypesSMS = transactionTypesSMS
    def get_showEmailOnvt(self): return self.showEmailOnvt
    def set_showEmailOnvt(self, showEmailOnvt): self.showEmailOnvt = showEmailOnvt
    def get_merchantSupportEmail(self): return self.merchantSupportEmail
    def set_merchantSupportEmail(self, merchantSupportEmail): self.merchantSupportEmail = merchantSupportEmail
    def get_enableAccountUpdaterBackgroundNotificationFailureEmails(self): return self.enableAccountUpdaterBackgroundNotificationFailureEmails
    def set_enableAccountUpdaterBackgroundNotificationFailureEmails(self, enableAccountUpdaterBackgroundNotificationFailureEmails): self.enableAccountUpdaterBackgroundNotificationFailureEmails = enableAccountUpdaterBackgroundNotificationFailureEmails
    def hasContent_(self):
        if (
            self.disableReceipts is not None or
            self.notificationEmail is not None or
            self.enableEmailCardHolderReceipt is not None or
            self.cardHolderEmailReceiptResponseCodes is not None or
            self.transactionTypesEmail is not None or
            self.enableSMSCardHolderReceipt is not None or
            self.cardHolderSMSReceiptResponseCodes is not None or
            self.transactionTypesSMS is not None or
            self.showEmailOnvt is not None or
            self.merchantSupportEmail is not None or
            self.enableAccountUpdaterBackgroundNotificationFailureEmails is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalReceiptsNotification', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.disableReceipts is not None:
            disableReceipts_ = self.disableReceipts
            etree_.SubElement(element, '{}disableReceipts').text = self.gds_format_boolean(disableReceipts_)
        if self.notificationEmail is not None:
            notificationEmail_ = self.notificationEmail
            etree_.SubElement(element, '{}notificationEmail').text = self.gds_format_string(notificationEmail_)
        if self.enableEmailCardHolderReceipt is not None:
            enableEmailCardHolderReceipt_ = self.enableEmailCardHolderReceipt
            etree_.SubElement(element, '{}enableEmailCardHolderReceipt').text = self.gds_format_boolean(enableEmailCardHolderReceipt_)
        if self.cardHolderEmailReceiptResponseCodes is not None:
            cardHolderEmailReceiptResponseCodes_ = self.cardHolderEmailReceiptResponseCodes
            etree_.SubElement(element, '{}cardHolderEmailReceiptResponseCodes').text = self.gds_format_string(cardHolderEmailReceiptResponseCodes_)
        if self.transactionTypesEmail is not None:
            transactionTypesEmail_ = self.transactionTypesEmail
            etree_.SubElement(element, '{}transactionTypesEmail').text = self.gds_format_string(transactionTypesEmail_)
        if self.enableSMSCardHolderReceipt is not None:
            enableSMSCardHolderReceipt_ = self.enableSMSCardHolderReceipt
            etree_.SubElement(element, '{}enableSMSCardHolderReceipt').text = self.gds_format_boolean(enableSMSCardHolderReceipt_)
        if self.cardHolderSMSReceiptResponseCodes is not None:
            cardHolderSMSReceiptResponseCodes_ = self.cardHolderSMSReceiptResponseCodes
            etree_.SubElement(element, '{}cardHolderSMSReceiptResponseCodes').text = self.gds_format_string(cardHolderSMSReceiptResponseCodes_)
        if self.transactionTypesSMS is not None:
            transactionTypesSMS_ = self.transactionTypesSMS
            etree_.SubElement(element, '{}transactionTypesSMS').text = self.gds_format_string(transactionTypesSMS_)
        if self.showEmailOnvt is not None:
            showEmailOnvt_ = self.showEmailOnvt
            etree_.SubElement(element, '{}showEmailOnvt').text = self.gds_format_boolean(showEmailOnvt_)
        if self.merchantSupportEmail is not None:
            merchantSupportEmail_ = self.merchantSupportEmail
            etree_.SubElement(element, '{}merchantSupportEmail').text = self.gds_format_string(merchantSupportEmail_)
        if self.enableAccountUpdaterBackgroundNotificationFailureEmails is not None:
            enableAccountUpdaterBackgroundNotificationFailureEmails_ = self.enableAccountUpdaterBackgroundNotificationFailureEmails
            etree_.SubElement(element, '{}enableAccountUpdaterBackgroundNotificationFailureEmails').text = self.gds_format_boolean(enableAccountUpdaterBackgroundNotificationFailureEmails_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalReceiptsNotification'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.disableReceipts is not None:
            showIndent(outfile, level)
            outfile.write('disableReceipts=%s,\n' % self.disableReceipts)
        if self.notificationEmail is not None:
            showIndent(outfile, level)
            outfile.write('notificationEmail=%s,\n' % self.gds_encode(quote_python(self.notificationEmail)))
        if self.enableEmailCardHolderReceipt is not None:
            showIndent(outfile, level)
            outfile.write('enableEmailCardHolderReceipt=%s,\n' % self.enableEmailCardHolderReceipt)
        if self.cardHolderEmailReceiptResponseCodes is not None:
            showIndent(outfile, level)
            outfile.write('cardHolderEmailReceiptResponseCodes=%s,\n' % self.gds_encode(quote_python(self.cardHolderEmailReceiptResponseCodes)))
        if self.transactionTypesEmail is not None:
            showIndent(outfile, level)
            outfile.write('transactionTypesEmail=%s,\n' % self.gds_encode(quote_python(self.transactionTypesEmail)))
        if self.enableSMSCardHolderReceipt is not None:
            showIndent(outfile, level)
            outfile.write('enableSMSCardHolderReceipt=%s,\n' % self.enableSMSCardHolderReceipt)
        if self.cardHolderSMSReceiptResponseCodes is not None:
            showIndent(outfile, level)
            outfile.write('cardHolderSMSReceiptResponseCodes=%s,\n' % self.gds_encode(quote_python(self.cardHolderSMSReceiptResponseCodes)))
        if self.transactionTypesSMS is not None:
            showIndent(outfile, level)
            outfile.write('transactionTypesSMS=%s,\n' % self.gds_encode(quote_python(self.transactionTypesSMS)))
        if self.showEmailOnvt is not None:
            showIndent(outfile, level)
            outfile.write('showEmailOnvt=%s,\n' % self.showEmailOnvt)
        if self.merchantSupportEmail is not None:
            showIndent(outfile, level)
            outfile.write('merchantSupportEmail=%s,\n' % self.gds_encode(quote_python(self.merchantSupportEmail)))
        if self.enableAccountUpdaterBackgroundNotificationFailureEmails is not None:
            showIndent(outfile, level)
            outfile.write('enableAccountUpdaterBackgroundNotificationFailureEmails=%s,\n' % self.enableAccountUpdaterBackgroundNotificationFailureEmails)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disableReceipts':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'disableReceipts')
            self.disableReceipts = ival_
        elif nodeName_ == 'notificationEmail':
            notificationEmail_ = child_.text
            notificationEmail_ = self.gds_validate_string(notificationEmail_, node, 'notificationEmail')
            self.notificationEmail = notificationEmail_
        elif nodeName_ == 'enableEmailCardHolderReceipt':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableEmailCardHolderReceipt')
            self.enableEmailCardHolderReceipt = ival_
        elif nodeName_ == 'cardHolderEmailReceiptResponseCodes':
            cardHolderEmailReceiptResponseCodes_ = child_.text
            cardHolderEmailReceiptResponseCodes_ = self.gds_validate_string(cardHolderEmailReceiptResponseCodes_, node, 'cardHolderEmailReceiptResponseCodes')
            self.cardHolderEmailReceiptResponseCodes = cardHolderEmailReceiptResponseCodes_
        elif nodeName_ == 'transactionTypesEmail':
            transactionTypesEmail_ = child_.text
            transactionTypesEmail_ = self.gds_validate_string(transactionTypesEmail_, node, 'transactionTypesEmail')
            self.transactionTypesEmail = transactionTypesEmail_
        elif nodeName_ == 'enableSMSCardHolderReceipt':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableSMSCardHolderReceipt')
            self.enableSMSCardHolderReceipt = ival_
        elif nodeName_ == 'cardHolderSMSReceiptResponseCodes':
            cardHolderSMSReceiptResponseCodes_ = child_.text
            cardHolderSMSReceiptResponseCodes_ = self.gds_validate_string(cardHolderSMSReceiptResponseCodes_, node, 'cardHolderSMSReceiptResponseCodes')
            self.cardHolderSMSReceiptResponseCodes = cardHolderSMSReceiptResponseCodes_
        elif nodeName_ == 'transactionTypesSMS':
            transactionTypesSMS_ = child_.text
            transactionTypesSMS_ = self.gds_validate_string(transactionTypesSMS_, node, 'transactionTypesSMS')
            self.transactionTypesSMS = transactionTypesSMS_
        elif nodeName_ == 'showEmailOnvt':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'showEmailOnvt')
            self.showEmailOnvt = ival_
        elif nodeName_ == 'merchantSupportEmail':
            merchantSupportEmail_ = child_.text
            merchantSupportEmail_ = self.gds_validate_string(merchantSupportEmail_, node, 'merchantSupportEmail')
            self.merchantSupportEmail = merchantSupportEmail_
        elif nodeName_ == 'enableAccountUpdaterBackgroundNotificationFailureEmails':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableAccountUpdaterBackgroundNotificationFailureEmails')
            self.enableAccountUpdaterBackgroundNotificationFailureEmails = ival_
    def sample_method(self):
        pass
# end class terminalReceiptsNotification


class terminalSecurityFraud(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('allowShowCvv', 'xs:boolean', 0, 0, {'name': 'allowShowCvv', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowAutoDeclineCvvFailures', 'xs:boolean', 0, 0, {'name': 'allowAutoDeclineCvvFailures', 'type': 'xs:boolean'}, None),
        MemberSpec_('cvvDeclineCodes', ['cvvResponseEnum', 'xs:string'], 1, 1, {'name': 'cvvDeclineCodes', 'type': 'xs:string', 'nillable': 'true', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('enableAvs', 'xs:boolean', 0, 0, {'name': 'enableAvs', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowAvsCompulsory', 'xs:boolean', 0, 0, {'name': 'allowAvsCompulsory', 'type': 'xs:boolean'}, None),
        MemberSpec_('apiAvsType', ['apiAddressModeEnum', 'xs:string'], 0, 1, {'name': 'apiAvsType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('avsSentAction', ['avsActionEnum', 'xs:string'], 0, 1, {'name': 'avsSentAction', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowAvsCodeApproval', 'xs:boolean', 0, 0, {'name': 'allowAvsCodeApproval', 'type': 'xs:boolean'}, None),
        MemberSpec_('approvedAVSCodes', 'approvedAVSCodesType', 0, 1, {'name': 'approvedAVSCodes', 'minOccurs': '0', 'type': 'approvedAVSCodesType'}, None),
        MemberSpec_('refundAmountLimit', 'xs:double', 0, 0, {'name': 'refundAmountLimit', 'type': 'xs:double'}, None),
        MemberSpec_('allowUnreferencedRefunds', 'xs:boolean', 0, 0, {'name': 'allowUnreferencedRefunds', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowUnreferencedRefundsAfterRefundDecline', 'xs:boolean', 0, 0, {'name': 'allowUnreferencedRefundsAfterRefundDecline', 'type': 'xs:boolean'}, None),
        MemberSpec_('unreferencedRefundlimit', 'xs:int', 0, 0, {'name': 'unreferencedRefundlimit', 'type': 'xs:int'}, None),
        MemberSpec_('threedSecure', 'xs:boolean', 0, 0, {'name': 'threedSecure', 'type': 'xs:boolean'}, None),
        MemberSpec_('threedsMerchantId', 'xs:string', 0, 1, {'name': 'threedsMerchantId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('threedsPassword', 'xs:string', 0, 1, {'name': 'threedsPassword', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowVoiceId', 'xs:boolean', 0, 0, {'name': 'allowVoiceId', 'type': 'xs:boolean'}, None),
        MemberSpec_('authId', 'xs:string', 0, 1, {'name': 'authId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('authPassword', 'xs:string', 0, 1, {'name': 'authPassword', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('maxMindActive', 'xs:boolean', 0, 0, {'name': 'maxMindActive', 'type': 'xs:boolean'}, None),
        MemberSpec_('maxMindRejectOnError', 'xs:boolean', 0, 0, {'name': 'maxMindRejectOnError', 'type': 'xs:boolean'}, None),
        MemberSpec_('maxMindRiskScoreThreshold', 'xs:double', 0, 0, {'name': 'maxMindRiskScoreThreshold', 'type': 'xs:double'}, None),
        MemberSpec_('threatMetrixEnabled', 'xs:boolean', 0, 0, {'name': 'threatMetrixEnabled', 'type': 'xs:boolean'}, None),
        MemberSpec_('threatMetrixOrgId', 'xs:string', 0, 1, {'name': 'threatMetrixOrgId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('threatMetrixApiKey', 'xs:string', 0, 1, {'name': 'threatMetrixApiKey', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('threatMetrixPolicyName', 'xs:string', 0, 1, {'name': 'threatMetrixPolicyName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('threatMetrixRejectOnError', 'xs:boolean', 0, 1, {'name': 'threatMetrixRejectOnError', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('threatMetrixRiskScoreThreshold', 'xs:int', 0, 1, {'name': 'threatMetrixRiskScoreThreshold', 'type': 'xs:int', 'minOccurs': '0'}, None),
        MemberSpec_('allowCardholderSignatureBypass', 'xs:boolean', 0, 1, {'name': 'allowCardholderSignatureBypass', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowCvvComplianceRuleBypass', 'xs:boolean', 0, 1, {'name': 'allowCvvComplianceRuleBypass', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, allowShowCvv=None, allowAutoDeclineCvvFailures=None, cvvDeclineCodes=None, enableAvs=None, allowAvsCompulsory=None, apiAvsType=None, avsSentAction=None, allowAvsCodeApproval=None, approvedAVSCodes=None, refundAmountLimit=None, allowUnreferencedRefunds=None, allowUnreferencedRefundsAfterRefundDecline=None, unreferencedRefundlimit=None, threedSecure=None, threedsMerchantId=None, threedsPassword=None, allowVoiceId=None, authId=None, authPassword=None, maxMindActive=None, maxMindRejectOnError=None, maxMindRiskScoreThreshold=None, threatMetrixEnabled=None, threatMetrixOrgId=None, threatMetrixApiKey=None, threatMetrixPolicyName=None, threatMetrixRejectOnError=None, threatMetrixRiskScoreThreshold=None, allowCardholderSignatureBypass=None, allowCvvComplianceRuleBypass=None):
        self.original_tagname_ = None
        self.allowShowCvv = allowShowCvv
        self.allowAutoDeclineCvvFailures = allowAutoDeclineCvvFailures
        if cvvDeclineCodes is None:
            self.cvvDeclineCodes = []
        else:
            self.cvvDeclineCodes = cvvDeclineCodes
        self.enableAvs = enableAvs
        self.allowAvsCompulsory = allowAvsCompulsory
        self.apiAvsType = apiAvsType
        self.validate_apiAddressModeEnum(self.apiAvsType)
        self.avsSentAction = avsSentAction
        self.validate_avsActionEnum(self.avsSentAction)
        self.allowAvsCodeApproval = allowAvsCodeApproval
        self.approvedAVSCodes = approvedAVSCodes
        self.refundAmountLimit = refundAmountLimit
        self.allowUnreferencedRefunds = allowUnreferencedRefunds
        self.allowUnreferencedRefundsAfterRefundDecline = allowUnreferencedRefundsAfterRefundDecline
        self.unreferencedRefundlimit = unreferencedRefundlimit
        self.threedSecure = threedSecure
        self.threedsMerchantId = threedsMerchantId
        self.threedsPassword = threedsPassword
        self.allowVoiceId = allowVoiceId
        self.authId = authId
        self.authPassword = authPassword
        self.maxMindActive = maxMindActive
        self.maxMindRejectOnError = maxMindRejectOnError
        self.maxMindRiskScoreThreshold = maxMindRiskScoreThreshold
        self.threatMetrixEnabled = threatMetrixEnabled
        self.threatMetrixOrgId = threatMetrixOrgId
        self.threatMetrixApiKey = threatMetrixApiKey
        self.threatMetrixPolicyName = threatMetrixPolicyName
        self.threatMetrixRejectOnError = threatMetrixRejectOnError
        self.threatMetrixRiskScoreThreshold = threatMetrixRiskScoreThreshold
        self.allowCardholderSignatureBypass = allowCardholderSignatureBypass
        self.allowCvvComplianceRuleBypass = allowCvvComplianceRuleBypass
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalSecurityFraud)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalSecurityFraud.subclass:
            return terminalSecurityFraud.subclass(*args_, **kwargs_)
        else:
            return terminalSecurityFraud(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allowShowCvv(self): return self.allowShowCvv
    def set_allowShowCvv(self, allowShowCvv): self.allowShowCvv = allowShowCvv
    def get_allowAutoDeclineCvvFailures(self): return self.allowAutoDeclineCvvFailures
    def set_allowAutoDeclineCvvFailures(self, allowAutoDeclineCvvFailures): self.allowAutoDeclineCvvFailures = allowAutoDeclineCvvFailures
    def get_cvvDeclineCodes(self): return self.cvvDeclineCodes
    def set_cvvDeclineCodes(self, cvvDeclineCodes): self.cvvDeclineCodes = cvvDeclineCodes
    def add_cvvDeclineCodes(self, value): self.cvvDeclineCodes.append(value)
    def insert_cvvDeclineCodes_at(self, index, value): self.cvvDeclineCodes.insert(index, value)
    def replace_cvvDeclineCodes_at(self, index, value): self.cvvDeclineCodes[index] = value
    def get_enableAvs(self): return self.enableAvs
    def set_enableAvs(self, enableAvs): self.enableAvs = enableAvs
    def get_allowAvsCompulsory(self): return self.allowAvsCompulsory
    def set_allowAvsCompulsory(self, allowAvsCompulsory): self.allowAvsCompulsory = allowAvsCompulsory
    def get_apiAvsType(self): return self.apiAvsType
    def set_apiAvsType(self, apiAvsType): self.apiAvsType = apiAvsType
    def get_avsSentAction(self): return self.avsSentAction
    def set_avsSentAction(self, avsSentAction): self.avsSentAction = avsSentAction
    def get_allowAvsCodeApproval(self): return self.allowAvsCodeApproval
    def set_allowAvsCodeApproval(self, allowAvsCodeApproval): self.allowAvsCodeApproval = allowAvsCodeApproval
    def get_approvedAVSCodes(self): return self.approvedAVSCodes
    def set_approvedAVSCodes(self, approvedAVSCodes): self.approvedAVSCodes = approvedAVSCodes
    def get_refundAmountLimit(self): return self.refundAmountLimit
    def set_refundAmountLimit(self, refundAmountLimit): self.refundAmountLimit = refundAmountLimit
    def get_allowUnreferencedRefunds(self): return self.allowUnreferencedRefunds
    def set_allowUnreferencedRefunds(self, allowUnreferencedRefunds): self.allowUnreferencedRefunds = allowUnreferencedRefunds
    def get_allowUnreferencedRefundsAfterRefundDecline(self): return self.allowUnreferencedRefundsAfterRefundDecline
    def set_allowUnreferencedRefundsAfterRefundDecline(self, allowUnreferencedRefundsAfterRefundDecline): self.allowUnreferencedRefundsAfterRefundDecline = allowUnreferencedRefundsAfterRefundDecline
    def get_unreferencedRefundlimit(self): return self.unreferencedRefundlimit
    def set_unreferencedRefundlimit(self, unreferencedRefundlimit): self.unreferencedRefundlimit = unreferencedRefundlimit
    def get_threedSecure(self): return self.threedSecure
    def set_threedSecure(self, threedSecure): self.threedSecure = threedSecure
    def get_threedsMerchantId(self): return self.threedsMerchantId
    def set_threedsMerchantId(self, threedsMerchantId): self.threedsMerchantId = threedsMerchantId
    def get_threedsPassword(self): return self.threedsPassword
    def set_threedsPassword(self, threedsPassword): self.threedsPassword = threedsPassword
    def get_allowVoiceId(self): return self.allowVoiceId
    def set_allowVoiceId(self, allowVoiceId): self.allowVoiceId = allowVoiceId
    def get_authId(self): return self.authId
    def set_authId(self, authId): self.authId = authId
    def get_authPassword(self): return self.authPassword
    def set_authPassword(self, authPassword): self.authPassword = authPassword
    def get_maxMindActive(self): return self.maxMindActive
    def set_maxMindActive(self, maxMindActive): self.maxMindActive = maxMindActive
    def get_maxMindRejectOnError(self): return self.maxMindRejectOnError
    def set_maxMindRejectOnError(self, maxMindRejectOnError): self.maxMindRejectOnError = maxMindRejectOnError
    def get_maxMindRiskScoreThreshold(self): return self.maxMindRiskScoreThreshold
    def set_maxMindRiskScoreThreshold(self, maxMindRiskScoreThreshold): self.maxMindRiskScoreThreshold = maxMindRiskScoreThreshold
    def get_threatMetrixEnabled(self): return self.threatMetrixEnabled
    def set_threatMetrixEnabled(self, threatMetrixEnabled): self.threatMetrixEnabled = threatMetrixEnabled
    def get_threatMetrixOrgId(self): return self.threatMetrixOrgId
    def set_threatMetrixOrgId(self, threatMetrixOrgId): self.threatMetrixOrgId = threatMetrixOrgId
    def get_threatMetrixApiKey(self): return self.threatMetrixApiKey
    def set_threatMetrixApiKey(self, threatMetrixApiKey): self.threatMetrixApiKey = threatMetrixApiKey
    def get_threatMetrixPolicyName(self): return self.threatMetrixPolicyName
    def set_threatMetrixPolicyName(self, threatMetrixPolicyName): self.threatMetrixPolicyName = threatMetrixPolicyName
    def get_threatMetrixRejectOnError(self): return self.threatMetrixRejectOnError
    def set_threatMetrixRejectOnError(self, threatMetrixRejectOnError): self.threatMetrixRejectOnError = threatMetrixRejectOnError
    def get_threatMetrixRiskScoreThreshold(self): return self.threatMetrixRiskScoreThreshold
    def set_threatMetrixRiskScoreThreshold(self, threatMetrixRiskScoreThreshold): self.threatMetrixRiskScoreThreshold = threatMetrixRiskScoreThreshold
    def get_allowCardholderSignatureBypass(self): return self.allowCardholderSignatureBypass
    def set_allowCardholderSignatureBypass(self, allowCardholderSignatureBypass): self.allowCardholderSignatureBypass = allowCardholderSignatureBypass
    def get_allowCvvComplianceRuleBypass(self): return self.allowCvvComplianceRuleBypass
    def set_allowCvvComplianceRuleBypass(self, allowCvvComplianceRuleBypass): self.allowCvvComplianceRuleBypass = allowCvvComplianceRuleBypass
    def validate_cvvResponseEnum(self, value):
        # Validate type cvvResponseEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MATCH', 'NOT_MATCH', 'NOT_PROCESSED', 'ISSUER_NOT_CERTIFIED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cvvResponseEnum' % {"value" : value.encode("utf-8")} )
    def validate_apiAddressModeEnum(self, value):
        # Validate type apiAddressModeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EXACT', 'POSTAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on apiAddressModeEnum' % {"value" : value.encode("utf-8")} )
    def validate_avsActionEnum(self, value):
        # Validate type avsActionEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['HIDE', 'DISPLAY', 'EDITABLE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on avsActionEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.allowShowCvv is not None or
            self.allowAutoDeclineCvvFailures is not None or
            self.cvvDeclineCodes or
            self.enableAvs is not None or
            self.allowAvsCompulsory is not None or
            self.apiAvsType is not None or
            self.avsSentAction is not None or
            self.allowAvsCodeApproval is not None or
            self.approvedAVSCodes is not None or
            self.refundAmountLimit is not None or
            self.allowUnreferencedRefunds is not None or
            self.allowUnreferencedRefundsAfterRefundDecline is not None or
            self.unreferencedRefundlimit is not None or
            self.threedSecure is not None or
            self.threedsMerchantId is not None or
            self.threedsPassword is not None or
            self.allowVoiceId is not None or
            self.authId is not None or
            self.authPassword is not None or
            self.maxMindActive is not None or
            self.maxMindRejectOnError is not None or
            self.maxMindRiskScoreThreshold is not None or
            self.threatMetrixEnabled is not None or
            self.threatMetrixOrgId is not None or
            self.threatMetrixApiKey is not None or
            self.threatMetrixPolicyName is not None or
            self.threatMetrixRejectOnError is not None or
            self.threatMetrixRiskScoreThreshold is not None or
            self.allowCardholderSignatureBypass is not None or
            self.allowCvvComplianceRuleBypass is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalSecurityFraud', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.allowShowCvv is not None:
            allowShowCvv_ = self.allowShowCvv
            etree_.SubElement(element, '{}allowShowCvv').text = self.gds_format_boolean(allowShowCvv_)
        if self.allowAutoDeclineCvvFailures is not None:
            allowAutoDeclineCvvFailures_ = self.allowAutoDeclineCvvFailures
            etree_.SubElement(element, '{}allowAutoDeclineCvvFailures').text = self.gds_format_boolean(allowAutoDeclineCvvFailures_)
        for cvvDeclineCodes_ in self.cvvDeclineCodes:
            etree_.SubElement(element, '{}cvvDeclineCodes').text = self.gds_format_string(cvvDeclineCodes_)
        if self.enableAvs is not None:
            enableAvs_ = self.enableAvs
            etree_.SubElement(element, '{}enableAvs').text = self.gds_format_boolean(enableAvs_)
        if self.allowAvsCompulsory is not None:
            allowAvsCompulsory_ = self.allowAvsCompulsory
            etree_.SubElement(element, '{}allowAvsCompulsory').text = self.gds_format_boolean(allowAvsCompulsory_)
        if self.apiAvsType is not None:
            apiAvsType_ = self.apiAvsType
            etree_.SubElement(element, '{}apiAvsType').text = self.gds_format_string(apiAvsType_)
        if self.avsSentAction is not None:
            avsSentAction_ = self.avsSentAction
            etree_.SubElement(element, '{}avsSentAction').text = self.gds_format_string(avsSentAction_)
        if self.allowAvsCodeApproval is not None:
            allowAvsCodeApproval_ = self.allowAvsCodeApproval
            etree_.SubElement(element, '{}allowAvsCodeApproval').text = self.gds_format_boolean(allowAvsCodeApproval_)
        if self.approvedAVSCodes is not None:
            approvedAVSCodes_ = self.approvedAVSCodes
            approvedAVSCodes_.to_etree(element, name_='approvedAVSCodes', mapping_=mapping_)
        if self.refundAmountLimit is not None:
            refundAmountLimit_ = self.refundAmountLimit
            etree_.SubElement(element, '{}refundAmountLimit').text = self.gds_format_double(refundAmountLimit_)
        if self.allowUnreferencedRefunds is not None:
            allowUnreferencedRefunds_ = self.allowUnreferencedRefunds
            etree_.SubElement(element, '{}allowUnreferencedRefunds').text = self.gds_format_boolean(allowUnreferencedRefunds_)
        if self.allowUnreferencedRefundsAfterRefundDecline is not None:
            allowUnreferencedRefundsAfterRefundDecline_ = self.allowUnreferencedRefundsAfterRefundDecline
            etree_.SubElement(element, '{}allowUnreferencedRefundsAfterRefundDecline').text = self.gds_format_boolean(allowUnreferencedRefundsAfterRefundDecline_)
        if self.unreferencedRefundlimit is not None:
            unreferencedRefundlimit_ = self.unreferencedRefundlimit
            etree_.SubElement(element, '{}unreferencedRefundlimit').text = self.gds_format_integer(unreferencedRefundlimit_)
        if self.threedSecure is not None:
            threedSecure_ = self.threedSecure
            etree_.SubElement(element, '{}threedSecure').text = self.gds_format_boolean(threedSecure_)
        if self.threedsMerchantId is not None:
            threedsMerchantId_ = self.threedsMerchantId
            etree_.SubElement(element, '{}threedsMerchantId').text = self.gds_format_string(threedsMerchantId_)
        if self.threedsPassword is not None:
            threedsPassword_ = self.threedsPassword
            etree_.SubElement(element, '{}threedsPassword').text = self.gds_format_string(threedsPassword_)
        if self.allowVoiceId is not None:
            allowVoiceId_ = self.allowVoiceId
            etree_.SubElement(element, '{}allowVoiceId').text = self.gds_format_boolean(allowVoiceId_)
        if self.authId is not None:
            authId_ = self.authId
            etree_.SubElement(element, '{}authId').text = self.gds_format_string(authId_)
        if self.authPassword is not None:
            authPassword_ = self.authPassword
            etree_.SubElement(element, '{}authPassword').text = self.gds_format_string(authPassword_)
        if self.maxMindActive is not None:
            maxMindActive_ = self.maxMindActive
            etree_.SubElement(element, '{}maxMindActive').text = self.gds_format_boolean(maxMindActive_)
        if self.maxMindRejectOnError is not None:
            maxMindRejectOnError_ = self.maxMindRejectOnError
            etree_.SubElement(element, '{}maxMindRejectOnError').text = self.gds_format_boolean(maxMindRejectOnError_)
        if self.maxMindRiskScoreThreshold is not None:
            maxMindRiskScoreThreshold_ = self.maxMindRiskScoreThreshold
            etree_.SubElement(element, '{}maxMindRiskScoreThreshold').text = self.gds_format_double(maxMindRiskScoreThreshold_)
        if self.threatMetrixEnabled is not None:
            threatMetrixEnabled_ = self.threatMetrixEnabled
            etree_.SubElement(element, '{}threatMetrixEnabled').text = self.gds_format_boolean(threatMetrixEnabled_)
        if self.threatMetrixOrgId is not None:
            threatMetrixOrgId_ = self.threatMetrixOrgId
            etree_.SubElement(element, '{}threatMetrixOrgId').text = self.gds_format_string(threatMetrixOrgId_)
        if self.threatMetrixApiKey is not None:
            threatMetrixApiKey_ = self.threatMetrixApiKey
            etree_.SubElement(element, '{}threatMetrixApiKey').text = self.gds_format_string(threatMetrixApiKey_)
        if self.threatMetrixPolicyName is not None:
            threatMetrixPolicyName_ = self.threatMetrixPolicyName
            etree_.SubElement(element, '{}threatMetrixPolicyName').text = self.gds_format_string(threatMetrixPolicyName_)
        if self.threatMetrixRejectOnError is not None:
            threatMetrixRejectOnError_ = self.threatMetrixRejectOnError
            etree_.SubElement(element, '{}threatMetrixRejectOnError').text = self.gds_format_boolean(threatMetrixRejectOnError_)
        if self.threatMetrixRiskScoreThreshold is not None:
            threatMetrixRiskScoreThreshold_ = self.threatMetrixRiskScoreThreshold
            etree_.SubElement(element, '{}threatMetrixRiskScoreThreshold').text = self.gds_format_integer(threatMetrixRiskScoreThreshold_)
        if self.allowCardholderSignatureBypass is not None:
            allowCardholderSignatureBypass_ = self.allowCardholderSignatureBypass
            etree_.SubElement(element, '{}allowCardholderSignatureBypass').text = self.gds_format_boolean(allowCardholderSignatureBypass_)
        if self.allowCvvComplianceRuleBypass is not None:
            allowCvvComplianceRuleBypass_ = self.allowCvvComplianceRuleBypass
            etree_.SubElement(element, '{}allowCvvComplianceRuleBypass').text = self.gds_format_boolean(allowCvvComplianceRuleBypass_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalSecurityFraud'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.allowShowCvv is not None:
            showIndent(outfile, level)
            outfile.write('allowShowCvv=%s,\n' % self.allowShowCvv)
        if self.allowAutoDeclineCvvFailures is not None:
            showIndent(outfile, level)
            outfile.write('allowAutoDeclineCvvFailures=%s,\n' % self.allowAutoDeclineCvvFailures)
        showIndent(outfile, level)
        outfile.write('cvvDeclineCodes=[\n')
        level += 1
        for cvvDeclineCodes_ in self.cvvDeclineCodes:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(cvvDeclineCodes_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.enableAvs is not None:
            showIndent(outfile, level)
            outfile.write('enableAvs=%s,\n' % self.enableAvs)
        if self.allowAvsCompulsory is not None:
            showIndent(outfile, level)
            outfile.write('allowAvsCompulsory=%s,\n' % self.allowAvsCompulsory)
        if self.apiAvsType is not None:
            showIndent(outfile, level)
            outfile.write('apiAvsType=%s,\n' % self.gds_encode(quote_python(self.apiAvsType)))
        if self.avsSentAction is not None:
            showIndent(outfile, level)
            outfile.write('avsSentAction=%s,\n' % self.gds_encode(quote_python(self.avsSentAction)))
        if self.allowAvsCodeApproval is not None:
            showIndent(outfile, level)
            outfile.write('allowAvsCodeApproval=%s,\n' % self.allowAvsCodeApproval)
        if self.approvedAVSCodes is not None:
            showIndent(outfile, level)
            outfile.write('approvedAVSCodes=model_.approvedAVSCodesType(\n')
            self.approvedAVSCodes.exportLiteral(outfile, level, name_='approvedAVSCodes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.refundAmountLimit is not None:
            showIndent(outfile, level)
            outfile.write('refundAmountLimit=%e,\n' % self.refundAmountLimit)
        if self.allowUnreferencedRefunds is not None:
            showIndent(outfile, level)
            outfile.write('allowUnreferencedRefunds=%s,\n' % self.allowUnreferencedRefunds)
        if self.allowUnreferencedRefundsAfterRefundDecline is not None:
            showIndent(outfile, level)
            outfile.write('allowUnreferencedRefundsAfterRefundDecline=%s,\n' % self.allowUnreferencedRefundsAfterRefundDecline)
        if self.unreferencedRefundlimit is not None:
            showIndent(outfile, level)
            outfile.write('unreferencedRefundlimit=%d,\n' % self.unreferencedRefundlimit)
        if self.threedSecure is not None:
            showIndent(outfile, level)
            outfile.write('threedSecure=%s,\n' % self.threedSecure)
        if self.threedsMerchantId is not None:
            showIndent(outfile, level)
            outfile.write('threedsMerchantId=%s,\n' % self.gds_encode(quote_python(self.threedsMerchantId)))
        if self.threedsPassword is not None:
            showIndent(outfile, level)
            outfile.write('threedsPassword=%s,\n' % self.gds_encode(quote_python(self.threedsPassword)))
        if self.allowVoiceId is not None:
            showIndent(outfile, level)
            outfile.write('allowVoiceId=%s,\n' % self.allowVoiceId)
        if self.authId is not None:
            showIndent(outfile, level)
            outfile.write('authId=%s,\n' % self.gds_encode(quote_python(self.authId)))
        if self.authPassword is not None:
            showIndent(outfile, level)
            outfile.write('authPassword=%s,\n' % self.gds_encode(quote_python(self.authPassword)))
        if self.maxMindActive is not None:
            showIndent(outfile, level)
            outfile.write('maxMindActive=%s,\n' % self.maxMindActive)
        if self.maxMindRejectOnError is not None:
            showIndent(outfile, level)
            outfile.write('maxMindRejectOnError=%s,\n' % self.maxMindRejectOnError)
        if self.maxMindRiskScoreThreshold is not None:
            showIndent(outfile, level)
            outfile.write('maxMindRiskScoreThreshold=%e,\n' % self.maxMindRiskScoreThreshold)
        if self.threatMetrixEnabled is not None:
            showIndent(outfile, level)
            outfile.write('threatMetrixEnabled=%s,\n' % self.threatMetrixEnabled)
        if self.threatMetrixOrgId is not None:
            showIndent(outfile, level)
            outfile.write('threatMetrixOrgId=%s,\n' % self.gds_encode(quote_python(self.threatMetrixOrgId)))
        if self.threatMetrixApiKey is not None:
            showIndent(outfile, level)
            outfile.write('threatMetrixApiKey=%s,\n' % self.gds_encode(quote_python(self.threatMetrixApiKey)))
        if self.threatMetrixPolicyName is not None:
            showIndent(outfile, level)
            outfile.write('threatMetrixPolicyName=%s,\n' % self.gds_encode(quote_python(self.threatMetrixPolicyName)))
        if self.threatMetrixRejectOnError is not None:
            showIndent(outfile, level)
            outfile.write('threatMetrixRejectOnError=%s,\n' % self.threatMetrixRejectOnError)
        if self.threatMetrixRiskScoreThreshold is not None:
            showIndent(outfile, level)
            outfile.write('threatMetrixRiskScoreThreshold=%d,\n' % self.threatMetrixRiskScoreThreshold)
        if self.allowCardholderSignatureBypass is not None:
            showIndent(outfile, level)
            outfile.write('allowCardholderSignatureBypass=%s,\n' % self.allowCardholderSignatureBypass)
        if self.allowCvvComplianceRuleBypass is not None:
            showIndent(outfile, level)
            outfile.write('allowCvvComplianceRuleBypass=%s,\n' % self.allowCvvComplianceRuleBypass)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allowShowCvv':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowShowCvv')
            self.allowShowCvv = ival_
        elif nodeName_ == 'allowAutoDeclineCvvFailures':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowAutoDeclineCvvFailures')
            self.allowAutoDeclineCvvFailures = ival_
        elif nodeName_ == 'cvvDeclineCodes':
            cvvDeclineCodes_ = child_.text
            cvvDeclineCodes_ = self.gds_validate_string(cvvDeclineCodes_, node, 'cvvDeclineCodes')
            self.cvvDeclineCodes.append(cvvDeclineCodes_)
            # validate type cvvResponseEnum
            self.validate_cvvResponseEnum(self.cvvDeclineCodes[-1])
        elif nodeName_ == 'enableAvs':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableAvs')
            self.enableAvs = ival_
        elif nodeName_ == 'allowAvsCompulsory':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowAvsCompulsory')
            self.allowAvsCompulsory = ival_
        elif nodeName_ == 'apiAvsType':
            apiAvsType_ = child_.text
            apiAvsType_ = self.gds_validate_string(apiAvsType_, node, 'apiAvsType')
            self.apiAvsType = apiAvsType_
            # validate type apiAddressModeEnum
            self.validate_apiAddressModeEnum(self.apiAvsType)
        elif nodeName_ == 'avsSentAction':
            avsSentAction_ = child_.text
            avsSentAction_ = self.gds_validate_string(avsSentAction_, node, 'avsSentAction')
            self.avsSentAction = avsSentAction_
            # validate type avsActionEnum
            self.validate_avsActionEnum(self.avsSentAction)
        elif nodeName_ == 'allowAvsCodeApproval':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowAvsCodeApproval')
            self.allowAvsCodeApproval = ival_
        elif nodeName_ == 'approvedAVSCodes':
            obj_ = approvedAVSCodesType.factory()
            obj_.build(child_)
            self.approvedAVSCodes = obj_
            obj_.original_tagname_ = 'approvedAVSCodes'
        elif nodeName_ == 'refundAmountLimit' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'refundAmountLimit')
            self.refundAmountLimit = fval_
        elif nodeName_ == 'allowUnreferencedRefunds':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowUnreferencedRefunds')
            self.allowUnreferencedRefunds = ival_
        elif nodeName_ == 'allowUnreferencedRefundsAfterRefundDecline':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowUnreferencedRefundsAfterRefundDecline')
            self.allowUnreferencedRefundsAfterRefundDecline = ival_
        elif nodeName_ == 'unreferencedRefundlimit' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'unreferencedRefundlimit')
            self.unreferencedRefundlimit = ival_
        elif nodeName_ == 'threedSecure':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'threedSecure')
            self.threedSecure = ival_
        elif nodeName_ == 'threedsMerchantId':
            threedsMerchantId_ = child_.text
            threedsMerchantId_ = self.gds_validate_string(threedsMerchantId_, node, 'threedsMerchantId')
            self.threedsMerchantId = threedsMerchantId_
        elif nodeName_ == 'threedsPassword':
            threedsPassword_ = child_.text
            threedsPassword_ = self.gds_validate_string(threedsPassword_, node, 'threedsPassword')
            self.threedsPassword = threedsPassword_
        elif nodeName_ == 'allowVoiceId':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowVoiceId')
            self.allowVoiceId = ival_
        elif nodeName_ == 'authId':
            authId_ = child_.text
            authId_ = self.gds_validate_string(authId_, node, 'authId')
            self.authId = authId_
        elif nodeName_ == 'authPassword':
            authPassword_ = child_.text
            authPassword_ = self.gds_validate_string(authPassword_, node, 'authPassword')
            self.authPassword = authPassword_
        elif nodeName_ == 'maxMindActive':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'maxMindActive')
            self.maxMindActive = ival_
        elif nodeName_ == 'maxMindRejectOnError':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'maxMindRejectOnError')
            self.maxMindRejectOnError = ival_
        elif nodeName_ == 'maxMindRiskScoreThreshold' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maxMindRiskScoreThreshold')
            self.maxMindRiskScoreThreshold = fval_
        elif nodeName_ == 'threatMetrixEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'threatMetrixEnabled')
            self.threatMetrixEnabled = ival_
        elif nodeName_ == 'threatMetrixOrgId':
            threatMetrixOrgId_ = child_.text
            threatMetrixOrgId_ = self.gds_validate_string(threatMetrixOrgId_, node, 'threatMetrixOrgId')
            self.threatMetrixOrgId = threatMetrixOrgId_
        elif nodeName_ == 'threatMetrixApiKey':
            threatMetrixApiKey_ = child_.text
            threatMetrixApiKey_ = self.gds_validate_string(threatMetrixApiKey_, node, 'threatMetrixApiKey')
            self.threatMetrixApiKey = threatMetrixApiKey_
        elif nodeName_ == 'threatMetrixPolicyName':
            threatMetrixPolicyName_ = child_.text
            threatMetrixPolicyName_ = self.gds_validate_string(threatMetrixPolicyName_, node, 'threatMetrixPolicyName')
            self.threatMetrixPolicyName = threatMetrixPolicyName_
        elif nodeName_ == 'threatMetrixRejectOnError':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'threatMetrixRejectOnError')
            self.threatMetrixRejectOnError = ival_
        elif nodeName_ == 'threatMetrixRiskScoreThreshold' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'threatMetrixRiskScoreThreshold')
            self.threatMetrixRiskScoreThreshold = ival_
        elif nodeName_ == 'allowCardholderSignatureBypass':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowCardholderSignatureBypass')
            self.allowCardholderSignatureBypass = ival_
        elif nodeName_ == 'allowCvvComplianceRuleBypass':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowCvvComplianceRuleBypass')
            self.allowCvvComplianceRuleBypass = ival_
    def sample_method(self):
        pass
# end class terminalSecurityFraud


class terminalAchSettings(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('allowAchJhTransactions', 'xs:boolean', 0, 0, {'name': 'allowAchJhTransactions', 'type': 'xs:boolean'}, None),
        MemberSpec_('achJhLocationId', 'xs:string', 0, 1, {'name': 'achJhLocationId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('achJhMerchantId', 'xs:string', 0, 1, {'name': 'achJhMerchantId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('achJhBankGroupId', 'xs:string', 0, 1, {'name': 'achJhBankGroupId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('achJhBankConvenienceFee', 'xs:string', 0, 1, {'name': 'achJhBankConvenienceFee', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('allowAchIpTransactions', 'xs:boolean', 0, 0, {'name': 'allowAchIpTransactions', 'type': 'xs:boolean'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, allowAchJhTransactions=None, achJhLocationId=None, achJhMerchantId=None, achJhBankGroupId=None, achJhBankConvenienceFee=None, allowAchIpTransactions=None):
        self.original_tagname_ = None
        self.allowAchJhTransactions = allowAchJhTransactions
        self.achJhLocationId = achJhLocationId
        self.achJhMerchantId = achJhMerchantId
        self.achJhBankGroupId = achJhBankGroupId
        self.achJhBankConvenienceFee = achJhBankConvenienceFee
        self.allowAchIpTransactions = allowAchIpTransactions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalAchSettings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalAchSettings.subclass:
            return terminalAchSettings.subclass(*args_, **kwargs_)
        else:
            return terminalAchSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allowAchJhTransactions(self): return self.allowAchJhTransactions
    def set_allowAchJhTransactions(self, allowAchJhTransactions): self.allowAchJhTransactions = allowAchJhTransactions
    def get_achJhLocationId(self): return self.achJhLocationId
    def set_achJhLocationId(self, achJhLocationId): self.achJhLocationId = achJhLocationId
    def get_achJhMerchantId(self): return self.achJhMerchantId
    def set_achJhMerchantId(self, achJhMerchantId): self.achJhMerchantId = achJhMerchantId
    def get_achJhBankGroupId(self): return self.achJhBankGroupId
    def set_achJhBankGroupId(self, achJhBankGroupId): self.achJhBankGroupId = achJhBankGroupId
    def get_achJhBankConvenienceFee(self): return self.achJhBankConvenienceFee
    def set_achJhBankConvenienceFee(self, achJhBankConvenienceFee): self.achJhBankConvenienceFee = achJhBankConvenienceFee
    def get_allowAchIpTransactions(self): return self.allowAchIpTransactions
    def set_allowAchIpTransactions(self, allowAchIpTransactions): self.allowAchIpTransactions = allowAchIpTransactions
    def hasContent_(self):
        if (
            self.allowAchJhTransactions is not None or
            self.achJhLocationId is not None or
            self.achJhMerchantId is not None or
            self.achJhBankGroupId is not None or
            self.achJhBankConvenienceFee is not None or
            self.allowAchIpTransactions is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalAchSettings', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.allowAchJhTransactions is not None:
            allowAchJhTransactions_ = self.allowAchJhTransactions
            etree_.SubElement(element, '{}allowAchJhTransactions').text = self.gds_format_boolean(allowAchJhTransactions_)
        if self.achJhLocationId is not None:
            achJhLocationId_ = self.achJhLocationId
            etree_.SubElement(element, '{}achJhLocationId').text = self.gds_format_string(achJhLocationId_)
        if self.achJhMerchantId is not None:
            achJhMerchantId_ = self.achJhMerchantId
            etree_.SubElement(element, '{}achJhMerchantId').text = self.gds_format_string(achJhMerchantId_)
        if self.achJhBankGroupId is not None:
            achJhBankGroupId_ = self.achJhBankGroupId
            etree_.SubElement(element, '{}achJhBankGroupId').text = self.gds_format_string(achJhBankGroupId_)
        if self.achJhBankConvenienceFee is not None:
            achJhBankConvenienceFee_ = self.achJhBankConvenienceFee
            etree_.SubElement(element, '{}achJhBankConvenienceFee').text = self.gds_format_string(achJhBankConvenienceFee_)
        if self.allowAchIpTransactions is not None:
            allowAchIpTransactions_ = self.allowAchIpTransactions
            etree_.SubElement(element, '{}allowAchIpTransactions').text = self.gds_format_boolean(allowAchIpTransactions_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalAchSettings'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.allowAchJhTransactions is not None:
            showIndent(outfile, level)
            outfile.write('allowAchJhTransactions=%s,\n' % self.allowAchJhTransactions)
        if self.achJhLocationId is not None:
            showIndent(outfile, level)
            outfile.write('achJhLocationId=%s,\n' % self.gds_encode(quote_python(self.achJhLocationId)))
        if self.achJhMerchantId is not None:
            showIndent(outfile, level)
            outfile.write('achJhMerchantId=%s,\n' % self.gds_encode(quote_python(self.achJhMerchantId)))
        if self.achJhBankGroupId is not None:
            showIndent(outfile, level)
            outfile.write('achJhBankGroupId=%s,\n' % self.gds_encode(quote_python(self.achJhBankGroupId)))
        if self.achJhBankConvenienceFee is not None:
            showIndent(outfile, level)
            outfile.write('achJhBankConvenienceFee=%s,\n' % self.gds_encode(quote_python(self.achJhBankConvenienceFee)))
        if self.allowAchIpTransactions is not None:
            showIndent(outfile, level)
            outfile.write('allowAchIpTransactions=%s,\n' % self.allowAchIpTransactions)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allowAchJhTransactions':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowAchJhTransactions')
            self.allowAchJhTransactions = ival_
        elif nodeName_ == 'achJhLocationId':
            achJhLocationId_ = child_.text
            achJhLocationId_ = self.gds_validate_string(achJhLocationId_, node, 'achJhLocationId')
            self.achJhLocationId = achJhLocationId_
        elif nodeName_ == 'achJhMerchantId':
            achJhMerchantId_ = child_.text
            achJhMerchantId_ = self.gds_validate_string(achJhMerchantId_, node, 'achJhMerchantId')
            self.achJhMerchantId = achJhMerchantId_
        elif nodeName_ == 'achJhBankGroupId':
            achJhBankGroupId_ = child_.text
            achJhBankGroupId_ = self.gds_validate_string(achJhBankGroupId_, node, 'achJhBankGroupId')
            self.achJhBankGroupId = achJhBankGroupId_
        elif nodeName_ == 'achJhBankConvenienceFee':
            achJhBankConvenienceFee_ = child_.text
            achJhBankConvenienceFee_ = self.gds_validate_string(achJhBankConvenienceFee_, node, 'achJhBankConvenienceFee')
            self.achJhBankConvenienceFee = achJhBankConvenienceFee_
        elif nodeName_ == 'allowAchIpTransactions':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowAchIpTransactions')
            self.allowAchIpTransactions = ival_
    def sample_method(self):
        pass
# end class terminalAchSettings


class terminalUnionPayProcessing(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('allowUnionPayProcessing', 'xs:boolean', 0, 0, {'name': 'allowUnionPayProcessing', 'type': 'xs:boolean'}, None),
        MemberSpec_('cupMerchantId', 'xs:string', 0, 1, {'name': 'cupMerchantId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cupMerchantCategoryCode', 'xs:string', 0, 1, {'name': 'cupMerchantCategoryCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cupMerchantName', 'xs:string', 0, 1, {'name': 'cupMerchantName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cupMerchantAbbreviation', 'xs:string', 0, 1, {'name': 'cupMerchantAbbreviation', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('draft256Billing', 'terminalDraft256Billing', 0, 1, {'name': 'draft256Billing', 'type': 'terminalDraft256Billing', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, allowUnionPayProcessing=None, cupMerchantId=None, cupMerchantCategoryCode=None, cupMerchantName=None, cupMerchantAbbreviation=None, draft256Billing=None):
        self.original_tagname_ = None
        self.allowUnionPayProcessing = allowUnionPayProcessing
        self.cupMerchantId = cupMerchantId
        self.cupMerchantCategoryCode = cupMerchantCategoryCode
        self.cupMerchantName = cupMerchantName
        self.cupMerchantAbbreviation = cupMerchantAbbreviation
        self.draft256Billing = draft256Billing
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalUnionPayProcessing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalUnionPayProcessing.subclass:
            return terminalUnionPayProcessing.subclass(*args_, **kwargs_)
        else:
            return terminalUnionPayProcessing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allowUnionPayProcessing(self): return self.allowUnionPayProcessing
    def set_allowUnionPayProcessing(self, allowUnionPayProcessing): self.allowUnionPayProcessing = allowUnionPayProcessing
    def get_cupMerchantId(self): return self.cupMerchantId
    def set_cupMerchantId(self, cupMerchantId): self.cupMerchantId = cupMerchantId
    def get_cupMerchantCategoryCode(self): return self.cupMerchantCategoryCode
    def set_cupMerchantCategoryCode(self, cupMerchantCategoryCode): self.cupMerchantCategoryCode = cupMerchantCategoryCode
    def get_cupMerchantName(self): return self.cupMerchantName
    def set_cupMerchantName(self, cupMerchantName): self.cupMerchantName = cupMerchantName
    def get_cupMerchantAbbreviation(self): return self.cupMerchantAbbreviation
    def set_cupMerchantAbbreviation(self, cupMerchantAbbreviation): self.cupMerchantAbbreviation = cupMerchantAbbreviation
    def get_draft256Billing(self): return self.draft256Billing
    def set_draft256Billing(self, draft256Billing): self.draft256Billing = draft256Billing
    def hasContent_(self):
        if (
            self.allowUnionPayProcessing is not None or
            self.cupMerchantId is not None or
            self.cupMerchantCategoryCode is not None or
            self.cupMerchantName is not None or
            self.cupMerchantAbbreviation is not None or
            self.draft256Billing is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalUnionPayProcessing', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.allowUnionPayProcessing is not None:
            allowUnionPayProcessing_ = self.allowUnionPayProcessing
            etree_.SubElement(element, '{}allowUnionPayProcessing').text = self.gds_format_boolean(allowUnionPayProcessing_)
        if self.cupMerchantId is not None:
            cupMerchantId_ = self.cupMerchantId
            etree_.SubElement(element, '{}cupMerchantId').text = self.gds_format_string(cupMerchantId_)
        if self.cupMerchantCategoryCode is not None:
            cupMerchantCategoryCode_ = self.cupMerchantCategoryCode
            etree_.SubElement(element, '{}cupMerchantCategoryCode').text = self.gds_format_string(cupMerchantCategoryCode_)
        if self.cupMerchantName is not None:
            cupMerchantName_ = self.cupMerchantName
            etree_.SubElement(element, '{}cupMerchantName').text = self.gds_format_string(cupMerchantName_)
        if self.cupMerchantAbbreviation is not None:
            cupMerchantAbbreviation_ = self.cupMerchantAbbreviation
            etree_.SubElement(element, '{}cupMerchantAbbreviation').text = self.gds_format_string(cupMerchantAbbreviation_)
        if self.draft256Billing is not None:
            draft256Billing_ = self.draft256Billing
            draft256Billing_.to_etree(element, name_='draft256Billing', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalUnionPayProcessing'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.allowUnionPayProcessing is not None:
            showIndent(outfile, level)
            outfile.write('allowUnionPayProcessing=%s,\n' % self.allowUnionPayProcessing)
        if self.cupMerchantId is not None:
            showIndent(outfile, level)
            outfile.write('cupMerchantId=%s,\n' % self.gds_encode(quote_python(self.cupMerchantId)))
        if self.cupMerchantCategoryCode is not None:
            showIndent(outfile, level)
            outfile.write('cupMerchantCategoryCode=%s,\n' % self.gds_encode(quote_python(self.cupMerchantCategoryCode)))
        if self.cupMerchantName is not None:
            showIndent(outfile, level)
            outfile.write('cupMerchantName=%s,\n' % self.gds_encode(quote_python(self.cupMerchantName)))
        if self.cupMerchantAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('cupMerchantAbbreviation=%s,\n' % self.gds_encode(quote_python(self.cupMerchantAbbreviation)))
        if self.draft256Billing is not None:
            showIndent(outfile, level)
            outfile.write('draft256Billing=model_.terminalDraft256Billing(\n')
            self.draft256Billing.exportLiteral(outfile, level, name_='draft256Billing')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allowUnionPayProcessing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowUnionPayProcessing')
            self.allowUnionPayProcessing = ival_
        elif nodeName_ == 'cupMerchantId':
            cupMerchantId_ = child_.text
            cupMerchantId_ = self.gds_validate_string(cupMerchantId_, node, 'cupMerchantId')
            self.cupMerchantId = cupMerchantId_
        elif nodeName_ == 'cupMerchantCategoryCode':
            cupMerchantCategoryCode_ = child_.text
            cupMerchantCategoryCode_ = self.gds_validate_string(cupMerchantCategoryCode_, node, 'cupMerchantCategoryCode')
            self.cupMerchantCategoryCode = cupMerchantCategoryCode_
        elif nodeName_ == 'cupMerchantName':
            cupMerchantName_ = child_.text
            cupMerchantName_ = self.gds_validate_string(cupMerchantName_, node, 'cupMerchantName')
            self.cupMerchantName = cupMerchantName_
        elif nodeName_ == 'cupMerchantAbbreviation':
            cupMerchantAbbreviation_ = child_.text
            cupMerchantAbbreviation_ = self.gds_validate_string(cupMerchantAbbreviation_, node, 'cupMerchantAbbreviation')
            self.cupMerchantAbbreviation = cupMerchantAbbreviation_
        elif nodeName_ == 'draft256Billing':
            obj_ = terminalDraft256Billing.factory()
            obj_.build(child_)
            self.draft256Billing = obj_
            obj_.original_tagname_ = 'draft256Billing'
    def sample_method(self):
        pass
# end class terminalUnionPayProcessing


class terminalDraft256Billing(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cupBankMerchantId', 'xs:string', 0, 1, {'name': 'cupBankMerchantId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cupTerminalIdNumber', 'xs:string', 0, 1, {'name': 'cupTerminalIdNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cupAcqInstitutionIdCode', 'xs:string', 0, 1, {'name': 'cupAcqInstitutionIdCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cupStoreNumber', 'xs:string', 0, 1, {'name': 'cupStoreNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cupMerchantName', 'xs:string', 0, 1, {'name': 'cupMerchantName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cupMerchantLocalPhoneNum', 'xs:string', 0, 1, {'name': 'cupMerchantLocalPhoneNum', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cupPostalCode', 'xs:string', 0, 1, {'name': 'cupPostalCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cupMerchantCity', 'xs:string', 0, 1, {'name': 'cupMerchantCity', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('merchantStreetAddress', 'xs:string', 0, 1, {'name': 'merchantStreetAddress', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cupMerchantState', 'xs:string', 0, 1, {'name': 'cupMerchantState', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cupBankMerchantId=None, cupTerminalIdNumber=None, cupAcqInstitutionIdCode=None, cupStoreNumber=None, cupMerchantName=None, cupMerchantLocalPhoneNum=None, cupPostalCode=None, cupMerchantCity=None, merchantStreetAddress=None, cupMerchantState=None):
        self.original_tagname_ = None
        self.cupBankMerchantId = cupBankMerchantId
        self.cupTerminalIdNumber = cupTerminalIdNumber
        self.cupAcqInstitutionIdCode = cupAcqInstitutionIdCode
        self.cupStoreNumber = cupStoreNumber
        self.cupMerchantName = cupMerchantName
        self.cupMerchantLocalPhoneNum = cupMerchantLocalPhoneNum
        self.cupPostalCode = cupPostalCode
        self.cupMerchantCity = cupMerchantCity
        self.merchantStreetAddress = merchantStreetAddress
        self.cupMerchantState = cupMerchantState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalDraft256Billing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalDraft256Billing.subclass:
            return terminalDraft256Billing.subclass(*args_, **kwargs_)
        else:
            return terminalDraft256Billing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cupBankMerchantId(self): return self.cupBankMerchantId
    def set_cupBankMerchantId(self, cupBankMerchantId): self.cupBankMerchantId = cupBankMerchantId
    def get_cupTerminalIdNumber(self): return self.cupTerminalIdNumber
    def set_cupTerminalIdNumber(self, cupTerminalIdNumber): self.cupTerminalIdNumber = cupTerminalIdNumber
    def get_cupAcqInstitutionIdCode(self): return self.cupAcqInstitutionIdCode
    def set_cupAcqInstitutionIdCode(self, cupAcqInstitutionIdCode): self.cupAcqInstitutionIdCode = cupAcqInstitutionIdCode
    def get_cupStoreNumber(self): return self.cupStoreNumber
    def set_cupStoreNumber(self, cupStoreNumber): self.cupStoreNumber = cupStoreNumber
    def get_cupMerchantName(self): return self.cupMerchantName
    def set_cupMerchantName(self, cupMerchantName): self.cupMerchantName = cupMerchantName
    def get_cupMerchantLocalPhoneNum(self): return self.cupMerchantLocalPhoneNum
    def set_cupMerchantLocalPhoneNum(self, cupMerchantLocalPhoneNum): self.cupMerchantLocalPhoneNum = cupMerchantLocalPhoneNum
    def get_cupPostalCode(self): return self.cupPostalCode
    def set_cupPostalCode(self, cupPostalCode): self.cupPostalCode = cupPostalCode
    def get_cupMerchantCity(self): return self.cupMerchantCity
    def set_cupMerchantCity(self, cupMerchantCity): self.cupMerchantCity = cupMerchantCity
    def get_merchantStreetAddress(self): return self.merchantStreetAddress
    def set_merchantStreetAddress(self, merchantStreetAddress): self.merchantStreetAddress = merchantStreetAddress
    def get_cupMerchantState(self): return self.cupMerchantState
    def set_cupMerchantState(self, cupMerchantState): self.cupMerchantState = cupMerchantState
    def hasContent_(self):
        if (
            self.cupBankMerchantId is not None or
            self.cupTerminalIdNumber is not None or
            self.cupAcqInstitutionIdCode is not None or
            self.cupStoreNumber is not None or
            self.cupMerchantName is not None or
            self.cupMerchantLocalPhoneNum is not None or
            self.cupPostalCode is not None or
            self.cupMerchantCity is not None or
            self.merchantStreetAddress is not None or
            self.cupMerchantState is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalDraft256Billing', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cupBankMerchantId is not None:
            cupBankMerchantId_ = self.cupBankMerchantId
            etree_.SubElement(element, '{}cupBankMerchantId').text = self.gds_format_string(cupBankMerchantId_)
        if self.cupTerminalIdNumber is not None:
            cupTerminalIdNumber_ = self.cupTerminalIdNumber
            etree_.SubElement(element, '{}cupTerminalIdNumber').text = self.gds_format_string(cupTerminalIdNumber_)
        if self.cupAcqInstitutionIdCode is not None:
            cupAcqInstitutionIdCode_ = self.cupAcqInstitutionIdCode
            etree_.SubElement(element, '{}cupAcqInstitutionIdCode').text = self.gds_format_string(cupAcqInstitutionIdCode_)
        if self.cupStoreNumber is not None:
            cupStoreNumber_ = self.cupStoreNumber
            etree_.SubElement(element, '{}cupStoreNumber').text = self.gds_format_string(cupStoreNumber_)
        if self.cupMerchantName is not None:
            cupMerchantName_ = self.cupMerchantName
            etree_.SubElement(element, '{}cupMerchantName').text = self.gds_format_string(cupMerchantName_)
        if self.cupMerchantLocalPhoneNum is not None:
            cupMerchantLocalPhoneNum_ = self.cupMerchantLocalPhoneNum
            etree_.SubElement(element, '{}cupMerchantLocalPhoneNum').text = self.gds_format_string(cupMerchantLocalPhoneNum_)
        if self.cupPostalCode is not None:
            cupPostalCode_ = self.cupPostalCode
            etree_.SubElement(element, '{}cupPostalCode').text = self.gds_format_string(cupPostalCode_)
        if self.cupMerchantCity is not None:
            cupMerchantCity_ = self.cupMerchantCity
            etree_.SubElement(element, '{}cupMerchantCity').text = self.gds_format_string(cupMerchantCity_)
        if self.merchantStreetAddress is not None:
            merchantStreetAddress_ = self.merchantStreetAddress
            etree_.SubElement(element, '{}merchantStreetAddress').text = self.gds_format_string(merchantStreetAddress_)
        if self.cupMerchantState is not None:
            cupMerchantState_ = self.cupMerchantState
            etree_.SubElement(element, '{}cupMerchantState').text = self.gds_format_string(cupMerchantState_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalDraft256Billing'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cupBankMerchantId is not None:
            showIndent(outfile, level)
            outfile.write('cupBankMerchantId=%s,\n' % self.gds_encode(quote_python(self.cupBankMerchantId)))
        if self.cupTerminalIdNumber is not None:
            showIndent(outfile, level)
            outfile.write('cupTerminalIdNumber=%s,\n' % self.gds_encode(quote_python(self.cupTerminalIdNumber)))
        if self.cupAcqInstitutionIdCode is not None:
            showIndent(outfile, level)
            outfile.write('cupAcqInstitutionIdCode=%s,\n' % self.gds_encode(quote_python(self.cupAcqInstitutionIdCode)))
        if self.cupStoreNumber is not None:
            showIndent(outfile, level)
            outfile.write('cupStoreNumber=%s,\n' % self.gds_encode(quote_python(self.cupStoreNumber)))
        if self.cupMerchantName is not None:
            showIndent(outfile, level)
            outfile.write('cupMerchantName=%s,\n' % self.gds_encode(quote_python(self.cupMerchantName)))
        if self.cupMerchantLocalPhoneNum is not None:
            showIndent(outfile, level)
            outfile.write('cupMerchantLocalPhoneNum=%s,\n' % self.gds_encode(quote_python(self.cupMerchantLocalPhoneNum)))
        if self.cupPostalCode is not None:
            showIndent(outfile, level)
            outfile.write('cupPostalCode=%s,\n' % self.gds_encode(quote_python(self.cupPostalCode)))
        if self.cupMerchantCity is not None:
            showIndent(outfile, level)
            outfile.write('cupMerchantCity=%s,\n' % self.gds_encode(quote_python(self.cupMerchantCity)))
        if self.merchantStreetAddress is not None:
            showIndent(outfile, level)
            outfile.write('merchantStreetAddress=%s,\n' % self.gds_encode(quote_python(self.merchantStreetAddress)))
        if self.cupMerchantState is not None:
            showIndent(outfile, level)
            outfile.write('cupMerchantState=%s,\n' % self.gds_encode(quote_python(self.cupMerchantState)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cupBankMerchantId':
            cupBankMerchantId_ = child_.text
            cupBankMerchantId_ = self.gds_validate_string(cupBankMerchantId_, node, 'cupBankMerchantId')
            self.cupBankMerchantId = cupBankMerchantId_
        elif nodeName_ == 'cupTerminalIdNumber':
            cupTerminalIdNumber_ = child_.text
            cupTerminalIdNumber_ = self.gds_validate_string(cupTerminalIdNumber_, node, 'cupTerminalIdNumber')
            self.cupTerminalIdNumber = cupTerminalIdNumber_
        elif nodeName_ == 'cupAcqInstitutionIdCode':
            cupAcqInstitutionIdCode_ = child_.text
            cupAcqInstitutionIdCode_ = self.gds_validate_string(cupAcqInstitutionIdCode_, node, 'cupAcqInstitutionIdCode')
            self.cupAcqInstitutionIdCode = cupAcqInstitutionIdCode_
        elif nodeName_ == 'cupStoreNumber':
            cupStoreNumber_ = child_.text
            cupStoreNumber_ = self.gds_validate_string(cupStoreNumber_, node, 'cupStoreNumber')
            self.cupStoreNumber = cupStoreNumber_
        elif nodeName_ == 'cupMerchantName':
            cupMerchantName_ = child_.text
            cupMerchantName_ = self.gds_validate_string(cupMerchantName_, node, 'cupMerchantName')
            self.cupMerchantName = cupMerchantName_
        elif nodeName_ == 'cupMerchantLocalPhoneNum':
            cupMerchantLocalPhoneNum_ = child_.text
            cupMerchantLocalPhoneNum_ = self.gds_validate_string(cupMerchantLocalPhoneNum_, node, 'cupMerchantLocalPhoneNum')
            self.cupMerchantLocalPhoneNum = cupMerchantLocalPhoneNum_
        elif nodeName_ == 'cupPostalCode':
            cupPostalCode_ = child_.text
            cupPostalCode_ = self.gds_validate_string(cupPostalCode_, node, 'cupPostalCode')
            self.cupPostalCode = cupPostalCode_
        elif nodeName_ == 'cupMerchantCity':
            cupMerchantCity_ = child_.text
            cupMerchantCity_ = self.gds_validate_string(cupMerchantCity_, node, 'cupMerchantCity')
            self.cupMerchantCity = cupMerchantCity_
        elif nodeName_ == 'merchantStreetAddress':
            merchantStreetAddress_ = child_.text
            merchantStreetAddress_ = self.gds_validate_string(merchantStreetAddress_, node, 'merchantStreetAddress')
            self.merchantStreetAddress = merchantStreetAddress_
        elif nodeName_ == 'cupMerchantState':
            cupMerchantState_ = child_.text
            cupMerchantState_ = self.gds_validate_string(cupMerchantState_, node, 'cupMerchantState')
            self.cupMerchantState = cupMerchantState_
    def sample_method(self):
        pass
# end class terminalDraft256Billing


class terminalIntegration(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('enableBackgroundValidation', 'xs:boolean', 0, 0, {'name': 'enableBackgroundValidation', 'type': 'xs:boolean'}, None),
        MemberSpec_('autoReady', 'xs:boolean', 0, 1, {'name': 'autoReady', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('autoReadyLimit', 'xs:int', 0, 1, {'name': 'autoReadyLimit', 'type': 'xs:int', 'minOccurs': '0'}, None),
        MemberSpec_('backgroundValidationUrl', 'xs:string', 0, 1, {'name': 'backgroundValidationUrl', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('receiptPageUrl', 'xs:string', 0, 1, {'name': 'receiptPageUrl', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('receiptMpiUrl', 'xs:string', 0, 1, {'name': 'receiptMpiUrl', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('receiptSecureCardUrl', 'xs:string', 0, 1, {'name': 'receiptSecureCardUrl', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('receiptSubscriptionUrl', 'xs:string', 0, 1, {'name': 'receiptSubscriptionUrl', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('subscriptionNotificationUrl', 'xs:string', 0, 1, {'name': 'subscriptionNotificationUrl', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('showMaskedCardDetailsInXmlResponse', 'xs:boolean', 0, 1, {'name': 'showMaskedCardDetailsInXmlResponse', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('paymentVersion', ['paymentVersionEnum', 'xs:string'], 0, 1, {'name': 'paymentVersion', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('useUniqueRef', 'xs:boolean', 0, 1, {'name': 'useUniqueRef', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('addBankResponseCodeToXML', 'xs:boolean', 0, 1, {'name': 'addBankResponseCodeToXML', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('enableAdditionalFieldsInXml', 'xs:boolean', 0, 1, {'name': 'enableAdditionalFieldsInXml', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('enableOriginalResponseInXml', 'xs:boolean', 0, 1, {'name': 'enableOriginalResponseInXml', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('enableSupportsApplePayInXmlResponse', 'xs:boolean', 0, 1, {'name': 'enableSupportsApplePayInXmlResponse', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('enableSupportsGooglePayInXmlResponse', 'xs:boolean', 0, 1, {'name': 'enableSupportsGooglePayInXmlResponse', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('enable3dsInXmlResponse', 'xs:boolean', 0, 1, {'name': 'enable3dsInXmlResponse', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('enableSupportedCardsInXmlResponse', 'xs:boolean', 0, 1, {'name': 'enableSupportedCardsInXmlResponse', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, enableBackgroundValidation=None, autoReady=None, autoReadyLimit=None, backgroundValidationUrl=None, receiptPageUrl=None, receiptMpiUrl=None, receiptSecureCardUrl=None, receiptSubscriptionUrl=None, subscriptionNotificationUrl=None, showMaskedCardDetailsInXmlResponse=None, paymentVersion=None, useUniqueRef=None, addBankResponseCodeToXML=None, enableAdditionalFieldsInXml=None, enableOriginalResponseInXml=None, enableSupportsApplePayInXmlResponse=None, enableSupportsGooglePayInXmlResponse=None, enable3dsInXmlResponse=None, enableSupportedCardsInXmlResponse=None):
        self.original_tagname_ = None
        self.enableBackgroundValidation = enableBackgroundValidation
        self.autoReady = autoReady
        self.autoReadyLimit = autoReadyLimit
        self.backgroundValidationUrl = backgroundValidationUrl
        self.receiptPageUrl = receiptPageUrl
        self.receiptMpiUrl = receiptMpiUrl
        self.receiptSecureCardUrl = receiptSecureCardUrl
        self.receiptSubscriptionUrl = receiptSubscriptionUrl
        self.subscriptionNotificationUrl = subscriptionNotificationUrl
        self.showMaskedCardDetailsInXmlResponse = showMaskedCardDetailsInXmlResponse
        self.paymentVersion = paymentVersion
        self.validate_paymentVersionEnum(self.paymentVersion)
        self.useUniqueRef = useUniqueRef
        self.addBankResponseCodeToXML = addBankResponseCodeToXML
        self.enableAdditionalFieldsInXml = enableAdditionalFieldsInXml
        self.enableOriginalResponseInXml = enableOriginalResponseInXml
        self.enableSupportsApplePayInXmlResponse = enableSupportsApplePayInXmlResponse
        self.enableSupportsGooglePayInXmlResponse = enableSupportsGooglePayInXmlResponse
        self.enable3dsInXmlResponse = enable3dsInXmlResponse
        self.enableSupportedCardsInXmlResponse = enableSupportedCardsInXmlResponse
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalIntegration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalIntegration.subclass:
            return terminalIntegration.subclass(*args_, **kwargs_)
        else:
            return terminalIntegration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enableBackgroundValidation(self): return self.enableBackgroundValidation
    def set_enableBackgroundValidation(self, enableBackgroundValidation): self.enableBackgroundValidation = enableBackgroundValidation
    def get_autoReady(self): return self.autoReady
    def set_autoReady(self, autoReady): self.autoReady = autoReady
    def get_autoReadyLimit(self): return self.autoReadyLimit
    def set_autoReadyLimit(self, autoReadyLimit): self.autoReadyLimit = autoReadyLimit
    def get_backgroundValidationUrl(self): return self.backgroundValidationUrl
    def set_backgroundValidationUrl(self, backgroundValidationUrl): self.backgroundValidationUrl = backgroundValidationUrl
    def get_receiptPageUrl(self): return self.receiptPageUrl
    def set_receiptPageUrl(self, receiptPageUrl): self.receiptPageUrl = receiptPageUrl
    def get_receiptMpiUrl(self): return self.receiptMpiUrl
    def set_receiptMpiUrl(self, receiptMpiUrl): self.receiptMpiUrl = receiptMpiUrl
    def get_receiptSecureCardUrl(self): return self.receiptSecureCardUrl
    def set_receiptSecureCardUrl(self, receiptSecureCardUrl): self.receiptSecureCardUrl = receiptSecureCardUrl
    def get_receiptSubscriptionUrl(self): return self.receiptSubscriptionUrl
    def set_receiptSubscriptionUrl(self, receiptSubscriptionUrl): self.receiptSubscriptionUrl = receiptSubscriptionUrl
    def get_subscriptionNotificationUrl(self): return self.subscriptionNotificationUrl
    def set_subscriptionNotificationUrl(self, subscriptionNotificationUrl): self.subscriptionNotificationUrl = subscriptionNotificationUrl
    def get_showMaskedCardDetailsInXmlResponse(self): return self.showMaskedCardDetailsInXmlResponse
    def set_showMaskedCardDetailsInXmlResponse(self, showMaskedCardDetailsInXmlResponse): self.showMaskedCardDetailsInXmlResponse = showMaskedCardDetailsInXmlResponse
    def get_paymentVersion(self): return self.paymentVersion
    def set_paymentVersion(self, paymentVersion): self.paymentVersion = paymentVersion
    def get_useUniqueRef(self): return self.useUniqueRef
    def set_useUniqueRef(self, useUniqueRef): self.useUniqueRef = useUniqueRef
    def get_addBankResponseCodeToXML(self): return self.addBankResponseCodeToXML
    def set_addBankResponseCodeToXML(self, addBankResponseCodeToXML): self.addBankResponseCodeToXML = addBankResponseCodeToXML
    def get_enableAdditionalFieldsInXml(self): return self.enableAdditionalFieldsInXml
    def set_enableAdditionalFieldsInXml(self, enableAdditionalFieldsInXml): self.enableAdditionalFieldsInXml = enableAdditionalFieldsInXml
    def get_enableOriginalResponseInXml(self): return self.enableOriginalResponseInXml
    def set_enableOriginalResponseInXml(self, enableOriginalResponseInXml): self.enableOriginalResponseInXml = enableOriginalResponseInXml
    def get_enableSupportsApplePayInXmlResponse(self): return self.enableSupportsApplePayInXmlResponse
    def set_enableSupportsApplePayInXmlResponse(self, enableSupportsApplePayInXmlResponse): self.enableSupportsApplePayInXmlResponse = enableSupportsApplePayInXmlResponse
    def get_enableSupportsGooglePayInXmlResponse(self): return self.enableSupportsGooglePayInXmlResponse
    def set_enableSupportsGooglePayInXmlResponse(self, enableSupportsGooglePayInXmlResponse): self.enableSupportsGooglePayInXmlResponse = enableSupportsGooglePayInXmlResponse
    def get_enable3dsInXmlResponse(self): return self.enable3dsInXmlResponse
    def set_enable3dsInXmlResponse(self, enable3dsInXmlResponse): self.enable3dsInXmlResponse = enable3dsInXmlResponse
    def get_enableSupportedCardsInXmlResponse(self): return self.enableSupportedCardsInXmlResponse
    def set_enableSupportedCardsInXmlResponse(self, enableSupportedCardsInXmlResponse): self.enableSupportedCardsInXmlResponse = enableSupportedCardsInXmlResponse
    def validate_paymentVersionEnum(self, value):
        # Validate type paymentVersionEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['VERSION_1', 'VERSION_2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on paymentVersionEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.enableBackgroundValidation is not None or
            self.autoReady is not None or
            self.autoReadyLimit is not None or
            self.backgroundValidationUrl is not None or
            self.receiptPageUrl is not None or
            self.receiptMpiUrl is not None or
            self.receiptSecureCardUrl is not None or
            self.receiptSubscriptionUrl is not None or
            self.subscriptionNotificationUrl is not None or
            self.showMaskedCardDetailsInXmlResponse is not None or
            self.paymentVersion is not None or
            self.useUniqueRef is not None or
            self.addBankResponseCodeToXML is not None or
            self.enableAdditionalFieldsInXml is not None or
            self.enableOriginalResponseInXml is not None or
            self.enableSupportsApplePayInXmlResponse is not None or
            self.enableSupportsGooglePayInXmlResponse is not None or
            self.enable3dsInXmlResponse is not None or
            self.enableSupportedCardsInXmlResponse is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalIntegration', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.enableBackgroundValidation is not None:
            enableBackgroundValidation_ = self.enableBackgroundValidation
            etree_.SubElement(element, '{}enableBackgroundValidation').text = self.gds_format_boolean(enableBackgroundValidation_)
        if self.autoReady is not None:
            autoReady_ = self.autoReady
            etree_.SubElement(element, '{}autoReady').text = self.gds_format_boolean(autoReady_)
        if self.autoReadyLimit is not None:
            autoReadyLimit_ = self.autoReadyLimit
            etree_.SubElement(element, '{}autoReadyLimit').text = self.gds_format_integer(autoReadyLimit_)
        if self.backgroundValidationUrl is not None:
            backgroundValidationUrl_ = self.backgroundValidationUrl
            etree_.SubElement(element, '{}backgroundValidationUrl').text = self.gds_format_string(backgroundValidationUrl_)
        if self.receiptPageUrl is not None:
            receiptPageUrl_ = self.receiptPageUrl
            etree_.SubElement(element, '{}receiptPageUrl').text = self.gds_format_string(receiptPageUrl_)
        if self.receiptMpiUrl is not None:
            receiptMpiUrl_ = self.receiptMpiUrl
            etree_.SubElement(element, '{}receiptMpiUrl').text = self.gds_format_string(receiptMpiUrl_)
        if self.receiptSecureCardUrl is not None:
            receiptSecureCardUrl_ = self.receiptSecureCardUrl
            etree_.SubElement(element, '{}receiptSecureCardUrl').text = self.gds_format_string(receiptSecureCardUrl_)
        if self.receiptSubscriptionUrl is not None:
            receiptSubscriptionUrl_ = self.receiptSubscriptionUrl
            etree_.SubElement(element, '{}receiptSubscriptionUrl').text = self.gds_format_string(receiptSubscriptionUrl_)
        if self.subscriptionNotificationUrl is not None:
            subscriptionNotificationUrl_ = self.subscriptionNotificationUrl
            etree_.SubElement(element, '{}subscriptionNotificationUrl').text = self.gds_format_string(subscriptionNotificationUrl_)
        if self.showMaskedCardDetailsInXmlResponse is not None:
            showMaskedCardDetailsInXmlResponse_ = self.showMaskedCardDetailsInXmlResponse
            etree_.SubElement(element, '{}showMaskedCardDetailsInXmlResponse').text = self.gds_format_boolean(showMaskedCardDetailsInXmlResponse_)
        if self.paymentVersion is not None:
            paymentVersion_ = self.paymentVersion
            etree_.SubElement(element, '{}paymentVersion').text = self.gds_format_string(paymentVersion_)
        if self.useUniqueRef is not None:
            useUniqueRef_ = self.useUniqueRef
            etree_.SubElement(element, '{}useUniqueRef').text = self.gds_format_boolean(useUniqueRef_)
        if self.addBankResponseCodeToXML is not None:
            addBankResponseCodeToXML_ = self.addBankResponseCodeToXML
            etree_.SubElement(element, '{}addBankResponseCodeToXML').text = self.gds_format_boolean(addBankResponseCodeToXML_)
        if self.enableAdditionalFieldsInXml is not None:
            enableAdditionalFieldsInXml_ = self.enableAdditionalFieldsInXml
            etree_.SubElement(element, '{}enableAdditionalFieldsInXml').text = self.gds_format_boolean(enableAdditionalFieldsInXml_)
        if self.enableOriginalResponseInXml is not None:
            enableOriginalResponseInXml_ = self.enableOriginalResponseInXml
            etree_.SubElement(element, '{}enableOriginalResponseInXml').text = self.gds_format_boolean(enableOriginalResponseInXml_)
        if self.enableSupportsApplePayInXmlResponse is not None:
            enableSupportsApplePayInXmlResponse_ = self.enableSupportsApplePayInXmlResponse
            etree_.SubElement(element, '{}enableSupportsApplePayInXmlResponse').text = self.gds_format_boolean(enableSupportsApplePayInXmlResponse_)
        if self.enableSupportsGooglePayInXmlResponse is not None:
            enableSupportsGooglePayInXmlResponse_ = self.enableSupportsGooglePayInXmlResponse
            etree_.SubElement(element, '{}enableSupportsGooglePayInXmlResponse').text = self.gds_format_boolean(enableSupportsGooglePayInXmlResponse_)
        if self.enable3dsInXmlResponse is not None:
            enable3dsInXmlResponse_ = self.enable3dsInXmlResponse
            etree_.SubElement(element, '{}enable3dsInXmlResponse').text = self.gds_format_boolean(enable3dsInXmlResponse_)
        if self.enableSupportedCardsInXmlResponse is not None:
            enableSupportedCardsInXmlResponse_ = self.enableSupportedCardsInXmlResponse
            etree_.SubElement(element, '{}enableSupportedCardsInXmlResponse').text = self.gds_format_boolean(enableSupportedCardsInXmlResponse_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalIntegration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.enableBackgroundValidation is not None:
            showIndent(outfile, level)
            outfile.write('enableBackgroundValidation=%s,\n' % self.enableBackgroundValidation)
        if self.autoReady is not None:
            showIndent(outfile, level)
            outfile.write('autoReady=%s,\n' % self.autoReady)
        if self.autoReadyLimit is not None:
            showIndent(outfile, level)
            outfile.write('autoReadyLimit=%d,\n' % self.autoReadyLimit)
        if self.backgroundValidationUrl is not None:
            showIndent(outfile, level)
            outfile.write('backgroundValidationUrl=%s,\n' % self.gds_encode(quote_python(self.backgroundValidationUrl)))
        if self.receiptPageUrl is not None:
            showIndent(outfile, level)
            outfile.write('receiptPageUrl=%s,\n' % self.gds_encode(quote_python(self.receiptPageUrl)))
        if self.receiptMpiUrl is not None:
            showIndent(outfile, level)
            outfile.write('receiptMpiUrl=%s,\n' % self.gds_encode(quote_python(self.receiptMpiUrl)))
        if self.receiptSecureCardUrl is not None:
            showIndent(outfile, level)
            outfile.write('receiptSecureCardUrl=%s,\n' % self.gds_encode(quote_python(self.receiptSecureCardUrl)))
        if self.receiptSubscriptionUrl is not None:
            showIndent(outfile, level)
            outfile.write('receiptSubscriptionUrl=%s,\n' % self.gds_encode(quote_python(self.receiptSubscriptionUrl)))
        if self.subscriptionNotificationUrl is not None:
            showIndent(outfile, level)
            outfile.write('subscriptionNotificationUrl=%s,\n' % self.gds_encode(quote_python(self.subscriptionNotificationUrl)))
        if self.showMaskedCardDetailsInXmlResponse is not None:
            showIndent(outfile, level)
            outfile.write('showMaskedCardDetailsInXmlResponse=%s,\n' % self.showMaskedCardDetailsInXmlResponse)
        if self.paymentVersion is not None:
            showIndent(outfile, level)
            outfile.write('paymentVersion=%s,\n' % self.gds_encode(quote_python(self.paymentVersion)))
        if self.useUniqueRef is not None:
            showIndent(outfile, level)
            outfile.write('useUniqueRef=%s,\n' % self.useUniqueRef)
        if self.addBankResponseCodeToXML is not None:
            showIndent(outfile, level)
            outfile.write('addBankResponseCodeToXML=%s,\n' % self.addBankResponseCodeToXML)
        if self.enableAdditionalFieldsInXml is not None:
            showIndent(outfile, level)
            outfile.write('enableAdditionalFieldsInXml=%s,\n' % self.enableAdditionalFieldsInXml)
        if self.enableOriginalResponseInXml is not None:
            showIndent(outfile, level)
            outfile.write('enableOriginalResponseInXml=%s,\n' % self.enableOriginalResponseInXml)
        if self.enableSupportsApplePayInXmlResponse is not None:
            showIndent(outfile, level)
            outfile.write('enableSupportsApplePayInXmlResponse=%s,\n' % self.enableSupportsApplePayInXmlResponse)
        if self.enableSupportsGooglePayInXmlResponse is not None:
            showIndent(outfile, level)
            outfile.write('enableSupportsGooglePayInXmlResponse=%s,\n' % self.enableSupportsGooglePayInXmlResponse)
        if self.enable3dsInXmlResponse is not None:
            showIndent(outfile, level)
            outfile.write('enable3dsInXmlResponse=%s,\n' % self.enable3dsInXmlResponse)
        if self.enableSupportedCardsInXmlResponse is not None:
            showIndent(outfile, level)
            outfile.write('enableSupportedCardsInXmlResponse=%s,\n' % self.enableSupportedCardsInXmlResponse)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enableBackgroundValidation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableBackgroundValidation')
            self.enableBackgroundValidation = ival_
        elif nodeName_ == 'autoReady':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'autoReady')
            self.autoReady = ival_
        elif nodeName_ == 'autoReadyLimit' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'autoReadyLimit')
            self.autoReadyLimit = ival_
        elif nodeName_ == 'backgroundValidationUrl':
            backgroundValidationUrl_ = child_.text
            backgroundValidationUrl_ = self.gds_validate_string(backgroundValidationUrl_, node, 'backgroundValidationUrl')
            self.backgroundValidationUrl = backgroundValidationUrl_
        elif nodeName_ == 'receiptPageUrl':
            receiptPageUrl_ = child_.text
            receiptPageUrl_ = self.gds_validate_string(receiptPageUrl_, node, 'receiptPageUrl')
            self.receiptPageUrl = receiptPageUrl_
        elif nodeName_ == 'receiptMpiUrl':
            receiptMpiUrl_ = child_.text
            receiptMpiUrl_ = self.gds_validate_string(receiptMpiUrl_, node, 'receiptMpiUrl')
            self.receiptMpiUrl = receiptMpiUrl_
        elif nodeName_ == 'receiptSecureCardUrl':
            receiptSecureCardUrl_ = child_.text
            receiptSecureCardUrl_ = self.gds_validate_string(receiptSecureCardUrl_, node, 'receiptSecureCardUrl')
            self.receiptSecureCardUrl = receiptSecureCardUrl_
        elif nodeName_ == 'receiptSubscriptionUrl':
            receiptSubscriptionUrl_ = child_.text
            receiptSubscriptionUrl_ = self.gds_validate_string(receiptSubscriptionUrl_, node, 'receiptSubscriptionUrl')
            self.receiptSubscriptionUrl = receiptSubscriptionUrl_
        elif nodeName_ == 'subscriptionNotificationUrl':
            subscriptionNotificationUrl_ = child_.text
            subscriptionNotificationUrl_ = self.gds_validate_string(subscriptionNotificationUrl_, node, 'subscriptionNotificationUrl')
            self.subscriptionNotificationUrl = subscriptionNotificationUrl_
        elif nodeName_ == 'showMaskedCardDetailsInXmlResponse':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'showMaskedCardDetailsInXmlResponse')
            self.showMaskedCardDetailsInXmlResponse = ival_
        elif nodeName_ == 'paymentVersion':
            paymentVersion_ = child_.text
            paymentVersion_ = self.gds_validate_string(paymentVersion_, node, 'paymentVersion')
            self.paymentVersion = paymentVersion_
            # validate type paymentVersionEnum
            self.validate_paymentVersionEnum(self.paymentVersion)
        elif nodeName_ == 'useUniqueRef':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'useUniqueRef')
            self.useUniqueRef = ival_
        elif nodeName_ == 'addBankResponseCodeToXML':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'addBankResponseCodeToXML')
            self.addBankResponseCodeToXML = ival_
        elif nodeName_ == 'enableAdditionalFieldsInXml':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableAdditionalFieldsInXml')
            self.enableAdditionalFieldsInXml = ival_
        elif nodeName_ == 'enableOriginalResponseInXml':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableOriginalResponseInXml')
            self.enableOriginalResponseInXml = ival_
        elif nodeName_ == 'enableSupportsApplePayInXmlResponse':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableSupportsApplePayInXmlResponse')
            self.enableSupportsApplePayInXmlResponse = ival_
        elif nodeName_ == 'enableSupportsGooglePayInXmlResponse':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableSupportsGooglePayInXmlResponse')
            self.enableSupportsGooglePayInXmlResponse = ival_
        elif nodeName_ == 'enable3dsInXmlResponse':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enable3dsInXmlResponse')
            self.enable3dsInXmlResponse = ival_
        elif nodeName_ == 'enableSupportedCardsInXmlResponse':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableSupportedCardsInXmlResponse')
            self.enableSupportedCardsInXmlResponse = ival_
    def sample_method(self):
        pass
# end class terminalIntegration


class merchantLevelLimitsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('merchantLimit', 'merchantLevelLimit', 1, 1, {'name': 'merchantLimit', 'type': 'merchantLevelLimit', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, merchantLimit=None):
        self.original_tagname_ = None
        if merchantLimit is None:
            self.merchantLimit = []
        else:
            self.merchantLimit = merchantLimit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, merchantLevelLimitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if merchantLevelLimitsType.subclass:
            return merchantLevelLimitsType.subclass(*args_, **kwargs_)
        else:
            return merchantLevelLimitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_merchantLimit(self): return self.merchantLimit
    def set_merchantLimit(self, merchantLimit): self.merchantLimit = merchantLimit
    def add_merchantLimit(self, value): self.merchantLimit.append(value)
    def insert_merchantLimit_at(self, index, value): self.merchantLimit.insert(index, value)
    def replace_merchantLimit_at(self, index, value): self.merchantLimit[index] = value
    def hasContent_(self):
        if (
            self.merchantLimit
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='merchantLevelLimitsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for merchantLimit_ in self.merchantLimit:
            merchantLimit_.to_etree(element, name_='merchantLimit', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='merchantLevelLimitsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('merchantLimit=[\n')
        level += 1
        for merchantLimit_ in self.merchantLimit:
            showIndent(outfile, level)
            outfile.write('model_.merchantLevelLimit(\n')
            merchantLimit_.exportLiteral(outfile, level, name_='merchantLevelLimit')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'merchantLimit':
            obj_ = merchantLevelLimit.factory()
            obj_.build(child_)
            self.merchantLimit.append(obj_)
            obj_.original_tagname_ = 'merchantLimit'
    def sample_method(self):
        pass
# end class merchantLevelLimitsType


class userProcessingTerminalsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('userProcessingTerminal', 'xs:string', 1, 1, {'name': 'userProcessingTerminal', 'type': 'xs:string', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, userProcessingTerminal=None):
        self.original_tagname_ = None
        if userProcessingTerminal is None:
            self.userProcessingTerminal = []
        else:
            self.userProcessingTerminal = userProcessingTerminal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, userProcessingTerminalsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if userProcessingTerminalsType.subclass:
            return userProcessingTerminalsType.subclass(*args_, **kwargs_)
        else:
            return userProcessingTerminalsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_userProcessingTerminal(self): return self.userProcessingTerminal
    def set_userProcessingTerminal(self, userProcessingTerminal): self.userProcessingTerminal = userProcessingTerminal
    def add_userProcessingTerminal(self, value): self.userProcessingTerminal.append(value)
    def insert_userProcessingTerminal_at(self, index, value): self.userProcessingTerminal.insert(index, value)
    def replace_userProcessingTerminal_at(self, index, value): self.userProcessingTerminal[index] = value
    def hasContent_(self):
        if (
            self.userProcessingTerminal
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='userProcessingTerminalsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for userProcessingTerminal_ in self.userProcessingTerminal:
            etree_.SubElement(element, '{}userProcessingTerminal').text = self.gds_format_string(userProcessingTerminal_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='userProcessingTerminalsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('userProcessingTerminal=[\n')
        level += 1
        for userProcessingTerminal_ in self.userProcessingTerminal:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(userProcessingTerminal_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userProcessingTerminal':
            userProcessingTerminal_ = child_.text
            userProcessingTerminal_ = self.gds_validate_string(userProcessingTerminal_, node, 'userProcessingTerminal')
            self.userProcessingTerminal.append(userProcessingTerminal_)
    def sample_method(self):
        pass
# end class userProcessingTerminalsType


class validationErrorsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('validationError', 'validationError', 1, 1, {'name': 'validationError', 'type': 'validationError', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, validationError=None):
        self.original_tagname_ = None
        if validationError is None:
            self.validationError = []
        else:
            self.validationError = validationError
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, validationErrorsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if validationErrorsType.subclass:
            return validationErrorsType.subclass(*args_, **kwargs_)
        else:
            return validationErrorsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_validationError(self): return self.validationError
    def set_validationError(self, validationError): self.validationError = validationError
    def add_validationError(self, value): self.validationError.append(value)
    def insert_validationError_at(self, index, value): self.validationError.insert(index, value)
    def replace_validationError_at(self, index, value): self.validationError[index] = value
    def hasContent_(self):
        if (
            self.validationError
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='validationErrorsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for validationError_ in self.validationError:
            validationError_.to_etree(element, name_='validationError', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='validationErrorsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('validationError=[\n')
        level += 1
        for validationError_ in self.validationError:
            showIndent(outfile, level)
            outfile.write('model_.validationError(\n')
            validationError_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validationError':
            obj_ = validationError.factory()
            obj_.build(child_)
            self.validationError.append(obj_)
            obj_.original_tagname_ = 'validationError'
    def sample_method(self):
        pass
# end class validationErrorsType


class cardsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('card', 'xs:string', 1, 1, {'name': 'card', 'type': 'xs:string', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, card=None):
        self.original_tagname_ = None
        if card is None:
            self.card = []
        else:
            self.card = card
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardsType.subclass:
            return cardsType.subclass(*args_, **kwargs_)
        else:
            return cardsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_card(self): return self.card
    def set_card(self, card): self.card = card
    def add_card(self, value): self.card.append(value)
    def insert_card_at(self, index, value): self.card.insert(index, value)
    def replace_card_at(self, index, value): self.card[index] = value
    def hasContent_(self):
        if (
            self.card
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='cardsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for card_ in self.card:
            etree_.SubElement(element, '{}card').text = self.gds_format_string(card_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='cardsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('card=[\n')
        level += 1
        for card_ in self.card:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(card_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'card':
            card_ = child_.text
            card_ = self.gds_validate_string(card_, node, 'card')
            self.card.append(card_)
    def sample_method(self):
        pass
# end class cardsType


class threeDsCardsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('threeDsCard', 'xs:string', 1, 1, {'name': 'threeDsCard', 'type': 'xs:string', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, threeDsCard=None):
        self.original_tagname_ = None
        if threeDsCard is None:
            self.threeDsCard = []
        else:
            self.threeDsCard = threeDsCard
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, threeDsCardsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if threeDsCardsType.subclass:
            return threeDsCardsType.subclass(*args_, **kwargs_)
        else:
            return threeDsCardsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_threeDsCard(self): return self.threeDsCard
    def set_threeDsCard(self, threeDsCard): self.threeDsCard = threeDsCard
    def add_threeDsCard(self, value): self.threeDsCard.append(value)
    def insert_threeDsCard_at(self, index, value): self.threeDsCard.insert(index, value)
    def replace_threeDsCard_at(self, index, value): self.threeDsCard[index] = value
    def hasContent_(self):
        if (
            self.threeDsCard
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='threeDsCardsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for threeDsCard_ in self.threeDsCard:
            etree_.SubElement(element, '{}threeDsCard').text = self.gds_format_string(threeDsCard_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='threeDsCardsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('threeDsCard=[\n')
        level += 1
        for threeDsCard_ in self.threeDsCard:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(threeDsCard_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'threeDsCard':
            threeDsCard_ = child_.text
            threeDsCard_ = self.gds_validate_string(threeDsCard_, node, 'threeDsCard')
            self.threeDsCard.append(threeDsCard_)
    def sample_method(self):
        pass
# end class threeDsCardsType


class currenciesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('currency', 'xs:string', 1, 1, {'name': 'currency', 'type': 'xs:string', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, currency=None):
        self.original_tagname_ = None
        if currency is None:
            self.currency = []
        else:
            self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, currenciesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if currenciesType.subclass:
            return currenciesType.subclass(*args_, **kwargs_)
        else:
            return currenciesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def add_currency(self, value): self.currency.append(value)
    def insert_currency_at(self, index, value): self.currency.insert(index, value)
    def replace_currency_at(self, index, value): self.currency[index] = value
    def hasContent_(self):
        if (
            self.currency
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='currenciesType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for currency_ in self.currency:
            etree_.SubElement(element, '{}currency').text = self.gds_format_string(currency_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='currenciesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('currency=[\n')
        level += 1
        for currency_ in self.currency:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(currency_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            currency_ = child_.text
            currency_ = self.gds_validate_string(currency_, node, 'currency')
            self.currency.append(currency_)
    def sample_method(self):
        pass
# end class currenciesType


class terminalLevelLimitsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('terminalLimit', 'terminalLevelLimit', 1, 1, {'name': 'terminalLimit', 'type': 'terminalLevelLimit', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, terminalLimit=None):
        self.original_tagname_ = None
        if terminalLimit is None:
            self.terminalLimit = []
        else:
            self.terminalLimit = terminalLimit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalLevelLimitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalLevelLimitsType.subclass:
            return terminalLevelLimitsType.subclass(*args_, **kwargs_)
        else:
            return terminalLevelLimitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_terminalLimit(self): return self.terminalLimit
    def set_terminalLimit(self, terminalLimit): self.terminalLimit = terminalLimit
    def add_terminalLimit(self, value): self.terminalLimit.append(value)
    def insert_terminalLimit_at(self, index, value): self.terminalLimit.insert(index, value)
    def replace_terminalLimit_at(self, index, value): self.terminalLimit[index] = value
    def hasContent_(self):
        if (
            self.terminalLimit
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalLevelLimitsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for terminalLimit_ in self.terminalLimit:
            terminalLimit_.to_etree(element, name_='terminalLimit', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalLevelLimitsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('terminalLimit=[\n')
        level += 1
        for terminalLimit_ in self.terminalLimit:
            showIndent(outfile, level)
            outfile.write('model_.terminalLevelLimit(\n')
            terminalLimit_.exportLiteral(outfile, level, name_='terminalLevelLimit')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'terminalLimit':
            obj_ = terminalLevelLimit.factory()
            obj_.build(child_)
            self.terminalLimit.append(obj_)
            obj_.original_tagname_ = 'terminalLimit'
    def sample_method(self):
        pass
# end class terminalLevelLimitsType


class cardLevelLimitsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardLimit', 'cardLevelLimit', 1, 1, {'name': 'cardLimit', 'type': 'cardLevelLimit', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardLimit=None):
        self.original_tagname_ = None
        if cardLimit is None:
            self.cardLimit = []
        else:
            self.cardLimit = cardLimit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardLevelLimitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardLevelLimitsType.subclass:
            return cardLevelLimitsType.subclass(*args_, **kwargs_)
        else:
            return cardLevelLimitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardLimit(self): return self.cardLimit
    def set_cardLimit(self, cardLimit): self.cardLimit = cardLimit
    def add_cardLimit(self, value): self.cardLimit.append(value)
    def insert_cardLimit_at(self, index, value): self.cardLimit.insert(index, value)
    def replace_cardLimit_at(self, index, value): self.cardLimit[index] = value
    def hasContent_(self):
        if (
            self.cardLimit
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='cardLevelLimitsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for cardLimit_ in self.cardLimit:
            cardLimit_.to_etree(element, name_='cardLimit', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='cardLevelLimitsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cardLimit=[\n')
        level += 1
        for cardLimit_ in self.cardLimit:
            showIndent(outfile, level)
            outfile.write('model_.cardLevelLimit(\n')
            cardLimit_.exportLiteral(outfile, level, name_='cardLevelLimit')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardLimit':
            obj_ = cardLevelLimit.factory()
            obj_.build(child_)
            self.cardLimit.append(obj_)
            obj_.original_tagname_ = 'cardLimit'
    def sample_method(self):
        pass
# end class cardLevelLimitsType


class limitsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('limit', 'cardVolumeLimit', 1, 1, {'name': 'limit', 'type': 'cardVolumeLimit', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, limit=None):
        self.original_tagname_ = None
        if limit is None:
            self.limit = []
        else:
            self.limit = limit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, limitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if limitsType.subclass:
            return limitsType.subclass(*args_, **kwargs_)
        else:
            return limitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_limit(self): return self.limit
    def set_limit(self, limit): self.limit = limit
    def add_limit(self, value): self.limit.append(value)
    def insert_limit_at(self, index, value): self.limit.insert(index, value)
    def replace_limit_at(self, index, value): self.limit[index] = value
    def hasContent_(self):
        if (
            self.limit
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='limitsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for limit_ in self.limit:
            limit_.to_etree(element, name_='limit', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='limitsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('limit=[\n')
        level += 1
        for limit_ in self.limit:
            showIndent(outfile, level)
            outfile.write('model_.cardVolumeLimit(\n')
            limit_.exportLiteral(outfile, level, name_='cardVolumeLimit')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'limit':
            obj_ = cardVolumeLimit.factory()
            obj_.build(child_)
            self.limit.append(obj_)
            obj_.original_tagname_ = 'limit'
    def sample_method(self):
        pass
# end class limitsType


class approvedAVSCodesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('approvedAVSCode', ['avsResponseEnum', 'xs:string'], 1, 1, {'name': 'approvedAVSCode', 'type': 'xs:string', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, approvedAVSCode=None):
        self.original_tagname_ = None
        if approvedAVSCode is None:
            self.approvedAVSCode = []
        else:
            self.approvedAVSCode = approvedAVSCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, approvedAVSCodesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if approvedAVSCodesType.subclass:
            return approvedAVSCodesType.subclass(*args_, **kwargs_)
        else:
            return approvedAVSCodesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approvedAVSCode(self): return self.approvedAVSCode
    def set_approvedAVSCode(self, approvedAVSCode): self.approvedAVSCode = approvedAVSCode
    def add_approvedAVSCode(self, value): self.approvedAVSCode.append(value)
    def insert_approvedAVSCode_at(self, index, value): self.approvedAVSCode.insert(index, value)
    def replace_approvedAVSCode_at(self, index, value): self.approvedAVSCode[index] = value
    def validate_avsResponseEnum(self, value):
        # Validate type avsResponseEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MATCH', 'PARTIAL_MATCH_ADDRESS', 'PARTIAL_MATCH_ZIP_CODE', 'NOT_MATCH', 'ADDRESS_NOT_VERIFIED_OR_UNAVAILABLE', 'SYSTEM_UNAVAILABLE', 'NOT_SUPPORTED', 'ABSENT_OR_INVALID_AVS', 'F', 'W', 'X']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on avsResponseEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.approvedAVSCode
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='approvedAVSCodesType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for approvedAVSCode_ in self.approvedAVSCode:
            etree_.SubElement(element, '{}approvedAVSCode').text = self.gds_format_string(approvedAVSCode_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='approvedAVSCodesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('approvedAVSCode=[\n')
        level += 1
        for approvedAVSCode_ in self.approvedAVSCode:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(approvedAVSCode_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'approvedAVSCode':
            approvedAVSCode_ = child_.text
            approvedAVSCode_ = self.gds_validate_string(approvedAVSCode_, node, 'approvedAVSCode')
            self.approvedAVSCode.append(approvedAVSCode_)
            # validate type avsResponseEnum
            self.validate_avsResponseEnum(self.approvedAVSCode[-1])
    def sample_method(self):
        pass
# end class approvedAVSCodesType


class merchantLevelLimit(volumeLimit):
    member_data_items_ = [
    ]
    subclass = None
    superclass = volumeLimit
    def __init__(self, limitScope=None, limitThreshold=None, withoutCvvOnly=None, withoutAvsOnly=None):
        self.original_tagname_ = None
        super(merchantLevelLimit, self).__init__(limitScope, limitThreshold, withoutCvvOnly, withoutAvsOnly, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, merchantLevelLimit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if merchantLevelLimit.subclass:
            return merchantLevelLimit.subclass(*args_, **kwargs_)
        else:
            return merchantLevelLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(merchantLevelLimit, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='merchantLevelLimit', mapping_=None):
        element = super(merchantLevelLimit, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='merchantLevelLimit'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(merchantLevelLimit, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(merchantLevelLimit, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(merchantLevelLimit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(merchantLevelLimit, self).buildChildren(child_, node, nodeName_, True)
        pass
    def sample_method(self):
        pass
# end class merchantLevelLimit


GDSClassesMapping = {
    'CardLevelLimit': cardLevelLimit,
    'CardVolumeLimit': cardVolumeLimit,
    'Merchant': merchant,
    'MerchantCustomSettings': merchantCustomSettings,
    'MerchantGeneralSetup': merchantGeneralSetup,
    'MerchantLevelLimit': merchantLevelLimit,
    'MerchantPortfolio': merchantPortfolio,
    'PartnerPortfolio': partnerPortfolio,
    'ServiceError': serviceError,
    'Terminal': terminal,
    'TerminalAchSettings': terminalAchSettings,
    'TerminalBankSettings': terminalBankSettings,
    'TerminalDraft256Billing': terminalDraft256Billing,
    'TerminalIntegration': terminalIntegration,
    'TerminalLevelLimit': terminalLevelLimit,
    'TerminalLimits': terminalLimits,
    'TerminalReceiptsNotification': terminalReceiptsNotification,
    'TerminalSecurityFraud': terminalSecurityFraud,
    'TerminalUnionPayProcessing': terminalUnionPayProcessing,
    'User': user,
    'ValidationError': validationError,
    'VolumeLimit': volumeLimit,
    'additionalSettings': additionalTerminalSettings,
    'features': terminalFeatures,
    'merchantPricing': pricing,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cardLevelLimit'
        rootClass = cardLevelLimit
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cardLevelLimit'
        rootClass = cardLevelLimit
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cardLevelLimit'
        rootClass = cardLevelLimit
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cardLevelLimit'
        rootClass = cardLevelLimit
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from boarding import *\n\n')
        sys.stdout.write('import boarding as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "additionalTerminalSettings",
    "approvedAVSCodesType",
    "cardLevelLimit",
    "cardLevelLimitsType",
    "cardVolumeLimit",
    "cardsType",
    "currenciesType",
    "limitsType",
    "merchant",
    "merchantCustomSettings",
    "merchantGeneralSetup",
    "merchantLevelLimit",
    "merchantLevelLimitsType",
    "merchantPortfolio",
    "partnerPortfolio",
    "pricing",
    "serviceError",
    "terminal",
    "terminalAchSettings",
    "terminalBankSettings",
    "terminalDraft256Billing",
    "terminalFeatures",
    "terminalIntegration",
    "terminalLevelLimit",
    "terminalLevelLimitsType",
    "terminalLimits",
    "terminalReceiptsNotification",
    "terminalSecurityFraud",
    "terminalUnionPayProcessing",
    "threeDsCardsType",
    "user",
    "userProcessingTerminalsType",
    "validationError",
    "validationErrorsType",
    "volumeLimit"
]
