#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated  by generateDS.py.
# Python 3.8.5 (default, Jan 27 2021, 15:41:15)  [GCC 9.3.0]
#
# Command line options:
#   ('--user-methods', 'rest_user_methods')
#   ('--export', 'etree literal')
#   ('--use-getter-setter', 'new')
#   ('--no-dates', '')
#   ('--no-versions', '')
#   ('-f', '')
#   ('-o', 'rest.py')
#
# Command line arguments:
#   rest.xsd
#
# Command line:
#   /usr/local/bin/generateDS --user-methods="rest_user_methods" --export="etree literal" --use-getter-setter="new" --no-dates --no-versions -f -o "rest.py" rest.xsd
#
# Current working directory (os.getcwd()):
#   model
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class additionalFieldType(object):
    ORDER_NUM='ORDER_NUM'


class applicationMatchType(object):
    _1='1'
    _2='2'
    _3='3'


class avsResponseCode(object):
    A='A'
    F='F'
    G='G'
    N='N'
    R='R'
    S='S'
    U='U'
    W='W'
    X='X'
    Y='Y'
    Z='Z'


class cardAccount(object):
    CASH='CASH'
    FOOD_STAMP='FOOD_STAMP'


class cardEntryMode(object):
    UNKNOWN='UNKNOWN'
    UNSPECIFIED='UNSPECIFIED'
    KEYED='KEYED'
    SWIPED='SWIPED'
    BARCODE='BARCODE'
    OCR='OCR'
    ICC='ICC'
    TRACK_ONE='TRACK_ONE'
    CONTACTLESS_ICC='CONTACTLESS_ICC'
    FILE='FILE'
    KEYED_FALLBACK='KEYED_FALLBACK'
    SWIPED_FALLBACK='SWIPED_FALLBACK'
    E_COMMERCE='E_COMMERCE'
    CONTACTLESS_MOTO='CONTACTLESS_MOTO'
    TRACK_ANY='TRACK_ANY'
    CONTACTLESS_MSR='CONTACTLESS_MSR'
    ICC_NO_CVV='ICC_NO_CVV'
    STORED='STORED'


class commerceType(object):
    NOT_APPLICABLE='NOT_APPLICABLE'
    INTERNET='INTERNET'
    INTERNET__3_DS_SECURED='INTERNET_3DS_SECURED'
    INTERNET__3_DS_ATTEMPTED='INTERNET_3DS_ATTEMPTED'
    MO='MO'
    MOTO='MOTO'


class currency(object):
    AED='AED'
    AFN='AFN'
    ALL='ALL'
    AMD='AMD'
    ANG='ANG'
    AOA='AOA'
    ARS='ARS'
    AUD='AUD'
    AWG='AWG'
    AZN='AZN'
    BAM='BAM'
    BBD='BBD'
    BDT='BDT'
    BGN='BGN'
    BHD='BHD'
    BIF='BIF'
    BMD='BMD'
    BND='BND'
    BOB='BOB'
    BOV='BOV'
    BRL='BRL'
    BSD='BSD'
    BTN='BTN'
    BWP='BWP'
    BYR='BYR'
    BZD='BZD'
    CAD='CAD'
    CDF='CDF'
    CHE='CHE'
    CHF='CHF'
    CHW='CHW'
    CLF='CLF'
    CLP='CLP'
    CNY='CNY'
    COP='COP'
    COU='COU'
    CRC='CRC'
    CUC='CUC'
    CUP='CUP'
    CVE='CVE'
    CZK='CZK'
    DJF='DJF'
    DKK='DKK'
    DOP='DOP'
    DZD='DZD'
    EGP='EGP'
    ERN='ERN'
    ETB='ETB'
    EUR='EUR'
    FJD='FJD'
    FKP='FKP'
    GBP='GBP'
    GEL='GEL'
    GHS='GHS'
    GIP='GIP'
    GMD='GMD'
    GNF='GNF'
    GTQ='GTQ'
    GYD='GYD'
    HKD='HKD'
    HNL='HNL'
    HRK='HRK'
    HTG='HTG'
    HUF='HUF'
    IDR='IDR'
    ILS='ILS'
    INR='INR'
    IQD='IQD'
    IRR='IRR'
    ISK='ISK'
    JMD='JMD'
    JOD='JOD'
    JPY='JPY'
    KES='KES'
    KGS='KGS'
    KHR='KHR'
    KMF='KMF'
    KPW='KPW'
    KRW='KRW'
    KWD='KWD'
    KYD='KYD'
    KZT='KZT'
    LAK='LAK'
    LBP='LBP'
    LKR='LKR'
    LRD='LRD'
    LSL='LSL'
    LTL='LTL'
    LVL='LVL'
    LYD='LYD'
    MAD='MAD'
    MDL='MDL'
    MGA='MGA'
    MKD='MKD'
    MMK='MMK'
    MNT='MNT'
    MOP='MOP'
    MRO='MRO'
    MRU='MRU'
    MUR='MUR'
    MVR='MVR'
    MWK='MWK'
    MXN='MXN'
    MXV='MXV'
    MYR='MYR'
    MZN='MZN'
    NAD='NAD'
    NGN='NGN'
    NIO='NIO'
    NOK='NOK'
    NPR='NPR'
    NZD='NZD'
    OMR='OMR'
    PAB='PAB'
    PEN='PEN'
    PGK='PGK'
    PHP='PHP'
    PKR='PKR'
    PLN='PLN'
    PYG='PYG'
    QAR='QAR'
    RON='RON'
    RSD='RSD'
    RUB='RUB'
    RWF='RWF'
    SAR='SAR'
    SBD='SBD'
    SCR='SCR'
    SDG='SDG'
    SEK='SEK'
    SGD='SGD'
    SHP='SHP'
    SLL='SLL'
    SOS='SOS'
    SRD='SRD'
    SSP='SSP'
    STD='STD'
    STN='STN'
    SVC='SVC'
    SYP='SYP'
    SZL='SZL'
    THB='THB'
    TJS='TJS'
    TMT='TMT'
    TND='TND'
    TOP='TOP'
    TRY='TRY'
    TTD='TTD'
    TWD='TWD'
    TZS='TZS'
    UAH='UAH'
    UGX='UGX'
    USD='USD'
    USN='USN'
    USS='USS'
    UYI='UYI'
    UYU='UYU'
    UZS='UZS'
    VEF='VEF'
    VES='VES'
    VND='VND'
    VUV='VUV'
    WST='WST'
    XAF='XAF'
    XCD='XCD'
    XOF='XOF'
    XPF='XPF'
    YER='YER'
    ZAR='ZAR'
    ZMW='ZMW'
    ZWL='ZWL'


class cvvResponseCode(object):
    M='M'
    N='N'
    P='P'
    U='U'


class debitAccountType(object):
    CHECKING='CHECKING'
    SAVINGS='SAVINGS'


class fallbackReason(object):
    TECHNICAL='TECHNICAL'
    EMPTY_CANDIDATE_LIST='EMPTY_CANDIDATE_LIST'


class messageDigestAlgorithm(object):
    SHA__256='SHA_256'
    SHA__384='SHA_384'
    SHA__512='SHA_512'


class paymentTypeEnum(object):
    CREDIT_DEBIT='CREDIT_DEBIT'
    EBT='EBT'


class saleRequestType(object):
    PURCHASE='PURCHASE'
    CASH_WITHDRAWAL='CASH_WITHDRAWAL'
    SALE='SALE'


class terminalCategory(object):
    UNATTENDED_TERMINAL='UNATTENDED_TERMINAL'


class terminalType(object):
    MOTO='MOTO'
    INTERNET='INTERNET'
    CHP='CHP'


class tipType(object):
    PERCENTAGE='PERCENTAGE'
    FIXED_AMOUNT='FIXED_AMOUNT'


class transactionReportCriterion(object):
    MERCHANT='MERCHANT'
    DEVICE='DEVICE'
    OPERATOR='OPERATOR'


class transactionState(object):
    OPEN='OPEN'
    CLOSED='CLOSED'


class transactionStatus(object):
    PENDING='PENDING'
    READY='READY'
    VOID='VOID'
    DECLINED='DECLINED'
    COMPLETE='COMPLETE'
    REFERRAL='REFERRAL'
    REVERSAL='REVERSAL'
    ACCEPTED='ACCEPTED'
    OTHER='OTHER'


class transactionType(object):
    SALE='SALE'
    REFUND='REFUND'
    PRE_AUTH='PRE_AUTH'
    PRE_AUTH_COMPLETION='PRE_AUTH_COMPLETION'
    OFFLINE_DECLINE='OFFLINE_DECLINE'
    DEFERRED_AUTH='DEFERRED_AUTH'


class protectedMethod(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('dateTime', 'xs:dateTime', 0, 0, {'name': 'dateTime', 'type': 'xs:dateTime'}, None),
        MemberSpec_('hash', 'hash', 0, 0, {'name': 'hash', 'type': 'hash'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, hash=None, extensiontype_=None):
        self.original_tagname_ = None
        if isinstance(dateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dateTime
        self.dateTime = initvalue_
        self.hash = hash
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protectedMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protectedMethod.subclass:
            return protectedMethod.subclass(*args_, **kwargs_)
        else:
            return protectedMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_hash(self): return self.hash
    def set_hash(self, hash): self.hash = hash
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.hash is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='protectedMethod', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.dateTime is not None:
            dateTime_ = self.dateTime
            etree_.SubElement(element, '{}dateTime').text = self.gds_format_datetime(dateTime_)
        if self.hash is not None:
            hash_ = self.hash
            hash_.to_etree(element, name_='hash', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='protectedMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.dateTime, input_name='dateTime'))
        if self.hash is not None:
            showIndent(outfile, level)
            outfile.write('hash=model_.hash(\n')
            self.hash.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTime = dval_
        elif nodeName_ == 'hash':
            obj_ = hash.factory()
            obj_.build(child_)
            self.hash = obj_
            obj_.original_tagname_ = 'hash'
# end class protectedMethod


class secureCard(protectedMethod):
    member_data_items_ = [
        MemberSpec_('cardEntryMode', ['cardEntryMode', 'xs:string'], 0, 1, {'name': 'cardEntryMode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardReference', 'xs:string', 0, 1, {'name': 'cardReference', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('customFields', 'customFieldsType', 0, 1, {'name': 'customFields', 'minOccurs': '0', 'type': 'customFieldsType'}, None),
        MemberSpec_('customer', 'customer', 0, 1, {'name': 'customer', 'type': 'customer', 'minOccurs': '0'}, None),
        MemberSpec_('device', 'posDevice', 0, 1, {'name': 'device', 'type': 'posDevice', 'minOccurs': '0'}, None),
        MemberSpec_('deviceType', 'xs:string', 0, 1, {'name': 'deviceType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('issueNo', 'xs:string', 0, 1, {'name': 'issueNo', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('merchantReference', 'xs:string', 0, 0, {'name': 'merchantReference', 'type': 'xs:string'}, None),
        MemberSpec_('permittedTerminals', 'xs:string', 0, 1, {'name': 'permittedTerminals', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('terminalId', 'xs:string', 0, 0, {'name': 'terminalId', 'type': 'xs:string'}, None),
        MemberSpec_('tokenMethod', 'tokenMethod', 0, 1, {'name': 'tokenMethod', 'type': 'tokenMethod', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, cardEntryMode=None, cardReference=None, customFields=None, customer=None, device=None, deviceType=None, issueNo=None, merchantReference=None, permittedTerminals=None, terminalId=None, tokenMethod=None):
        self.original_tagname_ = None
        super(secureCard, self).__init__(dateTime, hash, )
        self.cardEntryMode = cardEntryMode
        self.validate_cardEntryMode(self.cardEntryMode)
        self.cardReference = cardReference
        self.customFields = customFields
        self.customer = customer
        self.device = device
        self.deviceType = deviceType
        self.issueNo = issueNo
        self.merchantReference = merchantReference
        self.permittedTerminals = permittedTerminals
        self.terminalId = terminalId
        self.tokenMethod = tokenMethod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, secureCard)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if secureCard.subclass:
            return secureCard.subclass(*args_, **kwargs_)
        else:
            return secureCard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardEntryMode(self): return self.cardEntryMode
    def set_cardEntryMode(self, cardEntryMode): self.cardEntryMode = cardEntryMode
    def get_cardReference(self): return self.cardReference
    def set_cardReference(self, cardReference): self.cardReference = cardReference
    def get_customFields(self): return self.customFields
    def set_customFields(self, customFields): self.customFields = customFields
    def get_customer(self): return self.customer
    def set_customer(self, customer): self.customer = customer
    def get_device(self): return self.device
    def set_device(self, device): self.device = device
    def get_deviceType(self): return self.deviceType
    def set_deviceType(self, deviceType): self.deviceType = deviceType
    def get_issueNo(self): return self.issueNo
    def set_issueNo(self, issueNo): self.issueNo = issueNo
    def get_merchantReference(self): return self.merchantReference
    def set_merchantReference(self, merchantReference): self.merchantReference = merchantReference
    def get_permittedTerminals(self): return self.permittedTerminals
    def set_permittedTerminals(self, permittedTerminals): self.permittedTerminals = permittedTerminals
    def get_terminalId(self): return self.terminalId
    def set_terminalId(self, terminalId): self.terminalId = terminalId
    def get_tokenMethod(self): return self.tokenMethod
    def set_tokenMethod(self, tokenMethod): self.tokenMethod = tokenMethod
    def validate_cardEntryMode(self, value):
        # Validate type cardEntryMode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['UNKNOWN', 'UNSPECIFIED', 'KEYED', 'SWIPED', 'BARCODE', 'OCR', 'ICC', 'TRACK_ONE', 'CONTACTLESS_ICC', 'FILE', 'KEYED_FALLBACK', 'SWIPED_FALLBACK', 'E_COMMERCE', 'CONTACTLESS_MOTO', 'TRACK_ANY', 'CONTACTLESS_MSR', 'ICC_NO_CVV', 'STORED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cardEntryMode' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cardEntryMode is not None or
            self.cardReference is not None or
            self.customFields is not None or
            self.customer is not None or
            self.device is not None or
            self.deviceType is not None or
            self.issueNo is not None or
            self.merchantReference is not None or
            self.permittedTerminals is not None or
            self.terminalId is not None or
            self.tokenMethod is not None or
            super(secureCard, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='secureCard', mapping_=None):
        element = super(secureCard, self).to_etree(parent_element, name_, mapping_)
        if self.cardEntryMode is not None:
            cardEntryMode_ = self.cardEntryMode
            etree_.SubElement(element, '{}cardEntryMode').text = self.gds_format_string(cardEntryMode_)
        if self.cardReference is not None:
            cardReference_ = self.cardReference
            etree_.SubElement(element, '{}cardReference').text = self.gds_format_string(cardReference_)
        if self.customFields is not None:
            customFields_ = self.customFields
            customFields_.to_etree(element, name_='customFields', mapping_=mapping_)
        if self.customer is not None:
            customer_ = self.customer
            customer_.to_etree(element, name_='customer', mapping_=mapping_)
        if self.device is not None:
            device_ = self.device
            device_.to_etree(element, name_='device', mapping_=mapping_)
        if self.deviceType is not None:
            deviceType_ = self.deviceType
            etree_.SubElement(element, '{}deviceType').text = self.gds_format_string(deviceType_)
        if self.issueNo is not None:
            issueNo_ = self.issueNo
            etree_.SubElement(element, '{}issueNo').text = self.gds_format_string(issueNo_)
        if self.merchantReference is not None:
            merchantReference_ = self.merchantReference
            etree_.SubElement(element, '{}merchantReference').text = self.gds_format_string(merchantReference_)
        if self.permittedTerminals is not None:
            permittedTerminals_ = self.permittedTerminals
            etree_.SubElement(element, '{}permittedTerminals').text = self.gds_format_string(permittedTerminals_)
        if self.terminalId is not None:
            terminalId_ = self.terminalId
            etree_.SubElement(element, '{}terminalId').text = self.gds_format_string(terminalId_)
        if self.tokenMethod is not None:
            tokenMethod_ = self.tokenMethod
            tokenMethod_.to_etree(element, name_='tokenMethod', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='secureCard'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(secureCard, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(secureCard, self).exportLiteralChildren(outfile, level, name_)
        if self.cardEntryMode is not None:
            showIndent(outfile, level)
            outfile.write('cardEntryMode=%s,\n' % self.gds_encode(quote_python(self.cardEntryMode)))
        if self.cardReference is not None:
            showIndent(outfile, level)
            outfile.write('cardReference=%s,\n' % self.gds_encode(quote_python(self.cardReference)))
        if self.customFields is not None:
            showIndent(outfile, level)
            outfile.write('customFields=model_.customFieldsType(\n')
            self.customFields.exportLiteral(outfile, level, name_='customFields')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.customer is not None:
            showIndent(outfile, level)
            outfile.write('customer=model_.customer(\n')
            self.customer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.device is not None:
            showIndent(outfile, level)
            outfile.write('device=model_.posDevice(\n')
            self.device.exportLiteral(outfile, level, name_='device')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deviceType is not None:
            showIndent(outfile, level)
            outfile.write('deviceType=%s,\n' % self.gds_encode(quote_python(self.deviceType)))
        if self.issueNo is not None:
            showIndent(outfile, level)
            outfile.write('issueNo=%s,\n' % self.gds_encode(quote_python(self.issueNo)))
        if self.merchantReference is not None:
            showIndent(outfile, level)
            outfile.write('merchantReference=%s,\n' % self.gds_encode(quote_python(self.merchantReference)))
        if self.permittedTerminals is not None:
            showIndent(outfile, level)
            outfile.write('permittedTerminals=%s,\n' % self.gds_encode(quote_python(self.permittedTerminals)))
        if self.terminalId is not None:
            showIndent(outfile, level)
            outfile.write('terminalId=%s,\n' % self.gds_encode(quote_python(self.terminalId)))
        if self.tokenMethod is not None:
            showIndent(outfile, level)
            outfile.write('tokenMethod=model_.tokenMethod(\n')
            self.tokenMethod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(secureCard, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardEntryMode':
            cardEntryMode_ = child_.text
            cardEntryMode_ = self.gds_validate_string(cardEntryMode_, node, 'cardEntryMode')
            self.cardEntryMode = cardEntryMode_
            # validate type cardEntryMode
            self.validate_cardEntryMode(self.cardEntryMode)
        elif nodeName_ == 'cardReference':
            cardReference_ = child_.text
            cardReference_ = self.gds_validate_string(cardReference_, node, 'cardReference')
            self.cardReference = cardReference_
        elif nodeName_ == 'customFields':
            obj_ = customFieldsType.factory()
            obj_.build(child_)
            self.customFields = obj_
            obj_.original_tagname_ = 'customFields'
        elif nodeName_ == 'customer':
            obj_ = customer.factory()
            obj_.build(child_)
            self.customer = obj_
            obj_.original_tagname_ = 'customer'
        elif nodeName_ == 'device':
            obj_ = posDevice.factory()
            obj_.build(child_)
            self.device = obj_
            obj_.original_tagname_ = 'device'
        elif nodeName_ == 'deviceType':
            deviceType_ = child_.text
            deviceType_ = self.gds_validate_string(deviceType_, node, 'deviceType')
            self.deviceType = deviceType_
        elif nodeName_ == 'issueNo':
            issueNo_ = child_.text
            issueNo_ = self.gds_validate_string(issueNo_, node, 'issueNo')
            self.issueNo = issueNo_
        elif nodeName_ == 'merchantReference':
            merchantReference_ = child_.text
            merchantReference_ = self.gds_validate_string(merchantReference_, node, 'merchantReference')
            self.merchantReference = merchantReference_
        elif nodeName_ == 'permittedTerminals':
            permittedTerminals_ = child_.text
            permittedTerminals_ = self.gds_validate_string(permittedTerminals_, node, 'permittedTerminals')
            self.permittedTerminals = permittedTerminals_
        elif nodeName_ == 'terminalId':
            terminalId_ = child_.text
            terminalId_ = self.gds_validate_string(terminalId_, node, 'terminalId')
            self.terminalId = terminalId_
        elif nodeName_ == 'tokenMethod':
            obj_ = tokenMethod.factory()
            obj_.build(child_)
            self.tokenMethod = obj_
            obj_.original_tagname_ = 'tokenMethod'
        super(secureCard, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = []
        if self.cardEntryMode:
            hash_list.append(self.cardEntryMode)
        if self.customer:
            hash_list.append(self.customer.hash_string)
        if self.customFields:
            hash_list.append(self.customFields.hash_string)
        if self.cardReference:
            hash_list.append(self.cardReference)
        if self.device:
            hash_list.append(self.device.hash_string)
        if self.deviceType:
            hash_list.append(self.deviceType)
        if self.issueNo:
            hash_list.append(self.issueNo)
        hash_list.append(self.merchantReference)
        if self.permittedTerminals:
            hash_list.append(self.permittedTerminals)
        hash_list.append(self.terminalId)
        hash_list.append(self.tokenMethod.hash_string)
        hash_list.append(self.dateTime.isoformat('T', 'seconds'))
        return ':'.join(hash_list)
# end class secureCard


class customField(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('value', 'xs:string', 0, 0, {'name': 'value', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.original_tagname_ = None
        self.name = name
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customField.subclass:
            return customField.subclass(*args_, **kwargs_)
        else:
            return customField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='customField', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{}name').text = self.gds_format_string(name_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{}value').text = self.gds_format_string(value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='customField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % self.gds_encode(quote_python(self.name)))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % self.gds_encode(quote_python(self.value)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class customField


class customer(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('city', 'xs:string', 0, 1, {'name': 'city', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('country', 'xs:string', 0, 1, {'name': 'country', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('eMail', 'xs:string', 0, 1, {'name': 'eMail', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('ipAddress', 'xs:string', 0, 1, {'name': 'ipAddress', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('mobileNumber', 'xs:string', 0, 1, {'name': 'mobileNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('region', 'xs:string', 0, 1, {'name': 'region', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('signature', 'xs:string', 0, 1, {'name': 'signature', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, city=None, country=None, eMail=None, ipAddress=None, mobileNumber=None, region=None, signature=None):
        self.original_tagname_ = None
        self.city = city
        self.country = country
        self.eMail = eMail
        self.ipAddress = ipAddress
        self.mobileNumber = mobileNumber
        self.region = region
        self.signature = signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customer.subclass:
            return customer.subclass(*args_, **kwargs_)
        else:
            return customer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_eMail(self): return self.eMail
    def set_eMail(self, eMail): self.eMail = eMail
    def get_ipAddress(self): return self.ipAddress
    def set_ipAddress(self, ipAddress): self.ipAddress = ipAddress
    def get_mobileNumber(self): return self.mobileNumber
    def set_mobileNumber(self, mobileNumber): self.mobileNumber = mobileNumber
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def get_signature(self): return self.signature
    def set_signature(self, signature): self.signature = signature
    def hasContent_(self):
        if (
            self.city is not None or
            self.country is not None or
            self.eMail is not None or
            self.ipAddress is not None or
            self.mobileNumber is not None or
            self.region is not None or
            self.signature is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='customer', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.city is not None:
            city_ = self.city
            etree_.SubElement(element, '{}city').text = self.gds_format_string(city_)
        if self.country is not None:
            country_ = self.country
            etree_.SubElement(element, '{}country').text = self.gds_format_string(country_)
        if self.eMail is not None:
            eMail_ = self.eMail
            etree_.SubElement(element, '{}eMail').text = self.gds_format_string(eMail_)
        if self.ipAddress is not None:
            ipAddress_ = self.ipAddress
            etree_.SubElement(element, '{}ipAddress').text = self.gds_format_string(ipAddress_)
        if self.mobileNumber is not None:
            mobileNumber_ = self.mobileNumber
            etree_.SubElement(element, '{}mobileNumber').text = self.gds_format_string(mobileNumber_)
        if self.region is not None:
            region_ = self.region
            etree_.SubElement(element, '{}region').text = self.gds_format_string(region_)
        if self.signature is not None:
            signature_ = self.signature
            etree_.SubElement(element, '{}signature').text = self.gds_format_string(signature_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='customer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.city is not None:
            showIndent(outfile, level)
            outfile.write('city=%s,\n' % self.gds_encode(quote_python(self.city)))
        if self.country is not None:
            showIndent(outfile, level)
            outfile.write('country=%s,\n' % self.gds_encode(quote_python(self.country)))
        if self.eMail is not None:
            showIndent(outfile, level)
            outfile.write('eMail=%s,\n' % self.gds_encode(quote_python(self.eMail)))
        if self.ipAddress is not None:
            showIndent(outfile, level)
            outfile.write('ipAddress=%s,\n' % self.gds_encode(quote_python(self.ipAddress)))
        if self.mobileNumber is not None:
            showIndent(outfile, level)
            outfile.write('mobileNumber=%s,\n' % self.gds_encode(quote_python(self.mobileNumber)))
        if self.region is not None:
            showIndent(outfile, level)
            outfile.write('region=%s,\n' % self.gds_encode(quote_python(self.region)))
        if self.signature is not None:
            showIndent(outfile, level)
            outfile.write('signature=%s,\n' % self.gds_encode(quote_python(self.signature)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
        elif nodeName_ == 'eMail':
            eMail_ = child_.text
            eMail_ = self.gds_validate_string(eMail_, node, 'eMail')
            self.eMail = eMail_
        elif nodeName_ == 'ipAddress':
            ipAddress_ = child_.text
            ipAddress_ = self.gds_validate_string(ipAddress_, node, 'ipAddress')
            self.ipAddress = ipAddress_
        elif nodeName_ == 'mobileNumber':
            mobileNumber_ = child_.text
            mobileNumber_ = self.gds_validate_string(mobileNumber_, node, 'mobileNumber')
            self.mobileNumber = mobileNumber_
        elif nodeName_ == 'region':
            region_ = child_.text
            region_ = self.gds_validate_string(region_, node, 'region')
            self.region = region_
        elif nodeName_ == 'signature':
            signature_ = child_.text
            signature_ = self.gds_validate_string(signature_, node, 'signature')
            self.signature = signature_

    @property
    def hash_string(self):
        hash_list = []
        if self.city:
            hash_list.append(self.city)
        if self.country:
            hash_list.append(self.country)
        if self.eMail:
            hash_list.append(self.eMail)
        if self.ipAddress:
            hash_list.append(self.ipAddress)
        if self.mobileNumber:
            hash_list.append(self.mobileNumber)            
        if self.region:
            hash_list.append(self.region)
        if self.signature:
            hash_list.append(self.signature)
        return ':'.join(hash_list)
# end class customer


class posDevice(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('serialNumber', 'xs:string', 0, 1, {'name': 'serialNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('type_', 'xs:string', 0, 1, {'name': 'type', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, serialNumber=None, type_=None):
        self.original_tagname_ = None
        self.serialNumber = serialNumber
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, posDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if posDevice.subclass:
            return posDevice.subclass(*args_, **kwargs_)
        else:
            return posDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serialNumber(self): return self.serialNumber
    def set_serialNumber(self, serialNumber): self.serialNumber = serialNumber
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.serialNumber is not None or
            self.type_ is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='posDevice', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.serialNumber is not None:
            serialNumber_ = self.serialNumber
            etree_.SubElement(element, '{}serialNumber').text = self.gds_format_string(serialNumber_)
        if self.type_ is not None:
            type__ = self.type_
            etree_.SubElement(element, '{}type').text = self.gds_format_string(type__)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='posDevice'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.serialNumber is not None:
            showIndent(outfile, level)
            outfile.write('serialNumber=%s,\n' % self.gds_encode(quote_python(self.serialNumber)))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % self.gds_encode(quote_python(self.type_)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'serialNumber':
            serialNumber_ = child_.text
            serialNumber_ = self.gds_validate_string(serialNumber_, node, 'serialNumber')
            self.serialNumber = serialNumber_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_

    @property
    def hash_string(self):
        return ':'.join([self.serialNumber, self.type_])
# end class posDevice


class baseMethod(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseMethod.subclass:
            return baseMethod.subclass(*args_, **kwargs_)
        else:
            return baseMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='baseMethod', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='baseMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class baseMethod


class keyedSecureCard(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardCvv', 'xs:string', 0, 1, {'name': 'cardCvv', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardHolderName', 'xs:string', 0, 1, {'name': 'cardHolderName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardNumber', 'xs:string', 0, 0, {'name': 'cardNumber', 'type': 'xs:string'}, None),
        MemberSpec_('cardType', 'xs:string', 0, 1, {'name': 'cardType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('expiryDate', 'xs:string', 0, 0, {'name': 'expiryDate', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardCvv=None, cardHolderName=None, cardNumber=None, cardType=None, expiryDate=None):
        self.original_tagname_ = None
        self.cardCvv = cardCvv
        self.cardHolderName = cardHolderName
        self.cardNumber = cardNumber
        self.cardType = cardType
        self.expiryDate = expiryDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keyedSecureCard)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keyedSecureCard.subclass:
            return keyedSecureCard.subclass(*args_, **kwargs_)
        else:
            return keyedSecureCard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardCvv(self): return self.cardCvv
    def set_cardCvv(self, cardCvv): self.cardCvv = cardCvv
    def get_cardHolderName(self): return self.cardHolderName
    def set_cardHolderName(self, cardHolderName): self.cardHolderName = cardHolderName
    def get_cardNumber(self): return self.cardNumber
    def set_cardNumber(self, cardNumber): self.cardNumber = cardNumber
    def get_cardType(self): return self.cardType
    def set_cardType(self, cardType): self.cardType = cardType
    def get_expiryDate(self): return self.expiryDate
    def set_expiryDate(self, expiryDate): self.expiryDate = expiryDate
    def hasContent_(self):
        if (
            self.cardCvv is not None or
            self.cardHolderName is not None or
            self.cardNumber is not None or
            self.cardType is not None or
            self.expiryDate is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='keyedSecureCard', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cardCvv is not None:
            cardCvv_ = self.cardCvv
            etree_.SubElement(element, '{}cardCvv').text = self.gds_format_string(cardCvv_)
        if self.cardHolderName is not None:
            cardHolderName_ = self.cardHolderName
            etree_.SubElement(element, '{}cardHolderName').text = self.gds_format_string(cardHolderName_)
        if self.cardNumber is not None:
            cardNumber_ = self.cardNumber
            etree_.SubElement(element, '{}cardNumber').text = self.gds_format_string(cardNumber_)
        if self.cardType is not None:
            cardType_ = self.cardType
            etree_.SubElement(element, '{}cardType').text = self.gds_format_string(cardType_)
        if self.expiryDate is not None:
            expiryDate_ = self.expiryDate
            etree_.SubElement(element, '{}expiryDate').text = self.gds_format_string(expiryDate_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='keyedSecureCard'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardCvv is not None:
            showIndent(outfile, level)
            outfile.write('cardCvv=%s,\n' % self.gds_encode(quote_python(self.cardCvv)))
        if self.cardHolderName is not None:
            showIndent(outfile, level)
            outfile.write('cardHolderName=%s,\n' % self.gds_encode(quote_python(self.cardHolderName)))
        if self.cardNumber is not None:
            showIndent(outfile, level)
            outfile.write('cardNumber=%s,\n' % self.gds_encode(quote_python(self.cardNumber)))
        if self.cardType is not None:
            showIndent(outfile, level)
            outfile.write('cardType=%s,\n' % self.gds_encode(quote_python(self.cardType)))
        if self.expiryDate is not None:
            showIndent(outfile, level)
            outfile.write('expiryDate=%s,\n' % self.gds_encode(quote_python(self.expiryDate)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardCvv':
            cardCvv_ = child_.text
            cardCvv_ = self.gds_validate_string(cardCvv_, node, 'cardCvv')
            self.cardCvv = cardCvv_
        elif nodeName_ == 'cardHolderName':
            cardHolderName_ = child_.text
            cardHolderName_ = self.gds_validate_string(cardHolderName_, node, 'cardHolderName')
            self.cardHolderName = cardHolderName_
        elif nodeName_ == 'cardNumber':
            cardNumber_ = child_.text
            cardNumber_ = self.gds_validate_string(cardNumber_, node, 'cardNumber')
            self.cardNumber = cardNumber_
        elif nodeName_ == 'cardType':
            cardType_ = child_.text
            cardType_ = self.gds_validate_string(cardType_, node, 'cardType')
            self.cardType = cardType_
        elif nodeName_ == 'expiryDate':
            expiryDate_ = child_.text
            expiryDate_ = self.gds_validate_string(expiryDate_, node, 'expiryDate')
            self.expiryDate = expiryDate_

    @property
    def hash_string(self):
        return ':'.join([self.cardCvv, self.cardHolderName, self.cardNumber, self.cardType, self.expiryDate])
# end class keyedSecureCard


class keyedAsTrackData(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardAccount', ['cardAccount', 'xs:string'], 0, 1, {'name': 'cardAccount', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardHolderName', 'xs:string', 0, 1, {'name': 'cardHolderName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardType', 'xs:string', 0, 1, {'name': 'cardType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('encryptedData', 'xs:string', 0, 0, {'name': 'encryptedData', 'type': 'xs:string'}, None),
        MemberSpec_('firstDigitOfPan', 'xs:string', 0, 1, {'name': 'firstDigitOfPan', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('ksn', 'xs:string', 0, 1, {'name': 'ksn', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('pinDetails', 'pinDetails', 0, 1, {'name': 'pinDetails', 'type': 'pinDetails', 'minOccurs': '0'}, None),
        MemberSpec_('serial', 'xs:string', 0, 1, {'name': 'serial', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardAccount=None, cardHolderName=None, cardType=None, encryptedData=None, firstDigitOfPan=None, ksn=None, pinDetails=None, serial=None):
        self.original_tagname_ = None
        self.cardAccount = cardAccount
        self.validate_cardAccount(self.cardAccount)
        self.cardHolderName = cardHolderName
        self.cardType = cardType
        self.encryptedData = encryptedData
        self.firstDigitOfPan = firstDigitOfPan
        self.ksn = ksn
        self.pinDetails = pinDetails
        self.serial = serial
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keyedAsTrackData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keyedAsTrackData.subclass:
            return keyedAsTrackData.subclass(*args_, **kwargs_)
        else:
            return keyedAsTrackData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardAccount(self): return self.cardAccount
    def set_cardAccount(self, cardAccount): self.cardAccount = cardAccount
    def get_cardHolderName(self): return self.cardHolderName
    def set_cardHolderName(self, cardHolderName): self.cardHolderName = cardHolderName
    def get_cardType(self): return self.cardType
    def set_cardType(self, cardType): self.cardType = cardType
    def get_encryptedData(self): return self.encryptedData
    def set_encryptedData(self, encryptedData): self.encryptedData = encryptedData
    def get_firstDigitOfPan(self): return self.firstDigitOfPan
    def set_firstDigitOfPan(self, firstDigitOfPan): self.firstDigitOfPan = firstDigitOfPan
    def get_ksn(self): return self.ksn
    def set_ksn(self, ksn): self.ksn = ksn
    def get_pinDetails(self): return self.pinDetails
    def set_pinDetails(self, pinDetails): self.pinDetails = pinDetails
    def get_serial(self): return self.serial
    def set_serial(self, serial): self.serial = serial
    def validate_cardAccount(self, value):
        # Validate type cardAccount, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CASH', 'FOOD_STAMP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cardAccount' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cardAccount is not None or
            self.cardHolderName is not None or
            self.cardType is not None or
            self.encryptedData is not None or
            self.firstDigitOfPan is not None or
            self.ksn is not None or
            self.pinDetails is not None or
            self.serial is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='keyedAsTrackData', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cardAccount is not None:
            cardAccount_ = self.cardAccount
            etree_.SubElement(element, '{}cardAccount').text = self.gds_format_string(cardAccount_)
        if self.cardHolderName is not None:
            cardHolderName_ = self.cardHolderName
            etree_.SubElement(element, '{}cardHolderName').text = self.gds_format_string(cardHolderName_)
        if self.cardType is not None:
            cardType_ = self.cardType
            etree_.SubElement(element, '{}cardType').text = self.gds_format_string(cardType_)
        if self.encryptedData is not None:
            encryptedData_ = self.encryptedData
            etree_.SubElement(element, '{}encryptedData').text = self.gds_format_string(encryptedData_)
        if self.firstDigitOfPan is not None:
            firstDigitOfPan_ = self.firstDigitOfPan
            etree_.SubElement(element, '{}firstDigitOfPan').text = self.gds_format_string(firstDigitOfPan_)
        if self.ksn is not None:
            ksn_ = self.ksn
            etree_.SubElement(element, '{}ksn').text = self.gds_format_string(ksn_)
        if self.pinDetails is not None:
            pinDetails_ = self.pinDetails
            pinDetails_.to_etree(element, name_='pinDetails', mapping_=mapping_)
        if self.serial is not None:
            serial_ = self.serial
            etree_.SubElement(element, '{}serial').text = self.gds_format_string(serial_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='keyedAsTrackData'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardAccount is not None:
            showIndent(outfile, level)
            outfile.write('cardAccount=%s,\n' % self.gds_encode(quote_python(self.cardAccount)))
        if self.cardHolderName is not None:
            showIndent(outfile, level)
            outfile.write('cardHolderName=%s,\n' % self.gds_encode(quote_python(self.cardHolderName)))
        if self.cardType is not None:
            showIndent(outfile, level)
            outfile.write('cardType=%s,\n' % self.gds_encode(quote_python(self.cardType)))
        if self.encryptedData is not None:
            showIndent(outfile, level)
            outfile.write('encryptedData=%s,\n' % self.gds_encode(quote_python(self.encryptedData)))
        if self.firstDigitOfPan is not None:
            showIndent(outfile, level)
            outfile.write('firstDigitOfPan=%s,\n' % self.gds_encode(quote_python(self.firstDigitOfPan)))
        if self.ksn is not None:
            showIndent(outfile, level)
            outfile.write('ksn=%s,\n' % self.gds_encode(quote_python(self.ksn)))
        if self.pinDetails is not None:
            showIndent(outfile, level)
            outfile.write('pinDetails=model_.pinDetails(\n')
            self.pinDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serial is not None:
            showIndent(outfile, level)
            outfile.write('serial=%s,\n' % self.gds_encode(quote_python(self.serial)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardAccount':
            cardAccount_ = child_.text
            cardAccount_ = self.gds_validate_string(cardAccount_, node, 'cardAccount')
            self.cardAccount = cardAccount_
            # validate type cardAccount
            self.validate_cardAccount(self.cardAccount)
        elif nodeName_ == 'cardHolderName':
            cardHolderName_ = child_.text
            cardHolderName_ = self.gds_validate_string(cardHolderName_, node, 'cardHolderName')
            self.cardHolderName = cardHolderName_
        elif nodeName_ == 'cardType':
            cardType_ = child_.text
            cardType_ = self.gds_validate_string(cardType_, node, 'cardType')
            self.cardType = cardType_
        elif nodeName_ == 'encryptedData':
            encryptedData_ = child_.text
            encryptedData_ = self.gds_validate_string(encryptedData_, node, 'encryptedData')
            self.encryptedData = encryptedData_
        elif nodeName_ == 'firstDigitOfPan':
            firstDigitOfPan_ = child_.text
            firstDigitOfPan_ = self.gds_validate_string(firstDigitOfPan_, node, 'firstDigitOfPan')
            self.firstDigitOfPan = firstDigitOfPan_
        elif nodeName_ == 'ksn':
            ksn_ = child_.text
            ksn_ = self.gds_validate_string(ksn_, node, 'ksn')
            self.ksn = ksn_
        elif nodeName_ == 'pinDetails':
            obj_ = pinDetails.factory()
            obj_.build(child_)
            self.pinDetails = obj_
            obj_.original_tagname_ = 'pinDetails'
        elif nodeName_ == 'serial':
            serial_ = child_.text
            serial_ = self.gds_validate_string(serial_, node, 'serial')
            self.serial = serial_

    @property
    def hash_string(self):
        hash_list = []
        if self.cardAccount:
            hash_list.append(self.cardAccount)
        if self.cardHolderName:
            hash_list.append(self.cardHolderName)
        if self.cardType:
            hash_list.append(self.cardType)
        if self.encryptedData:
            hash_list.append(self.encryptedData)
        if self.firstDigitOfPan:
            hash_list.append(self.firstDigitOfPan)
        if self.ksn:
            hash_list.append(self.ksn)
        if self.pinDetails:
            hash_list.append(self.pinDetails)
        if self.serial:
            hash_list.append(self.serial)
        return ':'.join(hash_list)
# end class keyedAsTrackData


class pinDetails(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('dukptPinDetails', 'dukptPinDetails', 0, 0, {'name': 'dukptPinDetails', 'type': 'dukptPinDetails'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, dukptPinDetails=None):
        self.original_tagname_ = None
        self.dukptPinDetails = dukptPinDetails
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pinDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pinDetails.subclass:
            return pinDetails.subclass(*args_, **kwargs_)
        else:
            return pinDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dukptPinDetails(self): return self.dukptPinDetails
    def set_dukptPinDetails(self, dukptPinDetails): self.dukptPinDetails = dukptPinDetails
    def hasContent_(self):
        if (
            self.dukptPinDetails is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='pinDetails', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.dukptPinDetails is not None:
            dukptPinDetails_ = self.dukptPinDetails
            dukptPinDetails_.to_etree(element, name_='dukptPinDetails', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='pinDetails'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dukptPinDetails is not None:
            showIndent(outfile, level)
            outfile.write('dukptPinDetails=model_.dukptPinDetails(\n')
            self.dukptPinDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dukptPinDetails':
            obj_ = dukptPinDetails.factory()
            obj_.build(child_)
            self.dukptPinDetails = obj_
            obj_.original_tagname_ = 'dukptPinDetails'

    @property
    def hash_string(self):
        return ':'.join([self.dukptPinDetails.hash_string])
# end class pinDetails


class dukptPinDetails(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('pin', 'xs:string', 0, 0, {'name': 'pin', 'type': 'xs:string'}, None),
        MemberSpec_('pinKsn', 'xs:string', 0, 0, {'name': 'pinKsn', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, pin=None, pinKsn=None):
        self.original_tagname_ = None
        self.pin = pin
        self.pinKsn = pinKsn
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dukptPinDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dukptPinDetails.subclass:
            return dukptPinDetails.subclass(*args_, **kwargs_)
        else:
            return dukptPinDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pin(self): return self.pin
    def set_pin(self, pin): self.pin = pin
    def get_pinKsn(self): return self.pinKsn
    def set_pinKsn(self, pinKsn): self.pinKsn = pinKsn
    def hasContent_(self):
        if (
            self.pin is not None or
            self.pinKsn is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='dukptPinDetails', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.pin is not None:
            pin_ = self.pin
            etree_.SubElement(element, '{}pin').text = self.gds_format_string(pin_)
        if self.pinKsn is not None:
            pinKsn_ = self.pinKsn
            etree_.SubElement(element, '{}pinKsn').text = self.gds_format_string(pinKsn_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='dukptPinDetails'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.pin is not None:
            showIndent(outfile, level)
            outfile.write('pin=%s,\n' % self.gds_encode(quote_python(self.pin)))
        if self.pinKsn is not None:
            showIndent(outfile, level)
            outfile.write('pinKsn=%s,\n' % self.gds_encode(quote_python(self.pinKsn)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pin':
            pin_ = child_.text
            pin_ = self.gds_validate_string(pin_, node, 'pin')
            self.pin = pin_
        elif nodeName_ == 'pinKsn':
            pinKsn_ = child_.text
            pinKsn_ = self.gds_validate_string(pinKsn_, node, 'pinKsn')
            self.pinKsn = pinKsn_

    @property
    def hash_string(self):
        return ':'.join([self.pin, self.pinKsn])
# end class dukptPinDetails


class keyedEncrypted(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardAccount', ['cardAccount', 'xs:string'], 0, 1, {'name': 'cardAccount', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardHolderName', 'xs:string', 0, 1, {'name': 'cardHolderName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardType', 'xs:string', 0, 1, {'name': 'cardType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cvv', 'xs:string', 0, 1, {'name': 'cvv', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cvvEncrypted', 'xs:string', 0, 1, {'name': 'cvvEncrypted', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('expiryDate', 'xs:string', 0, 0, {'name': 'expiryDate', 'type': 'xs:string'}, None),
        MemberSpec_('ksn', 'xs:string', 0, 0, {'name': 'ksn', 'type': 'xs:string'}, None),
        MemberSpec_('panEncrypted', 'xs:string', 0, 0, {'name': 'panEncrypted', 'type': 'xs:string'}, None),
        MemberSpec_('panMasked', 'xs:string', 0, 0, {'name': 'panMasked', 'type': 'xs:string'}, None),
        MemberSpec_('pinDetails', 'pinDetails', 0, 1, {'name': 'pinDetails', 'type': 'pinDetails', 'minOccurs': '0'}, None),
        MemberSpec_('serial', 'xs:string', 0, 1, {'name': 'serial', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardAccount=None, cardHolderName=None, cardType=None, cvv=None, cvvEncrypted=None, expiryDate=None, ksn=None, panEncrypted=None, panMasked=None, pinDetails=None, serial=None):
        self.original_tagname_ = None
        self.cardAccount = cardAccount
        self.validate_cardAccount(self.cardAccount)
        self.cardHolderName = cardHolderName
        self.cardType = cardType
        self.cvv = cvv
        self.cvvEncrypted = cvvEncrypted
        self.expiryDate = expiryDate
        self.ksn = ksn
        self.panEncrypted = panEncrypted
        self.panMasked = panMasked
        self.pinDetails = pinDetails
        self.serial = serial
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keyedEncrypted)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keyedEncrypted.subclass:
            return keyedEncrypted.subclass(*args_, **kwargs_)
        else:
            return keyedEncrypted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardAccount(self): return self.cardAccount
    def set_cardAccount(self, cardAccount): self.cardAccount = cardAccount
    def get_cardHolderName(self): return self.cardHolderName
    def set_cardHolderName(self, cardHolderName): self.cardHolderName = cardHolderName
    def get_cardType(self): return self.cardType
    def set_cardType(self, cardType): self.cardType = cardType
    def get_cvv(self): return self.cvv
    def set_cvv(self, cvv): self.cvv = cvv
    def get_cvvEncrypted(self): return self.cvvEncrypted
    def set_cvvEncrypted(self, cvvEncrypted): self.cvvEncrypted = cvvEncrypted
    def get_expiryDate(self): return self.expiryDate
    def set_expiryDate(self, expiryDate): self.expiryDate = expiryDate
    def get_ksn(self): return self.ksn
    def set_ksn(self, ksn): self.ksn = ksn
    def get_panEncrypted(self): return self.panEncrypted
    def set_panEncrypted(self, panEncrypted): self.panEncrypted = panEncrypted
    def get_panMasked(self): return self.panMasked
    def set_panMasked(self, panMasked): self.panMasked = panMasked
    def get_pinDetails(self): return self.pinDetails
    def set_pinDetails(self, pinDetails): self.pinDetails = pinDetails
    def get_serial(self): return self.serial
    def set_serial(self, serial): self.serial = serial
    def validate_cardAccount(self, value):
        # Validate type cardAccount, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CASH', 'FOOD_STAMP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cardAccount' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cardAccount is not None or
            self.cardHolderName is not None or
            self.cardType is not None or
            self.cvv is not None or
            self.cvvEncrypted is not None or
            self.expiryDate is not None or
            self.ksn is not None or
            self.panEncrypted is not None or
            self.panMasked is not None or
            self.pinDetails is not None or
            self.serial is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='keyedEncrypted', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cardAccount is not None:
            cardAccount_ = self.cardAccount
            etree_.SubElement(element, '{}cardAccount').text = self.gds_format_string(cardAccount_)
        if self.cardHolderName is not None:
            cardHolderName_ = self.cardHolderName
            etree_.SubElement(element, '{}cardHolderName').text = self.gds_format_string(cardHolderName_)
        if self.cardType is not None:
            cardType_ = self.cardType
            etree_.SubElement(element, '{}cardType').text = self.gds_format_string(cardType_)
        if self.cvv is not None:
            cvv_ = self.cvv
            etree_.SubElement(element, '{}cvv').text = self.gds_format_string(cvv_)
        if self.cvvEncrypted is not None:
            cvvEncrypted_ = self.cvvEncrypted
            etree_.SubElement(element, '{}cvvEncrypted').text = self.gds_format_string(cvvEncrypted_)
        if self.expiryDate is not None:
            expiryDate_ = self.expiryDate
            etree_.SubElement(element, '{}expiryDate').text = self.gds_format_string(expiryDate_)
        if self.ksn is not None:
            ksn_ = self.ksn
            etree_.SubElement(element, '{}ksn').text = self.gds_format_string(ksn_)
        if self.panEncrypted is not None:
            panEncrypted_ = self.panEncrypted
            etree_.SubElement(element, '{}panEncrypted').text = self.gds_format_string(panEncrypted_)
        if self.panMasked is not None:
            panMasked_ = self.panMasked
            etree_.SubElement(element, '{}panMasked').text = self.gds_format_string(panMasked_)
        if self.pinDetails is not None:
            pinDetails_ = self.pinDetails
            pinDetails_.to_etree(element, name_='pinDetails', mapping_=mapping_)
        if self.serial is not None:
            serial_ = self.serial
            etree_.SubElement(element, '{}serial').text = self.gds_format_string(serial_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='keyedEncrypted'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardAccount is not None:
            showIndent(outfile, level)
            outfile.write('cardAccount=%s,\n' % self.gds_encode(quote_python(self.cardAccount)))
        if self.cardHolderName is not None:
            showIndent(outfile, level)
            outfile.write('cardHolderName=%s,\n' % self.gds_encode(quote_python(self.cardHolderName)))
        if self.cardType is not None:
            showIndent(outfile, level)
            outfile.write('cardType=%s,\n' % self.gds_encode(quote_python(self.cardType)))
        if self.cvv is not None:
            showIndent(outfile, level)
            outfile.write('cvv=%s,\n' % self.gds_encode(quote_python(self.cvv)))
        if self.cvvEncrypted is not None:
            showIndent(outfile, level)
            outfile.write('cvvEncrypted=%s,\n' % self.gds_encode(quote_python(self.cvvEncrypted)))
        if self.expiryDate is not None:
            showIndent(outfile, level)
            outfile.write('expiryDate=%s,\n' % self.gds_encode(quote_python(self.expiryDate)))
        if self.ksn is not None:
            showIndent(outfile, level)
            outfile.write('ksn=%s,\n' % self.gds_encode(quote_python(self.ksn)))
        if self.panEncrypted is not None:
            showIndent(outfile, level)
            outfile.write('panEncrypted=%s,\n' % self.gds_encode(quote_python(self.panEncrypted)))
        if self.panMasked is not None:
            showIndent(outfile, level)
            outfile.write('panMasked=%s,\n' % self.gds_encode(quote_python(self.panMasked)))
        if self.pinDetails is not None:
            showIndent(outfile, level)
            outfile.write('pinDetails=model_.pinDetails(\n')
            self.pinDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serial is not None:
            showIndent(outfile, level)
            outfile.write('serial=%s,\n' % self.gds_encode(quote_python(self.serial)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardAccount':
            cardAccount_ = child_.text
            cardAccount_ = self.gds_validate_string(cardAccount_, node, 'cardAccount')
            self.cardAccount = cardAccount_
            # validate type cardAccount
            self.validate_cardAccount(self.cardAccount)
        elif nodeName_ == 'cardHolderName':
            cardHolderName_ = child_.text
            cardHolderName_ = self.gds_validate_string(cardHolderName_, node, 'cardHolderName')
            self.cardHolderName = cardHolderName_
        elif nodeName_ == 'cardType':
            cardType_ = child_.text
            cardType_ = self.gds_validate_string(cardType_, node, 'cardType')
            self.cardType = cardType_
        elif nodeName_ == 'cvv':
            cvv_ = child_.text
            cvv_ = self.gds_validate_string(cvv_, node, 'cvv')
            self.cvv = cvv_
        elif nodeName_ == 'cvvEncrypted':
            cvvEncrypted_ = child_.text
            cvvEncrypted_ = self.gds_validate_string(cvvEncrypted_, node, 'cvvEncrypted')
            self.cvvEncrypted = cvvEncrypted_
        elif nodeName_ == 'expiryDate':
            expiryDate_ = child_.text
            expiryDate_ = self.gds_validate_string(expiryDate_, node, 'expiryDate')
            self.expiryDate = expiryDate_
        elif nodeName_ == 'ksn':
            ksn_ = child_.text
            ksn_ = self.gds_validate_string(ksn_, node, 'ksn')
            self.ksn = ksn_
        elif nodeName_ == 'panEncrypted':
            panEncrypted_ = child_.text
            panEncrypted_ = self.gds_validate_string(panEncrypted_, node, 'panEncrypted')
            self.panEncrypted = panEncrypted_
        elif nodeName_ == 'panMasked':
            panMasked_ = child_.text
            panMasked_ = self.gds_validate_string(panMasked_, node, 'panMasked')
            self.panMasked = panMasked_
        elif nodeName_ == 'pinDetails':
            obj_ = pinDetails.factory()
            obj_.build(child_)
            self.pinDetails = obj_
            obj_.original_tagname_ = 'pinDetails'
        elif nodeName_ == 'serial':
            serial_ = child_.text
            serial_ = self.gds_validate_string(serial_, node, 'serial')
            self.serial = serial_

    @property
    def hash_string(self):
        hash_list = []
        if self.cardHolderName:
            hash_list.append(self.cardHolderName)
        if self.cardType:
            hash_list.append(self.cardType)
        if self.cvv:
            hash_list.append(self.cvv)
        hash_list.append(self.expiryDate)
        hash_list.append(self.ksn)
        hash_list.append(self.panEncrypted)
        hash_list.append(self.panMasked)
        if self.pinDetails:
            hash_list.append(self.pinDetails)
        if self.serial:
            hash_list.append(self.serial)
        return ':'.join(hash_list)
# end class keyedEncrypted


class trackData(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardAccount', ['cardAccount', 'xs:string'], 0, 1, {'name': 'cardAccount', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardHolderName', 'xs:string', 0, 1, {'name': 'cardHolderName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardType', 'xs:string', 0, 1, {'name': 'cardType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('encryptedData', 'xs:string', 0, 0, {'name': 'encryptedData', 'type': 'xs:string'}, None),
        MemberSpec_('fallback', 'xs:boolean', 0, 1, {'name': 'fallback', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('fallbackReason', ['fallbackReason', 'xs:string'], 0, 1, {'name': 'fallbackReason', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('firstDigitOfPan', 'xs:string', 0, 1, {'name': 'firstDigitOfPan', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('ksn', 'xs:string', 0, 0, {'name': 'ksn', 'type': 'xs:string'}, None),
        MemberSpec_('pinDetails', 'pinDetails', 0, 1, {'name': 'pinDetails', 'type': 'pinDetails', 'minOccurs': '0'}, None),
        MemberSpec_('serial', 'xs:string', 0, 1, {'name': 'serial', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardAccount=None, cardHolderName=None, cardType=None, encryptedData=None, fallback=None, fallbackReason=None, firstDigitOfPan=None, ksn=None, pinDetails=None, serial=None, extensiontype_=None):
        self.original_tagname_ = None
        self.cardAccount = cardAccount
        self.validate_cardAccount(self.cardAccount)
        self.cardHolderName = cardHolderName
        self.cardType = cardType
        self.encryptedData = encryptedData
        self.fallback = fallback
        self.fallbackReason = fallbackReason
        self.validate_fallbackReason(self.fallbackReason)
        self.firstDigitOfPan = firstDigitOfPan
        self.ksn = ksn
        self.pinDetails = pinDetails
        self.serial = serial
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackData.subclass:
            return trackData.subclass(*args_, **kwargs_)
        else:
            return trackData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardAccount(self): return self.cardAccount
    def set_cardAccount(self, cardAccount): self.cardAccount = cardAccount
    def get_cardHolderName(self): return self.cardHolderName
    def set_cardHolderName(self, cardHolderName): self.cardHolderName = cardHolderName
    def get_cardType(self): return self.cardType
    def set_cardType(self, cardType): self.cardType = cardType
    def get_encryptedData(self): return self.encryptedData
    def set_encryptedData(self, encryptedData): self.encryptedData = encryptedData
    def get_fallback(self): return self.fallback
    def set_fallback(self, fallback): self.fallback = fallback
    def get_fallbackReason(self): return self.fallbackReason
    def set_fallbackReason(self, fallbackReason): self.fallbackReason = fallbackReason
    def get_firstDigitOfPan(self): return self.firstDigitOfPan
    def set_firstDigitOfPan(self, firstDigitOfPan): self.firstDigitOfPan = firstDigitOfPan
    def get_ksn(self): return self.ksn
    def set_ksn(self, ksn): self.ksn = ksn
    def get_pinDetails(self): return self.pinDetails
    def set_pinDetails(self, pinDetails): self.pinDetails = pinDetails
    def get_serial(self): return self.serial
    def set_serial(self, serial): self.serial = serial
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cardAccount(self, value):
        # Validate type cardAccount, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CASH', 'FOOD_STAMP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cardAccount' % {"value" : value.encode("utf-8")} )
    def validate_fallbackReason(self, value):
        # Validate type fallbackReason, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['TECHNICAL', 'EMPTY_CANDIDATE_LIST']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on fallbackReason' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cardAccount is not None or
            self.cardHolderName is not None or
            self.cardType is not None or
            self.encryptedData is not None or
            self.fallback is not None or
            self.fallbackReason is not None or
            self.firstDigitOfPan is not None or
            self.ksn is not None or
            self.pinDetails is not None or
            self.serial is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='trackData', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.cardAccount is not None:
            cardAccount_ = self.cardAccount
            etree_.SubElement(element, '{}cardAccount').text = self.gds_format_string(cardAccount_)
        if self.cardHolderName is not None:
            cardHolderName_ = self.cardHolderName
            etree_.SubElement(element, '{}cardHolderName').text = self.gds_format_string(cardHolderName_)
        if self.cardType is not None:
            cardType_ = self.cardType
            etree_.SubElement(element, '{}cardType').text = self.gds_format_string(cardType_)
        if self.encryptedData is not None:
            encryptedData_ = self.encryptedData
            etree_.SubElement(element, '{}encryptedData').text = self.gds_format_string(encryptedData_)
        if self.fallback is not None:
            fallback_ = self.fallback
            etree_.SubElement(element, '{}fallback').text = self.gds_format_boolean(fallback_)
        if self.fallbackReason is not None:
            fallbackReason_ = self.fallbackReason
            etree_.SubElement(element, '{}fallbackReason').text = self.gds_format_string(fallbackReason_)
        if self.firstDigitOfPan is not None:
            firstDigitOfPan_ = self.firstDigitOfPan
            etree_.SubElement(element, '{}firstDigitOfPan').text = self.gds_format_string(firstDigitOfPan_)
        if self.ksn is not None:
            ksn_ = self.ksn
            etree_.SubElement(element, '{}ksn').text = self.gds_format_string(ksn_)
        if self.pinDetails is not None:
            pinDetails_ = self.pinDetails
            pinDetails_.to_etree(element, name_='pinDetails', mapping_=mapping_)
        if self.serial is not None:
            serial_ = self.serial
            etree_.SubElement(element, '{}serial').text = self.gds_format_string(serial_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='trackData'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardAccount is not None:
            showIndent(outfile, level)
            outfile.write('cardAccount=%s,\n' % self.gds_encode(quote_python(self.cardAccount)))
        if self.cardHolderName is not None:
            showIndent(outfile, level)
            outfile.write('cardHolderName=%s,\n' % self.gds_encode(quote_python(self.cardHolderName)))
        if self.cardType is not None:
            showIndent(outfile, level)
            outfile.write('cardType=%s,\n' % self.gds_encode(quote_python(self.cardType)))
        if self.encryptedData is not None:
            showIndent(outfile, level)
            outfile.write('encryptedData=%s,\n' % self.gds_encode(quote_python(self.encryptedData)))
        if self.fallback is not None:
            showIndent(outfile, level)
            outfile.write('fallback=%s,\n' % self.fallback)
        if self.fallbackReason is not None:
            showIndent(outfile, level)
            outfile.write('fallbackReason=%s,\n' % self.gds_encode(quote_python(self.fallbackReason)))
        if self.firstDigitOfPan is not None:
            showIndent(outfile, level)
            outfile.write('firstDigitOfPan=%s,\n' % self.gds_encode(quote_python(self.firstDigitOfPan)))
        if self.ksn is not None:
            showIndent(outfile, level)
            outfile.write('ksn=%s,\n' % self.gds_encode(quote_python(self.ksn)))
        if self.pinDetails is not None:
            showIndent(outfile, level)
            outfile.write('pinDetails=model_.pinDetails(\n')
            self.pinDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serial is not None:
            showIndent(outfile, level)
            outfile.write('serial=%s,\n' % self.gds_encode(quote_python(self.serial)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardAccount':
            cardAccount_ = child_.text
            cardAccount_ = self.gds_validate_string(cardAccount_, node, 'cardAccount')
            self.cardAccount = cardAccount_
            # validate type cardAccount
            self.validate_cardAccount(self.cardAccount)
        elif nodeName_ == 'cardHolderName':
            cardHolderName_ = child_.text
            cardHolderName_ = self.gds_validate_string(cardHolderName_, node, 'cardHolderName')
            self.cardHolderName = cardHolderName_
        elif nodeName_ == 'cardType':
            cardType_ = child_.text
            cardType_ = self.gds_validate_string(cardType_, node, 'cardType')
            self.cardType = cardType_
        elif nodeName_ == 'encryptedData':
            encryptedData_ = child_.text
            encryptedData_ = self.gds_validate_string(encryptedData_, node, 'encryptedData')
            self.encryptedData = encryptedData_
        elif nodeName_ == 'fallback':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fallback')
            self.fallback = ival_
        elif nodeName_ == 'fallbackReason':
            fallbackReason_ = child_.text
            fallbackReason_ = self.gds_validate_string(fallbackReason_, node, 'fallbackReason')
            self.fallbackReason = fallbackReason_
            # validate type fallbackReason
            self.validate_fallbackReason(self.fallbackReason)
        elif nodeName_ == 'firstDigitOfPan':
            firstDigitOfPan_ = child_.text
            firstDigitOfPan_ = self.gds_validate_string(firstDigitOfPan_, node, 'firstDigitOfPan')
            self.firstDigitOfPan = firstDigitOfPan_
        elif nodeName_ == 'ksn':
            ksn_ = child_.text
            ksn_ = self.gds_validate_string(ksn_, node, 'ksn')
            self.ksn = ksn_
        elif nodeName_ == 'pinDetails':
            obj_ = pinDetails.factory()
            obj_.build(child_)
            self.pinDetails = obj_
            obj_.original_tagname_ = 'pinDetails'
        elif nodeName_ == 'serial':
            serial_ = child_.text
            serial_ = self.gds_validate_string(serial_, node, 'serial')
            self.serial = serial_

    @property
    def hash_string(self):
        hash_list = []
        if self.cardAccount:
            hash_list.append(self.cardAccount)
        if self.cardType:
            hash_list.append(self.cardType)
        hash_list.append(self.encryptedData)
        if self.fallback:
            hash_list.append(self.fallback)
        hash_list.append(self.ksn)
        if self.pinDetails:
            hash_list.append(self.pinDetails.hash_string)
        return ':'.join(hash_list)
# end class trackData


class emv(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardType', 'xs:string', 0, 1, {'name': 'cardType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('contactless', 'xs:boolean', 0, 1, {'name': 'contactless', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('emvTags', 'emvTag', 1, 0, {'name': 'emvTags', 'type': 'emvTag', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('firstDigitOfPan', 'xs:string', 0, 1, {'name': 'firstDigitOfPan', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('ksn', 'xs:string', 0, 0, {'name': 'ksn', 'type': 'xs:string'}, None),
        MemberSpec_('serial', 'xs:string', 0, 1, {'name': 'serial', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardType=None, contactless=None, emvTags=None, firstDigitOfPan=None, ksn=None, serial=None):
        self.original_tagname_ = None
        self.cardType = cardType
        self.contactless = contactless
        if emvTags is None:
            self.emvTags = []
        else:
            self.emvTags = emvTags
        self.firstDigitOfPan = firstDigitOfPan
        self.ksn = ksn
        self.serial = serial
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emv)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emv.subclass:
            return emv.subclass(*args_, **kwargs_)
        else:
            return emv(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardType(self): return self.cardType
    def set_cardType(self, cardType): self.cardType = cardType
    def get_contactless(self): return self.contactless
    def set_contactless(self, contactless): self.contactless = contactless
    def get_emvTags(self): return self.emvTags
    def set_emvTags(self, emvTags): self.emvTags = emvTags
    def add_emvTags(self, value): self.emvTags.append(value)
    def insert_emvTags_at(self, index, value): self.emvTags.insert(index, value)
    def replace_emvTags_at(self, index, value): self.emvTags[index] = value
    def get_firstDigitOfPan(self): return self.firstDigitOfPan
    def set_firstDigitOfPan(self, firstDigitOfPan): self.firstDigitOfPan = firstDigitOfPan
    def get_ksn(self): return self.ksn
    def set_ksn(self, ksn): self.ksn = ksn
    def get_serial(self): return self.serial
    def set_serial(self, serial): self.serial = serial
    def hasContent_(self):
        if (
            self.cardType is not None or
            self.contactless is not None or
            self.emvTags or
            self.firstDigitOfPan is not None or
            self.ksn is not None or
            self.serial is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='emv', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cardType is not None:
            cardType_ = self.cardType
            etree_.SubElement(element, '{}cardType').text = self.gds_format_string(cardType_)
        if self.contactless is not None:
            contactless_ = self.contactless
            etree_.SubElement(element, '{}contactless').text = self.gds_format_boolean(contactless_)
        for emvTags_ in self.emvTags:
            emvTags_.to_etree(element, name_='emvTags', mapping_=mapping_)
        if self.firstDigitOfPan is not None:
            firstDigitOfPan_ = self.firstDigitOfPan
            etree_.SubElement(element, '{}firstDigitOfPan').text = self.gds_format_string(firstDigitOfPan_)
        if self.ksn is not None:
            ksn_ = self.ksn
            etree_.SubElement(element, '{}ksn').text = self.gds_format_string(ksn_)
        if self.serial is not None:
            serial_ = self.serial
            etree_.SubElement(element, '{}serial').text = self.gds_format_string(serial_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='emv'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardType is not None:
            showIndent(outfile, level)
            outfile.write('cardType=%s,\n' % self.gds_encode(quote_python(self.cardType)))
        if self.contactless is not None:
            showIndent(outfile, level)
            outfile.write('contactless=%s,\n' % self.contactless)
        showIndent(outfile, level)
        outfile.write('emvTags=[\n')
        level += 1
        for emvTags_ in self.emvTags:
            showIndent(outfile, level)
            outfile.write('model_.emvTag(\n')
            emvTags_.exportLiteral(outfile, level, name_='emvTag')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.firstDigitOfPan is not None:
            showIndent(outfile, level)
            outfile.write('firstDigitOfPan=%s,\n' % self.gds_encode(quote_python(self.firstDigitOfPan)))
        if self.ksn is not None:
            showIndent(outfile, level)
            outfile.write('ksn=%s,\n' % self.gds_encode(quote_python(self.ksn)))
        if self.serial is not None:
            showIndent(outfile, level)
            outfile.write('serial=%s,\n' % self.gds_encode(quote_python(self.serial)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardType':
            cardType_ = child_.text
            cardType_ = self.gds_validate_string(cardType_, node, 'cardType')
            self.cardType = cardType_
        elif nodeName_ == 'contactless':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'contactless')
            self.contactless = ival_
        elif nodeName_ == 'emvTags':
            obj_ = emvTag.factory()
            obj_.build(child_)
            self.emvTags.append(obj_)
            obj_.original_tagname_ = 'emvTags'
        elif nodeName_ == 'firstDigitOfPan':
            firstDigitOfPan_ = child_.text
            firstDigitOfPan_ = self.gds_validate_string(firstDigitOfPan_, node, 'firstDigitOfPan')
            self.firstDigitOfPan = firstDigitOfPan_
        elif nodeName_ == 'ksn':
            ksn_ = child_.text
            ksn_ = self.gds_validate_string(ksn_, node, 'ksn')
            self.ksn = ksn_
        elif nodeName_ == 'serial':
            serial_ = child_.text
            serial_ = self.gds_validate_string(serial_, node, 'serial')
            self.serial = serial_
# end class emv


class emvTag(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('decimal', 'xs:int', 0, 0, {'name': 'decimal', 'type': 'xs:int'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'name': 'description', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('hex', 'xs:string', 0, 1, {'name': 'hex', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('value', 'xs:string', 0, 1, {'name': 'value', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, decimal=None, description=None, hex=None, value=None):
        self.original_tagname_ = None
        self.decimal = decimal
        self.description = description
        self.hex = hex
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emvTag)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emvTag.subclass:
            return emvTag.subclass(*args_, **kwargs_)
        else:
            return emvTag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_decimal(self): return self.decimal
    def set_decimal(self, decimal): self.decimal = decimal
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_hex(self): return self.hex
    def set_hex(self, hex): self.hex = hex
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.decimal is not None or
            self.description is not None or
            self.hex is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='emvTag', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.decimal is not None:
            decimal_ = self.decimal
            etree_.SubElement(element, '{}decimal').text = self.gds_format_integer(decimal_)
        if self.description is not None:
            description_ = self.description
            etree_.SubElement(element, '{}description').text = self.gds_format_string(description_)
        if self.hex is not None:
            hex_ = self.hex
            etree_.SubElement(element, '{}hex').text = self.gds_format_string(hex_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{}value').text = self.gds_format_string(value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='emvTag'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.decimal is not None:
            showIndent(outfile, level)
            outfile.write('decimal=%d,\n' % self.decimal)
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % self.gds_encode(quote_python(self.description)))
        if self.hex is not None:
            showIndent(outfile, level)
            outfile.write('hex=%s,\n' % self.gds_encode(quote_python(self.hex)))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % self.gds_encode(quote_python(self.value)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'decimal' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'decimal')
            self.decimal = ival_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'hex':
            hex_ = child_.text
            hex_ = self.gds_validate_string(hex_, node, 'hex')
            self.hex = hex_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class emvTag


class emvtlv(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardType', 'xs:string', 0, 1, {'name': 'cardType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('contactless', 'xs:boolean', 0, 1, {'name': 'contactless', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('firstDigitOfPan', 'xs:string', 0, 1, {'name': 'firstDigitOfPan', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('ksn', 'xs:string', 0, 1, {'name': 'ksn', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('serial', 'xs:string', 0, 1, {'name': 'serial', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('tlvString', 'xs:string', 0, 0, {'name': 'tlvString', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardType=None, contactless=None, firstDigitOfPan=None, ksn=None, serial=None, tlvString=None):
        self.original_tagname_ = None
        self.cardType = cardType
        self.contactless = contactless
        self.firstDigitOfPan = firstDigitOfPan
        self.ksn = ksn
        self.serial = serial
        self.tlvString = tlvString
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emvtlv)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emvtlv.subclass:
            return emvtlv.subclass(*args_, **kwargs_)
        else:
            return emvtlv(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardType(self): return self.cardType
    def set_cardType(self, cardType): self.cardType = cardType
    def get_contactless(self): return self.contactless
    def set_contactless(self, contactless): self.contactless = contactless
    def get_firstDigitOfPan(self): return self.firstDigitOfPan
    def set_firstDigitOfPan(self, firstDigitOfPan): self.firstDigitOfPan = firstDigitOfPan
    def get_ksn(self): return self.ksn
    def set_ksn(self, ksn): self.ksn = ksn
    def get_serial(self): return self.serial
    def set_serial(self, serial): self.serial = serial
    def get_tlvString(self): return self.tlvString
    def set_tlvString(self, tlvString): self.tlvString = tlvString
    def hasContent_(self):
        if (
            self.cardType is not None or
            self.contactless is not None or
            self.firstDigitOfPan is not None or
            self.ksn is not None or
            self.serial is not None or
            self.tlvString is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='emvtlv', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cardType is not None:
            cardType_ = self.cardType
            etree_.SubElement(element, '{}cardType').text = self.gds_format_string(cardType_)
        if self.contactless is not None:
            contactless_ = self.contactless
            etree_.SubElement(element, '{}contactless').text = self.gds_format_boolean(contactless_)
        if self.firstDigitOfPan is not None:
            firstDigitOfPan_ = self.firstDigitOfPan
            etree_.SubElement(element, '{}firstDigitOfPan').text = self.gds_format_string(firstDigitOfPan_)
        if self.ksn is not None:
            ksn_ = self.ksn
            etree_.SubElement(element, '{}ksn').text = self.gds_format_string(ksn_)
        if self.serial is not None:
            serial_ = self.serial
            etree_.SubElement(element, '{}serial').text = self.gds_format_string(serial_)
        if self.tlvString is not None:
            tlvString_ = self.tlvString
            etree_.SubElement(element, '{}tlvString').text = self.gds_format_string(tlvString_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='emvtlv'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardType is not None:
            showIndent(outfile, level)
            outfile.write('cardType=%s,\n' % self.gds_encode(quote_python(self.cardType)))
        if self.contactless is not None:
            showIndent(outfile, level)
            outfile.write('contactless=%s,\n' % self.contactless)
        if self.firstDigitOfPan is not None:
            showIndent(outfile, level)
            outfile.write('firstDigitOfPan=%s,\n' % self.gds_encode(quote_python(self.firstDigitOfPan)))
        if self.ksn is not None:
            showIndent(outfile, level)
            outfile.write('ksn=%s,\n' % self.gds_encode(quote_python(self.ksn)))
        if self.serial is not None:
            showIndent(outfile, level)
            outfile.write('serial=%s,\n' % self.gds_encode(quote_python(self.serial)))
        if self.tlvString is not None:
            showIndent(outfile, level)
            outfile.write('tlvString=%s,\n' % self.gds_encode(quote_python(self.tlvString)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardType':
            cardType_ = child_.text
            cardType_ = self.gds_validate_string(cardType_, node, 'cardType')
            self.cardType = cardType_
        elif nodeName_ == 'contactless':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'contactless')
            self.contactless = ival_
        elif nodeName_ == 'firstDigitOfPan':
            firstDigitOfPan_ = child_.text
            firstDigitOfPan_ = self.gds_validate_string(firstDigitOfPan_, node, 'firstDigitOfPan')
            self.firstDigitOfPan = firstDigitOfPan_
        elif nodeName_ == 'ksn':
            ksn_ = child_.text
            ksn_ = self.gds_validate_string(ksn_, node, 'ksn')
            self.ksn = ksn_
        elif nodeName_ == 'serial':
            serial_ = child_.text
            serial_ = self.gds_validate_string(serial_, node, 'serial')
            self.serial = serial_
        elif nodeName_ == 'tlvString':
            tlvString_ = child_.text
            tlvString_ = self.gds_validate_string(tlvString_, node, 'tlvString')
            self.tlvString = tlvString_

    @property
    def hash_string(self):
        hash_list = []
        if self.cardType:
            hash_list.append(self.cardType)
        if self.contactless:
            hash_list.append(self.contactless)
        if self.ksn:
            hash_list.append(self.ksn)
        hash_list.append(self.tlvString)
        return ':'.join(hash_list)
# end class emvtlv


class hash(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('messageDigestAlgorithm', ['messageDigestAlgorithm', 'xs:string'], 0, 0, {'name': 'messageDigestAlgorithm', 'type': 'xs:string'}, None),
        MemberSpec_('digest', 'xs:string', 0, 0, {'name': 'digest', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, messageDigestAlgorithm=None, digest=None):
        self.original_tagname_ = None
        self.messageDigestAlgorithm = messageDigestAlgorithm
        self.validate_messageDigestAlgorithm(self.messageDigestAlgorithm)
        self.digest = digest
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hash)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hash.subclass:
            return hash.subclass(*args_, **kwargs_)
        else:
            return hash(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_messageDigestAlgorithm(self): return self.messageDigestAlgorithm
    def set_messageDigestAlgorithm(self, messageDigestAlgorithm): self.messageDigestAlgorithm = messageDigestAlgorithm
    def get_digest(self): return self.digest
    def set_digest(self, digest): self.digest = digest
    def validate_messageDigestAlgorithm(self, value):
        # Validate type messageDigestAlgorithm, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SHA_256', 'SHA_384', 'SHA_512']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on messageDigestAlgorithm' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.messageDigestAlgorithm is not None or
            self.digest is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='hash', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.messageDigestAlgorithm is not None:
            messageDigestAlgorithm_ = self.messageDigestAlgorithm
            etree_.SubElement(element, '{}messageDigestAlgorithm').text = self.gds_format_string(messageDigestAlgorithm_)
        if self.digest is not None:
            digest_ = self.digest
            etree_.SubElement(element, '{}digest').text = self.gds_format_string(digest_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='hash'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.messageDigestAlgorithm is not None:
            showIndent(outfile, level)
            outfile.write('messageDigestAlgorithm=%s,\n' % self.gds_encode(quote_python(self.messageDigestAlgorithm)))
        if self.digest is not None:
            showIndent(outfile, level)
            outfile.write('digest=%s,\n' % self.gds_encode(quote_python(self.digest)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'messageDigestAlgorithm':
            messageDigestAlgorithm_ = child_.text
            messageDigestAlgorithm_ = self.gds_validate_string(messageDigestAlgorithm_, node, 'messageDigestAlgorithm')
            self.messageDigestAlgorithm = messageDigestAlgorithm_
            # validate type messageDigestAlgorithm
            self.validate_messageDigestAlgorithm(self.messageDigestAlgorithm)
        elif nodeName_ == 'digest':
            digest_ = child_.text
            digest_ = self.gds_validate_string(digest_, node, 'digest')
            self.digest = digest_
# end class hash


class standardKey(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('key', 'xs:string', 0, 1, {'name': 'key', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('validUntil', 'xs:dateTime', 0, 1, {'name': 'validUntil', 'type': 'xs:dateTime', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, key=None, validUntil=None, extensiontype_=None):
        self.original_tagname_ = None
        self.key = key
        if isinstance(validUntil, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(validUntil, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = validUntil
        self.validUntil = initvalue_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, standardKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if standardKey.subclass:
            return standardKey.subclass(*args_, **kwargs_)
        else:
            return standardKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_validUntil(self): return self.validUntil
    def set_validUntil(self, validUntil): self.validUntil = validUntil
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.key is not None or
            self.validUntil is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='standardKey', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.key is not None:
            key_ = self.key
            etree_.SubElement(element, '{}key').text = self.gds_format_string(key_)
        if self.validUntil is not None:
            validUntil_ = self.validUntil
            etree_.SubElement(element, '{}validUntil').text = self.gds_format_datetime(validUntil_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='standardKey'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % self.gds_encode(quote_python(self.key)))
        if self.validUntil is not None:
            showIndent(outfile, level)
            outfile.write('validUntil=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.validUntil, input_name='validUntil'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'key':
            key_ = child_.text
            key_ = self.gds_validate_string(key_, node, 'key')
            self.key = key_
        elif nodeName_ == 'validUntil':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.validUntil = dval_
# end class standardKey


class terminalConfiguration(protectedMethod):
    member_data_items_ = [
        MemberSpec_('allowCardholderSignatureBypass', 'xs:boolean', 0, 0, {'name': 'allowCardholderSignatureBypass', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowKeyed', 'xs:boolean', 0, 0, {'name': 'allowKeyed', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowMsrFallback', 'xs:boolean', 0, 0, {'name': 'allowMsrFallback', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowSurcharges', 'xs:boolean', 0, 0, {'name': 'allowSurcharges', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowSurchargesForMobile', 'xs:boolean', 0, 1, {'name': 'allowSurchargesForMobile', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowSurchargesForVT', 'xs:boolean', 0, 1, {'name': 'allowSurchargesForVT', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('allowTax', 'xs:boolean', 0, 0, {'name': 'allowTax', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowTip', 'xs:boolean', 0, 0, {'name': 'allowTip', 'type': 'xs:boolean'}, None),
        MemberSpec_('allowUnreferenced', 'xs:boolean', 0, 0, {'name': 'allowUnreferenced', 'type': 'xs:boolean'}, None),
        MemberSpec_('applications', 'applicationsType', 0, 1, {'name': 'applications', 'minOccurs': '0', 'type': 'applicationsType'}, None),
        MemberSpec_('avsCompulsory', 'xs:boolean', 0, 0, {'name': 'avsCompulsory', 'type': 'xs:boolean'}, None),
        MemberSpec_('avsEnabled', 'xs:boolean', 0, 0, {'name': 'avsEnabled', 'type': 'xs:boolean'}, None),
        MemberSpec_('caCertificates', 'caCertificatesType', 0, 1, {'name': 'caCertificates', 'minOccurs': '0', 'type': 'caCertificatesType'}, None),
        MemberSpec_('currencies', 'currenciesType', 0, 1, {'name': 'currencies', 'minOccurs': '0', 'type': 'currenciesType'}, None),
        MemberSpec_('emvTags', 'emvTagsType', 0, 1, {'name': 'emvTags', 'minOccurs': '0', 'type': 'emvTagsType'}, None),
        MemberSpec_('enableAutomaticSettle', 'xs:boolean', 0, 0, {'name': 'enableAutomaticSettle', 'type': 'xs:boolean'}, None),
        MemberSpec_('enableCardHolderReceipt', 'xs:boolean', 0, 0, {'name': 'enableCardHolderReceipt', 'type': 'xs:boolean'}, None),
        MemberSpec_('forceSecureCardValidation', 'xs:boolean', 0, 1, {'name': 'forceSecureCardValidation', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('merchantDetails', 'merchantDetails', 0, 0, {'name': 'merchantDetails', 'type': 'merchantDetails'}, None),
        MemberSpec_('revokedCaCertificates', 'revokedCaCertificatesType', 0, 1, {'name': 'revokedCaCertificates', 'minOccurs': '0', 'type': 'revokedCaCertificatesType'}, None),
        MemberSpec_('surchargePercentage', 'xs:double', 0, 1, {'name': 'surchargePercentage', 'type': 'xs:double', 'minOccurs': '0'}, None),
        MemberSpec_('terminalTaxes', 'terminalTaxesType', 0, 1, {'name': 'terminalTaxes', 'minOccurs': '0', 'type': 'terminalTaxesType'}, None),
        MemberSpec_('terminalTips', 'terminalTipsType', 0, 1, {'name': 'terminalTips', 'minOccurs': '0', 'type': 'terminalTipsType'}, None),
        MemberSpec_('validateSecureCardSecurity', 'xs:boolean', 0, 1, {'name': 'validateSecureCardSecurity', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, allowCardholderSignatureBypass=None, allowKeyed=None, allowMsrFallback=None, allowSurcharges=None, allowSurchargesForMobile=None, allowSurchargesForVT=None, allowTax=None, allowTip=None, allowUnreferenced=None, applications=None, avsCompulsory=None, avsEnabled=None, caCertificates=None, currencies=None, emvTags=None, enableAutomaticSettle=None, enableCardHolderReceipt=None, forceSecureCardValidation=None, merchantDetails=None, revokedCaCertificates=None, surchargePercentage=None, terminalTaxes=None, terminalTips=None, validateSecureCardSecurity=None):
        self.original_tagname_ = None
        super(terminalConfiguration, self).__init__(dateTime, hash, )
        self.allowCardholderSignatureBypass = allowCardholderSignatureBypass
        self.allowKeyed = allowKeyed
        self.allowMsrFallback = allowMsrFallback
        self.allowSurcharges = allowSurcharges
        self.allowSurchargesForMobile = allowSurchargesForMobile
        self.allowSurchargesForVT = allowSurchargesForVT
        self.allowTax = allowTax
        self.allowTip = allowTip
        self.allowUnreferenced = allowUnreferenced
        self.applications = applications
        self.avsCompulsory = avsCompulsory
        self.avsEnabled = avsEnabled
        self.caCertificates = caCertificates
        self.currencies = currencies
        self.emvTags = emvTags
        self.enableAutomaticSettle = enableAutomaticSettle
        self.enableCardHolderReceipt = enableCardHolderReceipt
        self.forceSecureCardValidation = forceSecureCardValidation
        self.merchantDetails = merchantDetails
        self.revokedCaCertificates = revokedCaCertificates
        self.surchargePercentage = surchargePercentage
        self.terminalTaxes = terminalTaxes
        self.terminalTips = terminalTips
        self.validateSecureCardSecurity = validateSecureCardSecurity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalConfiguration.subclass:
            return terminalConfiguration.subclass(*args_, **kwargs_)
        else:
            return terminalConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allowCardholderSignatureBypass(self): return self.allowCardholderSignatureBypass
    def set_allowCardholderSignatureBypass(self, allowCardholderSignatureBypass): self.allowCardholderSignatureBypass = allowCardholderSignatureBypass
    def get_allowKeyed(self): return self.allowKeyed
    def set_allowKeyed(self, allowKeyed): self.allowKeyed = allowKeyed
    def get_allowMsrFallback(self): return self.allowMsrFallback
    def set_allowMsrFallback(self, allowMsrFallback): self.allowMsrFallback = allowMsrFallback
    def get_allowSurcharges(self): return self.allowSurcharges
    def set_allowSurcharges(self, allowSurcharges): self.allowSurcharges = allowSurcharges
    def get_allowSurchargesForMobile(self): return self.allowSurchargesForMobile
    def set_allowSurchargesForMobile(self, allowSurchargesForMobile): self.allowSurchargesForMobile = allowSurchargesForMobile
    def get_allowSurchargesForVT(self): return self.allowSurchargesForVT
    def set_allowSurchargesForVT(self, allowSurchargesForVT): self.allowSurchargesForVT = allowSurchargesForVT
    def get_allowTax(self): return self.allowTax
    def set_allowTax(self, allowTax): self.allowTax = allowTax
    def get_allowTip(self): return self.allowTip
    def set_allowTip(self, allowTip): self.allowTip = allowTip
    def get_allowUnreferenced(self): return self.allowUnreferenced
    def set_allowUnreferenced(self, allowUnreferenced): self.allowUnreferenced = allowUnreferenced
    def get_applications(self): return self.applications
    def set_applications(self, applications): self.applications = applications
    def get_avsCompulsory(self): return self.avsCompulsory
    def set_avsCompulsory(self, avsCompulsory): self.avsCompulsory = avsCompulsory
    def get_avsEnabled(self): return self.avsEnabled
    def set_avsEnabled(self, avsEnabled): self.avsEnabled = avsEnabled
    def get_caCertificates(self): return self.caCertificates
    def set_caCertificates(self, caCertificates): self.caCertificates = caCertificates
    def get_currencies(self): return self.currencies
    def set_currencies(self, currencies): self.currencies = currencies
    def get_emvTags(self): return self.emvTags
    def set_emvTags(self, emvTags): self.emvTags = emvTags
    def get_enableAutomaticSettle(self): return self.enableAutomaticSettle
    def set_enableAutomaticSettle(self, enableAutomaticSettle): self.enableAutomaticSettle = enableAutomaticSettle
    def get_enableCardHolderReceipt(self): return self.enableCardHolderReceipt
    def set_enableCardHolderReceipt(self, enableCardHolderReceipt): self.enableCardHolderReceipt = enableCardHolderReceipt
    def get_forceSecureCardValidation(self): return self.forceSecureCardValidation
    def set_forceSecureCardValidation(self, forceSecureCardValidation): self.forceSecureCardValidation = forceSecureCardValidation
    def get_merchantDetails(self): return self.merchantDetails
    def set_merchantDetails(self, merchantDetails): self.merchantDetails = merchantDetails
    def get_revokedCaCertificates(self): return self.revokedCaCertificates
    def set_revokedCaCertificates(self, revokedCaCertificates): self.revokedCaCertificates = revokedCaCertificates
    def get_surchargePercentage(self): return self.surchargePercentage
    def set_surchargePercentage(self, surchargePercentage): self.surchargePercentage = surchargePercentage
    def get_terminalTaxes(self): return self.terminalTaxes
    def set_terminalTaxes(self, terminalTaxes): self.terminalTaxes = terminalTaxes
    def get_terminalTips(self): return self.terminalTips
    def set_terminalTips(self, terminalTips): self.terminalTips = terminalTips
    def get_validateSecureCardSecurity(self): return self.validateSecureCardSecurity
    def set_validateSecureCardSecurity(self, validateSecureCardSecurity): self.validateSecureCardSecurity = validateSecureCardSecurity
    def hasContent_(self):
        if (
            self.allowCardholderSignatureBypass is not None or
            self.allowKeyed is not None or
            self.allowMsrFallback is not None or
            self.allowSurcharges is not None or
            self.allowSurchargesForMobile is not None or
            self.allowSurchargesForVT is not None or
            self.allowTax is not None or
            self.allowTip is not None or
            self.allowUnreferenced is not None or
            self.applications is not None or
            self.avsCompulsory is not None or
            self.avsEnabled is not None or
            self.caCertificates is not None or
            self.currencies is not None or
            self.emvTags is not None or
            self.enableAutomaticSettle is not None or
            self.enableCardHolderReceipt is not None or
            self.forceSecureCardValidation is not None or
            self.merchantDetails is not None or
            self.revokedCaCertificates is not None or
            self.surchargePercentage is not None or
            self.terminalTaxes is not None or
            self.terminalTips is not None or
            self.validateSecureCardSecurity is not None or
            super(terminalConfiguration, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalConfiguration', mapping_=None):
        element = super(terminalConfiguration, self).to_etree(parent_element, name_, mapping_)
        if self.allowCardholderSignatureBypass is not None:
            allowCardholderSignatureBypass_ = self.allowCardholderSignatureBypass
            etree_.SubElement(element, '{}allowCardholderSignatureBypass').text = self.gds_format_boolean(allowCardholderSignatureBypass_)
        if self.allowKeyed is not None:
            allowKeyed_ = self.allowKeyed
            etree_.SubElement(element, '{}allowKeyed').text = self.gds_format_boolean(allowKeyed_)
        if self.allowMsrFallback is not None:
            allowMsrFallback_ = self.allowMsrFallback
            etree_.SubElement(element, '{}allowMsrFallback').text = self.gds_format_boolean(allowMsrFallback_)
        if self.allowSurcharges is not None:
            allowSurcharges_ = self.allowSurcharges
            etree_.SubElement(element, '{}allowSurcharges').text = self.gds_format_boolean(allowSurcharges_)
        if self.allowSurchargesForMobile is not None:
            allowSurchargesForMobile_ = self.allowSurchargesForMobile
            etree_.SubElement(element, '{}allowSurchargesForMobile').text = self.gds_format_boolean(allowSurchargesForMobile_)
        if self.allowSurchargesForVT is not None:
            allowSurchargesForVT_ = self.allowSurchargesForVT
            etree_.SubElement(element, '{}allowSurchargesForVT').text = self.gds_format_boolean(allowSurchargesForVT_)
        if self.allowTax is not None:
            allowTax_ = self.allowTax
            etree_.SubElement(element, '{}allowTax').text = self.gds_format_boolean(allowTax_)
        if self.allowTip is not None:
            allowTip_ = self.allowTip
            etree_.SubElement(element, '{}allowTip').text = self.gds_format_boolean(allowTip_)
        if self.allowUnreferenced is not None:
            allowUnreferenced_ = self.allowUnreferenced
            etree_.SubElement(element, '{}allowUnreferenced').text = self.gds_format_boolean(allowUnreferenced_)
        if self.applications is not None:
            applications_ = self.applications
            applications_.to_etree(element, name_='applications', mapping_=mapping_)
        if self.avsCompulsory is not None:
            avsCompulsory_ = self.avsCompulsory
            etree_.SubElement(element, '{}avsCompulsory').text = self.gds_format_boolean(avsCompulsory_)
        if self.avsEnabled is not None:
            avsEnabled_ = self.avsEnabled
            etree_.SubElement(element, '{}avsEnabled').text = self.gds_format_boolean(avsEnabled_)
        if self.caCertificates is not None:
            caCertificates_ = self.caCertificates
            caCertificates_.to_etree(element, name_='caCertificates', mapping_=mapping_)
        if self.currencies is not None:
            currencies_ = self.currencies
            currencies_.to_etree(element, name_='currencies', mapping_=mapping_)
        if self.emvTags is not None:
            emvTags_ = self.emvTags
            emvTags_.to_etree(element, name_='emvTags', mapping_=mapping_)
        if self.enableAutomaticSettle is not None:
            enableAutomaticSettle_ = self.enableAutomaticSettle
            etree_.SubElement(element, '{}enableAutomaticSettle').text = self.gds_format_boolean(enableAutomaticSettle_)
        if self.enableCardHolderReceipt is not None:
            enableCardHolderReceipt_ = self.enableCardHolderReceipt
            etree_.SubElement(element, '{}enableCardHolderReceipt').text = self.gds_format_boolean(enableCardHolderReceipt_)
        if self.forceSecureCardValidation is not None:
            forceSecureCardValidation_ = self.forceSecureCardValidation
            etree_.SubElement(element, '{}forceSecureCardValidation').text = self.gds_format_boolean(forceSecureCardValidation_)
        if self.merchantDetails is not None:
            merchantDetails_ = self.merchantDetails
            merchantDetails_.to_etree(element, name_='merchantDetails', mapping_=mapping_)
        if self.revokedCaCertificates is not None:
            revokedCaCertificates_ = self.revokedCaCertificates
            revokedCaCertificates_.to_etree(element, name_='revokedCaCertificates', mapping_=mapping_)
        if self.surchargePercentage is not None:
            surchargePercentage_ = self.surchargePercentage
            etree_.SubElement(element, '{}surchargePercentage').text = self.gds_format_double(surchargePercentage_)
        if self.terminalTaxes is not None:
            terminalTaxes_ = self.terminalTaxes
            terminalTaxes_.to_etree(element, name_='terminalTaxes', mapping_=mapping_)
        if self.terminalTips is not None:
            terminalTips_ = self.terminalTips
            terminalTips_.to_etree(element, name_='terminalTips', mapping_=mapping_)
        if self.validateSecureCardSecurity is not None:
            validateSecureCardSecurity_ = self.validateSecureCardSecurity
            etree_.SubElement(element, '{}validateSecureCardSecurity').text = self.gds_format_boolean(validateSecureCardSecurity_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalConfiguration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(terminalConfiguration, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(terminalConfiguration, self).exportLiteralChildren(outfile, level, name_)
        if self.allowCardholderSignatureBypass is not None:
            showIndent(outfile, level)
            outfile.write('allowCardholderSignatureBypass=%s,\n' % self.allowCardholderSignatureBypass)
        if self.allowKeyed is not None:
            showIndent(outfile, level)
            outfile.write('allowKeyed=%s,\n' % self.allowKeyed)
        if self.allowMsrFallback is not None:
            showIndent(outfile, level)
            outfile.write('allowMsrFallback=%s,\n' % self.allowMsrFallback)
        if self.allowSurcharges is not None:
            showIndent(outfile, level)
            outfile.write('allowSurcharges=%s,\n' % self.allowSurcharges)
        if self.allowSurchargesForMobile is not None:
            showIndent(outfile, level)
            outfile.write('allowSurchargesForMobile=%s,\n' % self.allowSurchargesForMobile)
        if self.allowSurchargesForVT is not None:
            showIndent(outfile, level)
            outfile.write('allowSurchargesForVT=%s,\n' % self.allowSurchargesForVT)
        if self.allowTax is not None:
            showIndent(outfile, level)
            outfile.write('allowTax=%s,\n' % self.allowTax)
        if self.allowTip is not None:
            showIndent(outfile, level)
            outfile.write('allowTip=%s,\n' % self.allowTip)
        if self.allowUnreferenced is not None:
            showIndent(outfile, level)
            outfile.write('allowUnreferenced=%s,\n' % self.allowUnreferenced)
        if self.applications is not None:
            showIndent(outfile, level)
            outfile.write('applications=model_.applicationsType(\n')
            self.applications.exportLiteral(outfile, level, name_='applications')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.avsCompulsory is not None:
            showIndent(outfile, level)
            outfile.write('avsCompulsory=%s,\n' % self.avsCompulsory)
        if self.avsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('avsEnabled=%s,\n' % self.avsEnabled)
        if self.caCertificates is not None:
            showIndent(outfile, level)
            outfile.write('caCertificates=model_.caCertificatesType(\n')
            self.caCertificates.exportLiteral(outfile, level, name_='caCertificates')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.currencies is not None:
            showIndent(outfile, level)
            outfile.write('currencies=model_.currenciesType(\n')
            self.currencies.exportLiteral(outfile, level, name_='currencies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.emvTags is not None:
            showIndent(outfile, level)
            outfile.write('emvTags=model_.emvTagsType(\n')
            self.emvTags.exportLiteral(outfile, level, name_='emvTags')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.enableAutomaticSettle is not None:
            showIndent(outfile, level)
            outfile.write('enableAutomaticSettle=%s,\n' % self.enableAutomaticSettle)
        if self.enableCardHolderReceipt is not None:
            showIndent(outfile, level)
            outfile.write('enableCardHolderReceipt=%s,\n' % self.enableCardHolderReceipt)
        if self.forceSecureCardValidation is not None:
            showIndent(outfile, level)
            outfile.write('forceSecureCardValidation=%s,\n' % self.forceSecureCardValidation)
        if self.merchantDetails is not None:
            showIndent(outfile, level)
            outfile.write('merchantDetails=model_.merchantDetails(\n')
            self.merchantDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.revokedCaCertificates is not None:
            showIndent(outfile, level)
            outfile.write('revokedCaCertificates=model_.revokedCaCertificatesType(\n')
            self.revokedCaCertificates.exportLiteral(outfile, level, name_='revokedCaCertificates')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.surchargePercentage is not None:
            showIndent(outfile, level)
            outfile.write('surchargePercentage=%e,\n' % self.surchargePercentage)
        if self.terminalTaxes is not None:
            showIndent(outfile, level)
            outfile.write('terminalTaxes=model_.terminalTaxesType(\n')
            self.terminalTaxes.exportLiteral(outfile, level, name_='terminalTaxes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.terminalTips is not None:
            showIndent(outfile, level)
            outfile.write('terminalTips=model_.terminalTipsType(\n')
            self.terminalTips.exportLiteral(outfile, level, name_='terminalTips')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.validateSecureCardSecurity is not None:
            showIndent(outfile, level)
            outfile.write('validateSecureCardSecurity=%s,\n' % self.validateSecureCardSecurity)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(terminalConfiguration, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allowCardholderSignatureBypass':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowCardholderSignatureBypass')
            self.allowCardholderSignatureBypass = ival_
        elif nodeName_ == 'allowKeyed':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowKeyed')
            self.allowKeyed = ival_
        elif nodeName_ == 'allowMsrFallback':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowMsrFallback')
            self.allowMsrFallback = ival_
        elif nodeName_ == 'allowSurcharges':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowSurcharges')
            self.allowSurcharges = ival_
        elif nodeName_ == 'allowSurchargesForMobile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowSurchargesForMobile')
            self.allowSurchargesForMobile = ival_
        elif nodeName_ == 'allowSurchargesForVT':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowSurchargesForVT')
            self.allowSurchargesForVT = ival_
        elif nodeName_ == 'allowTax':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowTax')
            self.allowTax = ival_
        elif nodeName_ == 'allowTip':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowTip')
            self.allowTip = ival_
        elif nodeName_ == 'allowUnreferenced':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowUnreferenced')
            self.allowUnreferenced = ival_
        elif nodeName_ == 'applications':
            obj_ = applicationsType.factory()
            obj_.build(child_)
            self.applications = obj_
            obj_.original_tagname_ = 'applications'
        elif nodeName_ == 'avsCompulsory':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'avsCompulsory')
            self.avsCompulsory = ival_
        elif nodeName_ == 'avsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'avsEnabled')
            self.avsEnabled = ival_
        elif nodeName_ == 'caCertificates':
            obj_ = caCertificatesType.factory()
            obj_.build(child_)
            self.caCertificates = obj_
            obj_.original_tagname_ = 'caCertificates'
        elif nodeName_ == 'currencies':
            obj_ = currenciesType.factory()
            obj_.build(child_)
            self.currencies = obj_
            obj_.original_tagname_ = 'currencies'
        elif nodeName_ == 'emvTags':
            obj_ = emvTagsType.factory()
            obj_.build(child_)
            self.emvTags = obj_
            obj_.original_tagname_ = 'emvTags'
        elif nodeName_ == 'enableAutomaticSettle':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableAutomaticSettle')
            self.enableAutomaticSettle = ival_
        elif nodeName_ == 'enableCardHolderReceipt':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enableCardHolderReceipt')
            self.enableCardHolderReceipt = ival_
        elif nodeName_ == 'forceSecureCardValidation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'forceSecureCardValidation')
            self.forceSecureCardValidation = ival_
        elif nodeName_ == 'merchantDetails':
            obj_ = merchantDetails.factory()
            obj_.build(child_)
            self.merchantDetails = obj_
            obj_.original_tagname_ = 'merchantDetails'
        elif nodeName_ == 'revokedCaCertificates':
            obj_ = revokedCaCertificatesType.factory()
            obj_.build(child_)
            self.revokedCaCertificates = obj_
            obj_.original_tagname_ = 'revokedCaCertificates'
        elif nodeName_ == 'surchargePercentage' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'surchargePercentage')
            self.surchargePercentage = fval_
        elif nodeName_ == 'terminalTaxes':
            obj_ = terminalTaxesType.factory()
            obj_.build(child_)
            self.terminalTaxes = obj_
            obj_.original_tagname_ = 'terminalTaxes'
        elif nodeName_ == 'terminalTips':
            obj_ = terminalTipsType.factory()
            obj_.build(child_)
            self.terminalTips = obj_
            obj_.original_tagname_ = 'terminalTips'
        elif nodeName_ == 'validateSecureCardSecurity':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'validateSecureCardSecurity')
            self.validateSecureCardSecurity = ival_
        super(terminalConfiguration, self).buildChildren(child_, node, nodeName_, True)
# end class terminalConfiguration


class application(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('applicationMatchType', ['applicationMatchType', 'xs:int'], 0, 1, {'name': 'applicationMatchType', 'type': 'xs:int', 'minOccurs': '0'}, None),
        MemberSpec_('card', 'xs:string', 0, 1, {'name': 'card', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('identifier', 'xs:string', 0, 1, {'name': 'identifier', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('version', 'xs:string', 0, 1, {'name': 'version', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, applicationMatchType=None, card=None, identifier=None, version=None):
        self.original_tagname_ = None
        self.applicationMatchType = applicationMatchType
        self.validate_applicationMatchType(self.applicationMatchType)
        self.card = card
        self.identifier = identifier
        self.version = version
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, application)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if application.subclass:
            return application.subclass(*args_, **kwargs_)
        else:
            return application(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_applicationMatchType(self): return self.applicationMatchType
    def set_applicationMatchType(self, applicationMatchType): self.applicationMatchType = applicationMatchType
    def get_card(self): return self.card
    def set_card(self, card): self.card = card
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def validate_applicationMatchType(self, value):
        # Validate type applicationMatchType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on applicationMatchType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.applicationMatchType is not None or
            self.card is not None or
            self.identifier is not None or
            self.version is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='application', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.applicationMatchType is not None:
            applicationMatchType_ = self.applicationMatchType
            etree_.SubElement(element, '{}applicationMatchType').text = self.gds_format_integer(applicationMatchType_)
        if self.card is not None:
            card_ = self.card
            etree_.SubElement(element, '{}card').text = self.gds_format_string(card_)
        if self.identifier is not None:
            identifier_ = self.identifier
            etree_.SubElement(element, '{}identifier').text = self.gds_format_string(identifier_)
        if self.version is not None:
            version_ = self.version
            etree_.SubElement(element, '{}version').text = self.gds_format_string(version_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='application'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.applicationMatchType is not None:
            showIndent(outfile, level)
            outfile.write('applicationMatchType=%d,\n' % self.applicationMatchType)
        if self.card is not None:
            showIndent(outfile, level)
            outfile.write('card=%s,\n' % self.gds_encode(quote_python(self.card)))
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=%s,\n' % self.gds_encode(quote_python(self.identifier)))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=%s,\n' % self.gds_encode(quote_python(self.version)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'applicationMatchType' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'applicationMatchType')
            self.applicationMatchType = ival_
            # validate type applicationMatchType
            self.validate_applicationMatchType(self.applicationMatchType)
        elif nodeName_ == 'card':
            card_ = child_.text
            card_ = self.gds_validate_string(card_, node, 'card')
            self.card = card_
        elif nodeName_ == 'identifier':
            identifier_ = child_.text
            identifier_ = self.gds_validate_string(identifier_, node, 'identifier')
            self.identifier = identifier_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
# end class application


class caCertificate(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('certificate', 'xs:string', 0, 1, {'name': 'certificate', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('exponent', 'xs:string', 0, 1, {'name': 'exponent', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('rid', 'xs:string', 0, 1, {'name': 'rid', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, certificate=None, exponent=None, rid=None):
        self.original_tagname_ = None
        self.certificate = certificate
        self.exponent = exponent
        self.rid = rid
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, caCertificate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if caCertificate.subclass:
            return caCertificate.subclass(*args_, **kwargs_)
        else:
            return caCertificate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_certificate(self): return self.certificate
    def set_certificate(self, certificate): self.certificate = certificate
    def get_exponent(self): return self.exponent
    def set_exponent(self, exponent): self.exponent = exponent
    def get_rid(self): return self.rid
    def set_rid(self, rid): self.rid = rid
    def hasContent_(self):
        if (
            self.certificate is not None or
            self.exponent is not None or
            self.rid is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='caCertificate', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.certificate is not None:
            certificate_ = self.certificate
            etree_.SubElement(element, '{}certificate').text = self.gds_format_string(certificate_)
        if self.exponent is not None:
            exponent_ = self.exponent
            etree_.SubElement(element, '{}exponent').text = self.gds_format_string(exponent_)
        if self.rid is not None:
            rid_ = self.rid
            etree_.SubElement(element, '{}rid').text = self.gds_format_string(rid_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='caCertificate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.certificate is not None:
            showIndent(outfile, level)
            outfile.write('certificate=%s,\n' % self.gds_encode(quote_python(self.certificate)))
        if self.exponent is not None:
            showIndent(outfile, level)
            outfile.write('exponent=%s,\n' % self.gds_encode(quote_python(self.exponent)))
        if self.rid is not None:
            showIndent(outfile, level)
            outfile.write('rid=%s,\n' % self.gds_encode(quote_python(self.rid)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'certificate':
            certificate_ = child_.text
            certificate_ = self.gds_validate_string(certificate_, node, 'certificate')
            self.certificate = certificate_
        elif nodeName_ == 'exponent':
            exponent_ = child_.text
            exponent_ = self.gds_validate_string(exponent_, node, 'exponent')
            self.exponent = exponent_
        elif nodeName_ == 'rid':
            rid_ = child_.text
            rid_ = self.gds_validate_string(rid_, node, 'rid')
            self.rid = rid_
# end class caCertificate


class merchantDetails(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('address1', 'xs:string', 0, 1, {'name': 'address1', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('address2', 'xs:string', 0, 1, {'name': 'address2', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('address3', 'xs:string', 0, 1, {'name': 'address3', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('city', 'xs:string', 0, 1, {'name': 'city', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('country', 'xs:string', 0, 1, {'name': 'country', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('name', 'xs:string', 0, 1, {'name': 'name', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('phone', 'xs:string', 0, 1, {'name': 'phone', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, address1=None, address2=None, address3=None, city=None, country=None, name=None, phone=None):
        self.original_tagname_ = None
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.city = city
        self.country = country
        self.name = name
        self.phone = phone
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, merchantDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if merchantDetails.subclass:
            return merchantDetails.subclass(*args_, **kwargs_)
        else:
            return merchantDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address1(self): return self.address1
    def set_address1(self, address1): self.address1 = address1
    def get_address2(self): return self.address2
    def set_address2(self, address2): self.address2 = address2
    def get_address3(self): return self.address3
    def set_address3(self, address3): self.address3 = address3
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_phone(self): return self.phone
    def set_phone(self, phone): self.phone = phone
    def hasContent_(self):
        if (
            self.address1 is not None or
            self.address2 is not None or
            self.address3 is not None or
            self.city is not None or
            self.country is not None or
            self.name is not None or
            self.phone is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='merchantDetails', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.address1 is not None:
            address1_ = self.address1
            etree_.SubElement(element, '{}address1').text = self.gds_format_string(address1_)
        if self.address2 is not None:
            address2_ = self.address2
            etree_.SubElement(element, '{}address2').text = self.gds_format_string(address2_)
        if self.address3 is not None:
            address3_ = self.address3
            etree_.SubElement(element, '{}address3').text = self.gds_format_string(address3_)
        if self.city is not None:
            city_ = self.city
            etree_.SubElement(element, '{}city').text = self.gds_format_string(city_)
        if self.country is not None:
            country_ = self.country
            etree_.SubElement(element, '{}country').text = self.gds_format_string(country_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{}name').text = self.gds_format_string(name_)
        if self.phone is not None:
            phone_ = self.phone
            etree_.SubElement(element, '{}phone').text = self.gds_format_string(phone_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='merchantDetails'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.address1 is not None:
            showIndent(outfile, level)
            outfile.write('address1=%s,\n' % self.gds_encode(quote_python(self.address1)))
        if self.address2 is not None:
            showIndent(outfile, level)
            outfile.write('address2=%s,\n' % self.gds_encode(quote_python(self.address2)))
        if self.address3 is not None:
            showIndent(outfile, level)
            outfile.write('address3=%s,\n' % self.gds_encode(quote_python(self.address3)))
        if self.city is not None:
            showIndent(outfile, level)
            outfile.write('city=%s,\n' % self.gds_encode(quote_python(self.city)))
        if self.country is not None:
            showIndent(outfile, level)
            outfile.write('country=%s,\n' % self.gds_encode(quote_python(self.country)))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % self.gds_encode(quote_python(self.name)))
        if self.phone is not None:
            showIndent(outfile, level)
            outfile.write('phone=%s,\n' % self.gds_encode(quote_python(self.phone)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address1':
            address1_ = child_.text
            address1_ = self.gds_validate_string(address1_, node, 'address1')
            self.address1 = address1_
        elif nodeName_ == 'address2':
            address2_ = child_.text
            address2_ = self.gds_validate_string(address2_, node, 'address2')
            self.address2 = address2_
        elif nodeName_ == 'address3':
            address3_ = child_.text
            address3_ = self.gds_validate_string(address3_, node, 'address3')
            self.address3 = address3_
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'phone':
            phone_ = child_.text
            phone_ = self.gds_validate_string(phone_, node, 'phone')
            self.phone = phone_
# end class merchantDetails


class terminalTax(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('percentage', 'xs:decimal', 0, 0, {'name': 'percentage', 'type': 'xs:decimal'}, None),
        MemberSpec_('uid', ['uId', 'xs:string'], 0, 1, {'name': 'uid', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, percentage=None, uid=None):
        self.original_tagname_ = None
        self.name = name
        self.percentage = percentage
        self.uid = uid
        self.validate_uId(self.uid)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalTax)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalTax.subclass:
            return terminalTax.subclass(*args_, **kwargs_)
        else:
            return terminalTax(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    def validate_uId(self, value):
        # Validate type uId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.name is not None or
            self.percentage is not None or
            self.uid is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalTax', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{}name').text = self.gds_format_string(name_)
        if self.percentage is not None:
            percentage_ = self.percentage
            etree_.SubElement(element, '{}percentage').text = self.gds_format_float(percentage_)
        if self.uid is not None:
            uid_ = self.uid
            etree_.SubElement(element, '{}uid').text = self.gds_format_string(uid_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalTax'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % self.gds_encode(quote_python(self.name)))
        if self.percentage is not None:
            showIndent(outfile, level)
            outfile.write('percentage=%f,\n' % self.percentage)
        if self.uid is not None:
            showIndent(outfile, level)
            outfile.write('uid=%s,\n' % self.gds_encode(quote_python(self.uid)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'percentage' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'percentage')
            self.percentage = fval_
        elif nodeName_ == 'uid':
            uid_ = child_.text
            uid_ = self.gds_validate_string(uid_, node, 'uid')
            self.uid = uid_
            # validate type uId
            self.validate_uId(self.uid)

    @property
    def hash_string(self):
        hash_list = [self.name, '{:.0f}'.format(self.percentage * 10000)]
        if self.uid:
            hash_list.append(self.uid)
        return ':'.join(hash_list)
# end class terminalTax


class terminalTip(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('amount', 'amount', 0, 1, {'name': 'amount', 'type': 'amount', 'minOccurs': '0'}, None),
        MemberSpec_('percentage', 'xs:decimal', 0, 1, {'name': 'percentage', 'type': 'xs:decimal', 'minOccurs': '0'}, None),
        MemberSpec_('tipType', ['tipType', 'xs:string'], 0, 0, {'name': 'tipType', 'type': 'xs:string'}, None),
        MemberSpec_('uid', ['uId', 'xs:string'], 0, 1, {'name': 'uid', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, amount=None, percentage=None, tipType=None, uid=None):
        self.original_tagname_ = None
        self.amount = amount
        self.percentage = percentage
        self.tipType = tipType
        self.validate_tipType(self.tipType)
        self.uid = uid
        self.validate_uId(self.uid)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalTip)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalTip.subclass:
            return terminalTip.subclass(*args_, **kwargs_)
        else:
            return terminalTip(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_tipType(self): return self.tipType
    def set_tipType(self, tipType): self.tipType = tipType
    def get_uid(self): return self.uid
    def set_uid(self, uid): self.uid = uid
    def validate_tipType(self, value):
        # Validate type tipType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PERCENTAGE', 'FIXED_AMOUNT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tipType' % {"value" : value.encode("utf-8")} )
    def validate_uId(self, value):
        # Validate type uId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.amount is not None or
            self.percentage is not None or
            self.tipType is not None or
            self.uid is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalTip', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.amount is not None:
            amount_ = self.amount
            amount_.to_etree(element, name_='amount', mapping_=mapping_)
        if self.percentage is not None:
            percentage_ = self.percentage
            etree_.SubElement(element, '{}percentage').text = self.gds_format_float(percentage_)
        if self.tipType is not None:
            tipType_ = self.tipType
            etree_.SubElement(element, '{}tipType').text = self.gds_format_string(tipType_)
        if self.uid is not None:
            uid_ = self.uid
            etree_.SubElement(element, '{}uid').text = self.gds_format_string(uid_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalTip'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.amount is not None:
            showIndent(outfile, level)
            outfile.write('amount=model_.amount(\n')
            self.amount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.percentage is not None:
            showIndent(outfile, level)
            outfile.write('percentage=%f,\n' % self.percentage)
        if self.tipType is not None:
            showIndent(outfile, level)
            outfile.write('tipType=%s,\n' % self.gds_encode(quote_python(self.tipType)))
        if self.uid is not None:
            showIndent(outfile, level)
            outfile.write('uid=%s,\n' % self.gds_encode(quote_python(self.uid)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            class_obj_ = self.get_class_obj_(child_, amount)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.amount = obj_
            obj_.original_tagname_ = 'amount'
        elif nodeName_ == 'percentage' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'percentage')
            self.percentage = fval_
        elif nodeName_ == 'tipType':
            tipType_ = child_.text
            tipType_ = self.gds_validate_string(tipType_, node, 'tipType')
            self.tipType = tipType_
            # validate type tipType
            self.validate_tipType(self.tipType)
        elif nodeName_ == 'uid':
            uid_ = child_.text
            uid_ = self.gds_validate_string(uid_, node, 'uid')
            self.uid = uid_
            # validate type uId
            self.validate_uId(self.uid)

    @property
    def hash_string(self):
        hash_list = [self.amount.hash_string]
        if self.percentage:
            hash_list.append(str(self.percentage))
        hash_list.append(self.tipType)
        if self.uid:
            hash_list.append(self.uid)
        return ':'.join(hash_list)
# end class terminalTip


class amount(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('amount', 'amount', 0, 1, {'name': 'amount', 'type': 'xs:decimal', 'minOccurs': '0'}, None),
        MemberSpec_('cashBackAmount', 'xs:decimal', 0, 1, {'name': 'cashBackAmount', 'type': 'xs:decimal', 'minOccurs': '0'}, None),
        MemberSpec_('currency', ['currency', 'xs:string'], 0, 0, {'name': 'currency', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, amount_member=None, cashBackAmount=None, currency=None, extensiontype_=None):
        self.original_tagname_ = None
        self.amount = amount_member
        self.cashBackAmount = cashBackAmount
        self.currency = currency
        self.validate_currency(self.currency)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, amount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if amount.subclass:
            return amount.subclass(*args_, **kwargs_)
        else:
            return amount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_cashBackAmount(self): return self.cashBackAmount
    def set_cashBackAmount(self, cashBackAmount): self.cashBackAmount = cashBackAmount
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_currency(self, value):
        # Validate type currency, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYR', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LTL', 'LVL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRO', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLL', 'SOS', 'SRD', 'SSP', 'STD', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'USS', 'UYI', 'UYU', 'UZS', 'VEF', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XCD', 'XOF', 'XPF', 'YER', 'ZAR', 'ZMW', 'ZWL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on currency' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.amount is not None or
            self.cashBackAmount is not None or
            self.currency is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='amount', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.amount is not None:
            amount_ = self.amount
            etree_.SubElement(element, '{}amount').text = self.gds_format_float(amount_)
        if self.cashBackAmount is not None:
            cashBackAmount_ = self.cashBackAmount
            etree_.SubElement(element, '{}cashBackAmount').text = self.gds_format_float(cashBackAmount_)
        if self.currency is not None:
            currency_ = self.currency
            etree_.SubElement(element, '{}currency').text = self.gds_format_string(currency_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='amount'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.amount is not None:
            showIndent(outfile, level)
            outfile.write('amount=%f,\n' % self.amount)
        if self.cashBackAmount is not None:
            showIndent(outfile, level)
            outfile.write('cashBackAmount=%f,\n' % self.cashBackAmount)
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=%s,\n' % self.gds_encode(quote_python(self.currency)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
        elif nodeName_ == 'cashBackAmount' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'cashBackAmount')
            self.cashBackAmount = fval_
        elif nodeName_ == 'currency':
            currency_ = child_.text
            currency_ = self.gds_validate_string(currency_, node, 'currency')
            self.currency = currency_
            # validate type currency
            self.validate_currency(self.currency)

    @property
    def hash_string(self):
        from constants import Currency
        from decimal import Decimal

        hash_list = []
        hash_list.append(str((Decimal(self.amount).quantize(Decimal(10) ** -Currency[self.currency].minorunits))).replace('.','').lstrip('0'))
        if self.cashBackAmount:
            hash_list.append(self.cashBackAmount)
        hash_list.append(self.currency)
        return ':'.join(hash_list)
# end class amount


class reversal(protectedMethod):
    member_data_items_ = [
        MemberSpec_('account', 'account', 0, 0, {'name': 'account', 'type': 'account'}, None),
        MemberSpec_('customer', 'customer', 0, 1, {'name': 'customer', 'type': 'customer', 'minOccurs': '0'}, None),
        MemberSpec_('deviceType', 'xs:string', 0, 0, {'name': 'deviceType', 'type': 'xs:string'}, None),
        MemberSpec_('previousTxnDateTime', 'xs:dateTime', 0, 1, {'name': 'previousTxnDateTime', 'type': 'xs:dateTime', 'minOccurs': '0'}, None),
        MemberSpec_('reason', 'xs:string', 0, 1, {'name': 'reason', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('tlvString', 'xs:string', 0, 1, {'name': 'tlvString', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('orderId', ['orderId', 'xs:string'], 0, 0, {'name': 'orderId', 'type': 'xs:string'}, 2),
        MemberSpec_('uniqueRef', ['uniqueRef', 'xs:string'], 0, 0, {'name': 'uniqueRef', 'type': 'xs:string'}, 2),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, account=None, customer=None, deviceType=None, previousTxnDateTime=None, reason=None, tlvString=None, orderId=None, uniqueRef=None):
        self.original_tagname_ = None
        super(reversal, self).__init__(dateTime, hash, )
        self.account = account
        self.customer = customer
        self.deviceType = deviceType
        if isinstance(previousTxnDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(previousTxnDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = previousTxnDateTime
        self.previousTxnDateTime = initvalue_
        self.reason = reason
        self.tlvString = tlvString
        self.orderId = orderId
        self.validate_orderId(self.orderId)
        self.uniqueRef = uniqueRef
        self.validate_uniqueRef(self.uniqueRef)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reversal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reversal.subclass:
            return reversal.subclass(*args_, **kwargs_)
        else:
            return reversal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def get_customer(self): return self.customer
    def set_customer(self, customer): self.customer = customer
    def get_deviceType(self): return self.deviceType
    def set_deviceType(self, deviceType): self.deviceType = deviceType
    def get_previousTxnDateTime(self): return self.previousTxnDateTime
    def set_previousTxnDateTime(self, previousTxnDateTime): self.previousTxnDateTime = previousTxnDateTime
    def get_reason(self): return self.reason
    def set_reason(self, reason): self.reason = reason
    def get_tlvString(self): return self.tlvString
    def set_tlvString(self, tlvString): self.tlvString = tlvString
    def get_orderId(self): return self.orderId
    def set_orderId(self, orderId): self.orderId = orderId
    def get_uniqueRef(self): return self.uniqueRef
    def set_uniqueRef(self, uniqueRef): self.uniqueRef = uniqueRef
    def validate_orderId(self, value):
        # Validate type orderId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_uniqueRef(self, value):
        # Validate type uniqueRef, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.account is not None or
            self.customer is not None or
            self.deviceType is not None or
            self.previousTxnDateTime is not None or
            self.reason is not None or
            self.tlvString is not None or
            self.orderId is not None or
            self.uniqueRef is not None or
            super(reversal, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='reversal', mapping_=None):
        element = super(reversal, self).to_etree(parent_element, name_, mapping_)
        if self.account is not None:
            account_ = self.account
            account_.to_etree(element, name_='account', mapping_=mapping_)
        if self.customer is not None:
            customer_ = self.customer
            customer_.to_etree(element, name_='customer', mapping_=mapping_)
        if self.deviceType is not None:
            deviceType_ = self.deviceType
            etree_.SubElement(element, '{}deviceType').text = self.gds_format_string(deviceType_)
        if self.previousTxnDateTime is not None:
            previousTxnDateTime_ = self.previousTxnDateTime
            etree_.SubElement(element, '{}previousTxnDateTime').text = self.gds_format_datetime(previousTxnDateTime_)
        if self.reason is not None:
            reason_ = self.reason
            etree_.SubElement(element, '{}reason').text = self.gds_format_string(reason_)
        if self.tlvString is not None:
            tlvString_ = self.tlvString
            etree_.SubElement(element, '{}tlvString').text = self.gds_format_string(tlvString_)
        if self.orderId is not None:
            orderId_ = self.orderId
            etree_.SubElement(element, '{}orderId').text = self.gds_format_string(orderId_)
        if self.uniqueRef is not None:
            uniqueRef_ = self.uniqueRef
            etree_.SubElement(element, '{}uniqueRef').text = self.gds_format_string(uniqueRef_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='reversal'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(reversal, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(reversal, self).exportLiteralChildren(outfile, level, name_)
        if self.account is not None:
            showIndent(outfile, level)
            outfile.write('account=model_.account(\n')
            self.account.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.customer is not None:
            showIndent(outfile, level)
            outfile.write('customer=model_.customer(\n')
            self.customer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deviceType is not None:
            showIndent(outfile, level)
            outfile.write('deviceType=%s,\n' % self.gds_encode(quote_python(self.deviceType)))
        if self.previousTxnDateTime is not None:
            showIndent(outfile, level)
            outfile.write('previousTxnDateTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.previousTxnDateTime, input_name='previousTxnDateTime'))
        if self.reason is not None:
            showIndent(outfile, level)
            outfile.write('reason=%s,\n' % self.gds_encode(quote_python(self.reason)))
        if self.tlvString is not None:
            showIndent(outfile, level)
            outfile.write('tlvString=%s,\n' % self.gds_encode(quote_python(self.tlvString)))
        if self.orderId is not None:
            showIndent(outfile, level)
            outfile.write('orderId=%s,\n' % self.gds_encode(quote_python(self.orderId)))
        if self.uniqueRef is not None:
            showIndent(outfile, level)
            outfile.write('uniqueRef=%s,\n' % self.gds_encode(quote_python(self.uniqueRef)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(reversal, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'account':
            obj_ = account.factory()
            obj_.build(child_)
            self.account = obj_
            obj_.original_tagname_ = 'account'
        elif nodeName_ == 'customer':
            obj_ = customer.factory()
            obj_.build(child_)
            self.customer = obj_
            obj_.original_tagname_ = 'customer'
        elif nodeName_ == 'deviceType':
            deviceType_ = child_.text
            deviceType_ = self.gds_validate_string(deviceType_, node, 'deviceType')
            self.deviceType = deviceType_
        elif nodeName_ == 'previousTxnDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.previousTxnDateTime = dval_
        elif nodeName_ == 'reason':
            reason_ = child_.text
            reason_ = self.gds_validate_string(reason_, node, 'reason')
            self.reason = reason_
        elif nodeName_ == 'tlvString':
            tlvString_ = child_.text
            tlvString_ = self.gds_validate_string(tlvString_, node, 'tlvString')
            self.tlvString = tlvString_
        elif nodeName_ == 'orderId':
            orderId_ = child_.text
            orderId_ = self.gds_validate_string(orderId_, node, 'orderId')
            self.orderId = orderId_
            # validate type orderId
            self.validate_orderId(self.orderId)
        elif nodeName_ == 'uniqueRef':
            uniqueRef_ = child_.text
            uniqueRef_ = self.gds_validate_string(uniqueRef_, node, 'uniqueRef')
            self.uniqueRef = uniqueRef_
            # validate type uniqueRef
            self.validate_uniqueRef(self.uniqueRef)
        super(reversal, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = [self.account.hash_string, self.customer.hash_string, self.deviceType, self.reason]
        if self.tlvString:
            hash_list.append(self.tlvString)
        hash_list.append(self.uniqueRef)
        hash_list.append(str(self.dateTime.isoformat('T', 'seconds')))
        return ':'.join(hash_list)
# end class reversal


class account(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('deviceId', 'xs:string', 0, 1, {'name': 'deviceId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('operator', 'xs:string', 0, 1, {'name': 'operator', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('paymentType', ['paymentTypeEnum', 'xs:string'], 0, 1, {'name': 'paymentType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('terminalCategory', ['terminalCategory', 'xs:string'], 0, 1, {'name': 'terminalCategory', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('terminalId', 'xs:string', 0, 0, {'name': 'terminalId', 'type': 'xs:string'}, None),
        MemberSpec_('terminalType', ['terminalType', 'xs:string'], 0, 0, {'name': 'terminalType', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, deviceId=None, operator=None, paymentType=None, terminalCategory=None, terminalId=None, terminalType=None):
        self.original_tagname_ = None
        self.deviceId = deviceId
        self.operator = operator
        self.paymentType = paymentType
        self.validate_paymentTypeEnum(self.paymentType)
        self.terminalCategory = terminalCategory
        self.validate_terminalCategory(self.terminalCategory)
        self.terminalId = terminalId
        self.terminalType = terminalType
        self.validate_terminalType(self.terminalType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, account)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if account.subclass:
            return account.subclass(*args_, **kwargs_)
        else:
            return account(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deviceId(self): return self.deviceId
    def set_deviceId(self, deviceId): self.deviceId = deviceId
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def get_paymentType(self): return self.paymentType
    def set_paymentType(self, paymentType): self.paymentType = paymentType
    def get_terminalCategory(self): return self.terminalCategory
    def set_terminalCategory(self, terminalCategory): self.terminalCategory = terminalCategory
    def get_terminalId(self): return self.terminalId
    def set_terminalId(self, terminalId): self.terminalId = terminalId
    def get_terminalType(self): return self.terminalType
    def set_terminalType(self, terminalType): self.terminalType = terminalType
    def validate_paymentTypeEnum(self, value):
        # Validate type paymentTypeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CREDIT_DEBIT', 'EBT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on paymentTypeEnum' % {"value" : value.encode("utf-8")} )
    def validate_terminalCategory(self, value):
        # Validate type terminalCategory, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['UNATTENDED_TERMINAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on terminalCategory' % {"value" : value.encode("utf-8")} )
    def validate_terminalType(self, value):
        # Validate type terminalType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MOTO', 'INTERNET', 'CHP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on terminalType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.deviceId is not None or
            self.operator is not None or
            self.paymentType is not None or
            self.terminalCategory is not None or
            self.terminalId is not None or
            self.terminalType is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='account', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.deviceId is not None:
            deviceId_ = self.deviceId
            etree_.SubElement(element, '{}deviceId').text = self.gds_format_string(deviceId_)
        if self.operator is not None:
            operator_ = self.operator
            etree_.SubElement(element, '{}operator').text = self.gds_format_string(operator_)
        if self.paymentType is not None:
            paymentType_ = self.paymentType
            etree_.SubElement(element, '{}paymentType').text = self.gds_format_string(paymentType_)
        if self.terminalCategory is not None:
            terminalCategory_ = self.terminalCategory
            etree_.SubElement(element, '{}terminalCategory').text = self.gds_format_string(terminalCategory_)
        if self.terminalId is not None:
            terminalId_ = self.terminalId
            etree_.SubElement(element, '{}terminalId').text = self.gds_format_string(terminalId_)
        if self.terminalType is not None:
            terminalType_ = self.terminalType
            etree_.SubElement(element, '{}terminalType').text = self.gds_format_string(terminalType_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='account'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.deviceId is not None:
            showIndent(outfile, level)
            outfile.write('deviceId=%s,\n' % self.gds_encode(quote_python(self.deviceId)))
        if self.operator is not None:
            showIndent(outfile, level)
            outfile.write('operator=%s,\n' % self.gds_encode(quote_python(self.operator)))
        if self.paymentType is not None:
            showIndent(outfile, level)
            outfile.write('paymentType=%s,\n' % self.gds_encode(quote_python(self.paymentType)))
        if self.terminalCategory is not None:
            showIndent(outfile, level)
            outfile.write('terminalCategory=%s,\n' % self.gds_encode(quote_python(self.terminalCategory)))
        if self.terminalId is not None:
            showIndent(outfile, level)
            outfile.write('terminalId=%s,\n' % self.gds_encode(quote_python(self.terminalId)))
        if self.terminalType is not None:
            showIndent(outfile, level)
            outfile.write('terminalType=%s,\n' % self.gds_encode(quote_python(self.terminalType)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deviceId':
            deviceId_ = child_.text
            deviceId_ = self.gds_validate_string(deviceId_, node, 'deviceId')
            self.deviceId = deviceId_
        elif nodeName_ == 'operator':
            operator_ = child_.text
            operator_ = self.gds_validate_string(operator_, node, 'operator')
            self.operator = operator_
        elif nodeName_ == 'paymentType':
            paymentType_ = child_.text
            paymentType_ = self.gds_validate_string(paymentType_, node, 'paymentType')
            self.paymentType = paymentType_
            # validate type paymentTypeEnum
            self.validate_paymentTypeEnum(self.paymentType)
        elif nodeName_ == 'terminalCategory':
            terminalCategory_ = child_.text
            terminalCategory_ = self.gds_validate_string(terminalCategory_, node, 'terminalCategory')
            self.terminalCategory = terminalCategory_
            # validate type terminalCategory
            self.validate_terminalCategory(self.terminalCategory)
        elif nodeName_ == 'terminalId':
            terminalId_ = child_.text
            terminalId_ = self.gds_validate_string(terminalId_, node, 'terminalId')
            self.terminalId = terminalId_
        elif nodeName_ == 'terminalType':
            terminalType_ = child_.text
            terminalType_ = self.gds_validate_string(terminalType_, node, 'terminalType')
            self.terminalType = terminalType_
            # validate type terminalType
            self.validate_terminalType(self.terminalType)

    @property
    def hash_string(self):
        hash_list = []
        if self.deviceId:
            hash_list.append(self.deviceId)
        if self.operator:
            hash_list.append(self.operator)
        if self.terminalCategory:
            hash_list.append(self.terminalCategory)
        if self.paymentType:
            hash_list.append(self.paymentType)
        hash_list.append(self.terminalId)
        hash_list.append(self.terminalType)
        return ':'.join(hash_list)
# end class account


class closeBatchResponse(protectedMethod):
    member_data_items_ = [
        MemberSpec_('account', 'account', 0, 0, {'name': 'account', 'type': 'account'}, None),
        MemberSpec_('batchTime', 'xs:string', 0, 0, {'name': 'batchTime', 'type': 'xs:string'}, None),
        MemberSpec_('timeZone', 'xs:string', 0, 1, {'name': 'timeZone', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('timeZoneOffset', 'xs:string', 0, 1, {'name': 'timeZoneOffset', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, account=None, batchTime=None, timeZone=None, timeZoneOffset=None):
        self.original_tagname_ = None
        super(closeBatchResponse, self).__init__(dateTime, hash, )
        self.account = account
        self.batchTime = batchTime
        self.timeZone = timeZone
        self.timeZoneOffset = timeZoneOffset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, closeBatchResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if closeBatchResponse.subclass:
            return closeBatchResponse.subclass(*args_, **kwargs_)
        else:
            return closeBatchResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def get_batchTime(self): return self.batchTime
    def set_batchTime(self, batchTime): self.batchTime = batchTime
    def get_timeZone(self): return self.timeZone
    def set_timeZone(self, timeZone): self.timeZone = timeZone
    def get_timeZoneOffset(self): return self.timeZoneOffset
    def set_timeZoneOffset(self, timeZoneOffset): self.timeZoneOffset = timeZoneOffset
    def hasContent_(self):
        if (
            self.account is not None or
            self.batchTime is not None or
            self.timeZone is not None or
            self.timeZoneOffset is not None or
            super(closeBatchResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='closeBatchResponse', mapping_=None):
        element = super(closeBatchResponse, self).to_etree(parent_element, name_, mapping_)
        if self.account is not None:
            account_ = self.account
            account_.to_etree(element, name_='account', mapping_=mapping_)
        if self.batchTime is not None:
            batchTime_ = self.batchTime
            etree_.SubElement(element, '{}batchTime').text = self.gds_format_string(batchTime_)
        if self.timeZone is not None:
            timeZone_ = self.timeZone
            etree_.SubElement(element, '{}timeZone').text = self.gds_format_string(timeZone_)
        if self.timeZoneOffset is not None:
            timeZoneOffset_ = self.timeZoneOffset
            etree_.SubElement(element, '{}timeZoneOffset').text = self.gds_format_string(timeZoneOffset_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='closeBatchResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(closeBatchResponse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(closeBatchResponse, self).exportLiteralChildren(outfile, level, name_)
        if self.account is not None:
            showIndent(outfile, level)
            outfile.write('account=model_.account(\n')
            self.account.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.batchTime is not None:
            showIndent(outfile, level)
            outfile.write('batchTime=%s,\n' % self.gds_encode(quote_python(self.batchTime)))
        if self.timeZone is not None:
            showIndent(outfile, level)
            outfile.write('timeZone=%s,\n' % self.gds_encode(quote_python(self.timeZone)))
        if self.timeZoneOffset is not None:
            showIndent(outfile, level)
            outfile.write('timeZoneOffset=%s,\n' % self.gds_encode(quote_python(self.timeZoneOffset)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(closeBatchResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'account':
            obj_ = account.factory()
            obj_.build(child_)
            self.account = obj_
            obj_.original_tagname_ = 'account'
        elif nodeName_ == 'batchTime':
            batchTime_ = child_.text
            batchTime_ = self.gds_validate_string(batchTime_, node, 'batchTime')
            self.batchTime = batchTime_
        elif nodeName_ == 'timeZone':
            timeZone_ = child_.text
            timeZone_ = self.gds_validate_string(timeZone_, node, 'timeZone')
            self.timeZone = timeZone_
        elif nodeName_ == 'timeZoneOffset':
            timeZoneOffset_ = child_.text
            timeZoneOffset_ = self.gds_validate_string(timeZoneOffset_, node, 'timeZoneOffset')
            self.timeZoneOffset = timeZoneOffset_
        super(closeBatchResponse, self).buildChildren(child_, node, nodeName_, True)
# end class closeBatchResponse


class additionalField(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', ['additionalFieldType', 'xs:string'], 0, 1, {'name': 'name', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('value', 'xs:string', 0, 1, {'name': 'value', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.original_tagname_ = None
        self.name = name
        self.validate_additionalFieldType(self.name)
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, additionalField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if additionalField.subclass:
            return additionalField.subclass(*args_, **kwargs_)
        else:
            return additionalField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_additionalFieldType(self, value):
        # Validate type additionalFieldType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ORDER_NUM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on additionalFieldType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='additionalField', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{}name').text = self.gds_format_string(name_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{}value').text = self.gds_format_string(value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='additionalField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % self.gds_encode(quote_python(self.name)))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % self.gds_encode(quote_python(self.value)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type additionalFieldType
            self.validate_additionalFieldType(self.name)
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class additionalField


class accountBalance(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('balanceAmount', 'xs:decimal', 0, 1, {'name': 'balanceAmount', 'type': 'xs:decimal', 'minOccurs': '0'}, None),
        MemberSpec_('cardAccount', ['cardAccount', 'xs:string'], 0, 1, {'name': 'cardAccount', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('currency', ['currency', 'xs:string'], 0, 1, {'name': 'currency', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, balanceAmount=None, cardAccount=None, currency=None):
        self.original_tagname_ = None
        self.balanceAmount = balanceAmount
        self.cardAccount = cardAccount
        self.validate_cardAccount(self.cardAccount)
        self.currency = currency
        self.validate_currency(self.currency)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accountBalance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accountBalance.subclass:
            return accountBalance.subclass(*args_, **kwargs_)
        else:
            return accountBalance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_balanceAmount(self): return self.balanceAmount
    def set_balanceAmount(self, balanceAmount): self.balanceAmount = balanceAmount
    def get_cardAccount(self): return self.cardAccount
    def set_cardAccount(self, cardAccount): self.cardAccount = cardAccount
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def validate_cardAccount(self, value):
        # Validate type cardAccount, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CASH', 'FOOD_STAMP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cardAccount' % {"value" : value.encode("utf-8")} )
    def validate_currency(self, value):
        # Validate type currency, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYR', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LTL', 'LVL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRO', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLL', 'SOS', 'SRD', 'SSP', 'STD', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'USS', 'UYI', 'UYU', 'UZS', 'VEF', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XCD', 'XOF', 'XPF', 'YER', 'ZAR', 'ZMW', 'ZWL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on currency' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.balanceAmount is not None or
            self.cardAccount is not None or
            self.currency is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='accountBalance', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.balanceAmount is not None:
            balanceAmount_ = self.balanceAmount
            etree_.SubElement(element, '{}balanceAmount').text = self.gds_format_float(balanceAmount_)
        if self.cardAccount is not None:
            cardAccount_ = self.cardAccount
            etree_.SubElement(element, '{}cardAccount').text = self.gds_format_string(cardAccount_)
        if self.currency is not None:
            currency_ = self.currency
            etree_.SubElement(element, '{}currency').text = self.gds_format_string(currency_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='accountBalance'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.balanceAmount is not None:
            showIndent(outfile, level)
            outfile.write('balanceAmount=%f,\n' % self.balanceAmount)
        if self.cardAccount is not None:
            showIndent(outfile, level)
            outfile.write('cardAccount=%s,\n' % self.gds_encode(quote_python(self.cardAccount)))
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=%s,\n' % self.gds_encode(quote_python(self.currency)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'balanceAmount' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'balanceAmount')
            self.balanceAmount = fval_
        elif nodeName_ == 'cardAccount':
            cardAccount_ = child_.text
            cardAccount_ = self.gds_validate_string(cardAccount_, node, 'cardAccount')
            self.cardAccount = cardAccount_
            # validate type cardAccount
            self.validate_cardAccount(self.cardAccount)
        elif nodeName_ == 'currency':
            currency_ = child_.text
            currency_ = self.gds_validate_string(currency_, node, 'currency')
            self.currency = currency_
            # validate type currency
            self.validate_currency(self.currency)

    @property
    def hashes(self):
        return self.to_hash(['balanceAmount', 'cardAccount'])
# end class accountBalance


class receiptFieldsVO(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardHolderName', 'xs:string', 0, 1, {'name': 'cardHolderName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardType', 'xs:string', 0, 1, {'name': 'cardType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('emvTags', 'emvTagReceiptFieldsVO', 0, 1, {'name': 'emvTags', 'type': 'emvTagReceiptFieldsVO', 'minOccurs': '0'}, None),
        MemberSpec_('expiryDate', 'xs:string', 0, 1, {'name': 'expiryDate', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('maskedPan', 'xs:string', 0, 1, {'name': 'maskedPan', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('transactionType', 'xs:int', 0, 0, {'name': 'transactionType', 'type': 'xs:int'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardHolderName=None, cardType=None, emvTags=None, expiryDate=None, maskedPan=None, transactionType=None):
        self.original_tagname_ = None
        self.cardHolderName = cardHolderName
        self.cardType = cardType
        self.emvTags = emvTags
        self.expiryDate = expiryDate
        self.maskedPan = maskedPan
        self.transactionType = transactionType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, receiptFieldsVO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if receiptFieldsVO.subclass:
            return receiptFieldsVO.subclass(*args_, **kwargs_)
        else:
            return receiptFieldsVO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardHolderName(self): return self.cardHolderName
    def set_cardHolderName(self, cardHolderName): self.cardHolderName = cardHolderName
    def get_cardType(self): return self.cardType
    def set_cardType(self, cardType): self.cardType = cardType
    def get_emvTags(self): return self.emvTags
    def set_emvTags(self, emvTags): self.emvTags = emvTags
    def get_expiryDate(self): return self.expiryDate
    def set_expiryDate(self, expiryDate): self.expiryDate = expiryDate
    def get_maskedPan(self): return self.maskedPan
    def set_maskedPan(self, maskedPan): self.maskedPan = maskedPan
    def get_transactionType(self): return self.transactionType
    def set_transactionType(self, transactionType): self.transactionType = transactionType
    def hasContent_(self):
        if (
            self.cardHolderName is not None or
            self.cardType is not None or
            self.emvTags is not None or
            self.expiryDate is not None or
            self.maskedPan is not None or
            self.transactionType is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='receiptFieldsVO', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cardHolderName is not None:
            cardHolderName_ = self.cardHolderName
            etree_.SubElement(element, '{}cardHolderName').text = self.gds_format_string(cardHolderName_)
        if self.cardType is not None:
            cardType_ = self.cardType
            etree_.SubElement(element, '{}cardType').text = self.gds_format_string(cardType_)
        if self.emvTags is not None:
            emvTags_ = self.emvTags
            emvTags_.to_etree(element, name_='emvTags', mapping_=mapping_)
        if self.expiryDate is not None:
            expiryDate_ = self.expiryDate
            etree_.SubElement(element, '{}expiryDate').text = self.gds_format_string(expiryDate_)
        if self.maskedPan is not None:
            maskedPan_ = self.maskedPan
            etree_.SubElement(element, '{}maskedPan').text = self.gds_format_string(maskedPan_)
        if self.transactionType is not None:
            transactionType_ = self.transactionType
            etree_.SubElement(element, '{}transactionType').text = self.gds_format_integer(transactionType_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='receiptFieldsVO'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardHolderName is not None:
            showIndent(outfile, level)
            outfile.write('cardHolderName=%s,\n' % self.gds_encode(quote_python(self.cardHolderName)))
        if self.cardType is not None:
            showIndent(outfile, level)
            outfile.write('cardType=%s,\n' % self.gds_encode(quote_python(self.cardType)))
        if self.emvTags is not None:
            showIndent(outfile, level)
            outfile.write('emvTags=model_.emvTagReceiptFieldsVO(\n')
            self.emvTags.exportLiteral(outfile, level, name_='emvTags')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.expiryDate is not None:
            showIndent(outfile, level)
            outfile.write('expiryDate=%s,\n' % self.gds_encode(quote_python(self.expiryDate)))
        if self.maskedPan is not None:
            showIndent(outfile, level)
            outfile.write('maskedPan=%s,\n' % self.gds_encode(quote_python(self.maskedPan)))
        if self.transactionType is not None:
            showIndent(outfile, level)
            outfile.write('transactionType=%d,\n' % self.transactionType)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardHolderName':
            cardHolderName_ = child_.text
            cardHolderName_ = self.gds_validate_string(cardHolderName_, node, 'cardHolderName')
            self.cardHolderName = cardHolderName_
        elif nodeName_ == 'cardType':
            cardType_ = child_.text
            cardType_ = self.gds_validate_string(cardType_, node, 'cardType')
            self.cardType = cardType_
        elif nodeName_ == 'emvTags':
            obj_ = emvTagReceiptFieldsVO.factory()
            obj_.build(child_)
            self.emvTags = obj_
            obj_.original_tagname_ = 'emvTags'
        elif nodeName_ == 'expiryDate':
            expiryDate_ = child_.text
            expiryDate_ = self.gds_validate_string(expiryDate_, node, 'expiryDate')
            self.expiryDate = expiryDate_
        elif nodeName_ == 'maskedPan':
            maskedPan_ = child_.text
            maskedPan_ = self.gds_validate_string(maskedPan_, node, 'maskedPan')
            self.maskedPan = maskedPan_
        elif nodeName_ == 'transactionType' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'transactionType')
            self.transactionType = ival_
# end class receiptFieldsVO


class emvTagReceiptFieldsVO(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('A50', 'xs:string', 0, 1, {'name': 'A50', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('A5F20', 'xs:string', 0, 1, {'name': 'A5F20', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('A9F06', 'xs:string', 0, 1, {'name': 'A9F06', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('A9F26', 'xs:string', 0, 1, {'name': 'A9F26', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, A50=None, A5F20=None, A9F06=None, A9F26=None):
        self.original_tagname_ = None
        self.A50 = A50
        self.A5F20 = A5F20
        self.A9F06 = A9F06
        self.A9F26 = A9F26
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emvTagReceiptFieldsVO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emvTagReceiptFieldsVO.subclass:
            return emvTagReceiptFieldsVO.subclass(*args_, **kwargs_)
        else:
            return emvTagReceiptFieldsVO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_A50(self): return self.A50
    def set_A50(self, A50): self.A50 = A50
    def get_A5F20(self): return self.A5F20
    def set_A5F20(self, A5F20): self.A5F20 = A5F20
    def get_A9F06(self): return self.A9F06
    def set_A9F06(self, A9F06): self.A9F06 = A9F06
    def get_A9F26(self): return self.A9F26
    def set_A9F26(self, A9F26): self.A9F26 = A9F26
    def hasContent_(self):
        if (
            self.A50 is not None or
            self.A5F20 is not None or
            self.A9F06 is not None or
            self.A9F26 is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='emvTagReceiptFieldsVO', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.A50 is not None:
            A50_ = self.A50
            etree_.SubElement(element, '{}A50').text = self.gds_format_string(A50_)
        if self.A5F20 is not None:
            A5F20_ = self.A5F20
            etree_.SubElement(element, '{}A5F20').text = self.gds_format_string(A5F20_)
        if self.A9F06 is not None:
            A9F06_ = self.A9F06
            etree_.SubElement(element, '{}A9F06').text = self.gds_format_string(A9F06_)
        if self.A9F26 is not None:
            A9F26_ = self.A9F26
            etree_.SubElement(element, '{}A9F26').text = self.gds_format_string(A9F26_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='emvTagReceiptFieldsVO'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.A50 is not None:
            showIndent(outfile, level)
            outfile.write('A50=%s,\n' % self.gds_encode(quote_python(self.A50)))
        if self.A5F20 is not None:
            showIndent(outfile, level)
            outfile.write('A5F20=%s,\n' % self.gds_encode(quote_python(self.A5F20)))
        if self.A9F06 is not None:
            showIndent(outfile, level)
            outfile.write('A9F06=%s,\n' % self.gds_encode(quote_python(self.A9F06)))
        if self.A9F26 is not None:
            showIndent(outfile, level)
            outfile.write('A9F26=%s,\n' % self.gds_encode(quote_python(self.A9F26)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'A50':
            A50_ = child_.text
            A50_ = self.gds_validate_string(A50_, node, 'A50')
            self.A50 = A50_
        elif nodeName_ == 'A5F20':
            A5F20_ = child_.text
            A5F20_ = self.gds_validate_string(A5F20_, node, 'A5F20')
            self.A5F20 = A5F20_
        elif nodeName_ == 'A9F06':
            A9F06_ = child_.text
            A9F06_ = self.gds_validate_string(A9F06_, node, 'A9F06')
            self.A9F06 = A9F06_
        elif nodeName_ == 'A9F26':
            A9F26_ = child_.text
            A9F26_ = self.gds_validate_string(A9F26_, node, 'A9F26')
            self.A9F26 = A9F26_
# end class emvTagReceiptFieldsVO


class transactionSurcharge(amount):
    member_data_items_ = [
        MemberSpec_('percentage', 'xs:decimal', 0, 0, {'name': 'percentage', 'type': 'xs:decimal'}, None),
    ]
    subclass = None
    superclass = amount
    def __init__(self, amount_member=None, cashBackAmount=None, currency=None, percentage=None):
        self.original_tagname_ = None
        super(transactionSurcharge, self).__init__(amount_member, cashBackAmount, currency, )
        self.percentage = percentage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transactionSurcharge)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transactionSurcharge.subclass:
            return transactionSurcharge.subclass(*args_, **kwargs_)
        else:
            return transactionSurcharge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def hasContent_(self):
        if (
            self.percentage is not None or
            super(transactionSurcharge, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='transactionSurcharge', mapping_=None):
        element = super(transactionSurcharge, self).to_etree(parent_element, name_, mapping_)
        if self.percentage is not None:
            percentage_ = self.percentage
            etree_.SubElement(element, '{}percentage').text = self.gds_format_float(percentage_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='transactionSurcharge'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(transactionSurcharge, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(transactionSurcharge, self).exportLiteralChildren(outfile, level, name_)
        if self.percentage is not None:
            showIndent(outfile, level)
            outfile.write('percentage=%f,\n' % self.percentage)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(transactionSurcharge, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'percentage' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'percentage')
            self.percentage = fval_
        super(transactionSurcharge, self).buildChildren(child_, node, nodeName_, True)
# end class transactionSurcharge


class tax(amount):
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('percentage', 'xs:decimal', 0, 0, {'name': 'percentage', 'type': 'xs:decimal'}, None),
    ]
    subclass = None
    superclass = amount
    def __init__(self, amount_member=None, cashBackAmount=None, currency=None, name=None, percentage=None):
        self.original_tagname_ = None
        super(tax, self).__init__(amount_member, cashBackAmount, currency, )
        self.name = name
        self.percentage = percentage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tax)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tax.subclass:
            return tax.subclass(*args_, **kwargs_)
        else:
            return tax(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def hasContent_(self):
        if (
            self.name is not None or
            self.percentage is not None or
            super(tax, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='tax', mapping_=None):
        element = super(tax, self).to_etree(parent_element, name_, mapping_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{}name').text = self.gds_format_string(name_)
        if self.percentage is not None:
            percentage_ = self.percentage
            etree_.SubElement(element, '{}percentage').text = self.gds_format_float(percentage_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='tax'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(tax, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(tax, self).exportLiteralChildren(outfile, level, name_)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % self.gds_encode(quote_python(self.name)))
        if self.percentage is not None:
            showIndent(outfile, level)
            outfile.write('percentage=%f,\n' % self.percentage)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tax, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'percentage' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'percentage')
            self.percentage = fval_
        super(tax, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = [self.name, str(self.percentage), self.amount, self.currency]
        return ':'.join(hash_list)
# end class tax


class tip(amount):
    member_data_items_ = [
        MemberSpec_('percentage', 'xs:decimal', 0, 1, {'name': 'percentage', 'type': 'xs:decimal', 'minOccurs': '0'}, None),
        MemberSpec_('tipType', ['tipType', 'xs:string'], 0, 0, {'name': 'tipType', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = amount
    def __init__(self, amount_member=None, cashBackAmount=None, currency=None, percentage=None, tipType=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tip, self).__init__(amount_member, cashBackAmount, currency, extensiontype_, )
        self.percentage = percentage
        self.tipType = tipType
        self.validate_tipType(self.tipType)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tip)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tip.subclass:
            return tip.subclass(*args_, **kwargs_)
        else:
            return tip(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_tipType(self): return self.tipType
    def set_tipType(self, tipType): self.tipType = tipType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tipType(self, value):
        # Validate type tipType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PERCENTAGE', 'FIXED_AMOUNT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tipType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.percentage is not None or
            self.tipType is not None or
            super(tip, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='tip', mapping_=None):
        element = super(tip, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.percentage is not None:
            percentage_ = self.percentage
            etree_.SubElement(element, '{}percentage').text = self.gds_format_float(percentage_)
        if self.tipType is not None:
            tipType_ = self.tipType
            etree_.SubElement(element, '{}tipType').text = self.gds_format_string(tipType_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='tip'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(tip, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(tip, self).exportLiteralChildren(outfile, level, name_)
        if self.percentage is not None:
            showIndent(outfile, level)
            outfile.write('percentage=%f,\n' % self.percentage)
        if self.tipType is not None:
            showIndent(outfile, level)
            outfile.write('tipType=%s,\n' % self.gds_encode(quote_python(self.tipType)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tip, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'percentage' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'percentage')
            self.percentage = fval_
        elif nodeName_ == 'tipType':
            tipType_ = child_.text
            tipType_ = self.gds_validate_string(tipType_, node, 'tipType')
            self.tipType = tipType_
            # validate type tipType
            self.validate_tipType(self.tipType)
        super(tip, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        from constants import Currency
        from decimal import Decimal
        hash_list = []
        if self.percentage:
            hash_list.append(str(round(self.percentage * 10000)))
        hash_list.append(self.tipType)
        hash_list.append(str((Decimal(self.amount).quantize(Decimal(10) ** -Currency[self.currency].minorunits))).replace('.','').lstrip('0'))
        hash_list.append(self.currency)
        return ':'.join(hash_list)
# end class tip


class balanceInquiry(protectedMethod):
    member_data_items_ = [
        MemberSpec_('account', 'account', 0, 0, {'name': 'account', 'type': 'account'}, None),
        MemberSpec_('cardReadMethod', 'paymentMethod', 0, 0, {'name': 'cardReadMethod', 'type': 'paymentMethod'}, None),
        MemberSpec_('currency', ['currency', 'xs:string'], 0, 0, {'name': 'currency', 'type': 'xs:string'}, None),
        MemberSpec_('customer', 'customer', 0, 1, {'name': 'customer', 'type': 'customer', 'minOccurs': '0'}, None),
        MemberSpec_('device', 'posDevice', 0, 1, {'name': 'device', 'type': 'posDevice', 'minOccurs': '0'}, None),
        MemberSpec_('deviceType', 'xs:string', 0, 1, {'name': 'deviceType', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, account=None, cardReadMethod=None, currency=None, customer=None, device=None, deviceType=None):
        self.original_tagname_ = None
        super(balanceInquiry, self).__init__(dateTime, hash, )
        self.account = account
        self.cardReadMethod = cardReadMethod
        self.currency = currency
        self.validate_currency(self.currency)
        self.customer = customer
        self.device = device
        self.deviceType = deviceType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, balanceInquiry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if balanceInquiry.subclass:
            return balanceInquiry.subclass(*args_, **kwargs_)
        else:
            return balanceInquiry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def get_cardReadMethod(self): return self.cardReadMethod
    def set_cardReadMethod(self, cardReadMethod): self.cardReadMethod = cardReadMethod
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_customer(self): return self.customer
    def set_customer(self, customer): self.customer = customer
    def get_device(self): return self.device
    def set_device(self, device): self.device = device
    def get_deviceType(self): return self.deviceType
    def set_deviceType(self, deviceType): self.deviceType = deviceType
    def validate_currency(self, value):
        # Validate type currency, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYR', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LTL', 'LVL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRO', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLL', 'SOS', 'SRD', 'SSP', 'STD', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'USS', 'UYI', 'UYU', 'UZS', 'VEF', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XCD', 'XOF', 'XPF', 'YER', 'ZAR', 'ZMW', 'ZWL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on currency' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.account is not None or
            self.cardReadMethod is not None or
            self.currency is not None or
            self.customer is not None or
            self.device is not None or
            self.deviceType is not None or
            super(balanceInquiry, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='balanceInquiry', mapping_=None):
        element = super(balanceInquiry, self).to_etree(parent_element, name_, mapping_)
        if self.account is not None:
            account_ = self.account
            account_.to_etree(element, name_='account', mapping_=mapping_)
        if self.cardReadMethod is not None:
            cardReadMethod_ = self.cardReadMethod
            cardReadMethod_.to_etree(element, name_='cardReadMethod', mapping_=mapping_)
        if self.currency is not None:
            currency_ = self.currency
            etree_.SubElement(element, '{}currency').text = self.gds_format_string(currency_)
        if self.customer is not None:
            customer_ = self.customer
            customer_.to_etree(element, name_='customer', mapping_=mapping_)
        if self.device is not None:
            device_ = self.device
            device_.to_etree(element, name_='device', mapping_=mapping_)
        if self.deviceType is not None:
            deviceType_ = self.deviceType
            etree_.SubElement(element, '{}deviceType').text = self.gds_format_string(deviceType_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='balanceInquiry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(balanceInquiry, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(balanceInquiry, self).exportLiteralChildren(outfile, level, name_)
        if self.account is not None:
            showIndent(outfile, level)
            outfile.write('account=model_.account(\n')
            self.account.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cardReadMethod is not None:
            showIndent(outfile, level)
            outfile.write('cardReadMethod=model_.paymentMethod(\n')
            self.cardReadMethod.exportLiteral(outfile, level, name_='cardReadMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=%s,\n' % self.gds_encode(quote_python(self.currency)))
        if self.customer is not None:
            showIndent(outfile, level)
            outfile.write('customer=model_.customer(\n')
            self.customer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.device is not None:
            showIndent(outfile, level)
            outfile.write('device=model_.posDevice(\n')
            self.device.exportLiteral(outfile, level, name_='device')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deviceType is not None:
            showIndent(outfile, level)
            outfile.write('deviceType=%s,\n' % self.gds_encode(quote_python(self.deviceType)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(balanceInquiry, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'account':
            obj_ = account.factory()
            obj_.build(child_)
            self.account = obj_
            obj_.original_tagname_ = 'account'
        elif nodeName_ == 'cardReadMethod':
            obj_ = paymentMethod.factory()
            obj_.build(child_)
            self.cardReadMethod = obj_
            obj_.original_tagname_ = 'cardReadMethod'
        elif nodeName_ == 'currency':
            currency_ = child_.text
            currency_ = self.gds_validate_string(currency_, node, 'currency')
            self.currency = currency_
            # validate type currency
            self.validate_currency(self.currency)
        elif nodeName_ == 'customer':
            obj_ = customer.factory()
            obj_.build(child_)
            self.customer = obj_
            obj_.original_tagname_ = 'customer'
        elif nodeName_ == 'device':
            obj_ = posDevice.factory()
            obj_.build(child_)
            self.device = obj_
            obj_.original_tagname_ = 'device'
        elif nodeName_ == 'deviceType':
            deviceType_ = child_.text
            deviceType_ = self.gds_validate_string(deviceType_, node, 'deviceType')
            self.deviceType = deviceType_
        super(balanceInquiry, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = [self.account.hash_string, self.cardReadMethod.hash_string, self.currency]
        if self.deviceType:
            hash_list.append(self.deviceType)
        hash_list.append(str(self.dateTime.isoformat('T')))
        return ':'.join(hash_list)
# end class balanceInquiry


class paymentMethod(baseMethod):
    member_data_items_ = [
        MemberSpec_('keyedCard', 'keyedCard', 0, 0, {'name': 'keyedCard', 'type': 'keyedCard'}, 3),
        MemberSpec_('keyedAsTrack2', 'keyedAsTrackData', 0, 0, {'name': 'keyedAsTrack2', 'type': 'keyedAsTrackData'}, 3),
        MemberSpec_('keyedEncrypted', 'keyedEncrypted', 0, 0, {'name': 'keyedEncrypted', 'type': 'keyedEncrypted'}, 3),
        MemberSpec_('secureCard', 'secureCard', 0, 0, {'name': 'secureCard', 'type': 'secureCardMethod'}, 3),
        MemberSpec_('track2', 'trackData', 0, 0, {'name': 'track2', 'type': 'trackData'}, 3),
        MemberSpec_('track2Contactless', 'trackDataContactless', 0, 0, {'name': 'track2Contactless', 'type': 'trackDataContactless'}, 3),
        MemberSpec_('emv', 'emv', 0, 0, {'name': 'emv', 'type': 'emv'}, 3),
        MemberSpec_('emvTlv', 'emvtlv', 0, 0, {'name': 'emvTlv', 'type': 'emvtlv'}, 3),
        MemberSpec_('voucher', 'voucher', 0, 0, {'name': 'voucher', 'type': 'voucher'}, 3),
        MemberSpec_('applePay', 'appleWallet', 0, 0, {'name': 'applePay', 'type': 'appleWallet'}, 3),
        MemberSpec_('androidPay', 'androidWallet', 0, 0, {'name': 'androidPay', 'type': 'androidWallet'}, 3),
    ]
    subclass = None
    superclass = baseMethod
    def __init__(self, keyedCard=None, keyedAsTrack2=None, keyedEncrypted=None, secureCard=None, track2=None, track2Contactless=None, emv=None, emvTlv=None, voucher=None, applePay=None, androidPay=None):
        self.original_tagname_ = None
        super(paymentMethod, self).__init__()
        self.keyedCard = keyedCard
        self.keyedAsTrack2 = keyedAsTrack2
        self.keyedEncrypted = keyedEncrypted
        self.secureCard = secureCard
        self.track2 = track2
        self.track2Contactless = track2Contactless
        self.emv = emv
        self.emvTlv = emvTlv
        self.voucher = voucher
        self.applePay = applePay
        self.androidPay = androidPay
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, paymentMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if paymentMethod.subclass:
            return paymentMethod.subclass(*args_, **kwargs_)
        else:
            return paymentMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_keyedCard(self): return self.keyedCard
    def set_keyedCard(self, keyedCard): self.keyedCard = keyedCard
    def get_keyedAsTrack2(self): return self.keyedAsTrack2
    def set_keyedAsTrack2(self, keyedAsTrack2): self.keyedAsTrack2 = keyedAsTrack2
    def get_keyedEncrypted(self): return self.keyedEncrypted
    def set_keyedEncrypted(self, keyedEncrypted): self.keyedEncrypted = keyedEncrypted
    def get_secureCard(self): return self.secureCard
    def set_secureCard(self, secureCard): self.secureCard = secureCard
    def get_track2(self): return self.track2
    def set_track2(self, track2): self.track2 = track2
    def get_track2Contactless(self): return self.track2Contactless
    def set_track2Contactless(self, track2Contactless): self.track2Contactless = track2Contactless
    def get_emv(self): return self.emv
    def set_emv(self, emv): self.emv = emv
    def get_emvTlv(self): return self.emvTlv
    def set_emvTlv(self, emvTlv): self.emvTlv = emvTlv
    def get_voucher(self): return self.voucher
    def set_voucher(self, voucher): self.voucher = voucher
    def get_applePay(self): return self.applePay
    def set_applePay(self, applePay): self.applePay = applePay
    def get_androidPay(self): return self.androidPay
    def set_androidPay(self, androidPay): self.androidPay = androidPay
    def hasContent_(self):
        if (
            self.keyedCard is not None or
            self.keyedAsTrack2 is not None or
            self.keyedEncrypted is not None or
            self.secureCard is not None or
            self.track2 is not None or
            self.track2Contactless is not None or
            self.emv is not None or
            self.emvTlv is not None or
            self.voucher is not None or
            self.applePay is not None or
            self.androidPay is not None or
            super(paymentMethod, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='paymentMethod', mapping_=None):
        element = super(paymentMethod, self).to_etree(parent_element, name_, mapping_)
        if self.keyedCard is not None:
            keyedCard_ = self.keyedCard
            keyedCard_.to_etree(element, name_='keyedCard', mapping_=mapping_)
        if self.keyedAsTrack2 is not None:
            keyedAsTrack2_ = self.keyedAsTrack2
            keyedAsTrack2_.to_etree(element, name_='keyedAsTrack2', mapping_=mapping_)
        if self.keyedEncrypted is not None:
            keyedEncrypted_ = self.keyedEncrypted
            keyedEncrypted_.to_etree(element, name_='keyedEncrypted', mapping_=mapping_)
        if self.secureCard is not None:
            secureCard_ = self.secureCard
            secureCard_.to_etree(element, name_='secureCard', mapping_=mapping_)
        if self.track2 is not None:
            track2_ = self.track2
            track2_.to_etree(element, name_='track2', mapping_=mapping_)
        if self.track2Contactless is not None:
            track2Contactless_ = self.track2Contactless
            track2Contactless_.to_etree(element, name_='track2Contactless', mapping_=mapping_)
        if self.emv is not None:
            emv_ = self.emv
            emv_.to_etree(element, name_='emv', mapping_=mapping_)
        if self.emvTlv is not None:
            emvTlv_ = self.emvTlv
            emvTlv_.to_etree(element, name_='emvTlv', mapping_=mapping_)
        if self.voucher is not None:
            voucher_ = self.voucher
            voucher_.to_etree(element, name_='voucher', mapping_=mapping_)
        if self.applePay is not None:
            applePay_ = self.applePay
            applePay_.to_etree(element, name_='applePay', mapping_=mapping_)
        if self.androidPay is not None:
            androidPay_ = self.androidPay
            androidPay_.to_etree(element, name_='androidPay', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='paymentMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(paymentMethod, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(paymentMethod, self).exportLiteralChildren(outfile, level, name_)
        if self.keyedCard is not None:
            showIndent(outfile, level)
            outfile.write('keyedCard=model_.keyedCard(\n')
            self.keyedCard.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.keyedAsTrack2 is not None:
            showIndent(outfile, level)
            outfile.write('keyedAsTrack2=model_.keyedAsTrackData(\n')
            self.keyedAsTrack2.exportLiteral(outfile, level, name_='keyedAsTrack2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.keyedEncrypted is not None:
            showIndent(outfile, level)
            outfile.write('keyedEncrypted=model_.keyedEncrypted(\n')
            self.keyedEncrypted.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secureCard is not None:
            showIndent(outfile, level)
            outfile.write('secureCard=model_.secureCardMethod(\n')
            self.secureCard.exportLiteral(outfile, level, name_='secureCard')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.track2 is not None:
            showIndent(outfile, level)
            outfile.write('track2=model_.trackData(\n')
            self.track2.exportLiteral(outfile, level, name_='track2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.track2Contactless is not None:
            showIndent(outfile, level)
            outfile.write('track2Contactless=model_.trackDataContactless(\n')
            self.track2Contactless.exportLiteral(outfile, level, name_='track2Contactless')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.emv is not None:
            showIndent(outfile, level)
            outfile.write('emv=model_.emv(\n')
            self.emv.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.emvTlv is not None:
            showIndent(outfile, level)
            outfile.write('emvTlv=model_.emvtlv(\n')
            self.emvTlv.exportLiteral(outfile, level, name_='emvTlv')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.voucher is not None:
            showIndent(outfile, level)
            outfile.write('voucher=model_.voucher(\n')
            self.voucher.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.applePay is not None:
            showIndent(outfile, level)
            outfile.write('applePay=model_.appleWallet(\n')
            self.applePay.exportLiteral(outfile, level, name_='applePay')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.androidPay is not None:
            showIndent(outfile, level)
            outfile.write('androidPay=model_.androidWallet(\n')
            self.androidPay.exportLiteral(outfile, level, name_='androidPay')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(paymentMethod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'keyedCard':
            obj_ = keyedCard.factory()
            obj_.build(child_)
            self.keyedCard = obj_
            obj_.original_tagname_ = 'keyedCard'
        elif nodeName_ == 'keyedAsTrack2':
            obj_ = keyedAsTrackData.factory()
            obj_.build(child_)
            self.keyedAsTrack2 = obj_
            obj_.original_tagname_ = 'keyedAsTrack2'
        elif nodeName_ == 'keyedEncrypted':
            obj_ = keyedEncrypted.factory()
            obj_.build(child_)
            self.keyedEncrypted = obj_
            obj_.original_tagname_ = 'keyedEncrypted'
        elif nodeName_ == 'secureCard':
            obj_ = secureCardMethod.factory()
            obj_.build(child_)
            self.secureCard = obj_
            obj_.original_tagname_ = 'secureCard'
        elif nodeName_ == 'track2':
            class_obj_ = self.get_class_obj_(child_, trackData)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.track2 = obj_
            obj_.original_tagname_ = 'track2'
        elif nodeName_ == 'track2Contactless':
            obj_ = trackDataContactless.factory()
            obj_.build(child_)
            self.track2Contactless = obj_
            obj_.original_tagname_ = 'track2Contactless'
        elif nodeName_ == 'emv':
            obj_ = emv.factory()
            obj_.build(child_)
            self.emv = obj_
            obj_.original_tagname_ = 'emv'
        elif nodeName_ == 'emvTlv':
            obj_ = emvtlv.factory()
            obj_.build(child_)
            self.emvTlv = obj_
            obj_.original_tagname_ = 'emvTlv'
        elif nodeName_ == 'voucher':
            obj_ = voucher.factory()
            obj_.build(child_)
            self.voucher = obj_
            obj_.original_tagname_ = 'voucher'
        elif nodeName_ == 'applePay':
            obj_ = appleWallet.factory()
            obj_.build(child_)
            self.applePay = obj_
            obj_.original_tagname_ = 'applePay'
        elif nodeName_ == 'androidPay':
            obj_ = androidWallet.factory()
            obj_.build(child_)
            self.androidPay = obj_
            obj_.original_tagname_ = 'androidPay'
        super(paymentMethod, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = []
        if self.keyedCard:
            hash_list.append(self.keyedCard.hash_string)
        if self.keyedAsTrack2:
            hash_list.append(self.keyedAsTrack2.hash_string)
        if self.keyedEncrypted:
            hash_list.append(self.keyedEncrypted.hash_string)
        if self.secureCard:
            hash_list.append(self.secureCard.hash_string)
        if self.track2:
            hash_list.append(self.track2.hash_string)
        if self.track2Contactless:
            hash_list.append(self.track2Contactless.hash_string)
        if self.emv:
            hash_list.append(self.emv.hash_string)
        if self.emvTlv:
            hash_list.append(self.emvTlv.hash_string)
        if self.voucher:
            hash_list.append(self.voucher.hash_string)
        if self.applePay:
            hash_list.append(self.applePay.hash_string)
        if self.androidPay:
            hash_list.append(self.androidPay.hash_string)
        return ':'.join(hash_list)
# end class paymentMethod


class cardDetails(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardAccount', ['cardAccount', 'xs:string'], 0, 1, {'name': 'cardAccount', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardHolderName', 'xs:string', 0, 1, {'name': 'cardHolderName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardNumber', 'xs:string', 0, 0, {'name': 'cardNumber', 'type': 'xs:string'}, None),
        MemberSpec_('cardType', 'xs:string', 0, 1, {'name': 'cardType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('expiryDate', 'xs:string', 0, 0, {'name': 'expiryDate', 'type': 'xs:string'}, None),
        MemberSpec_('pinDetails', 'pinDetails', 0, 1, {'name': 'pinDetails', 'type': 'pinDetails', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardAccount=None, cardHolderName=None, cardNumber=None, cardType=None, expiryDate=None, pinDetails=None, extensiontype_=None):
        self.original_tagname_ = None
        self.cardAccount = cardAccount
        self.validate_cardAccount(self.cardAccount)
        self.cardHolderName = cardHolderName
        self.cardNumber = cardNumber
        self.cardType = cardType
        self.expiryDate = expiryDate
        self.pinDetails = pinDetails
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardDetails.subclass:
            return cardDetails.subclass(*args_, **kwargs_)
        else:
            return cardDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardAccount(self): return self.cardAccount
    def set_cardAccount(self, cardAccount): self.cardAccount = cardAccount
    def get_cardHolderName(self): return self.cardHolderName
    def set_cardHolderName(self, cardHolderName): self.cardHolderName = cardHolderName
    def get_cardNumber(self): return self.cardNumber
    def set_cardNumber(self, cardNumber): self.cardNumber = cardNumber
    def get_cardType(self): return self.cardType
    def set_cardType(self, cardType): self.cardType = cardType
    def get_expiryDate(self): return self.expiryDate
    def set_expiryDate(self, expiryDate): self.expiryDate = expiryDate
    def get_pinDetails(self): return self.pinDetails
    def set_pinDetails(self, pinDetails): self.pinDetails = pinDetails
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cardAccount(self, value):
        # Validate type cardAccount, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CASH', 'FOOD_STAMP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cardAccount' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cardAccount is not None or
            self.cardHolderName is not None or
            self.cardNumber is not None or
            self.cardType is not None or
            self.expiryDate is not None or
            self.pinDetails is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='cardDetails', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.cardAccount is not None:
            cardAccount_ = self.cardAccount
            etree_.SubElement(element, '{}cardAccount').text = self.gds_format_string(cardAccount_)
        if self.cardHolderName is not None:
            cardHolderName_ = self.cardHolderName
            etree_.SubElement(element, '{}cardHolderName').text = self.gds_format_string(cardHolderName_)
        if self.cardNumber is not None:
            cardNumber_ = self.cardNumber
            etree_.SubElement(element, '{}cardNumber').text = self.gds_format_string(cardNumber_)
        if self.cardType is not None:
            cardType_ = self.cardType
            etree_.SubElement(element, '{}cardType').text = self.gds_format_string(cardType_)
        if self.expiryDate is not None:
            expiryDate_ = self.expiryDate
            etree_.SubElement(element, '{}expiryDate').text = self.gds_format_string(expiryDate_)
        if self.pinDetails is not None:
            pinDetails_ = self.pinDetails
            pinDetails_.to_etree(element, name_='pinDetails', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='cardDetails'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardAccount is not None:
            showIndent(outfile, level)
            outfile.write('cardAccount=%s,\n' % self.gds_encode(quote_python(self.cardAccount)))
        if self.cardHolderName is not None:
            showIndent(outfile, level)
            outfile.write('cardHolderName=%s,\n' % self.gds_encode(quote_python(self.cardHolderName)))
        if self.cardNumber is not None:
            showIndent(outfile, level)
            outfile.write('cardNumber=%s,\n' % self.gds_encode(quote_python(self.cardNumber)))
        if self.cardType is not None:
            showIndent(outfile, level)
            outfile.write('cardType=%s,\n' % self.gds_encode(quote_python(self.cardType)))
        if self.expiryDate is not None:
            showIndent(outfile, level)
            outfile.write('expiryDate=%s,\n' % self.gds_encode(quote_python(self.expiryDate)))
        if self.pinDetails is not None:
            showIndent(outfile, level)
            outfile.write('pinDetails=model_.pinDetails(\n')
            self.pinDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardAccount':
            cardAccount_ = child_.text
            cardAccount_ = self.gds_validate_string(cardAccount_, node, 'cardAccount')
            self.cardAccount = cardAccount_
            # validate type cardAccount
            self.validate_cardAccount(self.cardAccount)
        elif nodeName_ == 'cardHolderName':
            cardHolderName_ = child_.text
            cardHolderName_ = self.gds_validate_string(cardHolderName_, node, 'cardHolderName')
            self.cardHolderName = cardHolderName_
        elif nodeName_ == 'cardNumber':
            cardNumber_ = child_.text
            cardNumber_ = self.gds_validate_string(cardNumber_, node, 'cardNumber')
            self.cardNumber = cardNumber_
        elif nodeName_ == 'cardType':
            cardType_ = child_.text
            cardType_ = self.gds_validate_string(cardType_, node, 'cardType')
            self.cardType = cardType_
        elif nodeName_ == 'expiryDate':
            expiryDate_ = child_.text
            expiryDate_ = self.gds_validate_string(expiryDate_, node, 'expiryDate')
            self.expiryDate = expiryDate_
        elif nodeName_ == 'pinDetails':
            obj_ = pinDetails.factory()
            obj_.build(child_)
            self.pinDetails = obj_
            obj_.original_tagname_ = 'pinDetails'

    @property
    def hash_string(self):
        hash_list = []
        if self.cardAccount:
            hash_list.append(self.cardAccount)
        hash_list.append(self.cardNumber)
        if self.cardType:
            hash_list.append(self.cardType)
        hash_list.append(self.expiryDate)
        if self.pinDetails:
            hash_list.append(self.pinDetails.hash_string)
        return ':'.join(hash_list)
# end class cardDetails


class secureCardMethod(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardReference', 'xs:string', 0, 0, {'name': 'cardReference', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardReference=None):
        self.original_tagname_ = None
        self.cardReference = cardReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, secureCardMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if secureCardMethod.subclass:
            return secureCardMethod.subclass(*args_, **kwargs_)
        else:
            return secureCardMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardReference(self): return self.cardReference
    def set_cardReference(self, cardReference): self.cardReference = cardReference
    def hasContent_(self):
        if (
            self.cardReference is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='secureCardMethod', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cardReference is not None:
            cardReference_ = self.cardReference
            etree_.SubElement(element, '{}cardReference').text = self.gds_format_string(cardReference_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='secureCardMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardReference is not None:
            showIndent(outfile, level)
            outfile.write('cardReference=%s,\n' % self.gds_encode(quote_python(self.cardReference)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardReference':
            cardReference_ = child_.text
            cardReference_ = self.gds_validate_string(cardReference_, node, 'cardReference')
            self.cardReference = cardReference_
    @property
    def hash_string(self):
        return ':'.join([self.cardReference])
# end class secureCardMethod


class trackDataContactless(trackData):
    member_data_items_ = [
        MemberSpec_('additionalTags', 'xs:string', 0, 1, {'name': 'additionalTags', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = trackData
    def __init__(self, cardAccount=None, cardHolderName=None, cardType=None, encryptedData=None, fallback=None, fallbackReason=None, firstDigitOfPan=None, ksn=None, pinDetails=None, serial=None, additionalTags=None):
        self.original_tagname_ = None
        super(trackDataContactless, self).__init__(cardAccount, cardHolderName, cardType, encryptedData, fallback, fallbackReason, firstDigitOfPan, ksn, pinDetails, serial, )
        self.additionalTags = additionalTags
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackDataContactless)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackDataContactless.subclass:
            return trackDataContactless.subclass(*args_, **kwargs_)
        else:
            return trackDataContactless(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_additionalTags(self): return self.additionalTags
    def set_additionalTags(self, additionalTags): self.additionalTags = additionalTags
    def hasContent_(self):
        if (
            self.additionalTags is not None or
            super(trackDataContactless, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='trackDataContactless', mapping_=None):
        element = super(trackDataContactless, self).to_etree(parent_element, name_, mapping_)
        if self.additionalTags is not None:
            additionalTags_ = self.additionalTags
            etree_.SubElement(element, '{}additionalTags').text = self.gds_format_string(additionalTags_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='trackDataContactless'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(trackDataContactless, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(trackDataContactless, self).exportLiteralChildren(outfile, level, name_)
        if self.additionalTags is not None:
            showIndent(outfile, level)
            outfile.write('additionalTags=%s,\n' % self.gds_encode(quote_python(self.additionalTags)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(trackDataContactless, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'additionalTags':
            additionalTags_ = child_.text
            additionalTags_ = self.gds_validate_string(additionalTags_, node, 'additionalTags')
            self.additionalTags = additionalTags_
        super(trackDataContactless, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = []
        if self.additionalTags:
            hash_list.append(self.additionalTags)
        if self.cardHolderName:
            hash_list.append(self.cardHolderName)
        if self.cardType:
            hash_list.append(self.cardType)
        hash_list.append(self.encryptedData)
        if self.fallback:
            hash_list.append(self.fallback)
        hash_list.append(self.ksn)
        return ':'.join(hash_list)
# end class trackDataContactless


class voucher(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardAccount', ['cardAccount', 'xs:string'], 0, 1, {'name': 'cardAccount', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardNumber', 'xs:string', 0, 0, {'name': 'cardNumber', 'type': 'xs:string'}, None),
        MemberSpec_('cardType', 'xs:string', 0, 0, {'name': 'cardType', 'type': 'xs:string'}, None),
        MemberSpec_('voucherApprovalCode', 'xs:string', 0, 0, {'name': 'voucherApprovalCode', 'type': 'xs:string'}, None),
        MemberSpec_('voucherNumber', 'xs:string', 0, 0, {'name': 'voucherNumber', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardAccount=None, cardNumber=None, cardType=None, voucherApprovalCode=None, voucherNumber=None):
        self.original_tagname_ = None
        self.cardAccount = cardAccount
        self.validate_cardAccount(self.cardAccount)
        self.cardNumber = cardNumber
        self.cardType = cardType
        self.voucherApprovalCode = voucherApprovalCode
        self.voucherNumber = voucherNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, voucher)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if voucher.subclass:
            return voucher.subclass(*args_, **kwargs_)
        else:
            return voucher(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardAccount(self): return self.cardAccount
    def set_cardAccount(self, cardAccount): self.cardAccount = cardAccount
    def get_cardNumber(self): return self.cardNumber
    def set_cardNumber(self, cardNumber): self.cardNumber = cardNumber
    def get_cardType(self): return self.cardType
    def set_cardType(self, cardType): self.cardType = cardType
    def get_voucherApprovalCode(self): return self.voucherApprovalCode
    def set_voucherApprovalCode(self, voucherApprovalCode): self.voucherApprovalCode = voucherApprovalCode
    def get_voucherNumber(self): return self.voucherNumber
    def set_voucherNumber(self, voucherNumber): self.voucherNumber = voucherNumber
    def validate_cardAccount(self, value):
        # Validate type cardAccount, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CASH', 'FOOD_STAMP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cardAccount' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cardAccount is not None or
            self.cardNumber is not None or
            self.cardType is not None or
            self.voucherApprovalCode is not None or
            self.voucherNumber is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='voucher', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cardAccount is not None:
            cardAccount_ = self.cardAccount
            etree_.SubElement(element, '{}cardAccount').text = self.gds_format_string(cardAccount_)
        if self.cardNumber is not None:
            cardNumber_ = self.cardNumber
            etree_.SubElement(element, '{}cardNumber').text = self.gds_format_string(cardNumber_)
        if self.cardType is not None:
            cardType_ = self.cardType
            etree_.SubElement(element, '{}cardType').text = self.gds_format_string(cardType_)
        if self.voucherApprovalCode is not None:
            voucherApprovalCode_ = self.voucherApprovalCode
            etree_.SubElement(element, '{}voucherApprovalCode').text = self.gds_format_string(voucherApprovalCode_)
        if self.voucherNumber is not None:
            voucherNumber_ = self.voucherNumber
            etree_.SubElement(element, '{}voucherNumber').text = self.gds_format_string(voucherNumber_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='voucher'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardAccount is not None:
            showIndent(outfile, level)
            outfile.write('cardAccount=%s,\n' % self.gds_encode(quote_python(self.cardAccount)))
        if self.cardNumber is not None:
            showIndent(outfile, level)
            outfile.write('cardNumber=%s,\n' % self.gds_encode(quote_python(self.cardNumber)))
        if self.cardType is not None:
            showIndent(outfile, level)
            outfile.write('cardType=%s,\n' % self.gds_encode(quote_python(self.cardType)))
        if self.voucherApprovalCode is not None:
            showIndent(outfile, level)
            outfile.write('voucherApprovalCode=%s,\n' % self.gds_encode(quote_python(self.voucherApprovalCode)))
        if self.voucherNumber is not None:
            showIndent(outfile, level)
            outfile.write('voucherNumber=%s,\n' % self.gds_encode(quote_python(self.voucherNumber)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardAccount':
            cardAccount_ = child_.text
            cardAccount_ = self.gds_validate_string(cardAccount_, node, 'cardAccount')
            self.cardAccount = cardAccount_
            # validate type cardAccount
            self.validate_cardAccount(self.cardAccount)
        elif nodeName_ == 'cardNumber':
            cardNumber_ = child_.text
            cardNumber_ = self.gds_validate_string(cardNumber_, node, 'cardNumber')
            self.cardNumber = cardNumber_
        elif nodeName_ == 'cardType':
            cardType_ = child_.text
            cardType_ = self.gds_validate_string(cardType_, node, 'cardType')
            self.cardType = cardType_
        elif nodeName_ == 'voucherApprovalCode':
            voucherApprovalCode_ = child_.text
            voucherApprovalCode_ = self.gds_validate_string(voucherApprovalCode_, node, 'voucherApprovalCode')
            self.voucherApprovalCode = voucherApprovalCode_
        elif nodeName_ == 'voucherNumber':
            voucherNumber_ = child_.text
            voucherNumber_ = self.gds_validate_string(voucherNumber_, node, 'voucherNumber')
            self.voucherNumber = voucherNumber_

    @property
    def hash_string(self):
        hash_list = []
        if self.cardAccount:
            hash_list.append(self.cardAccount)
        hash_list.append(self.cardNumber)
        hash_list.append(self.cardType)
        hash_list.append(self.voucherApprovalCode)
        hash_list.append(self.voucherNumber)
        return ':'.join(hash_list)
# end class voucher


class appleWallet(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('payload', 'xs:string', 0, 0, {'name': 'payload', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, payload=None):
        self.original_tagname_ = None
        self.payload = payload
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, appleWallet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if appleWallet.subclass:
            return appleWallet.subclass(*args_, **kwargs_)
        else:
            return appleWallet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payload(self): return self.payload
    def set_payload(self, payload): self.payload = payload
    def hasContent_(self):
        if (
            self.payload is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='appleWallet', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.payload is not None:
            payload_ = self.payload
            etree_.SubElement(element, '{}payload').text = self.gds_format_string(payload_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='appleWallet'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.payload is not None:
            showIndent(outfile, level)
            outfile.write('payload=%s,\n' % self.gds_encode(quote_python(self.payload)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payload':
            payload_ = child_.text
            payload_ = self.gds_validate_string(payload_, node, 'payload')
            self.payload = payload_

    @property
    def hash_string(self):
        return ':'.join([self.payload])
# end class appleWallet


class androidWallet(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardType', 'xs:string', 0, 1, {'name': 'cardType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cardholderName', 'xs:string', 0, 1, {'name': 'cardholderName', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('payload', 'xs:string', 0, 0, {'name': 'payload', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardType=None, cardholderName=None, payload=None):
        self.original_tagname_ = None
        self.cardType = cardType
        self.cardholderName = cardholderName
        self.payload = payload
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, androidWallet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if androidWallet.subclass:
            return androidWallet.subclass(*args_, **kwargs_)
        else:
            return androidWallet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardType(self): return self.cardType
    def set_cardType(self, cardType): self.cardType = cardType
    def get_cardholderName(self): return self.cardholderName
    def set_cardholderName(self, cardholderName): self.cardholderName = cardholderName
    def get_payload(self): return self.payload
    def set_payload(self, payload): self.payload = payload
    def hasContent_(self):
        if (
            self.cardType is not None or
            self.cardholderName is not None or
            self.payload is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='androidWallet', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cardType is not None:
            cardType_ = self.cardType
            etree_.SubElement(element, '{}cardType').text = self.gds_format_string(cardType_)
        if self.cardholderName is not None:
            cardholderName_ = self.cardholderName
            etree_.SubElement(element, '{}cardholderName').text = self.gds_format_string(cardholderName_)
        if self.payload is not None:
            payload_ = self.payload
            etree_.SubElement(element, '{}payload').text = self.gds_format_string(payload_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='androidWallet'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardType is not None:
            showIndent(outfile, level)
            outfile.write('cardType=%s,\n' % self.gds_encode(quote_python(self.cardType)))
        if self.cardholderName is not None:
            showIndent(outfile, level)
            outfile.write('cardholderName=%s,\n' % self.gds_encode(quote_python(self.cardholderName)))
        if self.payload is not None:
            showIndent(outfile, level)
            outfile.write('payload=%s,\n' % self.gds_encode(quote_python(self.payload)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardType':
            cardType_ = child_.text
            cardType_ = self.gds_validate_string(cardType_, node, 'cardType')
            self.cardType = cardType_
        elif nodeName_ == 'cardholderName':
            cardholderName_ = child_.text
            cardholderName_ = self.gds_validate_string(cardholderName_, node, 'cardholderName')
            self.cardholderName = cardholderName_
        elif nodeName_ == 'payload':
            payload_ = child_.text
            payload_ = self.gds_validate_string(payload_, node, 'payload')
            self.payload = payload_

    @property
    def hash_string(self):
        return ':'.join([self.payload])
# end class androidWallet


class standardRequest(protectedMethod):
    member_data_items_ = [
        MemberSpec_('account', 'account', 0, 0, {'name': 'account', 'type': 'account'}, None),
        MemberSpec_('apiKey', 'xs:string', 0, 0, {'name': 'apiKey', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, account=None, apiKey=None, extensiontype_=None):
        self.original_tagname_ = None
        super(standardRequest, self).__init__(dateTime, hash, extensiontype_, )
        self.account = account
        self.apiKey = apiKey
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, standardRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if standardRequest.subclass:
            return standardRequest.subclass(*args_, **kwargs_)
        else:
            return standardRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def get_apiKey(self): return self.apiKey
    def set_apiKey(self, apiKey): self.apiKey = apiKey
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.account is not None or
            self.apiKey is not None or
            super(standardRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='standardRequest', mapping_=None):
        element = super(standardRequest, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.account is not None:
            account_ = self.account
            account_.to_etree(element, name_='account', mapping_=mapping_)
        if self.apiKey is not None:
            apiKey_ = self.apiKey
            etree_.SubElement(element, '{}apiKey').text = self.gds_format_string(apiKey_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='standardRequest'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(standardRequest, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(standardRequest, self).exportLiteralChildren(outfile, level, name_)
        if self.account is not None:
            showIndent(outfile, level)
            outfile.write('account=model_.account(\n')
            self.account.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.apiKey is not None:
            showIndent(outfile, level)
            outfile.write('apiKey=%s,\n' % self.gds_encode(quote_python(self.apiKey)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(standardRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'account':
            obj_ = account.factory()
            obj_.build(child_)
            self.account = obj_
            obj_.original_tagname_ = 'account'
        elif nodeName_ == 'apiKey':
            apiKey_ = child_.text
            apiKey_ = self.gds_validate_string(apiKey_, node, 'apiKey')
            self.apiKey = apiKey_
        super(standardRequest, self).buildChildren(child_, node, nodeName_, True)
# end class standardRequest


class transaction(protectedMethod):
    member_data_items_ = [
        MemberSpec_('account', 'account', 0, 0, {'name': 'account', 'type': 'account'}, None),
        MemberSpec_('amount', 'amount', 0, 0, {'name': 'amount', 'type': 'amount'}, None),
        MemberSpec_('autoReady', 'xs:boolean', 0, 1, {'name': 'autoReady', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('commerceType', ['commerceType', 'xs:string'], 0, 1, {'name': 'commerceType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('customer', 'customer', 0, 1, {'name': 'customer', 'type': 'customer', 'minOccurs': '0'}, None),
        MemberSpec_('receiptDetailsRequired', 'xs:boolean', 0, 0, {'name': 'receiptDetailsRequired', 'type': 'xs:boolean'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, account=None, amount=None, autoReady=None, commerceType=None, customer=None, receiptDetailsRequired=None, extensiontype_=None):
        self.original_tagname_ = None
        super(transaction, self).__init__(dateTime, hash, extensiontype_, )
        self.account = account
        self.amount = amount
        self.autoReady = autoReady
        self.commerceType = commerceType
        self.validate_commerceType(self.commerceType)
        self.customer = customer
        self.receiptDetailsRequired = receiptDetailsRequired
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transaction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transaction.subclass:
            return transaction.subclass(*args_, **kwargs_)
        else:
            return transaction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_autoReady(self): return self.autoReady
    def set_autoReady(self, autoReady): self.autoReady = autoReady
    def get_commerceType(self): return self.commerceType
    def set_commerceType(self, commerceType): self.commerceType = commerceType
    def get_customer(self): return self.customer
    def set_customer(self, customer): self.customer = customer
    def get_receiptDetailsRequired(self): return self.receiptDetailsRequired
    def set_receiptDetailsRequired(self, receiptDetailsRequired): self.receiptDetailsRequired = receiptDetailsRequired
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_commerceType(self, value):
        # Validate type commerceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NOT_APPLICABLE', 'INTERNET', 'INTERNET_3DS_SECURED', 'INTERNET_3DS_ATTEMPTED', 'MO', 'MOTO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on commerceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.account is not None or
            self.amount is not None or
            self.autoReady is not None or
            self.commerceType is not None or
            self.customer is not None or
            self.receiptDetailsRequired is not None or
            super(transaction, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='transaction', mapping_=None):
        element = super(transaction, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.account is not None:
            account_ = self.account
            account_.to_etree(element, name_='account', mapping_=mapping_)
        if self.amount is not None:
            amount_ = self.amount
            amount_.to_etree(element, name_='amount', mapping_=mapping_)
        if self.autoReady is not None:
            autoReady_ = self.autoReady
            etree_.SubElement(element, '{}autoReady').text = self.gds_format_boolean(autoReady_)
        if self.commerceType is not None:
            commerceType_ = self.commerceType
            etree_.SubElement(element, '{}commerceType').text = self.gds_format_string(commerceType_)
        if self.customer is not None:
            customer_ = self.customer
            customer_.to_etree(element, name_='customer', mapping_=mapping_)
        if self.receiptDetailsRequired is not None:
            receiptDetailsRequired_ = self.receiptDetailsRequired
            etree_.SubElement(element, '{}receiptDetailsRequired').text = self.gds_format_boolean(receiptDetailsRequired_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='transaction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(transaction, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(transaction, self).exportLiteralChildren(outfile, level, name_)
        if self.account is not None:
            showIndent(outfile, level)
            outfile.write('account=model_.account(\n')
            self.account.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.amount is not None:
            showIndent(outfile, level)
            outfile.write('amount=model_.amount(\n')
            self.amount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.autoReady is not None:
            showIndent(outfile, level)
            outfile.write('autoReady=%s,\n' % self.autoReady)
        if self.commerceType is not None:
            showIndent(outfile, level)
            outfile.write('commerceType=%s,\n' % self.gds_encode(quote_python(self.commerceType)))
        if self.customer is not None:
            showIndent(outfile, level)
            outfile.write('customer=model_.customer(\n')
            self.customer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.receiptDetailsRequired is not None:
            showIndent(outfile, level)
            outfile.write('receiptDetailsRequired=%s,\n' % self.receiptDetailsRequired)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(transaction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'account':
            obj_ = account.factory()
            obj_.build(child_)
            self.account = obj_
            obj_.original_tagname_ = 'account'
        elif nodeName_ == 'amount':
            class_obj_ = self.get_class_obj_(child_, amount)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.amount = obj_
            obj_.original_tagname_ = 'amount'
        elif nodeName_ == 'autoReady':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'autoReady')
            self.autoReady = ival_
        elif nodeName_ == 'commerceType':
            commerceType_ = child_.text
            commerceType_ = self.gds_validate_string(commerceType_, node, 'commerceType')
            self.commerceType = commerceType_
            # validate type commerceType
            self.validate_commerceType(self.commerceType)
        elif nodeName_ == 'customer':
            obj_ = customer.factory()
            obj_.build(child_)
            self.customer = obj_
            obj_.original_tagname_ = 'customer'
        elif nodeName_ == 'receiptDetailsRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'receiptDetailsRequired')
            self.receiptDetailsRequired = ival_
        super(transaction, self).buildChildren(child_, node, nodeName_, True)
# end class transaction


class avs(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('address1', 'xs:string', 0, 1, {'name': 'address1', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('address2', 'xs:string', 0, 1, {'name': 'address2', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('postCode', 'xs:string', 0, 1, {'name': 'postCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, address1=None, address2=None, postCode=None):
        self.original_tagname_ = None
        self.address1 = address1
        self.address2 = address2
        self.postCode = postCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, avs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if avs.subclass:
            return avs.subclass(*args_, **kwargs_)
        else:
            return avs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address1(self): return self.address1
    def set_address1(self, address1): self.address1 = address1
    def get_address2(self): return self.address2
    def set_address2(self, address2): self.address2 = address2
    def get_postCode(self): return self.postCode
    def set_postCode(self, postCode): self.postCode = postCode
    def hasContent_(self):
        if (
            self.address1 is not None or
            self.address2 is not None or
            self.postCode is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='avs', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.address1 is not None:
            address1_ = self.address1
            etree_.SubElement(element, '{}address1').text = self.gds_format_string(address1_)
        if self.address2 is not None:
            address2_ = self.address2
            etree_.SubElement(element, '{}address2').text = self.gds_format_string(address2_)
        if self.postCode is not None:
            postCode_ = self.postCode
            etree_.SubElement(element, '{}postCode').text = self.gds_format_string(postCode_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='avs'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.address1 is not None:
            showIndent(outfile, level)
            outfile.write('address1=%s,\n' % self.gds_encode(quote_python(self.address1)))
        if self.address2 is not None:
            showIndent(outfile, level)
            outfile.write('address2=%s,\n' % self.gds_encode(quote_python(self.address2)))
        if self.postCode is not None:
            showIndent(outfile, level)
            outfile.write('postCode=%s,\n' % self.gds_encode(quote_python(self.postCode)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address1':
            address1_ = child_.text
            address1_ = self.gds_validate_string(address1_, node, 'address1')
            self.address1 = address1_
        elif nodeName_ == 'address2':
            address2_ = child_.text
            address2_ = self.gds_validate_string(address2_, node, 'address2')
            self.address2 = address2_
        elif nodeName_ == 'postCode':
            postCode_ = child_.text
            postCode_ = self.gds_validate_string(postCode_, node, 'postCode')
            self.postCode = postCode_

    @property
    def hash_string(self):
        hash_list = []
        if self.address1:
            hash_list.append(self.address1)
        if self.address2:
            hash_list.append(self.address2)
        if self.postCode:
            hash_list.append(self.postCode)
        return ':'.join(hash_list)
# end class avs


class currencyRate(amount):
    member_data_items_ = [
        MemberSpec_('rate', 'xs:decimal', 0, 0, {'name': 'rate', 'type': 'xs:decimal'}, None),
    ]
    subclass = None
    superclass = amount
    def __init__(self, amount_member=None, cashBackAmount=None, currency=None, rate=None):
        self.original_tagname_ = None
        super(currencyRate, self).__init__(amount_member, cashBackAmount, currency, )
        self.rate = rate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, currencyRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if currencyRate.subclass:
            return currencyRate.subclass(*args_, **kwargs_)
        else:
            return currencyRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def hasContent_(self):
        if (
            self.rate is not None or
            super(currencyRate, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='currencyRate', mapping_=None):
        element = super(currencyRate, self).to_etree(parent_element, name_, mapping_)
        if self.rate is not None:
            rate_ = self.rate
            etree_.SubElement(element, '{}rate').text = self.gds_format_float(rate_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='currencyRate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(currencyRate, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(currencyRate, self).exportLiteralChildren(outfile, level, name_)
        if self.rate is not None:
            showIndent(outfile, level)
            outfile.write('rate=%f,\n' % self.rate)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(currencyRate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rate')
            self.rate = fval_
        super(currencyRate, self).buildChildren(child_, node, nodeName_, True)
# end class currencyRate


class serviceError(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('code', 'xs:string', 0, 1, {'name': 'code', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('message', 'xs:string', 0, 1, {'name': 'message', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('validationErrors', 'validationErrorsType', 0, 1, {'name': 'validationErrors', 'minOccurs': '0', 'type': 'validationErrorsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, code=None, message=None, validationErrors=None):
        self.original_tagname_ = None
        self.code = code
        self.message = message
        self.validationErrors = validationErrors
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serviceError)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serviceError.subclass:
            return serviceError.subclass(*args_, **kwargs_)
        else:
            return serviceError(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_validationErrors(self): return self.validationErrors
    def set_validationErrors(self, validationErrors): self.validationErrors = validationErrors
    def hasContent_(self):
        if (
            self.code is not None or
            self.message is not None or
            self.validationErrors is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='serviceError', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.code is not None:
            code_ = self.code
            etree_.SubElement(element, '{}code').text = self.gds_format_string(code_)
        if self.message is not None:
            message_ = self.message
            etree_.SubElement(element, '{}message').text = self.gds_format_string(message_)
        if self.validationErrors is not None:
            validationErrors_ = self.validationErrors
            validationErrors_.to_etree(element, name_='validationErrors', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='serviceError'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.code is not None:
            showIndent(outfile, level)
            outfile.write('code=%s,\n' % self.gds_encode(quote_python(self.code)))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % self.gds_encode(quote_python(self.message)))
        if self.validationErrors is not None:
            showIndent(outfile, level)
            outfile.write('validationErrors=model_.validationErrorsType(\n')
            self.validationErrors.exportLiteral(outfile, level, name_='validationErrors')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            code_ = child_.text
            code_ = self.gds_validate_string(code_, node, 'code')
            self.code = code_
        elif nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
        elif nodeName_ == 'validationErrors':
            obj_ = validationErrorsType.factory()
            obj_.build(child_)
            self.validationErrors = obj_
            obj_.original_tagname_ = 'validationErrors'
# end class serviceError


class validationError(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('code', 'xs:string', 0, 1, {'name': 'code', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('message', 'xs:string', 0, 1, {'name': 'message', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('target', 'xs:string', 0, 1, {'name': 'target', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, code=None, message=None, target=None):
        self.original_tagname_ = None
        self.code = code
        self.message = message
        self.target = target
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, validationError)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if validationError.subclass:
            return validationError.subclass(*args_, **kwargs_)
        else:
            return validationError(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def hasContent_(self):
        if (
            self.code is not None or
            self.message is not None or
            self.target is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='validationError', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.code is not None:
            code_ = self.code
            etree_.SubElement(element, '{}code').text = self.gds_format_string(code_)
        if self.message is not None:
            message_ = self.message
            etree_.SubElement(element, '{}message').text = self.gds_format_string(message_)
        if self.target is not None:
            target_ = self.target
            etree_.SubElement(element, '{}target').text = self.gds_format_string(target_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='validationError'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.code is not None:
            showIndent(outfile, level)
            outfile.write('code=%s,\n' % self.gds_encode(quote_python(self.code)))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % self.gds_encode(quote_python(self.message)))
        if self.target is not None:
            showIndent(outfile, level)
            outfile.write('target=%s,\n' % self.gds_encode(quote_python(self.target)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            code_ = child_.text
            code_ = self.gds_validate_string(code_, node, 'code')
            self.code = code_
        elif nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
        elif nodeName_ == 'target':
            target_ = child_.text
            target_ = self.gds_validate_string(target_, node, 'target')
            self.target = target_
# end class validationError


class refund(transaction):
    member_data_items_ = [
        MemberSpec_('device', 'posDevice', 0, 1, {'name': 'device', 'type': 'posDevice', 'minOccurs': '0'}, None),
        MemberSpec_('deviceType', 'xs:string', 0, 1, {'name': 'deviceType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('refundMethod', 'refundMethod', 0, 0, {'name': 'refundMethod', 'type': 'refundMethod'}, None),
    ]
    subclass = None
    superclass = transaction
    def __init__(self, dateTime=None, hash=None, account=None, amount=None, autoReady=None, commerceType=None, customer=None, receiptDetailsRequired=None, device=None, deviceType=None, refundMethod=None):
        self.original_tagname_ = None
        super(refund, self).__init__(dateTime, hash, account, amount, autoReady, commerceType, customer, receiptDetailsRequired, )
        self.device = device
        self.deviceType = deviceType
        self.refundMethod = refundMethod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refund)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refund.subclass:
            return refund.subclass(*args_, **kwargs_)
        else:
            return refund(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_device(self): return self.device
    def set_device(self, device): self.device = device
    def get_deviceType(self): return self.deviceType
    def set_deviceType(self, deviceType): self.deviceType = deviceType
    def get_refundMethod(self): return self.refundMethod
    def set_refundMethod(self, refundMethod): self.refundMethod = refundMethod
    def hasContent_(self):
        if (
            self.device is not None or
            self.deviceType is not None or
            self.refundMethod is not None or
            super(refund, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='refund', mapping_=None):
        element = super(refund, self).to_etree(parent_element, name_, mapping_)
        if self.device is not None:
            device_ = self.device
            device_.to_etree(element, name_='device', mapping_=mapping_)
        if self.deviceType is not None:
            deviceType_ = self.deviceType
            etree_.SubElement(element, '{}deviceType').text = self.gds_format_string(deviceType_)
        if self.refundMethod is not None:
            refundMethod_ = self.refundMethod
            refundMethod_.to_etree(element, name_='refundMethod', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='refund'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(refund, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(refund, self).exportLiteralChildren(outfile, level, name_)
        if self.device is not None:
            showIndent(outfile, level)
            outfile.write('device=model_.posDevice(\n')
            self.device.exportLiteral(outfile, level, name_='device')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deviceType is not None:
            showIndent(outfile, level)
            outfile.write('deviceType=%s,\n' % self.gds_encode(quote_python(self.deviceType)))
        if self.refundMethod is not None:
            showIndent(outfile, level)
            outfile.write('refundMethod=model_.refundMethod(\n')
            self.refundMethod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(refund, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'device':
            obj_ = posDevice.factory()
            obj_.build(child_)
            self.device = obj_
            obj_.original_tagname_ = 'device'
        elif nodeName_ == 'deviceType':
            deviceType_ = child_.text
            deviceType_ = self.gds_validate_string(deviceType_, node, 'deviceType')
            self.deviceType = deviceType_
        elif nodeName_ == 'refundMethod':
            obj_ = refundMethod.factory()
            obj_.build(child_)
            self.refundMethod = obj_
            obj_.original_tagname_ = 'refundMethod'
        super(refund, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = []
        if self.device:
            hash_list.append(self.device.hash_string)
        if self.deviceType:
            hash_list.append(self.deviceType)
        hash_list.append(self.refundMethod.hash_string)
        if self.refundMethod.unreferenced:
            hash_list.append('UNREFERENCED')
        if self.refundMethod.referenced:
            hash_list.append('REFERENCED')
        hash_list.append(self.account.hash_string)
        hash_list.append(self.amount.hash_string)
        if self.autoReady:
            hash_list.append(self.autoReady)
        if self.commerceType:
            hash_list.append(self.commerceType)
        if self.customer:
            hash_list.append(self.customer.hash_string)
        hash_list.append(str(self.dateTime.isoformat('T', 'seconds')))
        return ':'.join(hash_list)
# end class refund


class refundMethod(baseMethod):
    member_data_items_ = [
        MemberSpec_('referenced', 'refundReferenced', 0, 0, {'ref': 'referenced', 'name': 'referenced', 'type': 'referenced'}, 4),
        MemberSpec_('unreferenced', 'refundUnreferenced', 0, 0, {'ref': 'unreferenced', 'name': 'unreferenced', 'type': 'unreferenced'}, 4),
    ]
    subclass = None
    superclass = baseMethod
    def __init__(self, referenced=None, unreferenced=None):
        self.original_tagname_ = None
        super(refundMethod, self).__init__()
        self.referenced = referenced
        self.unreferenced = unreferenced
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refundMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refundMethod.subclass:
            return refundMethod.subclass(*args_, **kwargs_)
        else:
            return refundMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenced(self): return self.referenced
    def set_referenced(self, referenced): self.referenced = referenced
    def get_unreferenced(self): return self.unreferenced
    def set_unreferenced(self, unreferenced): self.unreferenced = unreferenced
    def hasContent_(self):
        if (
            self.referenced is not None or
            self.unreferenced is not None or
            super(refundMethod, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='refundMethod', mapping_=None):
        element = super(refundMethod, self).to_etree(parent_element, name_, mapping_)
        if self.referenced is not None:
            referenced_ = self.referenced
            referenced_.to_etree(element, name_='referenced', mapping_=mapping_)
        if self.unreferenced is not None:
            unreferenced_ = self.unreferenced
            unreferenced_.to_etree(element, name_='unreferenced', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='refundMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(refundMethod, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(refundMethod, self).exportLiteralChildren(outfile, level, name_)
        if self.referenced is not None:
            showIndent(outfile, level)
            outfile.write('referenced=model_.referenced(\n')
            self.referenced.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.unreferenced is not None:
            showIndent(outfile, level)
            outfile.write('unreferenced=model_.unreferenced(\n')
            self.unreferenced.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(refundMethod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenced':
            obj_ = refundReferenced.factory()
            obj_.build(child_)
            self.referenced = obj_
            obj_.original_tagname_ = 'referenced'
        elif nodeName_ == 'unreferenced':
            obj_ = refundUnreferenced.factory()
            obj_.build(child_)
            self.unreferenced = obj_
            obj_.original_tagname_ = 'unreferenced'
        super(refundMethod, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = []
        if self.referenced:
            hash_list.append(self.referenced.hash_string)
        if self.unreferenced:
            hash_list.append(self.unreferenced.hash_string)
        return ':'.join(hash_list)
# end class refundMethod


class refundBaseMethod(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('reason', 'xs:string', 0, 0, {'name': 'reason', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, reason=None, extensiontype_=None):
        self.original_tagname_ = None
        self.reason = reason
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refundBaseMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refundBaseMethod.subclass:
            return refundBaseMethod.subclass(*args_, **kwargs_)
        else:
            return refundBaseMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reason(self): return self.reason
    def set_reason(self, reason): self.reason = reason
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.reason is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='refundBaseMethod', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.reason is not None:
            reason_ = self.reason
            etree_.SubElement(element, '{}reason').text = self.gds_format_string(reason_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='refundBaseMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.reason is not None:
            showIndent(outfile, level)
            outfile.write('reason=%s,\n' % self.gds_encode(quote_python(self.reason)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reason':
            reason_ = child_.text
            reason_ = self.gds_validate_string(reason_, node, 'reason')
            self.reason = reason_
# end class refundBaseMethod


class refundUnreferenced(refundBaseMethod):
    member_data_items_ = [
        MemberSpec_('cardDetails', 'cardDetails', 0, 0, {'name': 'cardDetails', 'type': 'cardDetails'}, 6),
        MemberSpec_('keyedAsTrack2', 'keyedAsTrackData', 0, 0, {'name': 'keyedAsTrack2', 'type': 'keyedAsTrackData'}, 6),
        MemberSpec_('keyedEncrypted', 'keyedEncrypted', 0, 0, {'name': 'keyedEncrypted', 'type': 'keyedEncrypted'}, 6),
        MemberSpec_('cardRef', 'xs:string', 0, 0, {'name': 'cardRef', 'type': 'xs:string'}, 6),
        MemberSpec_('track2', 'trackData', 0, 0, {'name': 'track2', 'type': 'trackData'}, 6),
        MemberSpec_('emv', 'emv', 0, 0, {'name': 'emv', 'type': 'emv'}, 6),
        MemberSpec_('emvTlv', 'emvtlv', 0, 0, {'name': 'emvTlv', 'type': 'emvtlv'}, 6),
        MemberSpec_('voucher', 'voucher', 0, 0, {'name': 'voucher', 'type': 'voucher'}, 6),
        MemberSpec_('orderId', 'xs:string', 0, 0, {'name': 'orderId', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = refundBaseMethod
    def __init__(self, reason=None, cardDetails=None, keyedAsTrack2=None, keyedEncrypted=None, cardRef=None, track2=None, emv=None, emvTlv=None, voucher=None, orderId=None):
        self.original_tagname_ = None
        super(refundUnreferenced, self).__init__(reason, )
        self.cardDetails = cardDetails
        self.keyedAsTrack2 = keyedAsTrack2
        self.keyedEncrypted = keyedEncrypted
        self.cardRef = cardRef
        self.track2 = track2
        self.emv = emv
        self.emvTlv = emvTlv
        self.voucher = voucher
        self.orderId = orderId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refundUnreferenced)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refundUnreferenced.subclass:
            return refundUnreferenced.subclass(*args_, **kwargs_)
        else:
            return refundUnreferenced(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardDetails(self): return self.cardDetails
    def set_cardDetails(self, cardDetails): self.cardDetails = cardDetails
    def get_keyedAsTrack2(self): return self.keyedAsTrack2
    def set_keyedAsTrack2(self, keyedAsTrack2): self.keyedAsTrack2 = keyedAsTrack2
    def get_keyedEncrypted(self): return self.keyedEncrypted
    def set_keyedEncrypted(self, keyedEncrypted): self.keyedEncrypted = keyedEncrypted
    def get_cardRef(self): return self.cardRef
    def set_cardRef(self, cardRef): self.cardRef = cardRef
    def get_track2(self): return self.track2
    def set_track2(self, track2): self.track2 = track2
    def get_emv(self): return self.emv
    def set_emv(self, emv): self.emv = emv
    def get_emvTlv(self): return self.emvTlv
    def set_emvTlv(self, emvTlv): self.emvTlv = emvTlv
    def get_voucher(self): return self.voucher
    def set_voucher(self, voucher): self.voucher = voucher
    def get_orderId(self): return self.orderId
    def set_orderId(self, orderId): self.orderId = orderId
    def hasContent_(self):
        if (
            self.cardDetails is not None or
            self.keyedAsTrack2 is not None or
            self.keyedEncrypted is not None or
            self.cardRef is not None or
            self.track2 is not None or
            self.emv is not None or
            self.emvTlv is not None or
            self.voucher is not None or
            self.orderId is not None or
            super(refundUnreferenced, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='refundUnreferenced', mapping_=None):
        element = super(refundUnreferenced, self).to_etree(parent_element, name_, mapping_)
        if self.cardDetails is not None:
            cardDetails_ = self.cardDetails
            cardDetails_.to_etree(element, name_='cardDetails', mapping_=mapping_)
        if self.keyedAsTrack2 is not None:
            keyedAsTrack2_ = self.keyedAsTrack2
            keyedAsTrack2_.to_etree(element, name_='keyedAsTrack2', mapping_=mapping_)
        if self.keyedEncrypted is not None:
            keyedEncrypted_ = self.keyedEncrypted
            keyedEncrypted_.to_etree(element, name_='keyedEncrypted', mapping_=mapping_)
        if self.cardRef is not None:
            cardRef_ = self.cardRef
            etree_.SubElement(element, '{}cardRef').text = self.gds_format_string(cardRef_)
        if self.track2 is not None:
            track2_ = self.track2
            track2_.to_etree(element, name_='track2', mapping_=mapping_)
        if self.emv is not None:
            emv_ = self.emv
            emv_.to_etree(element, name_='emv', mapping_=mapping_)
        if self.emvTlv is not None:
            emvTlv_ = self.emvTlv
            emvTlv_.to_etree(element, name_='emvTlv', mapping_=mapping_)
        if self.voucher is not None:
            voucher_ = self.voucher
            voucher_.to_etree(element, name_='voucher', mapping_=mapping_)
        if self.orderId is not None:
            orderId_ = self.orderId
            etree_.SubElement(element, '{}orderId').text = self.gds_format_string(orderId_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='refundUnreferenced'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(refundUnreferenced, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(refundUnreferenced, self).exportLiteralChildren(outfile, level, name_)
        if self.cardDetails is not None:
            showIndent(outfile, level)
            outfile.write('cardDetails=model_.cardDetails(\n')
            self.cardDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.keyedAsTrack2 is not None:
            showIndent(outfile, level)
            outfile.write('keyedAsTrack2=model_.keyedAsTrackData(\n')
            self.keyedAsTrack2.exportLiteral(outfile, level, name_='keyedAsTrack2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.keyedEncrypted is not None:
            showIndent(outfile, level)
            outfile.write('keyedEncrypted=model_.keyedEncrypted(\n')
            self.keyedEncrypted.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cardRef is not None:
            showIndent(outfile, level)
            outfile.write('cardRef=%s,\n' % self.gds_encode(quote_python(self.cardRef)))
        if self.track2 is not None:
            showIndent(outfile, level)
            outfile.write('track2=model_.trackData(\n')
            self.track2.exportLiteral(outfile, level, name_='track2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.emv is not None:
            showIndent(outfile, level)
            outfile.write('emv=model_.emv(\n')
            self.emv.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.emvTlv is not None:
            showIndent(outfile, level)
            outfile.write('emvTlv=model_.emvtlv(\n')
            self.emvTlv.exportLiteral(outfile, level, name_='emvTlv')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.voucher is not None:
            showIndent(outfile, level)
            outfile.write('voucher=model_.voucher(\n')
            self.voucher.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.orderId is not None:
            showIndent(outfile, level)
            outfile.write('orderId=%s,\n' % self.gds_encode(quote_python(self.orderId)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(refundUnreferenced, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardDetails':
            class_obj_ = self.get_class_obj_(child_, cardDetails)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.cardDetails = obj_
            obj_.original_tagname_ = 'cardDetails'
        elif nodeName_ == 'keyedAsTrack2':
            obj_ = keyedAsTrackData.factory()
            obj_.build(child_)
            self.keyedAsTrack2 = obj_
            obj_.original_tagname_ = 'keyedAsTrack2'
        elif nodeName_ == 'keyedEncrypted':
            obj_ = keyedEncrypted.factory()
            obj_.build(child_)
            self.keyedEncrypted = obj_
            obj_.original_tagname_ = 'keyedEncrypted'
        elif nodeName_ == 'cardRef':
            cardRef_ = child_.text
            cardRef_ = self.gds_validate_string(cardRef_, node, 'cardRef')
            self.cardRef = cardRef_
        elif nodeName_ == 'track2':
            class_obj_ = self.get_class_obj_(child_, trackData)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.track2 = obj_
            obj_.original_tagname_ = 'track2'
        elif nodeName_ == 'emv':
            obj_ = emv.factory()
            obj_.build(child_)
            self.emv = obj_
            obj_.original_tagname_ = 'emv'
        elif nodeName_ == 'emvTlv':
            obj_ = emvtlv.factory()
            obj_.build(child_)
            self.emvTlv = obj_
            obj_.original_tagname_ = 'emvTlv'
        elif nodeName_ == 'voucher':
            obj_ = voucher.factory()
            obj_.build(child_)
            self.voucher = obj_
            obj_.original_tagname_ = 'voucher'
        elif nodeName_ == 'orderId':
            orderId_ = child_.text
            orderId_ = self.gds_validate_string(orderId_, node, 'orderId')
            self.orderId = orderId_
        super(refundUnreferenced, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = []
        if self.cardDetails:
            hash_list.append(self.cardDetails.hash_string)
        if self.voucher:
            hash_list.append(self.voucher.hash_string)
        hash_list.append(self.orderId)
        hash_list.append(self.reason)
        return ':'.join(hash_list)
# end class refundUnreferenced


class closeBatchRequest(protectedMethod):
    member_data_items_ = [
        MemberSpec_('account', 'account', 0, 0, {'name': 'account', 'type': 'account'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, account=None):
        self.original_tagname_ = None
        super(closeBatchRequest, self).__init__(dateTime, hash, )
        self.account = account
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, closeBatchRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if closeBatchRequest.subclass:
            return closeBatchRequest.subclass(*args_, **kwargs_)
        else:
            return closeBatchRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def hasContent_(self):
        if (
            self.account is not None or
            super(closeBatchRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='closeBatchRequest', mapping_=None):
        element = super(closeBatchRequest, self).to_etree(parent_element, name_, mapping_)
        if self.account is not None:
            account_ = self.account
            account_.to_etree(element, name_='account', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='closeBatchRequest'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(closeBatchRequest, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(closeBatchRequest, self).exportLiteralChildren(outfile, level, name_)
        if self.account is not None:
            showIndent(outfile, level)
            outfile.write('account=model_.account(\n')
            self.account.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(closeBatchRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'account':
            obj_ = account.factory()
            obj_.build(child_)
            self.account = obj_
            obj_.original_tagname_ = 'account'
        super(closeBatchRequest, self).buildChildren(child_, node, nodeName_, True)
# end class closeBatchRequest


class transactionUpdate(protectedMethod):
    member_data_items_ = [
        MemberSpec_('account', 'account', 0, 0, {'name': 'account', 'type': 'account'}, None),
        MemberSpec_('device', 'posDevice', 0, 1, {'name': 'device', 'type': 'posDevice', 'minOccurs': '0'}, None),
        MemberSpec_('deviceType', 'xs:string', 0, 1, {'name': 'deviceType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('uniqueRef', 'xs:string', 0, 0, {'name': 'uniqueRef', 'type': 'xs:string'}, None),
        MemberSpec_('customerSignature', 'customerSignature', 0, 0, {'name': 'customerSignature', 'type': 'customerSignature'}, 7),
        MemberSpec_('customerDetails', 'customerDetails', 0, 0, {'name': 'customerDetails', 'type': 'customerDetails'}, 7),
        MemberSpec_('issuerScriptResults', 'emv', 0, 0, {'name': 'issuerScriptResults', 'type': 'emv'}, 7),
        MemberSpec_('tipAdjustment', 'tipAdjustment', 0, 0, {'ref': 'tipAdjustment', 'name': 'tipAdjustment', 'type': 'tipAdjustment'}, 7),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, account=None, device=None, deviceType=None, uniqueRef=None, customerSignature=None, customerDetails=None, issuerScriptResults=None, tipAdjustment=None):
        self.original_tagname_ = None
        super(transactionUpdate, self).__init__(dateTime, hash, )
        self.account = account
        self.device = device
        self.deviceType = deviceType
        self.uniqueRef = uniqueRef
        self.customerSignature = customerSignature
        self.customerDetails = customerDetails
        self.issuerScriptResults = issuerScriptResults
        self.tipAdjustment = tipAdjustment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transactionUpdate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transactionUpdate.subclass:
            return transactionUpdate.subclass(*args_, **kwargs_)
        else:
            return transactionUpdate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def get_device(self): return self.device
    def set_device(self, device): self.device = device
    def get_deviceType(self): return self.deviceType
    def set_deviceType(self, deviceType): self.deviceType = deviceType
    def get_uniqueRef(self): return self.uniqueRef
    def set_uniqueRef(self, uniqueRef): self.uniqueRef = uniqueRef
    def get_customerSignature(self): return self.customerSignature
    def set_customerSignature(self, customerSignature): self.customerSignature = customerSignature
    def get_customerDetails(self): return self.customerDetails
    def set_customerDetails(self, customerDetails): self.customerDetails = customerDetails
    def get_issuerScriptResults(self): return self.issuerScriptResults
    def set_issuerScriptResults(self, issuerScriptResults): self.issuerScriptResults = issuerScriptResults
    def get_tipAdjustment(self): return self.tipAdjustment
    def set_tipAdjustment(self, tipAdjustment): self.tipAdjustment = tipAdjustment
    def hasContent_(self):
        if (
            self.account is not None or
            self.device is not None or
            self.deviceType is not None or
            self.uniqueRef is not None or
            self.customerSignature is not None or
            self.customerDetails is not None or
            self.issuerScriptResults is not None or
            self.tipAdjustment is not None or
            super(transactionUpdate, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='transactionUpdate', mapping_=None):
        element = super(transactionUpdate, self).to_etree(parent_element, name_, mapping_)
        if self.account is not None:
            account_ = self.account
            account_.to_etree(element, name_='account', mapping_=mapping_)
        if self.device is not None:
            device_ = self.device
            device_.to_etree(element, name_='device', mapping_=mapping_)
        if self.deviceType is not None:
            deviceType_ = self.deviceType
            etree_.SubElement(element, '{}deviceType').text = self.gds_format_string(deviceType_)
        if self.uniqueRef is not None:
            uniqueRef_ = self.uniqueRef
            etree_.SubElement(element, '{}uniqueRef').text = self.gds_format_string(uniqueRef_)
        if self.customerSignature is not None:
            customerSignature_ = self.customerSignature
            customerSignature_.to_etree(element, name_='customerSignature', mapping_=mapping_)
        if self.customerDetails is not None:
            customerDetails_ = self.customerDetails
            customerDetails_.to_etree(element, name_='customerDetails', mapping_=mapping_)
        if self.issuerScriptResults is not None:
            issuerScriptResults_ = self.issuerScriptResults
            issuerScriptResults_.to_etree(element, name_='issuerScriptResults', mapping_=mapping_)
        if self.tipAdjustment is not None:
            tipAdjustment_ = self.tipAdjustment
            tipAdjustment_.to_etree(element, name_='tipAdjustment', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='transactionUpdate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(transactionUpdate, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(transactionUpdate, self).exportLiteralChildren(outfile, level, name_)
        if self.account is not None:
            showIndent(outfile, level)
            outfile.write('account=model_.account(\n')
            self.account.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.device is not None:
            showIndent(outfile, level)
            outfile.write('device=model_.posDevice(\n')
            self.device.exportLiteral(outfile, level, name_='device')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deviceType is not None:
            showIndent(outfile, level)
            outfile.write('deviceType=%s,\n' % self.gds_encode(quote_python(self.deviceType)))
        if self.uniqueRef is not None:
            showIndent(outfile, level)
            outfile.write('uniqueRef=%s,\n' % self.gds_encode(quote_python(self.uniqueRef)))
        if self.customerSignature is not None:
            showIndent(outfile, level)
            outfile.write('customerSignature=model_.customerSignature(\n')
            self.customerSignature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.customerDetails is not None:
            showIndent(outfile, level)
            outfile.write('customerDetails=model_.customerDetails(\n')
            self.customerDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.issuerScriptResults is not None:
            showIndent(outfile, level)
            outfile.write('issuerScriptResults=model_.emv(\n')
            self.issuerScriptResults.exportLiteral(outfile, level, name_='issuerScriptResults')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tipAdjustment is not None:
            showIndent(outfile, level)
            outfile.write('tipAdjustment=model_.tipAdjustment(\n')
            self.tipAdjustment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(transactionUpdate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'account':
            obj_ = account.factory()
            obj_.build(child_)
            self.account = obj_
            obj_.original_tagname_ = 'account'
        elif nodeName_ == 'device':
            obj_ = posDevice.factory()
            obj_.build(child_)
            self.device = obj_
            obj_.original_tagname_ = 'device'
        elif nodeName_ == 'deviceType':
            deviceType_ = child_.text
            deviceType_ = self.gds_validate_string(deviceType_, node, 'deviceType')
            self.deviceType = deviceType_
        elif nodeName_ == 'uniqueRef':
            uniqueRef_ = child_.text
            uniqueRef_ = self.gds_validate_string(uniqueRef_, node, 'uniqueRef')
            self.uniqueRef = uniqueRef_
        elif nodeName_ == 'customerSignature':
            obj_ = customerSignature.factory()
            obj_.build(child_)
            self.customerSignature = obj_
            obj_.original_tagname_ = 'customerSignature'
        elif nodeName_ == 'customerDetails':
            obj_ = customerDetails.factory()
            obj_.build(child_)
            self.customerDetails = obj_
            obj_.original_tagname_ = 'customerDetails'
        elif nodeName_ == 'issuerScriptResults':
            obj_ = emv.factory()
            obj_.build(child_)
            self.issuerScriptResults = obj_
            obj_.original_tagname_ = 'issuerScriptResults'
        elif nodeName_ == 'tipAdjustment':
            obj_ = tipAdjustment.factory()
            obj_.build(child_)
            self.tipAdjustment = obj_
            obj_.original_tagname_ = 'tipAdjustment'
        super(transactionUpdate, self).buildChildren(child_, node, nodeName_, True)
    @property
    def hash_string(self):
        hash_list = [self.account.hash_string]
        if self.deviceType:
            hash_list.append(self.deviceType)
        hash_list.append(self.uniqueRef)
        if self.tipAdjustment:
            hash_list.append(self.tipAdjustment.hash_string)
        if self.customerDetails:
            hash_list.append(self.customerDetails.hash_string)
        hash_list.append(str(self.dateTime.isoformat('T', 'seconds')))
        return ':'.join(hash_list)
# end class transactionUpdate


class customerSignature(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('signature', 'xs:string', 0, 1, {'name': 'signature', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, signature=None):
        self.original_tagname_ = None
        self.signature = signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerSignature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerSignature.subclass:
            return customerSignature.subclass(*args_, **kwargs_)
        else:
            return customerSignature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_signature(self): return self.signature
    def set_signature(self, signature): self.signature = signature
    def hasContent_(self):
        if (
            self.signature is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='customerSignature', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.signature is not None:
            signature_ = self.signature
            etree_.SubElement(element, '{}signature').text = self.gds_format_string(signature_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='customerSignature'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.signature is not None:
            showIndent(outfile, level)
            outfile.write('signature=%s,\n' % self.gds_encode(quote_python(self.signature)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'signature':
            signature_ = child_.text
            signature_ = self.gds_validate_string(signature_, node, 'signature')
            self.signature = signature_
# end class customerSignature


class customerDetails(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('eMail', 'xs:string', 0, 1, {'name': 'eMail', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('mobileNumber', 'xs:string', 0, 1, {'name': 'mobileNumber', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, eMail=None, mobileNumber=None):
        self.original_tagname_ = None
        self.eMail = eMail
        self.mobileNumber = mobileNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customerDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customerDetails.subclass:
            return customerDetails.subclass(*args_, **kwargs_)
        else:
            return customerDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eMail(self): return self.eMail
    def set_eMail(self, eMail): self.eMail = eMail
    def get_mobileNumber(self): return self.mobileNumber
    def set_mobileNumber(self, mobileNumber): self.mobileNumber = mobileNumber
    def hasContent_(self):
        if (
            self.eMail is not None or
            self.mobileNumber is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='customerDetails', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.eMail is not None:
            eMail_ = self.eMail
            etree_.SubElement(element, '{}eMail').text = self.gds_format_string(eMail_)
        if self.mobileNumber is not None:
            mobileNumber_ = self.mobileNumber
            etree_.SubElement(element, '{}mobileNumber').text = self.gds_format_string(mobileNumber_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='customerDetails'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.eMail is not None:
            showIndent(outfile, level)
            outfile.write('eMail=%s,\n' % self.gds_encode(quote_python(self.eMail)))
        if self.mobileNumber is not None:
            showIndent(outfile, level)
            outfile.write('mobileNumber=%s,\n' % self.gds_encode(quote_python(self.mobileNumber)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eMail':
            eMail_ = child_.text
            eMail_ = self.gds_validate_string(eMail_, node, 'eMail')
            self.eMail = eMail_
        elif nodeName_ == 'mobileNumber':
            mobileNumber_ = child_.text
            mobileNumber_ = self.gds_validate_string(mobileNumber_, node, 'mobileNumber')
            self.mobileNumber = mobileNumber_

    @property
    def hash_string(self):
        hash_list = []
        if self.eMail:
            hash_list.append(self.eMail)
        if self.mobileNumber:
            hash_list.append(self.mobileNumber)
        return ':'.join(hash_list)
# end class customerDetails


class tipAdjustment(tip):
    member_data_items_ = [
    ]
    subclass = None
    superclass = tip
    def __init__(self, amount_member=None, cashBackAmount=None, currency=None, percentage=None, tipType=None):
        self.original_tagname_ = None
        super(tipAdjustment, self).__init__(amount_member, cashBackAmount, currency, percentage, tipType, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tipAdjustment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tipAdjustment.subclass:
            return tipAdjustment.subclass(*args_, **kwargs_)
        else:
            return tipAdjustment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(tipAdjustment, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='tipAdjustment', mapping_=None):
        element = super(tipAdjustment, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='tipAdjustment'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(tipAdjustment, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(tipAdjustment, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tipAdjustment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tipAdjustment, self).buildChildren(child_, node, nodeName_, True)
        pass
    @property
    def hash_string(self):
        from constants import Currency
        from decimal import Decimal
        hash_list = []
        if self.percentage:
            hash_list.append(str(round(self.percentage * 10000)))
        hash_list.append(self.tipType)
        hash_list.append(str((Decimal(self.amount).quantize(Decimal(10) ** -Currency[self.currency].minorunits))).replace('.','').lstrip('0'))
        hash_list.append(self.currency)
        return ':'.join(hash_list)
# end class tipAdjustment


class authenticationRequest(standardRequest):
    member_data_items_ = [
    ]
    subclass = None
    superclass = standardRequest
    def __init__(self, dateTime=None, hash=None, account=None, apiKey=None, extensiontype_=None):
        self.original_tagname_ = None
        super(authenticationRequest, self).__init__(dateTime, hash, account, apiKey, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, authenticationRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if authenticationRequest.subclass:
            return authenticationRequest.subclass(*args_, **kwargs_)
        else:
            return authenticationRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(authenticationRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='authenticationRequest', mapping_=None):
        element = super(authenticationRequest, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='authenticationRequest'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(authenticationRequest, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(authenticationRequest, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(authenticationRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(authenticationRequest, self).buildChildren(child_, node, nodeName_, True)
        pass

    @property
    def hash_string(self):
        hash_list = [self.account.hash_string, self.apiKey, str(self.dateTime.isoformat('T'))]
        return ':'.join(hash_list)
# end class authenticationRequest


class terminalAPIKey(standardKey):
    member_data_items_ = [
    ]
    subclass = None
    superclass = standardKey
    def __init__(self, key=None, validUntil=None):
        self.original_tagname_ = None
        super(terminalAPIKey, self).__init__(key, validUntil, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalAPIKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalAPIKey.subclass:
            return terminalAPIKey.subclass(*args_, **kwargs_)
        else:
            return terminalAPIKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(terminalAPIKey, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalAPIKey', mapping_=None):
        element = super(terminalAPIKey, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalAPIKey'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(terminalAPIKey, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(terminalAPIKey, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(terminalAPIKey, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(terminalAPIKey, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class terminalAPIKey


class transactionList(protectedMethod):
    member_data_items_ = [
        MemberSpec_('totalCount', 'xs:int', 0, 0, {'name': 'totalCount', 'type': 'xs:int'}, None),
        MemberSpec_('totalSummary', 'xs:string', 0, 1, {'name': 'totalSummary', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('transactionSummary', 'transactionSummary', 1, 1, {'name': 'transactionSummary', 'type': 'transactionSummary', 'nillable': 'true', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, totalCount=None, totalSummary=None, transactionSummary=None):
        self.original_tagname_ = None
        super(transactionList, self).__init__(dateTime, hash, )
        self.totalCount = totalCount
        self.totalSummary = totalSummary
        if transactionSummary is None:
            self.transactionSummary = []
        else:
            self.transactionSummary = transactionSummary
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transactionList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transactionList.subclass:
            return transactionList.subclass(*args_, **kwargs_)
        else:
            return transactionList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_totalCount(self): return self.totalCount
    def set_totalCount(self, totalCount): self.totalCount = totalCount
    def get_totalSummary(self): return self.totalSummary
    def set_totalSummary(self, totalSummary): self.totalSummary = totalSummary
    def get_transactionSummary(self): return self.transactionSummary
    def set_transactionSummary(self, transactionSummary): self.transactionSummary = transactionSummary
    def add_transactionSummary(self, value): self.transactionSummary.append(value)
    def insert_transactionSummary_at(self, index, value): self.transactionSummary.insert(index, value)
    def replace_transactionSummary_at(self, index, value): self.transactionSummary[index] = value
    def hasContent_(self):
        if (
            self.totalCount is not None or
            self.totalSummary is not None or
            self.transactionSummary or
            super(transactionList, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='transactionList', mapping_=None):
        element = super(transactionList, self).to_etree(parent_element, name_, mapping_)
        if self.totalCount is not None:
            totalCount_ = self.totalCount
            etree_.SubElement(element, '{}totalCount').text = self.gds_format_integer(totalCount_)
        if self.totalSummary is not None:
            totalSummary_ = self.totalSummary
            etree_.SubElement(element, '{}totalSummary').text = self.gds_format_string(totalSummary_)
        for transactionSummary_ in self.transactionSummary:
            transactionSummary_.to_etree(element, name_='transactionSummary', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='transactionList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(transactionList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(transactionList, self).exportLiteralChildren(outfile, level, name_)
        if self.totalCount is not None:
            showIndent(outfile, level)
            outfile.write('totalCount=%d,\n' % self.totalCount)
        if self.totalSummary is not None:
            showIndent(outfile, level)
            outfile.write('totalSummary=%s,\n' % self.gds_encode(quote_python(self.totalSummary)))
        showIndent(outfile, level)
        outfile.write('transactionSummary=[\n')
        level += 1
        for transactionSummary_ in self.transactionSummary:
            showIndent(outfile, level)
            outfile.write('model_.transactionSummary(\n')
            transactionSummary_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(transactionList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'totalCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalCount')
            self.totalCount = ival_
        elif nodeName_ == 'totalSummary':
            totalSummary_ = child_.text
            totalSummary_ = self.gds_validate_string(totalSummary_, node, 'totalSummary')
            self.totalSummary = totalSummary_
        elif nodeName_ == 'transactionSummary':
            obj_ = transactionSummary.factory()
            obj_.build(child_)
            self.transactionSummary.append(obj_)
            obj_.original_tagname_ = 'transactionSummary'
        super(transactionList, self).buildChildren(child_, node, nodeName_, True)
# end class transactionList


class transactionSummary(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('amount', 'amount', 0, 1, {'name': 'amount', 'type': 'amount', 'minOccurs': '0'}, None),
        MemberSpec_('approvalCode', 'xs:string', 0, 1, {'name': 'approvalCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('commerceType', ['commerceType', 'xs:string'], 0, 1, {'name': 'commerceType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'name': 'description', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('keyedCard', 'keyedCard', 0, 1, {'name': 'keyedCard', 'type': 'keyedCard', 'minOccurs': '0'}, None),
        MemberSpec_('orderId', 'xs:string', 0, 1, {'name': 'orderId', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('originalAmount', 'amount', 0, 1, {'name': 'originalAmount', 'type': 'amount', 'minOccurs': '0'}, None),
        MemberSpec_('responseCode', 'xs:string', 0, 1, {'name': 'responseCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('surcharge', 'transactionSurcharge', 0, 1, {'name': 'surcharge', 'type': 'transactionSurcharge', 'minOccurs': '0'}, None),
        MemberSpec_('taxes', 'tax', 1, 0, {'name': 'taxes', 'type': 'tax', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('tip', 'tip', 0, 1, {'name': 'tip', 'type': 'tip', 'minOccurs': '0'}, None),
        MemberSpec_('transactionDate', 'xs:dateTime', 0, 1, {'name': 'transactionDate', 'type': 'xs:dateTime', 'minOccurs': '0'}, None),
        MemberSpec_('transactionState', ['transactionState', 'xs:string'], 0, 1, {'name': 'transactionState', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('transactionStatus', ['transactionStatus', 'xs:string'], 0, 1, {'name': 'transactionStatus', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('transactionType', ['transactionType', 'xs:string'], 0, 1, {'name': 'transactionType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('uniqueRef', 'xs:string', 0, 1, {'name': 'uniqueRef', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, amount=None, approvalCode=None, commerceType=None, description=None, keyedCard=None, orderId=None, originalAmount=None, responseCode=None, surcharge=None, taxes=None, tip=None, transactionDate=None, transactionState=None, transactionStatus=None, transactionType=None, uniqueRef=None):
        self.original_tagname_ = None
        self.amount = amount
        self.approvalCode = approvalCode
        self.commerceType = commerceType
        self.validate_commerceType(self.commerceType)
        self.description = description
        self.keyedCard = keyedCard
        self.orderId = orderId
        self.originalAmount = originalAmount
        self.responseCode = responseCode
        self.surcharge = surcharge
        if taxes is None:
            self.taxes = []
        else:
            self.taxes = taxes
        self.tip = tip
        if isinstance(transactionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(transactionDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = transactionDate
        self.transactionDate = initvalue_
        self.transactionState = transactionState
        self.validate_transactionState(self.transactionState)
        self.transactionStatus = transactionStatus
        self.validate_transactionStatus(self.transactionStatus)
        self.transactionType = transactionType
        self.validate_transactionType(self.transactionType)
        self.uniqueRef = uniqueRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transactionSummary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transactionSummary.subclass:
            return transactionSummary.subclass(*args_, **kwargs_)
        else:
            return transactionSummary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_approvalCode(self): return self.approvalCode
    def set_approvalCode(self, approvalCode): self.approvalCode = approvalCode
    def get_commerceType(self): return self.commerceType
    def set_commerceType(self, commerceType): self.commerceType = commerceType
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_keyedCard(self): return self.keyedCard
    def set_keyedCard(self, keyedCard): self.keyedCard = keyedCard
    def get_orderId(self): return self.orderId
    def set_orderId(self, orderId): self.orderId = orderId
    def get_originalAmount(self): return self.originalAmount
    def set_originalAmount(self, originalAmount): self.originalAmount = originalAmount
    def get_responseCode(self): return self.responseCode
    def set_responseCode(self, responseCode): self.responseCode = responseCode
    def get_surcharge(self): return self.surcharge
    def set_surcharge(self, surcharge): self.surcharge = surcharge
    def get_taxes(self): return self.taxes
    def set_taxes(self, taxes): self.taxes = taxes
    def add_taxes(self, value): self.taxes.append(value)
    def insert_taxes_at(self, index, value): self.taxes.insert(index, value)
    def replace_taxes_at(self, index, value): self.taxes[index] = value
    def get_tip(self): return self.tip
    def set_tip(self, tip): self.tip = tip
    def get_transactionDate(self): return self.transactionDate
    def set_transactionDate(self, transactionDate): self.transactionDate = transactionDate
    def get_transactionState(self): return self.transactionState
    def set_transactionState(self, transactionState): self.transactionState = transactionState
    def get_transactionStatus(self): return self.transactionStatus
    def set_transactionStatus(self, transactionStatus): self.transactionStatus = transactionStatus
    def get_transactionType(self): return self.transactionType
    def set_transactionType(self, transactionType): self.transactionType = transactionType
    def get_uniqueRef(self): return self.uniqueRef
    def set_uniqueRef(self, uniqueRef): self.uniqueRef = uniqueRef
    def validate_commerceType(self, value):
        # Validate type commerceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NOT_APPLICABLE', 'INTERNET', 'INTERNET_3DS_SECURED', 'INTERNET_3DS_ATTEMPTED', 'MO', 'MOTO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on commerceType' % {"value" : value.encode("utf-8")} )
    def validate_transactionState(self, value):
        # Validate type transactionState, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['OPEN', 'CLOSED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on transactionState' % {"value" : value.encode("utf-8")} )
    def validate_transactionStatus(self, value):
        # Validate type transactionStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PENDING', 'READY', 'VOID', 'DECLINED', 'COMPLETE', 'REFERRAL', 'REVERSAL', 'ACCEPTED', 'OTHER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on transactionStatus' % {"value" : value.encode("utf-8")} )
    def validate_transactionType(self, value):
        # Validate type transactionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SALE', 'REFUND', 'PRE_AUTH', 'PRE_AUTH_COMPLETION', 'OFFLINE_DECLINE', 'DEFERRED_AUTH']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on transactionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.amount is not None or
            self.approvalCode is not None or
            self.commerceType is not None or
            self.description is not None or
            self.keyedCard is not None or
            self.orderId is not None or
            self.originalAmount is not None or
            self.responseCode is not None or
            self.surcharge is not None or
            self.taxes or
            self.tip is not None or
            self.transactionDate is not None or
            self.transactionState is not None or
            self.transactionStatus is not None or
            self.transactionType is not None or
            self.uniqueRef is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='transactionSummary', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.amount is not None:
            amount_ = self.amount
            amount_.to_etree(element, name_='amount', mapping_=mapping_)
        if self.approvalCode is not None:
            approvalCode_ = self.approvalCode
            etree_.SubElement(element, '{}approvalCode').text = self.gds_format_string(approvalCode_)
        if self.commerceType is not None:
            commerceType_ = self.commerceType
            etree_.SubElement(element, '{}commerceType').text = self.gds_format_string(commerceType_)
        if self.description is not None:
            description_ = self.description
            etree_.SubElement(element, '{}description').text = self.gds_format_string(description_)
        if self.keyedCard is not None:
            keyedCard_ = self.keyedCard
            keyedCard_.to_etree(element, name_='keyedCard', mapping_=mapping_)
        if self.orderId is not None:
            orderId_ = self.orderId
            etree_.SubElement(element, '{}orderId').text = self.gds_format_string(orderId_)
        if self.originalAmount is not None:
            originalAmount_ = self.originalAmount
            originalAmount_.to_etree(element, name_='originalAmount', mapping_=mapping_)
        if self.responseCode is not None:
            responseCode_ = self.responseCode
            etree_.SubElement(element, '{}responseCode').text = self.gds_format_string(responseCode_)
        if self.surcharge is not None:
            surcharge_ = self.surcharge
            surcharge_.to_etree(element, name_='surcharge', mapping_=mapping_)
        for taxes_ in self.taxes:
            taxes_.to_etree(element, name_='taxes', mapping_=mapping_)
        if self.tip is not None:
            tip_ = self.tip
            tip_.to_etree(element, name_='tip', mapping_=mapping_)
        if self.transactionDate is not None:
            transactionDate_ = self.transactionDate
            etree_.SubElement(element, '{}transactionDate').text = self.gds_format_datetime(transactionDate_)
        if self.transactionState is not None:
            transactionState_ = self.transactionState
            etree_.SubElement(element, '{}transactionState').text = self.gds_format_string(transactionState_)
        if self.transactionStatus is not None:
            transactionStatus_ = self.transactionStatus
            etree_.SubElement(element, '{}transactionStatus').text = self.gds_format_string(transactionStatus_)
        if self.transactionType is not None:
            transactionType_ = self.transactionType
            etree_.SubElement(element, '{}transactionType').text = self.gds_format_string(transactionType_)
        if self.uniqueRef is not None:
            uniqueRef_ = self.uniqueRef
            etree_.SubElement(element, '{}uniqueRef').text = self.gds_format_string(uniqueRef_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='transactionSummary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.amount is not None:
            showIndent(outfile, level)
            outfile.write('amount=model_.amount(\n')
            self.amount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.approvalCode is not None:
            showIndent(outfile, level)
            outfile.write('approvalCode=%s,\n' % self.gds_encode(quote_python(self.approvalCode)))
        if self.commerceType is not None:
            showIndent(outfile, level)
            outfile.write('commerceType=%s,\n' % self.gds_encode(quote_python(self.commerceType)))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % self.gds_encode(quote_python(self.description)))
        if self.keyedCard is not None:
            showIndent(outfile, level)
            outfile.write('keyedCard=model_.keyedCard(\n')
            self.keyedCard.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.orderId is not None:
            showIndent(outfile, level)
            outfile.write('orderId=%s,\n' % self.gds_encode(quote_python(self.orderId)))
        if self.originalAmount is not None:
            showIndent(outfile, level)
            outfile.write('originalAmount=model_.amount(\n')
            self.originalAmount.exportLiteral(outfile, level, name_='originalAmount')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.responseCode is not None:
            showIndent(outfile, level)
            outfile.write('responseCode=%s,\n' % self.gds_encode(quote_python(self.responseCode)))
        if self.surcharge is not None:
            showIndent(outfile, level)
            outfile.write('surcharge=model_.transactionSurcharge(\n')
            self.surcharge.exportLiteral(outfile, level, name_='surcharge')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('taxes=[\n')
        level += 1
        for taxes_ in self.taxes:
            showIndent(outfile, level)
            outfile.write('model_.tax(\n')
            taxes_.exportLiteral(outfile, level, name_='tax')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.tip is not None:
            showIndent(outfile, level)
            outfile.write('tip=model_.tip(\n')
            self.tip.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.transactionDate is not None:
            showIndent(outfile, level)
            outfile.write('transactionDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.transactionDate, input_name='transactionDate'))
        if self.transactionState is not None:
            showIndent(outfile, level)
            outfile.write('transactionState=%s,\n' % self.gds_encode(quote_python(self.transactionState)))
        if self.transactionStatus is not None:
            showIndent(outfile, level)
            outfile.write('transactionStatus=%s,\n' % self.gds_encode(quote_python(self.transactionStatus)))
        if self.transactionType is not None:
            showIndent(outfile, level)
            outfile.write('transactionType=%s,\n' % self.gds_encode(quote_python(self.transactionType)))
        if self.uniqueRef is not None:
            showIndent(outfile, level)
            outfile.write('uniqueRef=%s,\n' % self.gds_encode(quote_python(self.uniqueRef)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            class_obj_ = self.get_class_obj_(child_, amount)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.amount = obj_
            obj_.original_tagname_ = 'amount'
        elif nodeName_ == 'approvalCode':
            approvalCode_ = child_.text
            approvalCode_ = self.gds_validate_string(approvalCode_, node, 'approvalCode')
            self.approvalCode = approvalCode_
        elif nodeName_ == 'commerceType':
            commerceType_ = child_.text
            commerceType_ = self.gds_validate_string(commerceType_, node, 'commerceType')
            self.commerceType = commerceType_
            # validate type commerceType
            self.validate_commerceType(self.commerceType)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'keyedCard':
            obj_ = keyedCard.factory()
            obj_.build(child_)
            self.keyedCard = obj_
            obj_.original_tagname_ = 'keyedCard'
        elif nodeName_ == 'orderId':
            orderId_ = child_.text
            orderId_ = self.gds_validate_string(orderId_, node, 'orderId')
            self.orderId = orderId_
        elif nodeName_ == 'originalAmount':
            class_obj_ = self.get_class_obj_(child_, amount)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.originalAmount = obj_
            obj_.original_tagname_ = 'originalAmount'
        elif nodeName_ == 'responseCode':
            responseCode_ = child_.text
            responseCode_ = self.gds_validate_string(responseCode_, node, 'responseCode')
            self.responseCode = responseCode_
        elif nodeName_ == 'surcharge':
            obj_ = transactionSurcharge.factory()
            obj_.build(child_)
            self.surcharge = obj_
            obj_.original_tagname_ = 'surcharge'
        elif nodeName_ == 'taxes':
            obj_ = tax.factory()
            obj_.build(child_)
            self.taxes.append(obj_)
            obj_.original_tagname_ = 'taxes'
        elif nodeName_ == 'tip':
            class_obj_ = self.get_class_obj_(child_, tip)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.tip = obj_
            obj_.original_tagname_ = 'tip'
        elif nodeName_ == 'transactionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.transactionDate = dval_
        elif nodeName_ == 'transactionState':
            transactionState_ = child_.text
            transactionState_ = self.gds_validate_string(transactionState_, node, 'transactionState')
            self.transactionState = transactionState_
            # validate type transactionState
            self.validate_transactionState(self.transactionState)
        elif nodeName_ == 'transactionStatus':
            transactionStatus_ = child_.text
            transactionStatus_ = self.gds_validate_string(transactionStatus_, node, 'transactionStatus')
            self.transactionStatus = transactionStatus_
            # validate type transactionStatus
            self.validate_transactionStatus(self.transactionStatus)
        elif nodeName_ == 'transactionType':
            transactionType_ = child_.text
            transactionType_ = self.gds_validate_string(transactionType_, node, 'transactionType')
            self.transactionType = transactionType_
            # validate type transactionType
            self.validate_transactionType(self.transactionType)
        elif nodeName_ == 'uniqueRef':
            uniqueRef_ = child_.text
            uniqueRef_ = self.gds_validate_string(uniqueRef_, node, 'uniqueRef')
            self.uniqueRef = uniqueRef_
# end class transactionSummary


class paymentTypeTerminalConfiguration(protectedMethod):
    member_data_items_ = [
        MemberSpec_('paymentType', ['paymentTypeEnum', 'xs:string'], 0, 0, {'name': 'paymentType', 'type': 'xs:string'}, None),
        MemberSpec_('terminalConfiguration', 'terminalConfiguration', 0, 0, {'name': 'terminalConfiguration', 'type': 'terminalConfiguration'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, paymentType=None, terminalConfiguration=None):
        self.original_tagname_ = None
        super(paymentTypeTerminalConfiguration, self).__init__(dateTime, hash, )
        self.paymentType = paymentType
        self.validate_paymentTypeEnum(self.paymentType)
        self.terminalConfiguration = terminalConfiguration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, paymentTypeTerminalConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if paymentTypeTerminalConfiguration.subclass:
            return paymentTypeTerminalConfiguration.subclass(*args_, **kwargs_)
        else:
            return paymentTypeTerminalConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentType(self): return self.paymentType
    def set_paymentType(self, paymentType): self.paymentType = paymentType
    def get_terminalConfiguration(self): return self.terminalConfiguration
    def set_terminalConfiguration(self, terminalConfiguration): self.terminalConfiguration = terminalConfiguration
    def validate_paymentTypeEnum(self, value):
        # Validate type paymentTypeEnum, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CREDIT_DEBIT', 'EBT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on paymentTypeEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.paymentType is not None or
            self.terminalConfiguration is not None or
            super(paymentTypeTerminalConfiguration, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='paymentTypeTerminalConfiguration', mapping_=None):
        element = super(paymentTypeTerminalConfiguration, self).to_etree(parent_element, name_, mapping_)
        if self.paymentType is not None:
            paymentType_ = self.paymentType
            etree_.SubElement(element, '{}paymentType').text = self.gds_format_string(paymentType_)
        if self.terminalConfiguration is not None:
            terminalConfiguration_ = self.terminalConfiguration
            terminalConfiguration_.to_etree(element, name_='terminalConfiguration', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='paymentTypeTerminalConfiguration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(paymentTypeTerminalConfiguration, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(paymentTypeTerminalConfiguration, self).exportLiteralChildren(outfile, level, name_)
        if self.paymentType is not None:
            showIndent(outfile, level)
            outfile.write('paymentType=%s,\n' % self.gds_encode(quote_python(self.paymentType)))
        if self.terminalConfiguration is not None:
            showIndent(outfile, level)
            outfile.write('terminalConfiguration=model_.terminalConfiguration(\n')
            self.terminalConfiguration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(paymentTypeTerminalConfiguration, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentType':
            paymentType_ = child_.text
            paymentType_ = self.gds_validate_string(paymentType_, node, 'paymentType')
            self.paymentType = paymentType_
            # validate type paymentTypeEnum
            self.validate_paymentTypeEnum(self.paymentType)
        elif nodeName_ == 'terminalConfiguration':
            obj_ = terminalConfiguration.factory()
            obj_.build(child_)
            self.terminalConfiguration = obj_
            obj_.original_tagname_ = 'terminalConfiguration'
        super(paymentTypeTerminalConfiguration, self).buildChildren(child_, node, nodeName_, True)
# end class paymentTypeTerminalConfiguration


class cardTypeInfo(protectedMethod):
    member_data_items_ = [
        MemberSpec_('cardTypeName', 'xs:string', 0, 0, {'name': 'cardTypeName', 'type': 'xs:string'}, None),
        MemberSpec_('country', 'xs:string', 0, 1, {'name': 'country', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('currency', ['currency', 'xs:string'], 0, 1, {'name': 'currency', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('debit', 'xs:boolean', 0, 1, {'name': 'debit', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('eligibleForDcc', 'xs:boolean', 0, 1, {'name': 'eligibleForDcc', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, cardTypeName=None, country=None, currency=None, debit=None, eligibleForDcc=None):
        self.original_tagname_ = None
        super(cardTypeInfo, self).__init__(dateTime, hash, )
        self.cardTypeName = cardTypeName
        self.country = country
        self.currency = currency
        self.validate_currency(self.currency)
        self.debit = debit
        self.eligibleForDcc = eligibleForDcc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardTypeInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardTypeInfo.subclass:
            return cardTypeInfo.subclass(*args_, **kwargs_)
        else:
            return cardTypeInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardTypeName(self): return self.cardTypeName
    def set_cardTypeName(self, cardTypeName): self.cardTypeName = cardTypeName
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_debit(self): return self.debit
    def set_debit(self, debit): self.debit = debit
    def get_eligibleForDcc(self): return self.eligibleForDcc
    def set_eligibleForDcc(self, eligibleForDcc): self.eligibleForDcc = eligibleForDcc
    def validate_currency(self, value):
        # Validate type currency, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYR', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LTL', 'LVL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRO', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLL', 'SOS', 'SRD', 'SSP', 'STD', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'USS', 'UYI', 'UYU', 'UZS', 'VEF', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XCD', 'XOF', 'XPF', 'YER', 'ZAR', 'ZMW', 'ZWL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on currency' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cardTypeName is not None or
            self.country is not None or
            self.currency is not None or
            self.debit is not None or
            self.eligibleForDcc is not None or
            super(cardTypeInfo, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='cardTypeInfo', mapping_=None):
        element = super(cardTypeInfo, self).to_etree(parent_element, name_, mapping_)
        if self.cardTypeName is not None:
            cardTypeName_ = self.cardTypeName
            etree_.SubElement(element, '{}cardTypeName').text = self.gds_format_string(cardTypeName_)
        if self.country is not None:
            country_ = self.country
            etree_.SubElement(element, '{}country').text = self.gds_format_string(country_)
        if self.currency is not None:
            currency_ = self.currency
            etree_.SubElement(element, '{}currency').text = self.gds_format_string(currency_)
        if self.debit is not None:
            debit_ = self.debit
            etree_.SubElement(element, '{}debit').text = self.gds_format_boolean(debit_)
        if self.eligibleForDcc is not None:
            eligibleForDcc_ = self.eligibleForDcc
            etree_.SubElement(element, '{}eligibleForDcc').text = self.gds_format_boolean(eligibleForDcc_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='cardTypeInfo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(cardTypeInfo, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cardTypeInfo, self).exportLiteralChildren(outfile, level, name_)
        if self.cardTypeName is not None:
            showIndent(outfile, level)
            outfile.write('cardTypeName=%s,\n' % self.gds_encode(quote_python(self.cardTypeName)))
        if self.country is not None:
            showIndent(outfile, level)
            outfile.write('country=%s,\n' % self.gds_encode(quote_python(self.country)))
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=%s,\n' % self.gds_encode(quote_python(self.currency)))
        if self.debit is not None:
            showIndent(outfile, level)
            outfile.write('debit=%s,\n' % self.debit)
        if self.eligibleForDcc is not None:
            showIndent(outfile, level)
            outfile.write('eligibleForDcc=%s,\n' % self.eligibleForDcc)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(cardTypeInfo, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardTypeName':
            cardTypeName_ = child_.text
            cardTypeName_ = self.gds_validate_string(cardTypeName_, node, 'cardTypeName')
            self.cardTypeName = cardTypeName_
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
        elif nodeName_ == 'currency':
            currency_ = child_.text
            currency_ = self.gds_validate_string(currency_, node, 'currency')
            self.currency = currency_
            # validate type currency
            self.validate_currency(self.currency)
        elif nodeName_ == 'debit':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'debit')
            self.debit = ival_
        elif nodeName_ == 'eligibleForDcc':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'eligibleForDcc')
            self.eligibleForDcc = ival_
        super(cardTypeInfo, self).buildChildren(child_, node, nodeName_, True)
# end class cardTypeInfo


class terminalUpdate(protectedMethod):
    member_data_items_ = [
        MemberSpec_('account', 'account', 0, 0, {'name': 'account', 'type': 'account'}, None),
        MemberSpec_('settingCreate', 'settingCreateType', 0, 1, {'name': 'settingCreate', 'minOccurs': '0', 'type': 'settingCreateType'}, None),
        MemberSpec_('settingDelete', 'settingDeleteType', 0, 1, {'name': 'settingDelete', 'minOccurs': '0', 'type': 'settingDeleteType'}, None),
        MemberSpec_('settingUpdate', 'settingUpdateType', 0, 1, {'name': 'settingUpdate', 'minOccurs': '0', 'type': 'settingUpdateType'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, account=None, settingCreate=None, settingDelete=None, settingUpdate=None):
        self.original_tagname_ = None
        super(terminalUpdate, self).__init__(dateTime, hash, )
        self.account = account
        self.settingCreate = settingCreate
        self.settingDelete = settingDelete
        self.settingUpdate = settingUpdate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalUpdate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalUpdate.subclass:
            return terminalUpdate.subclass(*args_, **kwargs_)
        else:
            return terminalUpdate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def get_settingCreate(self): return self.settingCreate
    def set_settingCreate(self, settingCreate): self.settingCreate = settingCreate
    def get_settingDelete(self): return self.settingDelete
    def set_settingDelete(self, settingDelete): self.settingDelete = settingDelete
    def get_settingUpdate(self): return self.settingUpdate
    def set_settingUpdate(self, settingUpdate): self.settingUpdate = settingUpdate
    def hasContent_(self):
        if (
            self.account is not None or
            self.settingCreate is not None or
            self.settingDelete is not None or
            self.settingUpdate is not None or
            super(terminalUpdate, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalUpdate', mapping_=None):
        element = super(terminalUpdate, self).to_etree(parent_element, name_, mapping_)
        if self.account is not None:
            account_ = self.account
            account_.to_etree(element, name_='account', mapping_=mapping_)
        if self.settingCreate is not None:
            settingCreate_ = self.settingCreate
            settingCreate_.to_etree(element, name_='settingCreate', mapping_=mapping_)
        if self.settingDelete is not None:
            settingDelete_ = self.settingDelete
            settingDelete_.to_etree(element, name_='settingDelete', mapping_=mapping_)
        if self.settingUpdate is not None:
            settingUpdate_ = self.settingUpdate
            settingUpdate_.to_etree(element, name_='settingUpdate', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalUpdate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(terminalUpdate, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(terminalUpdate, self).exportLiteralChildren(outfile, level, name_)
        if self.account is not None:
            showIndent(outfile, level)
            outfile.write('account=model_.account(\n')
            self.account.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.settingCreate is not None:
            showIndent(outfile, level)
            outfile.write('settingCreate=model_.settingCreateType(\n')
            self.settingCreate.exportLiteral(outfile, level, name_='settingCreate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.settingDelete is not None:
            showIndent(outfile, level)
            outfile.write('settingDelete=model_.settingDeleteType(\n')
            self.settingDelete.exportLiteral(outfile, level, name_='settingDelete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.settingUpdate is not None:
            showIndent(outfile, level)
            outfile.write('settingUpdate=model_.settingUpdateType(\n')
            self.settingUpdate.exportLiteral(outfile, level, name_='settingUpdate')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(terminalUpdate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'account':
            obj_ = account.factory()
            obj_.build(child_)
            self.account = obj_
            obj_.original_tagname_ = 'account'
        elif nodeName_ == 'settingCreate':
            obj_ = settingCreateType.factory()
            obj_.build(child_)
            self.settingCreate = obj_
            obj_.original_tagname_ = 'settingCreate'
        elif nodeName_ == 'settingDelete':
            obj_ = settingDeleteType.factory()
            obj_.build(child_)
            self.settingDelete = obj_
            obj_.original_tagname_ = 'settingDelete'
        elif nodeName_ == 'settingUpdate':
            obj_ = settingUpdateType.factory()
            obj_.build(child_)
            self.settingUpdate = obj_
            obj_.original_tagname_ = 'settingUpdate'
        super(terminalUpdate, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = [self.account.hash_string]
        if self.settingCreate:
            hash_list.append(self.settingCreate.hash_string)
        hash_list.append(str(self.dateTime.isoformat('T')))
        return ':'.join(hash_list)
# end class terminalUpdate


class taxUId(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('valueOf_', ['uId', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, taxUId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if taxUId.subclass:
            return taxUId.subclass(*args_, **kwargs_)
        else:
            return taxUId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='taxUId', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='taxUId'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class taxUId


class tipUId(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('valueOf_', ['uId', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tipUId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tipUId.subclass:
            return tipUId.subclass(*args_, **kwargs_)
        else:
            return tipUId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='tipUId', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='tipUId'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tipUId


class transactionReport(protectedMethod):
    member_data_items_ = [
        MemberSpec_('balanceInquiryCount', 'xs:int', 0, 1, {'name': 'balanceInquiryCount', 'type': 'xs:int', 'minOccurs': '0'}, None),
        MemberSpec_('cardAccountSummaryList', 'cardAccountSummaryListType', 0, 1, {'name': 'cardAccountSummaryList', 'minOccurs': '0', 'type': 'cardAccountSummaryListType'}, None),
        MemberSpec_('criterionType', ['transactionReportCriterion', 'xs:string'], 0, 0, {'name': 'criterionType', 'type': 'xs:string'}, None),
        MemberSpec_('criterionValue', 'xs:string', 0, 1, {'name': 'criterionValue', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('settlementDate', 'xs:dateTime', 0, 0, {'name': 'settlementDate', 'type': 'xs:dateTime'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, balanceInquiryCount=None, cardAccountSummaryList=None, criterionType=None, criterionValue=None, settlementDate=None):
        self.original_tagname_ = None
        super(transactionReport, self).__init__(dateTime, hash, )
        self.balanceInquiryCount = balanceInquiryCount
        self.cardAccountSummaryList = cardAccountSummaryList
        self.criterionType = criterionType
        self.validate_transactionReportCriterion(self.criterionType)
        self.criterionValue = criterionValue
        if isinstance(settlementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(settlementDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = settlementDate
        self.settlementDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transactionReport)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transactionReport.subclass:
            return transactionReport.subclass(*args_, **kwargs_)
        else:
            return transactionReport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_balanceInquiryCount(self): return self.balanceInquiryCount
    def set_balanceInquiryCount(self, balanceInquiryCount): self.balanceInquiryCount = balanceInquiryCount
    def get_cardAccountSummaryList(self): return self.cardAccountSummaryList
    def set_cardAccountSummaryList(self, cardAccountSummaryList): self.cardAccountSummaryList = cardAccountSummaryList
    def get_criterionType(self): return self.criterionType
    def set_criterionType(self, criterionType): self.criterionType = criterionType
    def get_criterionValue(self): return self.criterionValue
    def set_criterionValue(self, criterionValue): self.criterionValue = criterionValue
    def get_settlementDate(self): return self.settlementDate
    def set_settlementDate(self, settlementDate): self.settlementDate = settlementDate
    def validate_transactionReportCriterion(self, value):
        # Validate type transactionReportCriterion, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MERCHANT', 'DEVICE', 'OPERATOR']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on transactionReportCriterion' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.balanceInquiryCount is not None or
            self.cardAccountSummaryList is not None or
            self.criterionType is not None or
            self.criterionValue is not None or
            self.settlementDate is not None or
            super(transactionReport, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='transactionReport', mapping_=None):
        element = super(transactionReport, self).to_etree(parent_element, name_, mapping_)
        if self.balanceInquiryCount is not None:
            balanceInquiryCount_ = self.balanceInquiryCount
            etree_.SubElement(element, '{}balanceInquiryCount').text = self.gds_format_integer(balanceInquiryCount_)
        if self.cardAccountSummaryList is not None:
            cardAccountSummaryList_ = self.cardAccountSummaryList
            cardAccountSummaryList_.to_etree(element, name_='cardAccountSummaryList', mapping_=mapping_)
        if self.criterionType is not None:
            criterionType_ = self.criterionType
            etree_.SubElement(element, '{}criterionType').text = self.gds_format_string(criterionType_)
        if self.criterionValue is not None:
            criterionValue_ = self.criterionValue
            etree_.SubElement(element, '{}criterionValue').text = self.gds_format_string(criterionValue_)
        if self.settlementDate is not None:
            settlementDate_ = self.settlementDate
            etree_.SubElement(element, '{}settlementDate').text = self.gds_format_datetime(settlementDate_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='transactionReport'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(transactionReport, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(transactionReport, self).exportLiteralChildren(outfile, level, name_)
        if self.balanceInquiryCount is not None:
            showIndent(outfile, level)
            outfile.write('balanceInquiryCount=%d,\n' % self.balanceInquiryCount)
        if self.cardAccountSummaryList is not None:
            showIndent(outfile, level)
            outfile.write('cardAccountSummaryList=model_.cardAccountSummaryListType(\n')
            self.cardAccountSummaryList.exportLiteral(outfile, level, name_='cardAccountSummaryList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.criterionType is not None:
            showIndent(outfile, level)
            outfile.write('criterionType=%s,\n' % self.gds_encode(quote_python(self.criterionType)))
        if self.criterionValue is not None:
            showIndent(outfile, level)
            outfile.write('criterionValue=%s,\n' % self.gds_encode(quote_python(self.criterionValue)))
        if self.settlementDate is not None:
            showIndent(outfile, level)
            outfile.write('settlementDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.settlementDate, input_name='settlementDate'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(transactionReport, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'balanceInquiryCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'balanceInquiryCount')
            self.balanceInquiryCount = ival_
        elif nodeName_ == 'cardAccountSummaryList':
            obj_ = cardAccountSummaryListType.factory()
            obj_.build(child_)
            self.cardAccountSummaryList = obj_
            obj_.original_tagname_ = 'cardAccountSummaryList'
        elif nodeName_ == 'criterionType':
            criterionType_ = child_.text
            criterionType_ = self.gds_validate_string(criterionType_, node, 'criterionType')
            self.criterionType = criterionType_
            # validate type transactionReportCriterion
            self.validate_transactionReportCriterion(self.criterionType)
        elif nodeName_ == 'criterionValue':
            criterionValue_ = child_.text
            criterionValue_ = self.gds_validate_string(criterionValue_, node, 'criterionValue')
            self.criterionValue = criterionValue_
        elif nodeName_ == 'settlementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.settlementDate = dval_
        super(transactionReport, self).buildChildren(child_, node, nodeName_, True)
# end class transactionReport


class cardAccountSummary(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('altPurchaseCount', 'xs:int', 0, 0, {'name': 'altPurchaseCount', 'type': 'xs:int'}, None),
        MemberSpec_('altPurchaseTotal', 'xs:decimal', 0, 0, {'name': 'altPurchaseTotal', 'type': 'xs:decimal'}, None),
        MemberSpec_('altRefundCount', 'xs:int', 0, 0, {'name': 'altRefundCount', 'type': 'xs:int'}, None),
        MemberSpec_('altRefundTotal', 'xs:decimal', 0, 0, {'name': 'altRefundTotal', 'type': 'xs:decimal'}, None),
        MemberSpec_('cardAccount', ['cardAccount', 'xs:string'], 0, 0, {'name': 'cardAccount', 'type': 'xs:string'}, None),
        MemberSpec_('currency', ['currency', 'xs:string'], 0, 0, {'name': 'currency', 'type': 'xs:string'}, None),
        MemberSpec_('purchaseCount', 'xs:int', 0, 0, {'name': 'purchaseCount', 'type': 'xs:int'}, None),
        MemberSpec_('purchaseReversalCount', 'xs:int', 0, 0, {'name': 'purchaseReversalCount', 'type': 'xs:int'}, None),
        MemberSpec_('purchaseReversalTotal', 'xs:decimal', 0, 0, {'name': 'purchaseReversalTotal', 'type': 'xs:decimal'}, None),
        MemberSpec_('purchaseTotal', 'xs:decimal', 0, 0, {'name': 'purchaseTotal', 'type': 'xs:decimal'}, None),
        MemberSpec_('refundCount', 'xs:int', 0, 0, {'name': 'refundCount', 'type': 'xs:int'}, None),
        MemberSpec_('refundReversalCount', 'xs:int', 0, 0, {'name': 'refundReversalCount', 'type': 'xs:int'}, None),
        MemberSpec_('refundReversalTotal', 'xs:decimal', 0, 0, {'name': 'refundReversalTotal', 'type': 'xs:decimal'}, None),
        MemberSpec_('refundTotal', 'xs:decimal', 0, 0, {'name': 'refundTotal', 'type': 'xs:decimal'}, None),
        MemberSpec_('subTotalAmount', 'xs:decimal', 0, 0, {'name': 'subTotalAmount', 'type': 'xs:decimal'}, None),
        MemberSpec_('subTotalCount', 'xs:int', 0, 0, {'name': 'subTotalCount', 'type': 'xs:int'}, None),
        MemberSpec_('withdrawalCount', 'xs:int', 0, 0, {'name': 'withdrawalCount', 'type': 'xs:int'}, None),
        MemberSpec_('withdrawalTotal', 'xs:decimal', 0, 0, {'name': 'withdrawalTotal', 'type': 'xs:decimal'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, altPurchaseCount=None, altPurchaseTotal=None, altRefundCount=None, altRefundTotal=None, cardAccount=None, currency=None, purchaseCount=None, purchaseReversalCount=None, purchaseReversalTotal=None, purchaseTotal=None, refundCount=None, refundReversalCount=None, refundReversalTotal=None, refundTotal=None, subTotalAmount=None, subTotalCount=None, withdrawalCount=None, withdrawalTotal=None):
        self.original_tagname_ = None
        self.altPurchaseCount = altPurchaseCount
        self.altPurchaseTotal = altPurchaseTotal
        self.altRefundCount = altRefundCount
        self.altRefundTotal = altRefundTotal
        self.cardAccount = cardAccount
        self.validate_cardAccount(self.cardAccount)
        self.currency = currency
        self.validate_currency(self.currency)
        self.purchaseCount = purchaseCount
        self.purchaseReversalCount = purchaseReversalCount
        self.purchaseReversalTotal = purchaseReversalTotal
        self.purchaseTotal = purchaseTotal
        self.refundCount = refundCount
        self.refundReversalCount = refundReversalCount
        self.refundReversalTotal = refundReversalTotal
        self.refundTotal = refundTotal
        self.subTotalAmount = subTotalAmount
        self.subTotalCount = subTotalCount
        self.withdrawalCount = withdrawalCount
        self.withdrawalTotal = withdrawalTotal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardAccountSummary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardAccountSummary.subclass:
            return cardAccountSummary.subclass(*args_, **kwargs_)
        else:
            return cardAccountSummary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_altPurchaseCount(self): return self.altPurchaseCount
    def set_altPurchaseCount(self, altPurchaseCount): self.altPurchaseCount = altPurchaseCount
    def get_altPurchaseTotal(self): return self.altPurchaseTotal
    def set_altPurchaseTotal(self, altPurchaseTotal): self.altPurchaseTotal = altPurchaseTotal
    def get_altRefundCount(self): return self.altRefundCount
    def set_altRefundCount(self, altRefundCount): self.altRefundCount = altRefundCount
    def get_altRefundTotal(self): return self.altRefundTotal
    def set_altRefundTotal(self, altRefundTotal): self.altRefundTotal = altRefundTotal
    def get_cardAccount(self): return self.cardAccount
    def set_cardAccount(self, cardAccount): self.cardAccount = cardAccount
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_purchaseCount(self): return self.purchaseCount
    def set_purchaseCount(self, purchaseCount): self.purchaseCount = purchaseCount
    def get_purchaseReversalCount(self): return self.purchaseReversalCount
    def set_purchaseReversalCount(self, purchaseReversalCount): self.purchaseReversalCount = purchaseReversalCount
    def get_purchaseReversalTotal(self): return self.purchaseReversalTotal
    def set_purchaseReversalTotal(self, purchaseReversalTotal): self.purchaseReversalTotal = purchaseReversalTotal
    def get_purchaseTotal(self): return self.purchaseTotal
    def set_purchaseTotal(self, purchaseTotal): self.purchaseTotal = purchaseTotal
    def get_refundCount(self): return self.refundCount
    def set_refundCount(self, refundCount): self.refundCount = refundCount
    def get_refundReversalCount(self): return self.refundReversalCount
    def set_refundReversalCount(self, refundReversalCount): self.refundReversalCount = refundReversalCount
    def get_refundReversalTotal(self): return self.refundReversalTotal
    def set_refundReversalTotal(self, refundReversalTotal): self.refundReversalTotal = refundReversalTotal
    def get_refundTotal(self): return self.refundTotal
    def set_refundTotal(self, refundTotal): self.refundTotal = refundTotal
    def get_subTotalAmount(self): return self.subTotalAmount
    def set_subTotalAmount(self, subTotalAmount): self.subTotalAmount = subTotalAmount
    def get_subTotalCount(self): return self.subTotalCount
    def set_subTotalCount(self, subTotalCount): self.subTotalCount = subTotalCount
    def get_withdrawalCount(self): return self.withdrawalCount
    def set_withdrawalCount(self, withdrawalCount): self.withdrawalCount = withdrawalCount
    def get_withdrawalTotal(self): return self.withdrawalTotal
    def set_withdrawalTotal(self, withdrawalTotal): self.withdrawalTotal = withdrawalTotal
    def validate_cardAccount(self, value):
        # Validate type cardAccount, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CASH', 'FOOD_STAMP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cardAccount' % {"value" : value.encode("utf-8")} )
    def validate_currency(self, value):
        # Validate type currency, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYR', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LTL', 'LVL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRO', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLL', 'SOS', 'SRD', 'SSP', 'STD', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'USS', 'UYI', 'UYU', 'UZS', 'VEF', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XCD', 'XOF', 'XPF', 'YER', 'ZAR', 'ZMW', 'ZWL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on currency' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.altPurchaseCount is not None or
            self.altPurchaseTotal is not None or
            self.altRefundCount is not None or
            self.altRefundTotal is not None or
            self.cardAccount is not None or
            self.currency is not None or
            self.purchaseCount is not None or
            self.purchaseReversalCount is not None or
            self.purchaseReversalTotal is not None or
            self.purchaseTotal is not None or
            self.refundCount is not None or
            self.refundReversalCount is not None or
            self.refundReversalTotal is not None or
            self.refundTotal is not None or
            self.subTotalAmount is not None or
            self.subTotalCount is not None or
            self.withdrawalCount is not None or
            self.withdrawalTotal is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='cardAccountSummary', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.altPurchaseCount is not None:
            altPurchaseCount_ = self.altPurchaseCount
            etree_.SubElement(element, '{}altPurchaseCount').text = self.gds_format_integer(altPurchaseCount_)
        if self.altPurchaseTotal is not None:
            altPurchaseTotal_ = self.altPurchaseTotal
            etree_.SubElement(element, '{}altPurchaseTotal').text = self.gds_format_float(altPurchaseTotal_)
        if self.altRefundCount is not None:
            altRefundCount_ = self.altRefundCount
            etree_.SubElement(element, '{}altRefundCount').text = self.gds_format_integer(altRefundCount_)
        if self.altRefundTotal is not None:
            altRefundTotal_ = self.altRefundTotal
            etree_.SubElement(element, '{}altRefundTotal').text = self.gds_format_float(altRefundTotal_)
        if self.cardAccount is not None:
            cardAccount_ = self.cardAccount
            etree_.SubElement(element, '{}cardAccount').text = self.gds_format_string(cardAccount_)
        if self.currency is not None:
            currency_ = self.currency
            etree_.SubElement(element, '{}currency').text = self.gds_format_string(currency_)
        if self.purchaseCount is not None:
            purchaseCount_ = self.purchaseCount
            etree_.SubElement(element, '{}purchaseCount').text = self.gds_format_integer(purchaseCount_)
        if self.purchaseReversalCount is not None:
            purchaseReversalCount_ = self.purchaseReversalCount
            etree_.SubElement(element, '{}purchaseReversalCount').text = self.gds_format_integer(purchaseReversalCount_)
        if self.purchaseReversalTotal is not None:
            purchaseReversalTotal_ = self.purchaseReversalTotal
            etree_.SubElement(element, '{}purchaseReversalTotal').text = self.gds_format_float(purchaseReversalTotal_)
        if self.purchaseTotal is not None:
            purchaseTotal_ = self.purchaseTotal
            etree_.SubElement(element, '{}purchaseTotal').text = self.gds_format_float(purchaseTotal_)
        if self.refundCount is not None:
            refundCount_ = self.refundCount
            etree_.SubElement(element, '{}refundCount').text = self.gds_format_integer(refundCount_)
        if self.refundReversalCount is not None:
            refundReversalCount_ = self.refundReversalCount
            etree_.SubElement(element, '{}refundReversalCount').text = self.gds_format_integer(refundReversalCount_)
        if self.refundReversalTotal is not None:
            refundReversalTotal_ = self.refundReversalTotal
            etree_.SubElement(element, '{}refundReversalTotal').text = self.gds_format_float(refundReversalTotal_)
        if self.refundTotal is not None:
            refundTotal_ = self.refundTotal
            etree_.SubElement(element, '{}refundTotal').text = self.gds_format_float(refundTotal_)
        if self.subTotalAmount is not None:
            subTotalAmount_ = self.subTotalAmount
            etree_.SubElement(element, '{}subTotalAmount').text = self.gds_format_float(subTotalAmount_)
        if self.subTotalCount is not None:
            subTotalCount_ = self.subTotalCount
            etree_.SubElement(element, '{}subTotalCount').text = self.gds_format_integer(subTotalCount_)
        if self.withdrawalCount is not None:
            withdrawalCount_ = self.withdrawalCount
            etree_.SubElement(element, '{}withdrawalCount').text = self.gds_format_integer(withdrawalCount_)
        if self.withdrawalTotal is not None:
            withdrawalTotal_ = self.withdrawalTotal
            etree_.SubElement(element, '{}withdrawalTotal').text = self.gds_format_float(withdrawalTotal_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='cardAccountSummary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.altPurchaseCount is not None:
            showIndent(outfile, level)
            outfile.write('altPurchaseCount=%d,\n' % self.altPurchaseCount)
        if self.altPurchaseTotal is not None:
            showIndent(outfile, level)
            outfile.write('altPurchaseTotal=%f,\n' % self.altPurchaseTotal)
        if self.altRefundCount is not None:
            showIndent(outfile, level)
            outfile.write('altRefundCount=%d,\n' % self.altRefundCount)
        if self.altRefundTotal is not None:
            showIndent(outfile, level)
            outfile.write('altRefundTotal=%f,\n' % self.altRefundTotal)
        if self.cardAccount is not None:
            showIndent(outfile, level)
            outfile.write('cardAccount=%s,\n' % self.gds_encode(quote_python(self.cardAccount)))
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=%s,\n' % self.gds_encode(quote_python(self.currency)))
        if self.purchaseCount is not None:
            showIndent(outfile, level)
            outfile.write('purchaseCount=%d,\n' % self.purchaseCount)
        if self.purchaseReversalCount is not None:
            showIndent(outfile, level)
            outfile.write('purchaseReversalCount=%d,\n' % self.purchaseReversalCount)
        if self.purchaseReversalTotal is not None:
            showIndent(outfile, level)
            outfile.write('purchaseReversalTotal=%f,\n' % self.purchaseReversalTotal)
        if self.purchaseTotal is not None:
            showIndent(outfile, level)
            outfile.write('purchaseTotal=%f,\n' % self.purchaseTotal)
        if self.refundCount is not None:
            showIndent(outfile, level)
            outfile.write('refundCount=%d,\n' % self.refundCount)
        if self.refundReversalCount is not None:
            showIndent(outfile, level)
            outfile.write('refundReversalCount=%d,\n' % self.refundReversalCount)
        if self.refundReversalTotal is not None:
            showIndent(outfile, level)
            outfile.write('refundReversalTotal=%f,\n' % self.refundReversalTotal)
        if self.refundTotal is not None:
            showIndent(outfile, level)
            outfile.write('refundTotal=%f,\n' % self.refundTotal)
        if self.subTotalAmount is not None:
            showIndent(outfile, level)
            outfile.write('subTotalAmount=%f,\n' % self.subTotalAmount)
        if self.subTotalCount is not None:
            showIndent(outfile, level)
            outfile.write('subTotalCount=%d,\n' % self.subTotalCount)
        if self.withdrawalCount is not None:
            showIndent(outfile, level)
            outfile.write('withdrawalCount=%d,\n' % self.withdrawalCount)
        if self.withdrawalTotal is not None:
            showIndent(outfile, level)
            outfile.write('withdrawalTotal=%f,\n' % self.withdrawalTotal)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'altPurchaseCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'altPurchaseCount')
            self.altPurchaseCount = ival_
        elif nodeName_ == 'altPurchaseTotal' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'altPurchaseTotal')
            self.altPurchaseTotal = fval_
        elif nodeName_ == 'altRefundCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'altRefundCount')
            self.altRefundCount = ival_
        elif nodeName_ == 'altRefundTotal' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'altRefundTotal')
            self.altRefundTotal = fval_
        elif nodeName_ == 'cardAccount':
            cardAccount_ = child_.text
            cardAccount_ = self.gds_validate_string(cardAccount_, node, 'cardAccount')
            self.cardAccount = cardAccount_
            # validate type cardAccount
            self.validate_cardAccount(self.cardAccount)
        elif nodeName_ == 'currency':
            currency_ = child_.text
            currency_ = self.gds_validate_string(currency_, node, 'currency')
            self.currency = currency_
            # validate type currency
            self.validate_currency(self.currency)
        elif nodeName_ == 'purchaseCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'purchaseCount')
            self.purchaseCount = ival_
        elif nodeName_ == 'purchaseReversalCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'purchaseReversalCount')
            self.purchaseReversalCount = ival_
        elif nodeName_ == 'purchaseReversalTotal' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'purchaseReversalTotal')
            self.purchaseReversalTotal = fval_
        elif nodeName_ == 'purchaseTotal' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'purchaseTotal')
            self.purchaseTotal = fval_
        elif nodeName_ == 'refundCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'refundCount')
            self.refundCount = ival_
        elif nodeName_ == 'refundReversalCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'refundReversalCount')
            self.refundReversalCount = ival_
        elif nodeName_ == 'refundReversalTotal' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'refundReversalTotal')
            self.refundReversalTotal = fval_
        elif nodeName_ == 'refundTotal' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'refundTotal')
            self.refundTotal = fval_
        elif nodeName_ == 'subTotalAmount' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'subTotalAmount')
            self.subTotalAmount = fval_
        elif nodeName_ == 'subTotalCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'subTotalCount')
            self.subTotalCount = ival_
        elif nodeName_ == 'withdrawalCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'withdrawalCount')
            self.withdrawalCount = ival_
        elif nodeName_ == 'withdrawalTotal' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'withdrawalTotal')
            self.withdrawalTotal = fval_
# end class cardAccountSummary


class payconexTransactionData(protectedMethod):
    member_data_items_ = [
        MemberSpec_('accountIdDigest', 'xs:string', 0, 0, {'name': 'accountIdDigest', 'type': 'xs:string'}, None),
        MemberSpec_('amount', 'amount', 0, 0, {'name': 'amount', 'type': 'amount'}, None),
        MemberSpec_('transactionId', 'xs:string', 0, 0, {'name': 'transactionId', 'type': 'xs:string'}, None),
        MemberSpec_('transactionType', ['transactionType', 'xs:string'], 0, 0, {'name': 'transactionType', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, accountIdDigest=None, amount=None, transactionId=None, transactionType=None):
        self.original_tagname_ = None
        super(payconexTransactionData, self).__init__(dateTime, hash, )
        self.accountIdDigest = accountIdDigest
        self.amount = amount
        self.transactionId = transactionId
        self.transactionType = transactionType
        self.validate_transactionType(self.transactionType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, payconexTransactionData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if payconexTransactionData.subclass:
            return payconexTransactionData.subclass(*args_, **kwargs_)
        else:
            return payconexTransactionData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountIdDigest(self): return self.accountIdDigest
    def set_accountIdDigest(self, accountIdDigest): self.accountIdDigest = accountIdDigest
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_transactionId(self): return self.transactionId
    def set_transactionId(self, transactionId): self.transactionId = transactionId
    def get_transactionType(self): return self.transactionType
    def set_transactionType(self, transactionType): self.transactionType = transactionType
    def validate_transactionType(self, value):
        # Validate type transactionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SALE', 'REFUND', 'PRE_AUTH', 'PRE_AUTH_COMPLETION', 'OFFLINE_DECLINE', 'DEFERRED_AUTH']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on transactionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.accountIdDigest is not None or
            self.amount is not None or
            self.transactionId is not None or
            self.transactionType is not None or
            super(payconexTransactionData, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='payconexTransactionData', mapping_=None):
        element = super(payconexTransactionData, self).to_etree(parent_element, name_, mapping_)
        if self.accountIdDigest is not None:
            accountIdDigest_ = self.accountIdDigest
            etree_.SubElement(element, '{}accountIdDigest').text = self.gds_format_string(accountIdDigest_)
        if self.amount is not None:
            amount_ = self.amount
            amount_.to_etree(element, name_='amount', mapping_=mapping_)
        if self.transactionId is not None:
            transactionId_ = self.transactionId
            etree_.SubElement(element, '{}transactionId').text = self.gds_format_string(transactionId_)
        if self.transactionType is not None:
            transactionType_ = self.transactionType
            etree_.SubElement(element, '{}transactionType').text = self.gds_format_string(transactionType_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='payconexTransactionData'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(payconexTransactionData, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(payconexTransactionData, self).exportLiteralChildren(outfile, level, name_)
        if self.accountIdDigest is not None:
            showIndent(outfile, level)
            outfile.write('accountIdDigest=%s,\n' % self.gds_encode(quote_python(self.accountIdDigest)))
        if self.amount is not None:
            showIndent(outfile, level)
            outfile.write('amount=model_.amount(\n')
            self.amount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.transactionId is not None:
            showIndent(outfile, level)
            outfile.write('transactionId=%s,\n' % self.gds_encode(quote_python(self.transactionId)))
        if self.transactionType is not None:
            showIndent(outfile, level)
            outfile.write('transactionType=%s,\n' % self.gds_encode(quote_python(self.transactionType)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(payconexTransactionData, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accountIdDigest':
            accountIdDigest_ = child_.text
            accountIdDigest_ = self.gds_validate_string(accountIdDigest_, node, 'accountIdDigest')
            self.accountIdDigest = accountIdDigest_
        elif nodeName_ == 'amount':
            class_obj_ = self.get_class_obj_(child_, amount)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.amount = obj_
            obj_.original_tagname_ = 'amount'
        elif nodeName_ == 'transactionId':
            transactionId_ = child_.text
            transactionId_ = self.gds_validate_string(transactionId_, node, 'transactionId')
            self.transactionId = transactionId_
        elif nodeName_ == 'transactionType':
            transactionType_ = child_.text
            transactionType_ = self.gds_validate_string(transactionType_, node, 'transactionType')
            self.transactionType = transactionType_
            # validate type transactionType
            self.validate_transactionType(self.transactionType)
        super(payconexTransactionData, self).buildChildren(child_, node, nodeName_, True)
# end class payconexTransactionData


class authenticationRequestKey(standardKey):
    member_data_items_ = [
    ]
    subclass = None
    superclass = standardKey
    def __init__(self, key=None, validUntil=None):
        self.original_tagname_ = None
        super(authenticationRequestKey, self).__init__(key, validUntil, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, authenticationRequestKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if authenticationRequestKey.subclass:
            return authenticationRequestKey.subclass(*args_, **kwargs_)
        else:
            return authenticationRequestKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(authenticationRequestKey, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='authenticationRequestKey', mapping_=None):
        element = super(authenticationRequestKey, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='authenticationRequestKey'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(authenticationRequestKey, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(authenticationRequestKey, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(authenticationRequestKey, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(authenticationRequestKey, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class authenticationRequestKey


class cardTypeInfoRequest(protectedMethod):
    member_data_items_ = [
        MemberSpec_('account', 'account', 0, 0, {'name': 'account', 'type': 'account'}, None),
        MemberSpec_('cardTypeMethod', 'cardTypeMethod', 0, 0, {'name': 'cardTypeMethod', 'type': 'cardTypeMethod'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, account=None, cardTypeMethod=None):
        self.original_tagname_ = None
        super(cardTypeInfoRequest, self).__init__(dateTime, hash, )
        self.account = account
        self.cardTypeMethod = cardTypeMethod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardTypeInfoRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardTypeInfoRequest.subclass:
            return cardTypeInfoRequest.subclass(*args_, **kwargs_)
        else:
            return cardTypeInfoRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def get_cardTypeMethod(self): return self.cardTypeMethod
    def set_cardTypeMethod(self, cardTypeMethod): self.cardTypeMethod = cardTypeMethod
    def hasContent_(self):
        if (
            self.account is not None or
            self.cardTypeMethod is not None or
            super(cardTypeInfoRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='cardTypeInfoRequest', mapping_=None):
        element = super(cardTypeInfoRequest, self).to_etree(parent_element, name_, mapping_)
        if self.account is not None:
            account_ = self.account
            account_.to_etree(element, name_='account', mapping_=mapping_)
        if self.cardTypeMethod is not None:
            cardTypeMethod_ = self.cardTypeMethod
            cardTypeMethod_.to_etree(element, name_='cardTypeMethod', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='cardTypeInfoRequest'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(cardTypeInfoRequest, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cardTypeInfoRequest, self).exportLiteralChildren(outfile, level, name_)
        if self.account is not None:
            showIndent(outfile, level)
            outfile.write('account=model_.account(\n')
            self.account.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cardTypeMethod is not None:
            showIndent(outfile, level)
            outfile.write('cardTypeMethod=model_.cardTypeMethod(\n')
            self.cardTypeMethod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(cardTypeInfoRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'account':
            obj_ = account.factory()
            obj_.build(child_)
            self.account = obj_
            obj_.original_tagname_ = 'account'
        elif nodeName_ == 'cardTypeMethod':
            obj_ = cardTypeMethod.factory()
            obj_.build(child_)
            self.cardTypeMethod = obj_
            obj_.original_tagname_ = 'cardTypeMethod'
        super(cardTypeInfoRequest, self).buildChildren(child_, node, nodeName_, True)
# end class cardTypeInfoRequest


class cardTypeMethod(baseMethod):
    member_data_items_ = [
        MemberSpec_('ClearCard', 'clearCard', 0, 0, {'name': 'ClearCard', 'type': 'clearCard'}, None),
    ]
    subclass = None
    superclass = baseMethod
    def __init__(self, ClearCard=None):
        self.original_tagname_ = None
        super(cardTypeMethod, self).__init__()
        self.ClearCard = ClearCard
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardTypeMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardTypeMethod.subclass:
            return cardTypeMethod.subclass(*args_, **kwargs_)
        else:
            return cardTypeMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClearCard(self): return self.ClearCard
    def set_ClearCard(self, ClearCard): self.ClearCard = ClearCard
    def hasContent_(self):
        if (
            self.ClearCard is not None or
            super(cardTypeMethod, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='cardTypeMethod', mapping_=None):
        element = super(cardTypeMethod, self).to_etree(parent_element, name_, mapping_)
        if self.ClearCard is not None:
            ClearCard_ = self.ClearCard
            ClearCard_.to_etree(element, name_='ClearCard', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='cardTypeMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(cardTypeMethod, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cardTypeMethod, self).exportLiteralChildren(outfile, level, name_)
        if self.ClearCard is not None:
            showIndent(outfile, level)
            outfile.write('ClearCard=model_.clearCard(\n')
            self.ClearCard.exportLiteral(outfile, level, name_='ClearCard')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(cardTypeMethod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClearCard':
            obj_ = clearCard.factory()
            obj_.build(child_)
            self.ClearCard = obj_
            obj_.original_tagname_ = 'ClearCard'
        super(cardTypeMethod, self).buildChildren(child_, node, nodeName_, True)
# end class cardTypeMethod


class clearCard(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardNumber', 'xs:string', 0, 0, {'name': 'cardNumber', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardNumber=None):
        self.original_tagname_ = None
        self.cardNumber = cardNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clearCard)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clearCard.subclass:
            return clearCard.subclass(*args_, **kwargs_)
        else:
            return clearCard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardNumber(self): return self.cardNumber
    def set_cardNumber(self, cardNumber): self.cardNumber = cardNumber
    def hasContent_(self):
        if (
            self.cardNumber is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='clearCard', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cardNumber is not None:
            cardNumber_ = self.cardNumber
            etree_.SubElement(element, '{}cardNumber').text = self.gds_format_string(cardNumber_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='clearCard'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cardNumber is not None:
            showIndent(outfile, level)
            outfile.write('cardNumber=%s,\n' % self.gds_encode(quote_python(self.cardNumber)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardNumber':
            cardNumber_ = child_.text
            cardNumber_ = self.gds_validate_string(cardNumber_, node, 'cardNumber')
            self.cardNumber = cardNumber_
# end class clearCard


class terminalUpdateResponse(protectedMethod):
    member_data_items_ = [
        MemberSpec_('settingCreate', 'settingCreateType3', 0, 1, {'name': 'settingCreate', 'minOccurs': '0', 'type': 'settingCreateType3'}, None),
        MemberSpec_('settingDelete', 'settingDeleteType4', 0, 1, {'name': 'settingDelete', 'minOccurs': '0', 'type': 'settingDeleteType4'}, None),
        MemberSpec_('settingUpdate', 'settingUpdateType5', 0, 1, {'name': 'settingUpdate', 'minOccurs': '0', 'type': 'settingUpdateType5'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, settingCreate=None, settingDelete=None, settingUpdate=None):
        self.original_tagname_ = None
        super(terminalUpdateResponse, self).__init__(dateTime, hash, )
        self.settingCreate = settingCreate
        self.settingDelete = settingDelete
        self.settingUpdate = settingUpdate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalUpdateResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalUpdateResponse.subclass:
            return terminalUpdateResponse.subclass(*args_, **kwargs_)
        else:
            return terminalUpdateResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settingCreate(self): return self.settingCreate
    def set_settingCreate(self, settingCreate): self.settingCreate = settingCreate
    def get_settingDelete(self): return self.settingDelete
    def set_settingDelete(self, settingDelete): self.settingDelete = settingDelete
    def get_settingUpdate(self): return self.settingUpdate
    def set_settingUpdate(self, settingUpdate): self.settingUpdate = settingUpdate
    def hasContent_(self):
        if (
            self.settingCreate is not None or
            self.settingDelete is not None or
            self.settingUpdate is not None or
            super(terminalUpdateResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalUpdateResponse', mapping_=None):
        element = super(terminalUpdateResponse, self).to_etree(parent_element, name_, mapping_)
        if self.settingCreate is not None:
            settingCreate_ = self.settingCreate
            settingCreate_.to_etree(element, name_='settingCreate', mapping_=mapping_)
        if self.settingDelete is not None:
            settingDelete_ = self.settingDelete
            settingDelete_.to_etree(element, name_='settingDelete', mapping_=mapping_)
        if self.settingUpdate is not None:
            settingUpdate_ = self.settingUpdate
            settingUpdate_.to_etree(element, name_='settingUpdate', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalUpdateResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(terminalUpdateResponse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(terminalUpdateResponse, self).exportLiteralChildren(outfile, level, name_)
        if self.settingCreate is not None:
            showIndent(outfile, level)
            outfile.write('settingCreate=model_.settingCreateType3(\n')
            self.settingCreate.exportLiteral(outfile, level, name_='settingCreate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.settingDelete is not None:
            showIndent(outfile, level)
            outfile.write('settingDelete=model_.settingDeleteType4(\n')
            self.settingDelete.exportLiteral(outfile, level, name_='settingDelete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.settingUpdate is not None:
            showIndent(outfile, level)
            outfile.write('settingUpdate=model_.settingUpdateType5(\n')
            self.settingUpdate.exportLiteral(outfile, level, name_='settingUpdate')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(terminalUpdateResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settingCreate':
            obj_ = settingCreateType3.factory()
            obj_.build(child_)
            self.settingCreate = obj_
            obj_.original_tagname_ = 'settingCreate'
        elif nodeName_ == 'settingDelete':
            obj_ = settingDeleteType4.factory()
            obj_.build(child_)
            self.settingDelete = obj_
            obj_.original_tagname_ = 'settingDelete'
        elif nodeName_ == 'settingUpdate':
            obj_ = settingUpdateType5.factory()
            obj_.build(child_)
            self.settingUpdate = obj_
            obj_.original_tagname_ = 'settingUpdate'
        super(terminalUpdateResponse, self).buildChildren(child_, node, nodeName_, True)
# end class terminalUpdateResponse


class customFieldsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('customField', 'customField', 1, 1, {'name': 'customField', 'type': 'customField', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, customField=None):
        self.original_tagname_ = None
        if customField is None:
            self.customField = []
        else:
            self.customField = customField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customFieldsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customFieldsType.subclass:
            return customFieldsType.subclass(*args_, **kwargs_)
        else:
            return customFieldsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_customField(self): return self.customField
    def set_customField(self, customField): self.customField = customField
    def add_customField(self, value): self.customField.append(value)
    def insert_customField_at(self, index, value): self.customField.insert(index, value)
    def replace_customField_at(self, index, value): self.customField[index] = value
    def hasContent_(self):
        if (
            self.customField
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='customFieldsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for customField_ in self.customField:
            customField_.to_etree(element, name_='customField', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='customFieldsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('customField=[\n')
        level += 1
        for customField_ in self.customField:
            showIndent(outfile, level)
            outfile.write('model_.customField(\n')
            customField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'customField':
            obj_ = customField.factory()
            obj_.build(child_)
            self.customField.append(obj_)
            obj_.original_tagname_ = 'customField'

    @property
    def hash_string(self):
        hash_list = []
        if self.customField is not None:
            for cf in self.customField:
                hash_list.append(cf.name)
                hash_list.append(cf.value)
        return ':'.join(hash_list)
# end class customFieldsType


class applicationsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('application', 'application', 1, 0, {'ref': 'application', 'maxOccurs': 'unbounded', 'name': 'application', 'type': 'application'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, application=None):
        self.original_tagname_ = None
        if application is None:
            self.application = []
        else:
            self.application = application
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, applicationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if applicationsType.subclass:
            return applicationsType.subclass(*args_, **kwargs_)
        else:
            return applicationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_application(self): return self.application
    def set_application(self, application): self.application = application
    def add_application(self, value): self.application.append(value)
    def insert_application_at(self, index, value): self.application.insert(index, value)
    def replace_application_at(self, index, value): self.application[index] = value
    def hasContent_(self):
        if (
            self.application
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='applicationsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for application_ in self.application:
            application_.to_etree(element, name_='application', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='applicationsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('application=[\n')
        level += 1
        for application_ in self.application:
            showIndent(outfile, level)
            outfile.write('model_.application(\n')
            application_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'application':
            obj_ = application.factory()
            obj_.build(child_)
            self.application.append(obj_)
            obj_.original_tagname_ = 'application'
# end class applicationsType


class caCertificatesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('caCertificate', 'caCertificate', 1, 0, {'ref': 'caCertificate', 'maxOccurs': 'unbounded', 'name': 'caCertificate', 'type': 'caCertificate'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, caCertificate=None):
        self.original_tagname_ = None
        if caCertificate is None:
            self.caCertificate = []
        else:
            self.caCertificate = caCertificate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, caCertificatesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if caCertificatesType.subclass:
            return caCertificatesType.subclass(*args_, **kwargs_)
        else:
            return caCertificatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_caCertificate(self): return self.caCertificate
    def set_caCertificate(self, caCertificate): self.caCertificate = caCertificate
    def add_caCertificate(self, value): self.caCertificate.append(value)
    def insert_caCertificate_at(self, index, value): self.caCertificate.insert(index, value)
    def replace_caCertificate_at(self, index, value): self.caCertificate[index] = value
    def hasContent_(self):
        if (
            self.caCertificate
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='caCertificatesType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for caCertificate_ in self.caCertificate:
            caCertificate_.to_etree(element, name_='caCertificate', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='caCertificatesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('caCertificate=[\n')
        level += 1
        for caCertificate_ in self.caCertificate:
            showIndent(outfile, level)
            outfile.write('model_.caCertificate(\n')
            caCertificate_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'caCertificate':
            obj_ = caCertificate.factory()
            obj_.build(child_)
            self.caCertificate.append(obj_)
            obj_.original_tagname_ = 'caCertificate'
# end class caCertificatesType


class currenciesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('currency', ['currency', 'xs:string'], 1, 0, {'name': 'currency', 'type': 'xs:string', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, currency=None):
        self.original_tagname_ = None
        if currency is None:
            self.currency = []
        else:
            self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, currenciesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if currenciesType.subclass:
            return currenciesType.subclass(*args_, **kwargs_)
        else:
            return currenciesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def add_currency(self, value): self.currency.append(value)
    def insert_currency_at(self, index, value): self.currency.insert(index, value)
    def replace_currency_at(self, index, value): self.currency[index] = value
    def validate_currency(self, value):
        # Validate type currency, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYR', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LTL', 'LVL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRO', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLL', 'SOS', 'SRD', 'SSP', 'STD', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'USS', 'UYI', 'UYU', 'UZS', 'VEF', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XCD', 'XOF', 'XPF', 'YER', 'ZAR', 'ZMW', 'ZWL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on currency' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.currency
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='currenciesType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for currency_ in self.currency:
            etree_.SubElement(element, '{}currency').text = self.gds_format_string(currency_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='currenciesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('currency=[\n')
        level += 1
        for currency_ in self.currency:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(currency_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            currency_ = child_.text
            currency_ = self.gds_validate_string(currency_, node, 'currency')
            self.currency.append(currency_)
            # validate type currency
            self.validate_currency(self.currency[-1])
# end class currenciesType


class emvTagsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('emvTag', 'emvTag', 1, 0, {'name': 'emvTag', 'type': 'emvTag', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, emvTag=None):
        self.original_tagname_ = None
        if emvTag is None:
            self.emvTag = []
        else:
            self.emvTag = emvTag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emvTagsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emvTagsType.subclass:
            return emvTagsType.subclass(*args_, **kwargs_)
        else:
            return emvTagsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emvTag(self): return self.emvTag
    def set_emvTag(self, emvTag): self.emvTag = emvTag
    def add_emvTag(self, value): self.emvTag.append(value)
    def insert_emvTag_at(self, index, value): self.emvTag.insert(index, value)
    def replace_emvTag_at(self, index, value): self.emvTag[index] = value
    def hasContent_(self):
        if (
            self.emvTag
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='emvTagsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for emvTag_ in self.emvTag:
            emvTag_.to_etree(element, name_='emvTag', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='emvTagsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('emvTag=[\n')
        level += 1
        for emvTag_ in self.emvTag:
            showIndent(outfile, level)
            outfile.write('model_.emvTag(\n')
            emvTag_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emvTag':
            obj_ = emvTag.factory()
            obj_.build(child_)
            self.emvTag.append(obj_)
            obj_.original_tagname_ = 'emvTag'
# end class emvTagsType


class revokedCaCertificatesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('revokedCaCertificate', 'caCertificate', 1, 0, {'name': 'revokedCaCertificate', 'type': 'caCertificate', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, revokedCaCertificate=None):
        self.original_tagname_ = None
        if revokedCaCertificate is None:
            self.revokedCaCertificate = []
        else:
            self.revokedCaCertificate = revokedCaCertificate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, revokedCaCertificatesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if revokedCaCertificatesType.subclass:
            return revokedCaCertificatesType.subclass(*args_, **kwargs_)
        else:
            return revokedCaCertificatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_revokedCaCertificate(self): return self.revokedCaCertificate
    def set_revokedCaCertificate(self, revokedCaCertificate): self.revokedCaCertificate = revokedCaCertificate
    def add_revokedCaCertificate(self, value): self.revokedCaCertificate.append(value)
    def insert_revokedCaCertificate_at(self, index, value): self.revokedCaCertificate.insert(index, value)
    def replace_revokedCaCertificate_at(self, index, value): self.revokedCaCertificate[index] = value
    def hasContent_(self):
        if (
            self.revokedCaCertificate
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='revokedCaCertificatesType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for revokedCaCertificate_ in self.revokedCaCertificate:
            revokedCaCertificate_.to_etree(element, name_='revokedCaCertificate', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='revokedCaCertificatesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('revokedCaCertificate=[\n')
        level += 1
        for revokedCaCertificate_ in self.revokedCaCertificate:
            showIndent(outfile, level)
            outfile.write('model_.caCertificate(\n')
            revokedCaCertificate_.exportLiteral(outfile, level, name_='caCertificate')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'revokedCaCertificate':
            obj_ = caCertificate.factory()
            obj_.build(child_)
            self.revokedCaCertificate.append(obj_)
            obj_.original_tagname_ = 'revokedCaCertificate'
# end class revokedCaCertificatesType


class terminalTaxesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('terminalTax', 'terminalTax', 1, 0, {'name': 'terminalTax', 'type': 'terminalTax', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, terminalTax=None):
        self.original_tagname_ = None
        if terminalTax is None:
            self.terminalTax = []
        else:
            self.terminalTax = terminalTax
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalTaxesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalTaxesType.subclass:
            return terminalTaxesType.subclass(*args_, **kwargs_)
        else:
            return terminalTaxesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_terminalTax(self): return self.terminalTax
    def set_terminalTax(self, terminalTax): self.terminalTax = terminalTax
    def add_terminalTax(self, value): self.terminalTax.append(value)
    def insert_terminalTax_at(self, index, value): self.terminalTax.insert(index, value)
    def replace_terminalTax_at(self, index, value): self.terminalTax[index] = value
    def hasContent_(self):
        if (
            self.terminalTax
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalTaxesType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for terminalTax_ in self.terminalTax:
            terminalTax_.to_etree(element, name_='terminalTax', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalTaxesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('terminalTax=[\n')
        level += 1
        for terminalTax_ in self.terminalTax:
            showIndent(outfile, level)
            outfile.write('model_.terminalTax(\n')
            terminalTax_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'terminalTax':
            obj_ = terminalTax.factory()
            obj_.build(child_)
            self.terminalTax.append(obj_)
            obj_.original_tagname_ = 'terminalTax'
# end class terminalTaxesType


class terminalTipsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('terminalTip', 'terminalTip', 1, 0, {'name': 'terminalTip', 'type': 'terminalTip', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, terminalTip=None):
        self.original_tagname_ = None
        if terminalTip is None:
            self.terminalTip = []
        else:
            self.terminalTip = terminalTip
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, terminalTipsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if terminalTipsType.subclass:
            return terminalTipsType.subclass(*args_, **kwargs_)
        else:
            return terminalTipsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_terminalTip(self): return self.terminalTip
    def set_terminalTip(self, terminalTip): self.terminalTip = terminalTip
    def add_terminalTip(self, value): self.terminalTip.append(value)
    def insert_terminalTip_at(self, index, value): self.terminalTip.insert(index, value)
    def replace_terminalTip_at(self, index, value): self.terminalTip[index] = value
    def hasContent_(self):
        if (
            self.terminalTip
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='terminalTipsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for terminalTip_ in self.terminalTip:
            terminalTip_.to_etree(element, name_='terminalTip', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='terminalTipsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('terminalTip=[\n')
        level += 1
        for terminalTip_ in self.terminalTip:
            showIndent(outfile, level)
            outfile.write('model_.terminalTip(\n')
            terminalTip_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'terminalTip':
            obj_ = terminalTip.factory()
            obj_.build(child_)
            self.terminalTip.append(obj_)
            obj_.original_tagname_ = 'terminalTip'
# end class terminalTipsType


class additionalFieldsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('additionalField', 'additionalField', 1, 1, {'name': 'additionalField', 'type': 'additionalField', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, additionalField=None):
        self.original_tagname_ = None
        if additionalField is None:
            self.additionalField = []
        else:
            self.additionalField = additionalField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, additionalFieldsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if additionalFieldsType.subclass:
            return additionalFieldsType.subclass(*args_, **kwargs_)
        else:
            return additionalFieldsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_additionalField(self): return self.additionalField
    def set_additionalField(self, additionalField): self.additionalField = additionalField
    def add_additionalField(self, value): self.additionalField.append(value)
    def insert_additionalField_at(self, index, value): self.additionalField.insert(index, value)
    def replace_additionalField_at(self, index, value): self.additionalField[index] = value
    def hasContent_(self):
        if (
            self.additionalField
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='additionalFieldsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for additionalField_ in self.additionalField:
            additionalField_.to_etree(element, name_='additionalField', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='additionalFieldsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('additionalField=[\n')
        level += 1
        for additionalField_ in self.additionalField:
            showIndent(outfile, level)
            outfile.write('model_.additionalField(\n')
            additionalField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'additionalField':
            obj_ = additionalField.factory()
            obj_.build(child_)
            self.additionalField.append(obj_)
            obj_.original_tagname_ = 'additionalField'
# end class additionalFieldsType


class availableBalanceListType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('availableBalance', 'accountBalance', 1, 1, {'name': 'availableBalance', 'type': 'accountBalance', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, availableBalance=None):
        self.original_tagname_ = None
        if availableBalance is None:
            self.availableBalance = []
        else:
            self.availableBalance = availableBalance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, availableBalanceListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if availableBalanceListType.subclass:
            return availableBalanceListType.subclass(*args_, **kwargs_)
        else:
            return availableBalanceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_availableBalance(self): return self.availableBalance
    def set_availableBalance(self, availableBalance): self.availableBalance = availableBalance
    def add_availableBalance(self, value): self.availableBalance.append(value)
    def insert_availableBalance_at(self, index, value): self.availableBalance.insert(index, value)
    def replace_availableBalance_at(self, index, value): self.availableBalance[index] = value
    def hasContent_(self):
        if (
            self.availableBalance
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='availableBalanceListType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for availableBalance_ in self.availableBalance:
            availableBalance_.to_etree(element, name_='availableBalance', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='availableBalanceListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('availableBalance=[\n')
        level += 1
        for availableBalance_ in self.availableBalance:
            showIndent(outfile, level)
            outfile.write('model_.accountBalance(\n')
            availableBalance_.exportLiteral(outfile, level, name_='accountBalance')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'availableBalance':
            obj_ = accountBalance.factory()
            obj_.build(child_)
            self.availableBalance.append(obj_)
            obj_.original_tagname_ = 'availableBalance'
# end class availableBalanceListType


class customFieldsType1(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('customField', 'customField', 1, 1, {'name': 'customField', 'type': 'customField', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, customField=None):
        self.original_tagname_ = None
        if customField is None:
            self.customField = []
        else:
            self.customField = customField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, customFieldsType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if customFieldsType1.subclass:
            return customFieldsType1.subclass(*args_, **kwargs_)
        else:
            return customFieldsType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_customField(self): return self.customField
    def set_customField(self, customField): self.customField = customField
    def add_customField(self, value): self.customField.append(value)
    def insert_customField_at(self, index, value): self.customField.insert(index, value)
    def replace_customField_at(self, index, value): self.customField[index] = value
    def hasContent_(self):
        if (
            self.customField
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='customFieldsType1', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for customField_ in self.customField:
            customField_.to_etree(element, name_='customField', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='customFieldsType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('customField=[\n')
        level += 1
        for customField_ in self.customField:
            showIndent(outfile, level)
            outfile.write('model_.customField(\n')
            customField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'customField':
            obj_ = customField.factory()
            obj_.build(child_)
            self.customField.append(obj_)
            obj_.original_tagname_ = 'customField'
# end class customFieldsType1


class taxesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('tax', 'tax', 1, 0, {'name': 'tax', 'type': 'tax', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, tax=None):
        self.original_tagname_ = None
        if tax is None:
            self.tax = []
        else:
            self.tax = tax
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, taxesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if taxesType.subclass:
            return taxesType.subclass(*args_, **kwargs_)
        else:
            return taxesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tax(self): return self.tax
    def set_tax(self, tax): self.tax = tax
    def add_tax(self, value): self.tax.append(value)
    def insert_tax_at(self, index, value): self.tax.insert(index, value)
    def replace_tax_at(self, index, value): self.tax[index] = value
    def hasContent_(self):
        if (
            self.tax
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='taxesType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for tax_ in self.tax:
            tax_.to_etree(element, name_='tax', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='taxesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tax=[\n')
        level += 1
        for tax_ in self.tax:
            showIndent(outfile, level)
            outfile.write('model_.tax(\n')
            tax_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tax':
            obj_ = tax.factory()
            obj_.build(child_)
            self.tax.append(obj_)
            obj_.original_tagname_ = 'tax'

    @property
    def hash_string(self):
        taxes_hash = []
        for t in self.tax:
            taxes_hash.append(t.name + ':' + format(t.percentage * 10000, '.0f') + ':' + format(t.amount * 100, '.0f') + ':' + t.currency)
        return ':'.join(taxes_hash)
# end class taxesType


class validationErrorsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('validationError', 'validationError', 1, 1, {'name': 'validationError', 'type': 'validationError', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, validationError=None):
        self.original_tagname_ = None
        if validationError is None:
            self.validationError = []
        else:
            self.validationError = validationError
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, validationErrorsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if validationErrorsType.subclass:
            return validationErrorsType.subclass(*args_, **kwargs_)
        else:
            return validationErrorsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_validationError(self): return self.validationError
    def set_validationError(self, validationError): self.validationError = validationError
    def add_validationError(self, value): self.validationError.append(value)
    def insert_validationError_at(self, index, value): self.validationError.insert(index, value)
    def replace_validationError_at(self, index, value): self.validationError[index] = value
    def hasContent_(self):
        if (
            self.validationError
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='validationErrorsType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for validationError_ in self.validationError:
            validationError_.to_etree(element, name_='validationError', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='validationErrorsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('validationError=[\n')
        level += 1
        for validationError_ in self.validationError:
            showIndent(outfile, level)
            outfile.write('model_.validationError(\n')
            validationError_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validationError':
            obj_ = validationError.factory()
            obj_.build(child_)
            self.validationError.append(obj_)
            obj_.original_tagname_ = 'validationError'
# end class validationErrorsType


class availableBalanceListType2(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('availableBalance', 'accountBalance', 1, 1, {'name': 'availableBalance', 'type': 'accountBalance', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, availableBalance=None):
        self.original_tagname_ = None
        if availableBalance is None:
            self.availableBalance = []
        else:
            self.availableBalance = availableBalance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, availableBalanceListType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if availableBalanceListType2.subclass:
            return availableBalanceListType2.subclass(*args_, **kwargs_)
        else:
            return availableBalanceListType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_availableBalance(self): return self.availableBalance
    def set_availableBalance(self, availableBalance): self.availableBalance = availableBalance
    def add_availableBalance(self, value): self.availableBalance.append(value)
    def insert_availableBalance_at(self, index, value): self.availableBalance.insert(index, value)
    def replace_availableBalance_at(self, index, value): self.availableBalance[index] = value
    def hasContent_(self):
        if (
            self.availableBalance
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='availableBalanceListType2', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for availableBalance_ in self.availableBalance:
            availableBalance_.to_etree(element, name_='availableBalance', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='availableBalanceListType2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('availableBalance=[\n')
        level += 1
        for availableBalance_ in self.availableBalance:
            showIndent(outfile, level)
            outfile.write('model_.accountBalance(\n')
            availableBalance_.exportLiteral(outfile, level, name_='accountBalance')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'availableBalance':
            obj_ = accountBalance.factory()
            obj_.build(child_)
            self.availableBalance.append(obj_)
            obj_.original_tagname_ = 'availableBalance'
# end class availableBalanceListType2


class settingCreateType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('tax', 'tax', 1, 0, {'name': 'tax', 'type': 'terminalTax'}, 8),
        MemberSpec_('tip', 'tip', 1, 0, {'name': 'tip', 'type': 'terminalTip'}, 8),
    ]
    subclass = None
    superclass = None
    def __init__(self, tax=None, tip=None):
        self.original_tagname_ = None
        if tax is None:
            self.tax = []
        else:
            self.tax = tax
        if tip is None:
            self.tip = []
        else:
            self.tip = tip
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, settingCreateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if settingCreateType.subclass:
            return settingCreateType.subclass(*args_, **kwargs_)
        else:
            return settingCreateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tax(self): return self.tax
    def set_tax(self, tax): self.tax = tax
    def add_tax(self, value): self.tax.append(value)
    def insert_tax_at(self, index, value): self.tax.insert(index, value)
    def replace_tax_at(self, index, value): self.tax[index] = value
    def get_tip(self): return self.tip
    def set_tip(self, tip): self.tip = tip
    def add_tip(self, value): self.tip.append(value)
    def insert_tip_at(self, index, value): self.tip.insert(index, value)
    def replace_tip_at(self, index, value): self.tip[index] = value
    def hasContent_(self):
        if (
            self.tax or
            self.tip
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='settingCreateType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for tax_ in self.tax:
            tax_.to_etree(element, name_='tax', mapping_=mapping_)
        for tip_ in self.tip:
            tip_.to_etree(element, name_='tip', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='settingCreateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tax=[\n')
        level += 1
        for tax_ in self.tax:
            showIndent(outfile, level)
            outfile.write('model_.terminalTax(\n')
            tax_.exportLiteral(outfile, level, name_='terminalTax')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tip=[\n')
        level += 1
        for tip_ in self.tip:
            showIndent(outfile, level)
            outfile.write('model_.terminalTip(\n')
            tip_.exportLiteral(outfile, level, name_='terminalTip')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tax':
            obj_ = terminalTax.factory()
            obj_.build(child_)
            self.tax.append(obj_)
            obj_.original_tagname_ = 'tax'
        elif nodeName_ == 'tip':
            obj_ = terminalTip.factory()
            obj_.build(child_)
            self.tip.append(obj_)
            obj_.original_tagname_ = 'tip'

    @property
    def hash_string(self):
        hash_list = []
        if self.tax:
            hash_list.append(self.tax[0].hash_string)
        if self.tip:
            hash_list.append(self.tip[0].hash_string)
        return ':'.join(hash_list)
# end class settingCreateType


class settingDeleteType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('tax', 'tax', 1, 0, {'name': 'tax', 'type': 'taxUId'}, 9),
        MemberSpec_('tip', 'tip', 1, 0, {'name': 'tip', 'type': 'tipUId'}, 9),
    ]
    subclass = None
    superclass = None
    def __init__(self, tax=None, tip=None):
        self.original_tagname_ = None
        if tax is None:
            self.tax = []
        else:
            self.tax = tax
        if tip is None:
            self.tip = []
        else:
            self.tip = tip
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, settingDeleteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if settingDeleteType.subclass:
            return settingDeleteType.subclass(*args_, **kwargs_)
        else:
            return settingDeleteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tax(self): return self.tax
    def set_tax(self, tax): self.tax = tax
    def add_tax(self, value): self.tax.append(value)
    def insert_tax_at(self, index, value): self.tax.insert(index, value)
    def replace_tax_at(self, index, value): self.tax[index] = value
    def get_tip(self): return self.tip
    def set_tip(self, tip): self.tip = tip
    def add_tip(self, value): self.tip.append(value)
    def insert_tip_at(self, index, value): self.tip.insert(index, value)
    def replace_tip_at(self, index, value): self.tip[index] = value
    def hasContent_(self):
        if (
            self.tax or
            self.tip
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='settingDeleteType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for tax_ in self.tax:
            tax_.to_etree(element, name_='tax', mapping_=mapping_)
        for tip_ in self.tip:
            tip_.to_etree(element, name_='tip', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='settingDeleteType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tax=[\n')
        level += 1
        for tax_ in self.tax:
            showIndent(outfile, level)
            outfile.write('model_.taxUId(\n')
            tax_.exportLiteral(outfile, level, name_='taxUId')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tip=[\n')
        level += 1
        for tip_ in self.tip:
            showIndent(outfile, level)
            outfile.write('model_.tipUId(\n')
            tip_.exportLiteral(outfile, level, name_='tipUId')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tax':
            obj_ = taxUId.factory()
            obj_.build(child_)
            self.tax.append(obj_)
            obj_.original_tagname_ = 'tax'
        elif nodeName_ == 'tip':
            obj_ = tipUId.factory()
            obj_.build(child_)
            self.tip.append(obj_)
            obj_.original_tagname_ = 'tip'
# end class settingDeleteType


class settingUpdateType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('tax', 'tax', 1, 0, {'name': 'tax', 'type': 'terminalTax'}, 10),
        MemberSpec_('tip', 'tip', 1, 0, {'name': 'tip', 'type': 'terminalTip'}, 10),
    ]
    subclass = None
    superclass = None
    def __init__(self, tax=None, tip=None):
        self.original_tagname_ = None
        if tax is None:
            self.tax = []
        else:
            self.tax = tax
        if tip is None:
            self.tip = []
        else:
            self.tip = tip
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, settingUpdateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if settingUpdateType.subclass:
            return settingUpdateType.subclass(*args_, **kwargs_)
        else:
            return settingUpdateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tax(self): return self.tax
    def set_tax(self, tax): self.tax = tax
    def add_tax(self, value): self.tax.append(value)
    def insert_tax_at(self, index, value): self.tax.insert(index, value)
    def replace_tax_at(self, index, value): self.tax[index] = value
    def get_tip(self): return self.tip
    def set_tip(self, tip): self.tip = tip
    def add_tip(self, value): self.tip.append(value)
    def insert_tip_at(self, index, value): self.tip.insert(index, value)
    def replace_tip_at(self, index, value): self.tip[index] = value
    def hasContent_(self):
        if (
            self.tax or
            self.tip
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='settingUpdateType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for tax_ in self.tax:
            tax_.to_etree(element, name_='tax', mapping_=mapping_)
        for tip_ in self.tip:
            tip_.to_etree(element, name_='tip', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='settingUpdateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tax=[\n')
        level += 1
        for tax_ in self.tax:
            showIndent(outfile, level)
            outfile.write('model_.terminalTax(\n')
            tax_.exportLiteral(outfile, level, name_='terminalTax')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tip=[\n')
        level += 1
        for tip_ in self.tip:
            showIndent(outfile, level)
            outfile.write('model_.terminalTip(\n')
            tip_.exportLiteral(outfile, level, name_='terminalTip')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tax':
            obj_ = terminalTax.factory()
            obj_.build(child_)
            self.tax.append(obj_)
            obj_.original_tagname_ = 'tax'
        elif nodeName_ == 'tip':
            obj_ = terminalTip.factory()
            obj_.build(child_)
            self.tip.append(obj_)
            obj_.original_tagname_ = 'tip'
# end class settingUpdateType


class cardAccountSummaryListType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cardAccountSummary', 'cardAccountSummary', 1, 1, {'name': 'cardAccountSummary', 'type': 'cardAccountSummary', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cardAccountSummary=None):
        self.original_tagname_ = None
        if cardAccountSummary is None:
            self.cardAccountSummary = []
        else:
            self.cardAccountSummary = cardAccountSummary
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardAccountSummaryListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardAccountSummaryListType.subclass:
            return cardAccountSummaryListType.subclass(*args_, **kwargs_)
        else:
            return cardAccountSummaryListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardAccountSummary(self): return self.cardAccountSummary
    def set_cardAccountSummary(self, cardAccountSummary): self.cardAccountSummary = cardAccountSummary
    def add_cardAccountSummary(self, value): self.cardAccountSummary.append(value)
    def insert_cardAccountSummary_at(self, index, value): self.cardAccountSummary.insert(index, value)
    def replace_cardAccountSummary_at(self, index, value): self.cardAccountSummary[index] = value
    def hasContent_(self):
        if (
            self.cardAccountSummary
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='cardAccountSummaryListType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for cardAccountSummary_ in self.cardAccountSummary:
            cardAccountSummary_.to_etree(element, name_='cardAccountSummary', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='cardAccountSummaryListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cardAccountSummary=[\n')
        level += 1
        for cardAccountSummary_ in self.cardAccountSummary:
            showIndent(outfile, level)
            outfile.write('model_.cardAccountSummary(\n')
            cardAccountSummary_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardAccountSummary':
            obj_ = cardAccountSummary.factory()
            obj_.build(child_)
            self.cardAccountSummary.append(obj_)
            obj_.original_tagname_ = 'cardAccountSummary'
# end class cardAccountSummaryListType


class settingCreateType3(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('tax', 'tax', 1, 0, {'name': 'tax', 'type': 'terminalTax'}, 11),
        MemberSpec_('tip', 'tip', 1, 0, {'name': 'tip', 'type': 'terminalTip'}, 11),
    ]
    subclass = None
    superclass = None
    def __init__(self, tax=None, tip=None):
        self.original_tagname_ = None
        if tax is None:
            self.tax = []
        else:
            self.tax = tax
        if tip is None:
            self.tip = []
        else:
            self.tip = tip
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, settingCreateType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if settingCreateType3.subclass:
            return settingCreateType3.subclass(*args_, **kwargs_)
        else:
            return settingCreateType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tax(self): return self.tax
    def set_tax(self, tax): self.tax = tax
    def add_tax(self, value): self.tax.append(value)
    def insert_tax_at(self, index, value): self.tax.insert(index, value)
    def replace_tax_at(self, index, value): self.tax[index] = value
    def get_tip(self): return self.tip
    def set_tip(self, tip): self.tip = tip
    def add_tip(self, value): self.tip.append(value)
    def insert_tip_at(self, index, value): self.tip.insert(index, value)
    def replace_tip_at(self, index, value): self.tip[index] = value
    def hasContent_(self):
        if (
            self.tax or
            self.tip
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='settingCreateType3', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for tax_ in self.tax:
            tax_.to_etree(element, name_='tax', mapping_=mapping_)
        for tip_ in self.tip:
            tip_.to_etree(element, name_='tip', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='settingCreateType3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tax=[\n')
        level += 1
        for tax_ in self.tax:
            showIndent(outfile, level)
            outfile.write('model_.terminalTax(\n')
            tax_.exportLiteral(outfile, level, name_='terminalTax')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tip=[\n')
        level += 1
        for tip_ in self.tip:
            showIndent(outfile, level)
            outfile.write('model_.terminalTip(\n')
            tip_.exportLiteral(outfile, level, name_='terminalTip')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tax':
            obj_ = terminalTax.factory()
            obj_.build(child_)
            self.tax.append(obj_)
            obj_.original_tagname_ = 'tax'
        elif nodeName_ == 'tip':
            obj_ = terminalTip.factory()
            obj_.build(child_)
            self.tip.append(obj_)
            obj_.original_tagname_ = 'tip'
# end class settingCreateType3


class settingDeleteType4(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('tax', 'tax', 1, 0, {'name': 'tax', 'type': 'taxUId'}, 12),
        MemberSpec_('tip', 'tip', 1, 0, {'name': 'tip', 'type': 'tipUId'}, 12),
    ]
    subclass = None
    superclass = None
    def __init__(self, tax=None, tip=None):
        self.original_tagname_ = None
        if tax is None:
            self.tax = []
        else:
            self.tax = tax
        if tip is None:
            self.tip = []
        else:
            self.tip = tip
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, settingDeleteType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if settingDeleteType4.subclass:
            return settingDeleteType4.subclass(*args_, **kwargs_)
        else:
            return settingDeleteType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tax(self): return self.tax
    def set_tax(self, tax): self.tax = tax
    def add_tax(self, value): self.tax.append(value)
    def insert_tax_at(self, index, value): self.tax.insert(index, value)
    def replace_tax_at(self, index, value): self.tax[index] = value
    def get_tip(self): return self.tip
    def set_tip(self, tip): self.tip = tip
    def add_tip(self, value): self.tip.append(value)
    def insert_tip_at(self, index, value): self.tip.insert(index, value)
    def replace_tip_at(self, index, value): self.tip[index] = value
    def hasContent_(self):
        if (
            self.tax or
            self.tip
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='settingDeleteType4', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for tax_ in self.tax:
            tax_.to_etree(element, name_='tax', mapping_=mapping_)
        for tip_ in self.tip:
            tip_.to_etree(element, name_='tip', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='settingDeleteType4'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tax=[\n')
        level += 1
        for tax_ in self.tax:
            showIndent(outfile, level)
            outfile.write('model_.taxUId(\n')
            tax_.exportLiteral(outfile, level, name_='taxUId')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tip=[\n')
        level += 1
        for tip_ in self.tip:
            showIndent(outfile, level)
            outfile.write('model_.tipUId(\n')
            tip_.exportLiteral(outfile, level, name_='tipUId')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tax':
            obj_ = taxUId.factory()
            obj_.build(child_)
            self.tax.append(obj_)
            obj_.original_tagname_ = 'tax'
        elif nodeName_ == 'tip':
            obj_ = tipUId.factory()
            obj_.build(child_)
            self.tip.append(obj_)
            obj_.original_tagname_ = 'tip'
# end class settingDeleteType4


class settingUpdateType5(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('tax', 'tax', 1, 0, {'name': 'tax', 'type': 'terminalTax'}, 13),
        MemberSpec_('tip', 'tip', 1, 0, {'name': 'tip', 'type': 'terminalTip'}, 13),
    ]
    subclass = None
    superclass = None
    def __init__(self, tax=None, tip=None):
        self.original_tagname_ = None
        if tax is None:
            self.tax = []
        else:
            self.tax = tax
        if tip is None:
            self.tip = []
        else:
            self.tip = tip
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, settingUpdateType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if settingUpdateType5.subclass:
            return settingUpdateType5.subclass(*args_, **kwargs_)
        else:
            return settingUpdateType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tax(self): return self.tax
    def set_tax(self, tax): self.tax = tax
    def add_tax(self, value): self.tax.append(value)
    def insert_tax_at(self, index, value): self.tax.insert(index, value)
    def replace_tax_at(self, index, value): self.tax[index] = value
    def get_tip(self): return self.tip
    def set_tip(self, tip): self.tip = tip
    def add_tip(self, value): self.tip.append(value)
    def insert_tip_at(self, index, value): self.tip.insert(index, value)
    def replace_tip_at(self, index, value): self.tip[index] = value
    def hasContent_(self):
        if (
            self.tax or
            self.tip
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='settingUpdateType5', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for tax_ in self.tax:
            tax_.to_etree(element, name_='tax', mapping_=mapping_)
        for tip_ in self.tip:
            tip_.to_etree(element, name_='tip', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='settingUpdateType5'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tax=[\n')
        level += 1
        for tax_ in self.tax:
            showIndent(outfile, level)
            outfile.write('model_.terminalTax(\n')
            tax_.exportLiteral(outfile, level, name_='terminalTax')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tip=[\n')
        level += 1
        for tip_ in self.tip:
            showIndent(outfile, level)
            outfile.write('model_.terminalTip(\n')
            tip_.exportLiteral(outfile, level, name_='terminalTip')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tax':
            obj_ = terminalTax.factory()
            obj_.build(child_)
            self.tax.append(obj_)
            obj_.original_tagname_ = 'tax'
        elif nodeName_ == 'tip':
            obj_ = terminalTip.factory()
            obj_.build(child_)
            self.tip.append(obj_)
            obj_.original_tagname_ = 'tip'
# end class settingUpdateType5


class authTokenRequest(authenticationRequest):
    member_data_items_ = [
        MemberSpec_('gatewayId', 'xs:string', 0, 0, {'name': 'gatewayId', 'type': 'xs:string'}, None),
        MemberSpec_('merchantId', 'xs:string', 0, 0, {'name': 'merchantId', 'type': 'xs:string'}, None),
        MemberSpec_('password', 'xs:string', 0, 0, {'name': 'password', 'type': 'xs:string'}, None),
        MemberSpec_('userName', 'xs:string', 0, 0, {'name': 'userName', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = authenticationRequest
    def __init__(self, dateTime=None, hash=None, account=None, apiKey=None, gatewayId=None, merchantId=None, password=None, userName=None):
        self.original_tagname_ = None
        super(authTokenRequest, self).__init__(dateTime, hash, account, apiKey, )
        self.gatewayId = gatewayId
        self.merchantId = merchantId
        self.password = password
        self.userName = userName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, authTokenRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if authTokenRequest.subclass:
            return authTokenRequest.subclass(*args_, **kwargs_)
        else:
            return authTokenRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gatewayId(self): return self.gatewayId
    def set_gatewayId(self, gatewayId): self.gatewayId = gatewayId
    def get_merchantId(self): return self.merchantId
    def set_merchantId(self, merchantId): self.merchantId = merchantId
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def get_userName(self): return self.userName
    def set_userName(self, userName): self.userName = userName
    def hasContent_(self):
        if (
            self.gatewayId is not None or
            self.merchantId is not None or
            self.password is not None or
            self.userName is not None or
            super(authTokenRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='authTokenRequest', mapping_=None):
        element = super(authTokenRequest, self).to_etree(parent_element, name_, mapping_)
        if self.gatewayId is not None:
            gatewayId_ = self.gatewayId
            etree_.SubElement(element, '{}gatewayId').text = self.gds_format_string(gatewayId_)
        if self.merchantId is not None:
            merchantId_ = self.merchantId
            etree_.SubElement(element, '{}merchantId').text = self.gds_format_string(merchantId_)
        if self.password is not None:
            password_ = self.password
            etree_.SubElement(element, '{}password').text = self.gds_format_string(password_)
        if self.userName is not None:
            userName_ = self.userName
            etree_.SubElement(element, '{}userName').text = self.gds_format_string(userName_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='authTokenRequest'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(authTokenRequest, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(authTokenRequest, self).exportLiteralChildren(outfile, level, name_)
        if self.gatewayId is not None:
            showIndent(outfile, level)
            outfile.write('gatewayId=%s,\n' % self.gds_encode(quote_python(self.gatewayId)))
        if self.merchantId is not None:
            showIndent(outfile, level)
            outfile.write('merchantId=%s,\n' % self.gds_encode(quote_python(self.merchantId)))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % self.gds_encode(quote_python(self.password)))
        if self.userName is not None:
            showIndent(outfile, level)
            outfile.write('userName=%s,\n' % self.gds_encode(quote_python(self.userName)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(authTokenRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gatewayId':
            gatewayId_ = child_.text
            gatewayId_ = self.gds_validate_string(gatewayId_, node, 'gatewayId')
            self.gatewayId = gatewayId_
        elif nodeName_ == 'merchantId':
            merchantId_ = child_.text
            merchantId_ = self.gds_validate_string(merchantId_, node, 'merchantId')
            self.merchantId = merchantId_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'userName':
            userName_ = child_.text
            userName_ = self.gds_validate_string(userName_, node, 'userName')
            self.userName = userName_
        super(authTokenRequest, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = []
        if self.gatewayId:
            hash_list.append(self.gatewayId)
        if self.merchantId:
            hash_list.append(self.merchantId)
        if self.password:
            hash_list.append(self.password)
        if self.userName:
            hash_list.append(self.userName)    
        hash_list.append(self.account.hash_string)
        hash_list.append(self.apiKey)
        hash_list.append(str(self.dateTime.isoformat('T')))
        return ':'.join(hash_list)
# end class authTokenRequest


class refundReferenced(refundBaseMethod):
    member_data_items_ = [
        MemberSpec_('previousTxnDateTime', 'xs:dateTime', 0, 1, {'name': 'previousTxnDateTime', 'type': 'xs:dateTime', 'minOccurs': '0'}, None),
        MemberSpec_('orderId', ['orderId', 'xs:string'], 0, 0, {'name': 'orderId', 'type': 'xs:string'}, 5),
        MemberSpec_('uniqueRef', ['uniqueRef', 'xs:string'], 0, 0, {'name': 'uniqueRef', 'type': 'xs:string'}, 5),
    ]
    subclass = None
    superclass = refundBaseMethod
    def __init__(self, reason=None, previousTxnDateTime=None, orderId=None, uniqueRef=None):
        self.original_tagname_ = None
        super(refundReferenced, self).__init__(reason, )
        if isinstance(previousTxnDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(previousTxnDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = previousTxnDateTime
        self.previousTxnDateTime = initvalue_
        self.orderId = orderId
        self.validate_orderId(self.orderId)
        self.uniqueRef = uniqueRef
        self.validate_uniqueRef(self.uniqueRef)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refundReferenced)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refundReferenced.subclass:
            return refundReferenced.subclass(*args_, **kwargs_)
        else:
            return refundReferenced(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_previousTxnDateTime(self): return self.previousTxnDateTime
    def set_previousTxnDateTime(self, previousTxnDateTime): self.previousTxnDateTime = previousTxnDateTime
    def get_orderId(self): return self.orderId
    def set_orderId(self, orderId): self.orderId = orderId
    def get_uniqueRef(self): return self.uniqueRef
    def set_uniqueRef(self, uniqueRef): self.uniqueRef = uniqueRef
    def validate_orderId(self, value):
        # Validate type orderId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_uniqueRef(self, value):
        # Validate type uniqueRef, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.previousTxnDateTime is not None or
            self.orderId is not None or
            self.uniqueRef is not None or
            super(refundReferenced, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='refundReferenced', mapping_=None):
        element = super(refundReferenced, self).to_etree(parent_element, name_, mapping_)
        if self.previousTxnDateTime is not None:
            previousTxnDateTime_ = self.previousTxnDateTime
            etree_.SubElement(element, '{}previousTxnDateTime').text = self.gds_format_datetime(previousTxnDateTime_)
        if self.orderId is not None:
            orderId_ = self.orderId
            etree_.SubElement(element, '{}orderId').text = self.gds_format_string(orderId_)
        if self.uniqueRef is not None:
            uniqueRef_ = self.uniqueRef
            etree_.SubElement(element, '{}uniqueRef').text = self.gds_format_string(uniqueRef_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='refundReferenced'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(refundReferenced, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(refundReferenced, self).exportLiteralChildren(outfile, level, name_)
        if self.previousTxnDateTime is not None:
            showIndent(outfile, level)
            outfile.write('previousTxnDateTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.previousTxnDateTime, input_name='previousTxnDateTime'))
        if self.orderId is not None:
            showIndent(outfile, level)
            outfile.write('orderId=%s,\n' % self.gds_encode(quote_python(self.orderId)))
        if self.uniqueRef is not None:
            showIndent(outfile, level)
            outfile.write('uniqueRef=%s,\n' % self.gds_encode(quote_python(self.uniqueRef)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(refundReferenced, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'previousTxnDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.previousTxnDateTime = dval_
        elif nodeName_ == 'orderId':
            orderId_ = child_.text
            orderId_ = self.gds_validate_string(orderId_, node, 'orderId')
            self.orderId = orderId_
            # validate type orderId
            self.validate_orderId(self.orderId)
        elif nodeName_ == 'uniqueRef':
            uniqueRef_ = child_.text
            uniqueRef_ = self.gds_validate_string(uniqueRef_, node, 'uniqueRef')
            self.uniqueRef = uniqueRef_
            # validate type uniqueRef
            self.validate_uniqueRef(self.uniqueRef)
        super(refundReferenced, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = []
        # if self.previousTxnDateTime:
        #     hash_list.append(self.previousTxnDateTime)
        if self.uniqueRef:
            hash_list.append(self.uniqueRef)
        if self.orderId:
            hash_list.append(self.orderId)
        hash_list.append(self.reason)
        return ':'.join(hash_list)
# end class refundReferenced


class sale(transaction):
    member_data_items_ = [
        MemberSpec_('avs', 'avs', 0, 1, {'name': 'avs', 'type': 'avs', 'minOccurs': '0'}, None),
        MemberSpec_('bypassSurcharge', 'xs:boolean', 0, 1, {'name': 'bypassSurcharge', 'type': 'xs:boolean', 'minOccurs': '0'}, None),
        MemberSpec_('cardEntryMode', ['cardEntryMode', 'xs:string'], 0, 1, {'name': 'cardEntryMode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('currencyRate', 'currencyRate', 0, 1, {'name': 'currencyRate', 'type': 'currencyRate', 'minOccurs': '0'}, None),
        MemberSpec_('customFields', 'customFieldsType1', 0, 1, {'name': 'customFields', 'minOccurs': '0', 'type': 'customFieldsType1'}, None),
        MemberSpec_('debitAccountType', ['debitAccountType', 'xs:string'], 0, 1, {'name': 'debitAccountType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('device', 'posDevice', 0, 1, {'name': 'device', 'type': 'posDevice', 'minOccurs': '0'}, None),
        MemberSpec_('deviceType', 'xs:string', 0, 1, {'name': 'deviceType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('downgradeType', ['cardEntryMode', 'xs:string'], 0, 1, {'name': 'downgradeType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('merchantReference', 'xs:string', 0, 1, {'name': 'merchantReference', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('orderId', 'xs:string', 0, 0, {'name': 'orderId', 'type': 'xs:string'}, None),
        MemberSpec_('paymentMethod', 'paymentMethod', 0, 0, {'name': 'paymentMethod', 'type': 'paymentMethod'}, None),
        MemberSpec_('permittedTerminals', 'xs:string', 0, 1, {'name': 'permittedTerminals', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('requestType', ['saleRequestType', 'xs:string'], 0, 1, {'name': 'requestType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('taxes', 'taxesType', 0, 1, {'name': 'taxes', 'minOccurs': '0', 'type': 'taxesType'}, None),
        MemberSpec_('tip', 'tip', 0, 1, {'name': 'tip', 'type': 'tip', 'minOccurs': '0'}, None),
        MemberSpec_('transactionType', ['transactionType', 'xs:string'], 0, 1, {'name': 'transactionType', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = transaction
    def __init__(self, dateTime=None, hash=None, account=None, amount=None, autoReady=None, commerceType=None, customer=None, receiptDetailsRequired=None, avs=None, bypassSurcharge=None, cardEntryMode=None, currencyRate=None, customFields=None, debitAccountType=None, device=None, deviceType=None, downgradeType=None, merchantReference=None, orderId=None, paymentMethod=None, permittedTerminals=None, requestType=None, taxes=None, tip=None, transactionType=None):
        self.original_tagname_ = None
        super(sale, self).__init__(dateTime, hash, account, amount, autoReady, commerceType, customer, receiptDetailsRequired, )
        self.avs = avs
        self.bypassSurcharge = bypassSurcharge
        self.cardEntryMode = cardEntryMode
        self.validate_cardEntryMode(self.cardEntryMode)
        self.currencyRate = currencyRate
        self.customFields = customFields
        self.debitAccountType = debitAccountType
        self.validate_debitAccountType(self.debitAccountType)
        self.device = device
        self.deviceType = deviceType
        self.downgradeType = downgradeType
        self.validate_cardEntryMode(self.downgradeType)
        self.merchantReference = merchantReference
        self.orderId = orderId
        self.paymentMethod = paymentMethod
        self.permittedTerminals = permittedTerminals
        self.requestType = requestType
        self.validate_saleRequestType(self.requestType)
        self.taxes = taxes
        self.tip = tip
        self.transactionType = transactionType
        self.validate_transactionType(self.transactionType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sale)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sale.subclass:
            return sale.subclass(*args_, **kwargs_)
        else:
            return sale(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_avs(self): return self.avs
    def set_avs(self, avs): self.avs = avs
    def get_bypassSurcharge(self): return self.bypassSurcharge
    def set_bypassSurcharge(self, bypassSurcharge): self.bypassSurcharge = bypassSurcharge
    def get_cardEntryMode(self): return self.cardEntryMode
    def set_cardEntryMode(self, cardEntryMode): self.cardEntryMode = cardEntryMode
    def get_currencyRate(self): return self.currencyRate
    def set_currencyRate(self, currencyRate): self.currencyRate = currencyRate
    def get_customFields(self): return self.customFields
    def set_customFields(self, customFields): self.customFields = customFields
    def get_debitAccountType(self): return self.debitAccountType
    def set_debitAccountType(self, debitAccountType): self.debitAccountType = debitAccountType
    def get_device(self): return self.device
    def set_device(self, device): self.device = device
    def get_deviceType(self): return self.deviceType
    def set_deviceType(self, deviceType): self.deviceType = deviceType
    def get_downgradeType(self): return self.downgradeType
    def set_downgradeType(self, downgradeType): self.downgradeType = downgradeType
    def get_merchantReference(self): return self.merchantReference
    def set_merchantReference(self, merchantReference): self.merchantReference = merchantReference
    def get_orderId(self): return self.orderId
    def set_orderId(self, orderId): self.orderId = orderId
    def get_paymentMethod(self): return self.paymentMethod
    def set_paymentMethod(self, paymentMethod): self.paymentMethod = paymentMethod
    def get_permittedTerminals(self): return self.permittedTerminals
    def set_permittedTerminals(self, permittedTerminals): self.permittedTerminals = permittedTerminals
    def get_requestType(self): return self.requestType
    def set_requestType(self, requestType): self.requestType = requestType
    def get_taxes(self): return self.taxes
    def set_taxes(self, taxes): self.taxes = taxes
    def get_tip(self): return self.tip
    def set_tip(self, tip): self.tip = tip
    def get_transactionType(self): return self.transactionType
    def set_transactionType(self, transactionType): self.transactionType = transactionType
    def validate_cardEntryMode(self, value):
        # Validate type cardEntryMode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['UNKNOWN', 'UNSPECIFIED', 'KEYED', 'SWIPED', 'BARCODE', 'OCR', 'ICC', 'TRACK_ONE', 'CONTACTLESS_ICC', 'FILE', 'KEYED_FALLBACK', 'SWIPED_FALLBACK', 'E_COMMERCE', 'CONTACTLESS_MOTO', 'TRACK_ANY', 'CONTACTLESS_MSR', 'ICC_NO_CVV', 'STORED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cardEntryMode' % {"value" : value.encode("utf-8")} )
    def validate_debitAccountType(self, value):
        # Validate type debitAccountType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CHECKING', 'SAVINGS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on debitAccountType' % {"value" : value.encode("utf-8")} )
    def validate_saleRequestType(self, value):
        # Validate type saleRequestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PURCHASE', 'CASH_WITHDRAWAL', 'SALE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on saleRequestType' % {"value" : value.encode("utf-8")} )
    def validate_transactionType(self, value):
        # Validate type transactionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SALE', 'REFUND', 'PRE_AUTH', 'PRE_AUTH_COMPLETION', 'OFFLINE_DECLINE', 'DEFERRED_AUTH']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on transactionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.avs is not None or
            self.bypassSurcharge is not None or
            self.cardEntryMode is not None or
            self.currencyRate is not None or
            self.customFields is not None or
            self.debitAccountType is not None or
            self.device is not None or
            self.deviceType is not None or
            self.downgradeType is not None or
            self.merchantReference is not None or
            self.orderId is not None or
            self.paymentMethod is not None or
            self.permittedTerminals is not None or
            self.requestType is not None or
            self.taxes is not None or
            self.tip is not None or
            self.transactionType is not None or
            super(sale, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='sale', mapping_=None):
        element = super(sale, self).to_etree(parent_element, name_, mapping_)
        if self.avs is not None:
            avs_ = self.avs
            avs_.to_etree(element, name_='avs', mapping_=mapping_)
        if self.bypassSurcharge is not None:
            bypassSurcharge_ = self.bypassSurcharge
            etree_.SubElement(element, '{}bypassSurcharge').text = self.gds_format_boolean(bypassSurcharge_)
        if self.cardEntryMode is not None:
            cardEntryMode_ = self.cardEntryMode
            etree_.SubElement(element, '{}cardEntryMode').text = self.gds_format_string(cardEntryMode_)
        if self.currencyRate is not None:
            currencyRate_ = self.currencyRate
            currencyRate_.to_etree(element, name_='currencyRate', mapping_=mapping_)
        if self.customFields is not None:
            customFields_ = self.customFields
            customFields_.to_etree(element, name_='customFields', mapping_=mapping_)
        if self.debitAccountType is not None:
            debitAccountType_ = self.debitAccountType
            etree_.SubElement(element, '{}debitAccountType').text = self.gds_format_string(debitAccountType_)
        if self.device is not None:
            device_ = self.device
            device_.to_etree(element, name_='device', mapping_=mapping_)
        if self.deviceType is not None:
            deviceType_ = self.deviceType
            etree_.SubElement(element, '{}deviceType').text = self.gds_format_string(deviceType_)
        if self.downgradeType is not None:
            downgradeType_ = self.downgradeType
            etree_.SubElement(element, '{}downgradeType').text = self.gds_format_string(downgradeType_)
        if self.merchantReference is not None:
            merchantReference_ = self.merchantReference
            etree_.SubElement(element, '{}merchantReference').text = self.gds_format_string(merchantReference_)
        if self.orderId is not None:
            orderId_ = self.orderId
            etree_.SubElement(element, '{}orderId').text = self.gds_format_string(orderId_)
        if self.paymentMethod is not None:
            paymentMethod_ = self.paymentMethod
            paymentMethod_.to_etree(element, name_='paymentMethod', mapping_=mapping_)
        if self.permittedTerminals is not None:
            permittedTerminals_ = self.permittedTerminals
            etree_.SubElement(element, '{}permittedTerminals').text = self.gds_format_string(permittedTerminals_)
        if self.requestType is not None:
            requestType_ = self.requestType
            etree_.SubElement(element, '{}requestType').text = self.gds_format_string(requestType_)
        if self.taxes is not None:
            taxes_ = self.taxes
            taxes_.to_etree(element, name_='taxes', mapping_=mapping_)
        if self.tip is not None:
            tip_ = self.tip
            tip_.to_etree(element, name_='tip', mapping_=mapping_)
        if self.transactionType is not None:
            transactionType_ = self.transactionType
            etree_.SubElement(element, '{}transactionType').text = self.gds_format_string(transactionType_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='sale'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(sale, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sale, self).exportLiteralChildren(outfile, level, name_)
        if self.avs is not None:
            showIndent(outfile, level)
            outfile.write('avs=model_.avs(\n')
            self.avs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bypassSurcharge is not None:
            showIndent(outfile, level)
            outfile.write('bypassSurcharge=%s,\n' % self.bypassSurcharge)
        if self.cardEntryMode is not None:
            showIndent(outfile, level)
            outfile.write('cardEntryMode=%s,\n' % self.gds_encode(quote_python(self.cardEntryMode)))
        if self.currencyRate is not None:
            showIndent(outfile, level)
            outfile.write('currencyRate=model_.currencyRate(\n')
            self.currencyRate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.customFields is not None:
            showIndent(outfile, level)
            outfile.write('customFields=model_.customFieldsType1(\n')
            self.customFields.exportLiteral(outfile, level, name_='customFields')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.debitAccountType is not None:
            showIndent(outfile, level)
            outfile.write('debitAccountType=%s,\n' % self.gds_encode(quote_python(self.debitAccountType)))
        if self.device is not None:
            showIndent(outfile, level)
            outfile.write('device=model_.posDevice(\n')
            self.device.exportLiteral(outfile, level, name_='device')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deviceType is not None:
            showIndent(outfile, level)
            outfile.write('deviceType=%s,\n' % self.gds_encode(quote_python(self.deviceType)))
        if self.downgradeType is not None:
            showIndent(outfile, level)
            outfile.write('downgradeType=%s,\n' % self.gds_encode(quote_python(self.downgradeType)))
        if self.merchantReference is not None:
            showIndent(outfile, level)
            outfile.write('merchantReference=%s,\n' % self.gds_encode(quote_python(self.merchantReference)))
        if self.orderId is not None:
            showIndent(outfile, level)
            outfile.write('orderId=%s,\n' % self.gds_encode(quote_python(self.orderId)))
        if self.paymentMethod is not None:
            showIndent(outfile, level)
            outfile.write('paymentMethod=model_.paymentMethod(\n')
            self.paymentMethod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.permittedTerminals is not None:
            showIndent(outfile, level)
            outfile.write('permittedTerminals=%s,\n' % self.gds_encode(quote_python(self.permittedTerminals)))
        if self.requestType is not None:
            showIndent(outfile, level)
            outfile.write('requestType=%s,\n' % self.gds_encode(quote_python(self.requestType)))
        if self.taxes is not None:
            showIndent(outfile, level)
            outfile.write('taxes=model_.taxesType(\n')
            self.taxes.exportLiteral(outfile, level, name_='taxes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tip is not None:
            showIndent(outfile, level)
            outfile.write('tip=model_.tip(\n')
            self.tip.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.transactionType is not None:
            showIndent(outfile, level)
            outfile.write('transactionType=%s,\n' % self.gds_encode(quote_python(self.transactionType)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(sale, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'avs':
            obj_ = avs.factory()
            obj_.build(child_)
            self.avs = obj_
            obj_.original_tagname_ = 'avs'
        elif nodeName_ == 'bypassSurcharge':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'bypassSurcharge')
            self.bypassSurcharge = ival_
        elif nodeName_ == 'cardEntryMode':
            cardEntryMode_ = child_.text
            cardEntryMode_ = self.gds_validate_string(cardEntryMode_, node, 'cardEntryMode')
            self.cardEntryMode = cardEntryMode_
            # validate type cardEntryMode
            self.validate_cardEntryMode(self.cardEntryMode)
        elif nodeName_ == 'currencyRate':
            obj_ = currencyRate.factory()
            obj_.build(child_)
            self.currencyRate = obj_
            obj_.original_tagname_ = 'currencyRate'
        elif nodeName_ == 'customFields':
            obj_ = customFieldsType1.factory()
            obj_.build(child_)
            self.customFields = obj_
            obj_.original_tagname_ = 'customFields'
        elif nodeName_ == 'debitAccountType':
            debitAccountType_ = child_.text
            debitAccountType_ = self.gds_validate_string(debitAccountType_, node, 'debitAccountType')
            self.debitAccountType = debitAccountType_
            # validate type debitAccountType
            self.validate_debitAccountType(self.debitAccountType)
        elif nodeName_ == 'device':
            obj_ = posDevice.factory()
            obj_.build(child_)
            self.device = obj_
            obj_.original_tagname_ = 'device'
        elif nodeName_ == 'deviceType':
            deviceType_ = child_.text
            deviceType_ = self.gds_validate_string(deviceType_, node, 'deviceType')
            self.deviceType = deviceType_
        elif nodeName_ == 'downgradeType':
            downgradeType_ = child_.text
            downgradeType_ = self.gds_validate_string(downgradeType_, node, 'downgradeType')
            self.downgradeType = downgradeType_
            # validate type cardEntryMode
            self.validate_cardEntryMode(self.downgradeType)
        elif nodeName_ == 'merchantReference':
            merchantReference_ = child_.text
            merchantReference_ = self.gds_validate_string(merchantReference_, node, 'merchantReference')
            self.merchantReference = merchantReference_
        elif nodeName_ == 'orderId':
            orderId_ = child_.text
            orderId_ = self.gds_validate_string(orderId_, node, 'orderId')
            self.orderId = orderId_
        elif nodeName_ == 'paymentMethod':
            obj_ = paymentMethod.factory()
            obj_.build(child_)
            self.paymentMethod = obj_
            obj_.original_tagname_ = 'paymentMethod'
        elif nodeName_ == 'permittedTerminals':
            permittedTerminals_ = child_.text
            permittedTerminals_ = self.gds_validate_string(permittedTerminals_, node, 'permittedTerminals')
            self.permittedTerminals = permittedTerminals_
        elif nodeName_ == 'requestType':
            requestType_ = child_.text
            requestType_ = self.gds_validate_string(requestType_, node, 'requestType')
            self.requestType = requestType_
            # validate type saleRequestType
            self.validate_saleRequestType(self.requestType)
        elif nodeName_ == 'taxes':
            obj_ = taxesType.factory()
            obj_.build(child_)
            self.taxes = obj_
            obj_.original_tagname_ = 'taxes'
        elif nodeName_ == 'tip':
            class_obj_ = self.get_class_obj_(child_, tip)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.tip = obj_
            obj_.original_tagname_ = 'tip'
        elif nodeName_ == 'transactionType':
            transactionType_ = child_.text
            transactionType_ = self.gds_validate_string(transactionType_, node, 'transactionType')
            self.transactionType = transactionType_
            # validate type transactionType
            self.validate_transactionType(self.transactionType)
        super(sale, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = []
        if self.bypassSurcharge is not None:
            hash_list.append(str(self.bypassSurcharge).lower())
        if self.avs:
            hash_list.append(self.avs.hash_string)
        if self.cardEntryMode:
            hash_list.append(self.cardEntryMode)
        if self.device:
            hash_list.append(self.device.hash_string)
        if self.currencyRate:
            hash_list.append(self.currencyRate)
        if self.deviceType:
            hash_list.append(self.deviceType)
        hash_list.append(self.orderId)
        hash_list.append(self.paymentMethod.hash_string)
        if self.customFields:
            hash_list.append(self.customFields.hash_string)
        if self.taxes:
            hash_list.append(self.taxes.hash_string)
        if self.tip:
            hash_list.append(self.tip.hash_string)
        if self.requestType:
            hash_list.append(self.requestType)
        if self.transactionType:
            hash_list.append(self.transactionType)
        hash_list.append(self.account.hash_string)
        hash_list.append(self.amount.hash_string)
        if self.autoReady:
            hash_list.append(self.autoReady)
        if self.commerceType:
            hash_list.append(self.commerceType)
        if self.customer:
            hash_list.append(self.customer.hash_string)
        hash_list.append(str(self.dateTime.isoformat('T', 'seconds')))
        return ':'.join(hash_list)
# end class sale


class configurationRequest(standardRequest):
    member_data_items_ = [
        MemberSpec_('deviceType', 'xs:string', 0, 1, {'name': 'deviceType', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = standardRequest
    def __init__(self, dateTime=None, hash=None, account=None, apiKey=None, deviceType=None):
        self.original_tagname_ = None
        super(configurationRequest, self).__init__(dateTime, hash, account, apiKey, )
        self.deviceType = deviceType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, configurationRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if configurationRequest.subclass:
            return configurationRequest.subclass(*args_, **kwargs_)
        else:
            return configurationRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deviceType(self): return self.deviceType
    def set_deviceType(self, deviceType): self.deviceType = deviceType
    def hasContent_(self):
        if (
            self.deviceType is not None or
            super(configurationRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='configurationRequest', mapping_=None):
        element = super(configurationRequest, self).to_etree(parent_element, name_, mapping_)
        if self.deviceType is not None:
            deviceType_ = self.deviceType
            etree_.SubElement(element, '{}deviceType').text = self.gds_format_string(deviceType_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='configurationRequest'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(configurationRequest, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(configurationRequest, self).exportLiteralChildren(outfile, level, name_)
        if self.deviceType is not None:
            showIndent(outfile, level)
            outfile.write('deviceType=%s,\n' % self.gds_encode(quote_python(self.deviceType)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(configurationRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deviceType':
            deviceType_ = child_.text
            deviceType_ = self.gds_validate_string(deviceType_, node, 'deviceType')
            self.deviceType = deviceType_
        super(configurationRequest, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = [self.account.hash_string, self.apiKey, str(self.dateTime.isoformat('T'))]
        return ':'.join(hash_list)
# end class configurationRequest


class keyedCard(cardDetails):
    member_data_items_ = [
        MemberSpec_('cvv', 'xs:string', 0, 1, {'name': 'cvv', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = cardDetails
    def __init__(self, cardAccount=None, cardHolderName=None, cardNumber=None, cardType=None, expiryDate=None, pinDetails=None, cvv=None):
        self.original_tagname_ = None
        super(keyedCard, self).__init__(cardAccount, cardHolderName, cardNumber, cardType, expiryDate, pinDetails, )
        self.cvv = cvv
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, keyedCard)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if keyedCard.subclass:
            return keyedCard.subclass(*args_, **kwargs_)
        else:
            return keyedCard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cvv(self): return self.cvv
    def set_cvv(self, cvv): self.cvv = cvv
    def hasContent_(self):
        if (
            self.cvv is not None or
            super(keyedCard, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='keyedCard', mapping_=None):
        element = super(keyedCard, self).to_etree(parent_element, name_, mapping_)
        if self.cvv is not None:
            cvv_ = self.cvv
            etree_.SubElement(element, '{}cvv').text = self.gds_format_string(cvv_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='keyedCard'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(keyedCard, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(keyedCard, self).exportLiteralChildren(outfile, level, name_)
        if self.cvv is not None:
            showIndent(outfile, level)
            outfile.write('cvv=%s,\n' % self.gds_encode(quote_python(self.cvv)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(keyedCard, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cvv':
            cvv_ = child_.text
            cvv_ = self.gds_validate_string(cvv_, node, 'cvv')
            self.cvv = cvv_
        super(keyedCard, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        hash_list = []
        if self.cvv:
            hash_list.append(self.cvv)
        if self.cardAccount:
            hash_list.append(self.cardAccount)
        if self.cardHolderName:
            hash_list.append(self.cardHolderName)
        hash_list.append(self.cardNumber)
        if self.cardType:
            hash_list.append(self.cardType)
        if self.expiryDate:
            hash_list.append(self.expiryDate)
        if self.pinDetails:
            hash_list.append(self.pinDetails.hash_string)
        return ':'.join(hash_list)
# end class keyedCard


class authToken(standardKey):
    member_data_items_ = [
    ]
    subclass = None
    superclass = standardKey
    def __init__(self, key=None, validUntil=None):
        self.original_tagname_ = None
        super(authToken, self).__init__(key, validUntil, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, authToken)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if authToken.subclass:
            return authToken.subclass(*args_, **kwargs_)
        else:
            return authToken(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(authToken, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='authToken', mapping_=None):
        element = super(authToken, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='authToken'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(authToken, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(authToken, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(authToken, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(authToken, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class authToken


class tokenMethod(baseMethod):
    member_data_items_ = [
        MemberSpec_('keyedSecureCard', 'keyedSecureCard', 0, 0, {'name': 'keyedSecureCard', 'type': 'keyedSecureCard'}, 1),
        MemberSpec_('keyedAsTrack2', 'keyedAsTrackData', 0, 0, {'name': 'keyedAsTrack2', 'type': 'keyedAsTrackData'}, 1),
        MemberSpec_('keyedEncrypted', 'keyedEncrypted', 0, 0, {'name': 'keyedEncrypted', 'type': 'keyedEncrypted'}, 1),
        MemberSpec_('trackSecureCard', 'trackData', 0, 0, {'name': 'trackSecureCard', 'type': 'trackData'}, 1),
        MemberSpec_('emvSecureCard', 'emv', 0, 0, {'name': 'emvSecureCard', 'type': 'emv'}, 1),
        MemberSpec_('emvTlvSecureCard', 'emvtlv', 0, 0, {'name': 'emvTlvSecureCard', 'type': 'emvtlv'}, 1),
    ]
    subclass = None
    superclass = baseMethod
    def __init__(self, keyedSecureCard=None, keyedAsTrack2=None, keyedEncrypted=None, trackSecureCard=None, emvSecureCard=None, emvTlvSecureCard=None):
        self.original_tagname_ = None
        super(tokenMethod, self).__init__()
        self.keyedSecureCard = keyedSecureCard
        self.keyedAsTrack2 = keyedAsTrack2
        self.keyedEncrypted = keyedEncrypted
        self.trackSecureCard = trackSecureCard
        self.emvSecureCard = emvSecureCard
        self.emvTlvSecureCard = emvTlvSecureCard
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tokenMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tokenMethod.subclass:
            return tokenMethod.subclass(*args_, **kwargs_)
        else:
            return tokenMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_keyedSecureCard(self): return self.keyedSecureCard
    def set_keyedSecureCard(self, keyedSecureCard): self.keyedSecureCard = keyedSecureCard
    def get_keyedAsTrack2(self): return self.keyedAsTrack2
    def set_keyedAsTrack2(self, keyedAsTrack2): self.keyedAsTrack2 = keyedAsTrack2
    def get_keyedEncrypted(self): return self.keyedEncrypted
    def set_keyedEncrypted(self, keyedEncrypted): self.keyedEncrypted = keyedEncrypted
    def get_trackSecureCard(self): return self.trackSecureCard
    def set_trackSecureCard(self, trackSecureCard): self.trackSecureCard = trackSecureCard
    def get_emvSecureCard(self): return self.emvSecureCard
    def set_emvSecureCard(self, emvSecureCard): self.emvSecureCard = emvSecureCard
    def get_emvTlvSecureCard(self): return self.emvTlvSecureCard
    def set_emvTlvSecureCard(self, emvTlvSecureCard): self.emvTlvSecureCard = emvTlvSecureCard
    def hasContent_(self):
        if (
            self.keyedSecureCard is not None or
            self.keyedAsTrack2 is not None or
            self.keyedEncrypted is not None or
            self.trackSecureCard is not None or
            self.emvSecureCard is not None or
            self.emvTlvSecureCard is not None or
            super(tokenMethod, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='tokenMethod', mapping_=None):
        element = super(tokenMethod, self).to_etree(parent_element, name_, mapping_)
        if self.keyedSecureCard is not None:
            keyedSecureCard_ = self.keyedSecureCard
            keyedSecureCard_.to_etree(element, name_='keyedSecureCard', mapping_=mapping_)
        if self.keyedAsTrack2 is not None:
            keyedAsTrack2_ = self.keyedAsTrack2
            keyedAsTrack2_.to_etree(element, name_='keyedAsTrack2', mapping_=mapping_)
        if self.keyedEncrypted is not None:
            keyedEncrypted_ = self.keyedEncrypted
            keyedEncrypted_.to_etree(element, name_='keyedEncrypted', mapping_=mapping_)
        if self.trackSecureCard is not None:
            trackSecureCard_ = self.trackSecureCard
            trackSecureCard_.to_etree(element, name_='trackSecureCard', mapping_=mapping_)
        if self.emvSecureCard is not None:
            emvSecureCard_ = self.emvSecureCard
            emvSecureCard_.to_etree(element, name_='emvSecureCard', mapping_=mapping_)
        if self.emvTlvSecureCard is not None:
            emvTlvSecureCard_ = self.emvTlvSecureCard
            emvTlvSecureCard_.to_etree(element, name_='emvTlvSecureCard', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='tokenMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(tokenMethod, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(tokenMethod, self).exportLiteralChildren(outfile, level, name_)
        if self.keyedSecureCard is not None:
            showIndent(outfile, level)
            outfile.write('keyedSecureCard=model_.keyedSecureCard(\n')
            self.keyedSecureCard.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.keyedAsTrack2 is not None:
            showIndent(outfile, level)
            outfile.write('keyedAsTrack2=model_.keyedAsTrackData(\n')
            self.keyedAsTrack2.exportLiteral(outfile, level, name_='keyedAsTrack2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.keyedEncrypted is not None:
            showIndent(outfile, level)
            outfile.write('keyedEncrypted=model_.keyedEncrypted(\n')
            self.keyedEncrypted.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.trackSecureCard is not None:
            showIndent(outfile, level)
            outfile.write('trackSecureCard=model_.trackData(\n')
            self.trackSecureCard.exportLiteral(outfile, level, name_='trackSecureCard')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.emvSecureCard is not None:
            showIndent(outfile, level)
            outfile.write('emvSecureCard=model_.emv(\n')
            self.emvSecureCard.exportLiteral(outfile, level, name_='emvSecureCard')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.emvTlvSecureCard is not None:
            showIndent(outfile, level)
            outfile.write('emvTlvSecureCard=model_.emvtlv(\n')
            self.emvTlvSecureCard.exportLiteral(outfile, level, name_='emvTlvSecureCard')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tokenMethod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'keyedSecureCard':
            obj_ = keyedSecureCard.factory()
            obj_.build(child_)
            self.keyedSecureCard = obj_
            obj_.original_tagname_ = 'keyedSecureCard'
        elif nodeName_ == 'keyedAsTrack2':
            obj_ = keyedAsTrackData.factory()
            obj_.build(child_)
            self.keyedAsTrack2 = obj_
            obj_.original_tagname_ = 'keyedAsTrack2'
        elif nodeName_ == 'keyedEncrypted':
            obj_ = keyedEncrypted.factory()
            obj_.build(child_)
            self.keyedEncrypted = obj_
            obj_.original_tagname_ = 'keyedEncrypted'
        elif nodeName_ == 'trackSecureCard':
            class_obj_ = self.get_class_obj_(child_, trackData)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.trackSecureCard = obj_
            obj_.original_tagname_ = 'trackSecureCard'
        elif nodeName_ == 'emvSecureCard':
            obj_ = emv.factory()
            obj_.build(child_)
            self.emvSecureCard = obj_
            obj_.original_tagname_ = 'emvSecureCard'
        elif nodeName_ == 'emvTlvSecureCard':
            obj_ = emvtlv.factory()
            obj_.build(child_)
            self.emvTlvSecureCard = obj_
            obj_.original_tagname_ = 'emvTlvSecureCard'
        super(tokenMethod, self).buildChildren(child_, node, nodeName_, True)

    @property
    def hash_string(self):
        if self.keyedSecureCard:
            return self.keyedSecureCard.hash_string
        if self.keyedAsTrack2:
            return self.keyedAsTrack2.hash_string
# end class tokenMethod


class response(protectedMethod):
    member_data_items_ = [
        MemberSpec_('code', 'xs:string', 0, 0, {'name': 'code', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 0, {'name': 'description', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = protectedMethod
    def __init__(self, dateTime=None, hash=None, code=None, description=None, extensiontype_=None):
        self.original_tagname_ = None
        super(response, self).__init__(dateTime, hash, extensiontype_, )
        self.code = code
        self.description = description
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if response.subclass:
            return response.subclass(*args_, **kwargs_)
        else:
            return response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.code is not None or
            self.description is not None or
            super(response, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='response', mapping_=None):
        element = super(response, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.code is not None:
            code_ = self.code
            etree_.SubElement(element, '{}code').text = self.gds_format_string(code_)
        if self.description is not None:
            description_ = self.description
            etree_.SubElement(element, '{}description').text = self.gds_format_string(description_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='response'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(response, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(response, self).exportLiteralChildren(outfile, level, name_)
        if self.code is not None:
            showIndent(outfile, level)
            outfile.write('code=%s,\n' % self.gds_encode(quote_python(self.code)))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % self.gds_encode(quote_python(self.description)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(response, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            code_ = child_.text
            code_ = self.gds_validate_string(code_, node, 'code')
            self.code = code_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        super(response, self).buildChildren(child_, node, nodeName_, True)
# end class response


class secureCardRestResponse(response):
    member_data_items_ = [
        MemberSpec_('secureCard', 'secureCard', 0, 1, {'name': 'secureCard', 'type': 'secureCard', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = response
    def __init__(self, dateTime=None, hash=None, code=None, description=None, secureCard=None):
        self.original_tagname_ = None
        super(secureCardRestResponse, self).__init__(dateTime, hash, code, description, )
        self.secureCard = secureCard
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, secureCardRestResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if secureCardRestResponse.subclass:
            return secureCardRestResponse.subclass(*args_, **kwargs_)
        else:
            return secureCardRestResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_secureCard(self): return self.secureCard
    def set_secureCard(self, secureCard): self.secureCard = secureCard
    def hasContent_(self):
        if (
            self.secureCard is not None or
            super(secureCardRestResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='secureCardRestResponse', mapping_=None):
        element = super(secureCardRestResponse, self).to_etree(parent_element, name_, mapping_)
        if self.secureCard is not None:
            secureCard_ = self.secureCard
            secureCard_.to_etree(element, name_='secureCard', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='secureCardRestResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(secureCardRestResponse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(secureCardRestResponse, self).exportLiteralChildren(outfile, level, name_)
        if self.secureCard is not None:
            showIndent(outfile, level)
            outfile.write('secureCard=model_.secureCard(\n')
            self.secureCard.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(secureCardRestResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'secureCard':
            obj_ = secureCard.factory()
            obj_.build(child_)
            self.secureCard = obj_
            obj_.original_tagname_ = 'secureCard'
        super(secureCardRestResponse, self).buildChildren(child_, node, nodeName_, True)
# end class secureCardRestResponse


class secureCardRegisterRestResponse(response):
    member_data_items_ = [
        MemberSpec_('cardReference', 'xs:string', 0, 1, {'name': 'cardReference', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('merchantRef', 'xs:string', 0, 1, {'name': 'merchantRef', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = response
    def __init__(self, dateTime=None, hash=None, code=None, description=None, cardReference=None, merchantRef=None):
        self.original_tagname_ = None
        super(secureCardRegisterRestResponse, self).__init__(dateTime, hash, code, description, )
        self.cardReference = cardReference
        self.merchantRef = merchantRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, secureCardRegisterRestResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if secureCardRegisterRestResponse.subclass:
            return secureCardRegisterRestResponse.subclass(*args_, **kwargs_)
        else:
            return secureCardRegisterRestResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cardReference(self): return self.cardReference
    def set_cardReference(self, cardReference): self.cardReference = cardReference
    def get_merchantRef(self): return self.merchantRef
    def set_merchantRef(self, merchantRef): self.merchantRef = merchantRef
    def hasContent_(self):
        if (
            self.cardReference is not None or
            self.merchantRef is not None or
            super(secureCardRegisterRestResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='secureCardRegisterRestResponse', mapping_=None):
        element = super(secureCardRegisterRestResponse, self).to_etree(parent_element, name_, mapping_)
        if self.cardReference is not None:
            cardReference_ = self.cardReference
            etree_.SubElement(element, '{}cardReference').text = self.gds_format_string(cardReference_)
        if self.merchantRef is not None:
            merchantRef_ = self.merchantRef
            etree_.SubElement(element, '{}merchantRef').text = self.gds_format_string(merchantRef_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='secureCardRegisterRestResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(secureCardRegisterRestResponse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(secureCardRegisterRestResponse, self).exportLiteralChildren(outfile, level, name_)
        if self.cardReference is not None:
            showIndent(outfile, level)
            outfile.write('cardReference=%s,\n' % self.gds_encode(quote_python(self.cardReference)))
        if self.merchantRef is not None:
            showIndent(outfile, level)
            outfile.write('merchantRef=%s,\n' % self.gds_encode(quote_python(self.merchantRef)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(secureCardRegisterRestResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cardReference':
            cardReference_ = child_.text
            cardReference_ = self.gds_validate_string(cardReference_, node, 'cardReference')
            self.cardReference = cardReference_
        elif nodeName_ == 'merchantRef':
            merchantRef_ = child_.text
            merchantRef_ = self.gds_validate_string(merchantRef_, node, 'merchantRef')
            self.merchantRef = merchantRef_
        super(secureCardRegisterRestResponse, self).buildChildren(child_, node, nodeName_, True)
# end class secureCardRegisterRestResponse


class secureCardRemoveRestResponse(response):
    member_data_items_ = [
    ]
    subclass = None
    superclass = response
    def __init__(self, dateTime=None, hash=None, code=None, description=None):
        self.original_tagname_ = None
        super(secureCardRemoveRestResponse, self).__init__(dateTime, hash, code, description, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, secureCardRemoveRestResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if secureCardRemoveRestResponse.subclass:
            return secureCardRemoveRestResponse.subclass(*args_, **kwargs_)
        else:
            return secureCardRemoveRestResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(secureCardRemoveRestResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='secureCardRemoveRestResponse', mapping_=None):
        element = super(secureCardRemoveRestResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='secureCardRemoveRestResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(secureCardRemoveRestResponse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(secureCardRemoveRestResponse, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(secureCardRemoveRestResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(secureCardRemoveRestResponse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class secureCardRemoveRestResponse


class balanceInquiryResponse(response):
    member_data_items_ = [
        MemberSpec_('availableBalanceList', 'availableBalanceListType2', 0, 1, {'name': 'availableBalanceList', 'minOccurs': '0', 'type': 'availableBalanceListType2'}, None),
        MemberSpec_('balanceAmount', 'xs:decimal', 0, 1, {'name': 'balanceAmount', 'type': 'xs:decimal', 'minOccurs': '0'}, None),
        MemberSpec_('bankResponseCode', 'xs:string', 0, 1, {'name': 'bankResponseCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('bankResponseText', 'xs:string', 0, 1, {'name': 'bankResponseText', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('currency', ['currency', 'xs:string'], 0, 1, {'name': 'currency', 'type': 'xs:string', 'minOccurs': '0'}, None),
    ]
    subclass = None
    superclass = response
    def __init__(self, dateTime=None, hash=None, code=None, description=None, availableBalanceList=None, balanceAmount=None, bankResponseCode=None, bankResponseText=None, currency=None):
        self.original_tagname_ = None
        super(balanceInquiryResponse, self).__init__(dateTime, hash, code, description, )
        self.availableBalanceList = availableBalanceList
        self.balanceAmount = balanceAmount
        self.bankResponseCode = bankResponseCode
        self.bankResponseText = bankResponseText
        self.currency = currency
        self.validate_currency(self.currency)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, balanceInquiryResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if balanceInquiryResponse.subclass:
            return balanceInquiryResponse.subclass(*args_, **kwargs_)
        else:
            return balanceInquiryResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_availableBalanceList(self): return self.availableBalanceList
    def set_availableBalanceList(self, availableBalanceList): self.availableBalanceList = availableBalanceList
    def get_balanceAmount(self): return self.balanceAmount
    def set_balanceAmount(self, balanceAmount): self.balanceAmount = balanceAmount
    def get_bankResponseCode(self): return self.bankResponseCode
    def set_bankResponseCode(self, bankResponseCode): self.bankResponseCode = bankResponseCode
    def get_bankResponseText(self): return self.bankResponseText
    def set_bankResponseText(self, bankResponseText): self.bankResponseText = bankResponseText
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def validate_currency(self, value):
        # Validate type currency, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYR', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LTL', 'LVL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRO', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLL', 'SOS', 'SRD', 'SSP', 'STD', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'USS', 'UYI', 'UYU', 'UZS', 'VEF', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XCD', 'XOF', 'XPF', 'YER', 'ZAR', 'ZMW', 'ZWL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on currency' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.availableBalanceList is not None or
            self.balanceAmount is not None or
            self.bankResponseCode is not None or
            self.bankResponseText is not None or
            self.currency is not None or
            super(balanceInquiryResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='balanceInquiryResponse', mapping_=None):
        element = super(balanceInquiryResponse, self).to_etree(parent_element, name_, mapping_)
        if self.availableBalanceList is not None:
            availableBalanceList_ = self.availableBalanceList
            availableBalanceList_.to_etree(element, name_='availableBalanceList', mapping_=mapping_)
        if self.balanceAmount is not None:
            balanceAmount_ = self.balanceAmount
            etree_.SubElement(element, '{}balanceAmount').text = self.gds_format_float(balanceAmount_)
        if self.bankResponseCode is not None:
            bankResponseCode_ = self.bankResponseCode
            etree_.SubElement(element, '{}bankResponseCode').text = self.gds_format_string(bankResponseCode_)
        if self.bankResponseText is not None:
            bankResponseText_ = self.bankResponseText
            etree_.SubElement(element, '{}bankResponseText').text = self.gds_format_string(bankResponseText_)
        if self.currency is not None:
            currency_ = self.currency
            etree_.SubElement(element, '{}currency').text = self.gds_format_string(currency_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='balanceInquiryResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(balanceInquiryResponse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(balanceInquiryResponse, self).exportLiteralChildren(outfile, level, name_)
        if self.availableBalanceList is not None:
            showIndent(outfile, level)
            outfile.write('availableBalanceList=model_.availableBalanceListType2(\n')
            self.availableBalanceList.exportLiteral(outfile, level, name_='availableBalanceList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.balanceAmount is not None:
            showIndent(outfile, level)
            outfile.write('balanceAmount=%f,\n' % self.balanceAmount)
        if self.bankResponseCode is not None:
            showIndent(outfile, level)
            outfile.write('bankResponseCode=%s,\n' % self.gds_encode(quote_python(self.bankResponseCode)))
        if self.bankResponseText is not None:
            showIndent(outfile, level)
            outfile.write('bankResponseText=%s,\n' % self.gds_encode(quote_python(self.bankResponseText)))
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=%s,\n' % self.gds_encode(quote_python(self.currency)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(balanceInquiryResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'availableBalanceList':
            obj_ = availableBalanceListType2.factory()
            obj_.build(child_)
            self.availableBalanceList = obj_
            obj_.original_tagname_ = 'availableBalanceList'
        elif nodeName_ == 'balanceAmount' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'balanceAmount')
            self.balanceAmount = fval_
        elif nodeName_ == 'bankResponseCode':
            bankResponseCode_ = child_.text
            bankResponseCode_ = self.gds_validate_string(bankResponseCode_, node, 'bankResponseCode')
            self.bankResponseCode = bankResponseCode_
        elif nodeName_ == 'bankResponseText':
            bankResponseText_ = child_.text
            bankResponseText_ = self.gds_validate_string(bankResponseText_, node, 'bankResponseText')
            self.bankResponseText = bankResponseText_
        elif nodeName_ == 'currency':
            currency_ = child_.text
            currency_ = self.gds_validate_string(currency_, node, 'currency')
            self.currency = currency_
            # validate type currency
            self.validate_currency(self.currency)
        super(balanceInquiryResponse, self).buildChildren(child_, node, nodeName_, True)
# end class balanceInquiryResponse


class transactionResponse(response):
    member_data_items_ = [
        MemberSpec_('aVSResponseCode', ['avsResponseCode', 'xs:string'], 0, 1, {'name': 'aVSResponseCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('additionalFields', 'additionalFieldsType', 0, 1, {'name': 'additionalFields', 'minOccurs': '0', 'type': 'additionalFieldsType'}, None),
        MemberSpec_('approvalCode', 'xs:string', 0, 1, {'name': 'approvalCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('authorizedAmount', 'xs:decimal', 0, 1, {'name': 'authorizedAmount', 'type': 'xs:decimal', 'minOccurs': '0'}, None),
        MemberSpec_('availableBalanceList', 'availableBalanceListType', 0, 1, {'name': 'availableBalanceList', 'minOccurs': '0', 'type': 'availableBalanceListType'}, None),
        MemberSpec_('bankResponseCode', 'xs:string', 0, 1, {'name': 'bankResponseCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('bankResponseText', 'xs:string', 0, 1, {'name': 'bankResponseText', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cVVResponseCode', ['cvvResponseCode', 'xs:string'], 0, 1, {'name': 'cVVResponseCode', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('cashBackAmount', 'xs:decimal', 0, 1, {'name': 'cashBackAmount', 'type': 'xs:decimal', 'minOccurs': '0'}, None),
        MemberSpec_('currency', ['currency', 'xs:string'], 0, 1, {'name': 'currency', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('emvTags', 'emvTag', 1, 1, {'name': 'emvTags', 'type': 'emvTag', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('receiptFields', 'receiptFieldsVO', 0, 1, {'name': 'receiptFields', 'type': 'receiptFieldsVO', 'minOccurs': '0'}, None),
        MemberSpec_('requestType', ['saleRequestType', 'xs:string'], 0, 1, {'name': 'requestType', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('secureCardMerchantRef', 'xs:string', 0, 1, {'name': 'secureCardMerchantRef', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('secureCardReference', 'xs:string', 0, 1, {'name': 'secureCardReference', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('surcharge', 'transactionSurcharge', 0, 1, {'name': 'surcharge', 'type': 'transactionSurcharge', 'minOccurs': '0'}, None),
        MemberSpec_('taxes', 'tax', 1, 0, {'name': 'taxes', 'type': 'tax', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('tip', 'tip', 0, 1, {'name': 'tip', 'type': 'tip', 'minOccurs': '0'}, None),
        MemberSpec_('transactionStatus', ['transactionStatus', 'xs:string'], 0, 1, {'name': 'transactionStatus', 'type': 'xs:string', 'minOccurs': '0'}, None),
        MemberSpec_('uniqueRef', 'xs:string', 0, 0, {'name': 'uniqueRef', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = response
    def __init__(self, dateTime=None, hash=None, code=None, description=None, aVSResponseCode=None, additionalFields=None, approvalCode=None, authorizedAmount=None, availableBalanceList=None, bankResponseCode=None, bankResponseText=None, cVVResponseCode=None, cashBackAmount=None, currency=None, emvTags=None, receiptFields=None, requestType=None, secureCardMerchantRef=None, secureCardReference=None, surcharge=None, taxes=None, tip=None, transactionStatus=None, uniqueRef=None):
        self.original_tagname_ = None
        super(transactionResponse, self).__init__(dateTime, hash, code, description, )
        self.aVSResponseCode = aVSResponseCode
        self.validate_avsResponseCode(self.aVSResponseCode)
        self.additionalFields = additionalFields
        self.approvalCode = approvalCode
        self.authorizedAmount = authorizedAmount
        self.availableBalanceList = availableBalanceList
        self.bankResponseCode = bankResponseCode
        self.bankResponseText = bankResponseText
        self.cVVResponseCode = cVVResponseCode
        self.validate_cvvResponseCode(self.cVVResponseCode)
        self.cashBackAmount = cashBackAmount
        self.currency = currency
        self.validate_currency(self.currency)
        if emvTags is None:
            self.emvTags = []
        else:
            self.emvTags = emvTags
        self.receiptFields = receiptFields
        self.requestType = requestType
        self.validate_saleRequestType(self.requestType)
        self.secureCardMerchantRef = secureCardMerchantRef
        self.secureCardReference = secureCardReference
        self.surcharge = surcharge
        if taxes is None:
            self.taxes = []
        else:
            self.taxes = taxes
        self.tip = tip
        self.transactionStatus = transactionStatus
        self.validate_transactionStatus(self.transactionStatus)
        self.uniqueRef = uniqueRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transactionResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transactionResponse.subclass:
            return transactionResponse.subclass(*args_, **kwargs_)
        else:
            return transactionResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aVSResponseCode(self): return self.aVSResponseCode
    def set_aVSResponseCode(self, aVSResponseCode): self.aVSResponseCode = aVSResponseCode
    def get_additionalFields(self): return self.additionalFields
    def set_additionalFields(self, additionalFields): self.additionalFields = additionalFields
    def get_approvalCode(self): return self.approvalCode
    def set_approvalCode(self, approvalCode): self.approvalCode = approvalCode
    def get_authorizedAmount(self): return self.authorizedAmount
    def set_authorizedAmount(self, authorizedAmount): self.authorizedAmount = authorizedAmount
    def get_availableBalanceList(self): return self.availableBalanceList
    def set_availableBalanceList(self, availableBalanceList): self.availableBalanceList = availableBalanceList
    def get_bankResponseCode(self): return self.bankResponseCode
    def set_bankResponseCode(self, bankResponseCode): self.bankResponseCode = bankResponseCode
    def get_bankResponseText(self): return self.bankResponseText
    def set_bankResponseText(self, bankResponseText): self.bankResponseText = bankResponseText
    def get_cVVResponseCode(self): return self.cVVResponseCode
    def set_cVVResponseCode(self, cVVResponseCode): self.cVVResponseCode = cVVResponseCode
    def get_cashBackAmount(self): return self.cashBackAmount
    def set_cashBackAmount(self, cashBackAmount): self.cashBackAmount = cashBackAmount
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_emvTags(self): return self.emvTags
    def set_emvTags(self, emvTags): self.emvTags = emvTags
    def add_emvTags(self, value): self.emvTags.append(value)
    def insert_emvTags_at(self, index, value): self.emvTags.insert(index, value)
    def replace_emvTags_at(self, index, value): self.emvTags[index] = value
    def get_receiptFields(self): return self.receiptFields
    def set_receiptFields(self, receiptFields): self.receiptFields = receiptFields
    def get_requestType(self): return self.requestType
    def set_requestType(self, requestType): self.requestType = requestType
    def get_secureCardMerchantRef(self): return self.secureCardMerchantRef
    def set_secureCardMerchantRef(self, secureCardMerchantRef): self.secureCardMerchantRef = secureCardMerchantRef
    def get_secureCardReference(self): return self.secureCardReference
    def set_secureCardReference(self, secureCardReference): self.secureCardReference = secureCardReference
    def get_surcharge(self): return self.surcharge
    def set_surcharge(self, surcharge): self.surcharge = surcharge
    def get_taxes(self): return self.taxes
    def set_taxes(self, taxes): self.taxes = taxes
    def add_taxes(self, value): self.taxes.append(value)
    def insert_taxes_at(self, index, value): self.taxes.insert(index, value)
    def replace_taxes_at(self, index, value): self.taxes[index] = value
    def get_tip(self): return self.tip
    def set_tip(self, tip): self.tip = tip
    def get_transactionStatus(self): return self.transactionStatus
    def set_transactionStatus(self, transactionStatus): self.transactionStatus = transactionStatus
    def get_uniqueRef(self): return self.uniqueRef
    def set_uniqueRef(self, uniqueRef): self.uniqueRef = uniqueRef
    def validate_avsResponseCode(self, value):
        # Validate type avsResponseCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A', 'F', 'G', 'N', 'R', 'S', 'U', 'W', 'X', 'Y', 'Z']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on avsResponseCode' % {"value" : value.encode("utf-8")} )
    def validate_cvvResponseCode(self, value):
        # Validate type cvvResponseCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['M', 'N', 'P', 'U']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cvvResponseCode' % {"value" : value.encode("utf-8")} )
    def validate_currency(self, value):
        # Validate type currency, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYR', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LTL', 'LVL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRO', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLL', 'SOS', 'SRD', 'SSP', 'STD', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'USS', 'UYI', 'UYU', 'UZS', 'VEF', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XCD', 'XOF', 'XPF', 'YER', 'ZAR', 'ZMW', 'ZWL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on currency' % {"value" : value.encode("utf-8")} )
    def validate_saleRequestType(self, value):
        # Validate type saleRequestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PURCHASE', 'CASH_WITHDRAWAL', 'SALE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on saleRequestType' % {"value" : value.encode("utf-8")} )
    def validate_transactionStatus(self, value):
        # Validate type transactionStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PENDING', 'READY', 'VOID', 'DECLINED', 'COMPLETE', 'REFERRAL', 'REVERSAL', 'ACCEPTED', 'OTHER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on transactionStatus' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.aVSResponseCode is not None or
            self.additionalFields is not None or
            self.approvalCode is not None or
            self.authorizedAmount is not None or
            self.availableBalanceList is not None or
            self.bankResponseCode is not None or
            self.bankResponseText is not None or
            self.cVVResponseCode is not None or
            self.cashBackAmount is not None or
            self.currency is not None or
            self.emvTags or
            self.receiptFields is not None or
            self.requestType is not None or
            self.secureCardMerchantRef is not None or
            self.secureCardReference is not None or
            self.surcharge is not None or
            self.taxes or
            self.tip is not None or
            self.transactionStatus is not None or
            self.uniqueRef is not None or
            super(transactionResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='transactionResponse', mapping_=None):
        element = super(transactionResponse, self).to_etree(parent_element, name_, mapping_)
        if self.aVSResponseCode is not None:
            aVSResponseCode_ = self.aVSResponseCode
            etree_.SubElement(element, '{}aVSResponseCode').text = self.gds_format_string(aVSResponseCode_)
        if self.additionalFields is not None:
            additionalFields_ = self.additionalFields
            additionalFields_.to_etree(element, name_='additionalFields', mapping_=mapping_)
        if self.approvalCode is not None:
            approvalCode_ = self.approvalCode
            etree_.SubElement(element, '{}approvalCode').text = self.gds_format_string(approvalCode_)
        if self.authorizedAmount is not None:
            authorizedAmount_ = self.authorizedAmount
            etree_.SubElement(element, '{}authorizedAmount').text = self.gds_format_float(authorizedAmount_)
        if self.availableBalanceList is not None:
            availableBalanceList_ = self.availableBalanceList
            availableBalanceList_.to_etree(element, name_='availableBalanceList', mapping_=mapping_)
        if self.bankResponseCode is not None:
            bankResponseCode_ = self.bankResponseCode
            etree_.SubElement(element, '{}bankResponseCode').text = self.gds_format_string(bankResponseCode_)
        if self.bankResponseText is not None:
            bankResponseText_ = self.bankResponseText
            etree_.SubElement(element, '{}bankResponseText').text = self.gds_format_string(bankResponseText_)
        if self.cVVResponseCode is not None:
            cVVResponseCode_ = self.cVVResponseCode
            etree_.SubElement(element, '{}cVVResponseCode').text = self.gds_format_string(cVVResponseCode_)
        if self.cashBackAmount is not None:
            cashBackAmount_ = self.cashBackAmount
            etree_.SubElement(element, '{}cashBackAmount').text = self.gds_format_float(cashBackAmount_)
        if self.currency is not None:
            currency_ = self.currency
            etree_.SubElement(element, '{}currency').text = self.gds_format_string(currency_)
        for emvTags_ in self.emvTags:
            emvTags_.to_etree(element, name_='emvTags', mapping_=mapping_)
        if self.receiptFields is not None:
            receiptFields_ = self.receiptFields
            receiptFields_.to_etree(element, name_='receiptFields', mapping_=mapping_)
        if self.requestType is not None:
            requestType_ = self.requestType
            etree_.SubElement(element, '{}requestType').text = self.gds_format_string(requestType_)
        if self.secureCardMerchantRef is not None:
            secureCardMerchantRef_ = self.secureCardMerchantRef
            etree_.SubElement(element, '{}secureCardMerchantRef').text = self.gds_format_string(secureCardMerchantRef_)
        if self.secureCardReference is not None:
            secureCardReference_ = self.secureCardReference
            etree_.SubElement(element, '{}secureCardReference').text = self.gds_format_string(secureCardReference_)
        if self.surcharge is not None:
            surcharge_ = self.surcharge
            surcharge_.to_etree(element, name_='surcharge', mapping_=mapping_)
        for taxes_ in self.taxes:
            taxes_.to_etree(element, name_='taxes', mapping_=mapping_)
        if self.tip is not None:
            tip_ = self.tip
            tip_.to_etree(element, name_='tip', mapping_=mapping_)
        if self.transactionStatus is not None:
            transactionStatus_ = self.transactionStatus
            etree_.SubElement(element, '{}transactionStatus').text = self.gds_format_string(transactionStatus_)
        if self.uniqueRef is not None:
            uniqueRef_ = self.uniqueRef
            etree_.SubElement(element, '{}uniqueRef').text = self.gds_format_string(uniqueRef_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='transactionResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(transactionResponse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(transactionResponse, self).exportLiteralChildren(outfile, level, name_)
        if self.aVSResponseCode is not None:
            showIndent(outfile, level)
            outfile.write('aVSResponseCode=%s,\n' % self.gds_encode(quote_python(self.aVSResponseCode)))
        if self.additionalFields is not None:
            showIndent(outfile, level)
            outfile.write('additionalFields=model_.additionalFieldsType(\n')
            self.additionalFields.exportLiteral(outfile, level, name_='additionalFields')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.approvalCode is not None:
            showIndent(outfile, level)
            outfile.write('approvalCode=%s,\n' % self.gds_encode(quote_python(self.approvalCode)))
        if self.authorizedAmount is not None:
            showIndent(outfile, level)
            outfile.write('authorizedAmount=%f,\n' % self.authorizedAmount)
        if self.availableBalanceList is not None:
            showIndent(outfile, level)
            outfile.write('availableBalanceList=model_.availableBalanceListType(\n')
            self.availableBalanceList.exportLiteral(outfile, level, name_='availableBalanceList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bankResponseCode is not None:
            showIndent(outfile, level)
            outfile.write('bankResponseCode=%s,\n' % self.gds_encode(quote_python(self.bankResponseCode)))
        if self.bankResponseText is not None:
            showIndent(outfile, level)
            outfile.write('bankResponseText=%s,\n' % self.gds_encode(quote_python(self.bankResponseText)))
        if self.cVVResponseCode is not None:
            showIndent(outfile, level)
            outfile.write('cVVResponseCode=%s,\n' % self.gds_encode(quote_python(self.cVVResponseCode)))
        if self.cashBackAmount is not None:
            showIndent(outfile, level)
            outfile.write('cashBackAmount=%f,\n' % self.cashBackAmount)
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=%s,\n' % self.gds_encode(quote_python(self.currency)))
        showIndent(outfile, level)
        outfile.write('emvTags=[\n')
        level += 1
        for emvTags_ in self.emvTags:
            showIndent(outfile, level)
            outfile.write('model_.emvTag(\n')
            emvTags_.exportLiteral(outfile, level, name_='emvTag')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.receiptFields is not None:
            showIndent(outfile, level)
            outfile.write('receiptFields=model_.receiptFieldsVO(\n')
            self.receiptFields.exportLiteral(outfile, level, name_='receiptFields')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.requestType is not None:
            showIndent(outfile, level)
            outfile.write('requestType=%s,\n' % self.gds_encode(quote_python(self.requestType)))
        if self.secureCardMerchantRef is not None:
            showIndent(outfile, level)
            outfile.write('secureCardMerchantRef=%s,\n' % self.gds_encode(quote_python(self.secureCardMerchantRef)))
        if self.secureCardReference is not None:
            showIndent(outfile, level)
            outfile.write('secureCardReference=%s,\n' % self.gds_encode(quote_python(self.secureCardReference)))
        if self.surcharge is not None:
            showIndent(outfile, level)
            outfile.write('surcharge=model_.transactionSurcharge(\n')
            self.surcharge.exportLiteral(outfile, level, name_='surcharge')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('taxes=[\n')
        level += 1
        for taxes_ in self.taxes:
            showIndent(outfile, level)
            outfile.write('model_.tax(\n')
            taxes_.exportLiteral(outfile, level, name_='tax')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.tip is not None:
            showIndent(outfile, level)
            outfile.write('tip=model_.tip(\n')
            self.tip.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.transactionStatus is not None:
            showIndent(outfile, level)
            outfile.write('transactionStatus=%s,\n' % self.gds_encode(quote_python(self.transactionStatus)))
        if self.uniqueRef is not None:
            showIndent(outfile, level)
            outfile.write('uniqueRef=%s,\n' % self.gds_encode(quote_python(self.uniqueRef)))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(transactionResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'aVSResponseCode':
            aVSResponseCode_ = child_.text
            aVSResponseCode_ = self.gds_validate_string(aVSResponseCode_, node, 'aVSResponseCode')
            self.aVSResponseCode = aVSResponseCode_
            # validate type avsResponseCode
            self.validate_avsResponseCode(self.aVSResponseCode)
        elif nodeName_ == 'additionalFields':
            obj_ = additionalFieldsType.factory()
            obj_.build(child_)
            self.additionalFields = obj_
            obj_.original_tagname_ = 'additionalFields'
        elif nodeName_ == 'approvalCode':
            approvalCode_ = child_.text
            approvalCode_ = self.gds_validate_string(approvalCode_, node, 'approvalCode')
            self.approvalCode = approvalCode_
        elif nodeName_ == 'authorizedAmount' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'authorizedAmount')
            self.authorizedAmount = fval_
        elif nodeName_ == 'availableBalanceList':
            obj_ = availableBalanceListType.factory()
            obj_.build(child_)
            self.availableBalanceList = obj_
            obj_.original_tagname_ = 'availableBalanceList'
        elif nodeName_ == 'bankResponseCode':
            bankResponseCode_ = child_.text
            bankResponseCode_ = self.gds_validate_string(bankResponseCode_, node, 'bankResponseCode')
            self.bankResponseCode = bankResponseCode_
        elif nodeName_ == 'bankResponseText':
            bankResponseText_ = child_.text
            bankResponseText_ = self.gds_validate_string(bankResponseText_, node, 'bankResponseText')
            self.bankResponseText = bankResponseText_
        elif nodeName_ == 'cVVResponseCode':
            cVVResponseCode_ = child_.text
            cVVResponseCode_ = self.gds_validate_string(cVVResponseCode_, node, 'cVVResponseCode')
            self.cVVResponseCode = cVVResponseCode_
            # validate type cvvResponseCode
            self.validate_cvvResponseCode(self.cVVResponseCode)
        elif nodeName_ == 'cashBackAmount' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'cashBackAmount')
            self.cashBackAmount = fval_
        elif nodeName_ == 'currency':
            currency_ = child_.text
            currency_ = self.gds_validate_string(currency_, node, 'currency')
            self.currency = currency_
            # validate type currency
            self.validate_currency(self.currency)
        elif nodeName_ == 'emvTags':
            obj_ = emvTag.factory()
            obj_.build(child_)
            self.emvTags.append(obj_)
            obj_.original_tagname_ = 'emvTags'
        elif nodeName_ == 'receiptFields':
            obj_ = receiptFieldsVO.factory()
            obj_.build(child_)
            self.receiptFields = obj_
            obj_.original_tagname_ = 'receiptFields'
        elif nodeName_ == 'requestType':
            requestType_ = child_.text
            requestType_ = self.gds_validate_string(requestType_, node, 'requestType')
            self.requestType = requestType_
            # validate type saleRequestType
            self.validate_saleRequestType(self.requestType)
        elif nodeName_ == 'secureCardMerchantRef':
            secureCardMerchantRef_ = child_.text
            secureCardMerchantRef_ = self.gds_validate_string(secureCardMerchantRef_, node, 'secureCardMerchantRef')
            self.secureCardMerchantRef = secureCardMerchantRef_
        elif nodeName_ == 'secureCardReference':
            secureCardReference_ = child_.text
            secureCardReference_ = self.gds_validate_string(secureCardReference_, node, 'secureCardReference')
            self.secureCardReference = secureCardReference_
        elif nodeName_ == 'surcharge':
            obj_ = transactionSurcharge.factory()
            obj_.build(child_)
            self.surcharge = obj_
            obj_.original_tagname_ = 'surcharge'
        elif nodeName_ == 'taxes':
            obj_ = tax.factory()
            obj_.build(child_)
            self.taxes.append(obj_)
            obj_.original_tagname_ = 'taxes'
        elif nodeName_ == 'tip':
            class_obj_ = self.get_class_obj_(child_, tip)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.tip = obj_
            obj_.original_tagname_ = 'tip'
        elif nodeName_ == 'transactionStatus':
            transactionStatus_ = child_.text
            transactionStatus_ = self.gds_validate_string(transactionStatus_, node, 'transactionStatus')
            self.transactionStatus = transactionStatus_
            # validate type transactionStatus
            self.validate_transactionStatus(self.transactionStatus)
        elif nodeName_ == 'uniqueRef':
            uniqueRef_ = child_.text
            uniqueRef_ = self.gds_validate_string(uniqueRef_, node, 'uniqueRef')
            self.uniqueRef = uniqueRef_
        super(transactionResponse, self).buildChildren(child_, node, nodeName_, True)
# end class transactionResponse


GDSClassesMapping = {
    'AuthToken': authToken,
    'AuthTokenRequest': authTokenRequest,
    'AuthenticationRequest': authenticationRequest,
    'AuthenticationRequestKey': authenticationRequestKey,
    'BalanceInquiry': balanceInquiry,
    'BalanceInquiryResponse': balanceInquiryResponse,
    'CardAccountSummary': cardAccountSummary,
    'CardTypeInfo': cardTypeInfo,
    'CardTypeInfoRequest': cardTypeInfoRequest,
    'CloseBatchRequest': closeBatchRequest,
    'CloseBatchResponse': closeBatchResponse,
    'ConfigurationRequest': configurationRequest,
    'CustomField': customField,
    'EMVTag': emvTag,
    'PayconexTransactionData': payconexTransactionData,
    'Refund': refund,
    'Response': response,
    'Reversal': reversal,
    'Sale': sale,
    'SecureCard': secureCard,
    'SecureCardRegisterResponse': secureCardRegisterRestResponse,
    'SecureCardRemoveResponse': secureCardRemoveRestResponse,
    'SecureCardResponse': secureCardRestResponse,
    'ServiceError': serviceError,
    'TerminalAPIKey': terminalAPIKey,
    'TerminalConfiguration': terminalConfiguration,
    'TerminalTax': terminalTax,
    'TerminalTip': terminalTip,
    'TerminalUpdate': terminalUpdate,
    'TerminalUpdateResponse': terminalUpdateResponse,
    'Tip': tip,
    'TransactionList': transactionList,
    'TransactionReport': transactionReport,
    'TransactionResponse': transactionResponse,
    'TransactionUpdate': transactionUpdate,
    'ValidationError': validationError,
    'application': application,
    'caCertificate': caCertificate,
    'paymentTypeTerminalConfiguration': paymentTypeTerminalConfiguration,
    'referenced': refundReferenced,
    'tipAdjustment': tipAdjustment,
    'unreferenced': refundUnreferenced,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'authToken'
        rootClass = authToken
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'authToken'
        rootClass = authToken
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'authToken'
        rootClass = authToken
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'authToken'
        rootClass = authToken
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from rest import *\n\n')
        sys.stdout.write('import rest as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "account",
    "accountBalance",
    "additionalField",
    "additionalFieldsType",
    "amount",
    "androidWallet",
    "appleWallet",
    "application",
    "applicationsType",
    "authToken",
    "authTokenRequest",
    "authenticationRequest",
    "authenticationRequestKey",
    "availableBalanceListType",
    "availableBalanceListType2",
    "avs",
    "balanceInquiry",
    "balanceInquiryResponse",
    "baseMethod",
    "caCertificate",
    "caCertificatesType",
    "cardAccountSummary",
    "cardAccountSummaryListType",
    "cardDetails",
    "cardTypeInfo",
    "cardTypeInfoRequest",
    "cardTypeMethod",
    "clearCard",
    "closeBatchRequest",
    "closeBatchResponse",
    "configurationRequest",
    "currenciesType",
    "currencyRate",
    "customField",
    "customFieldsType",
    "customFieldsType1",
    "customer",
    "customerDetails",
    "customerSignature",
    "dukptPinDetails",
    "emv",
    "emvTag",
    "emvTagReceiptFieldsVO",
    "emvTagsType",
    "emvtlv",
    "hash",
    "keyedAsTrackData",
    "keyedCard",
    "keyedEncrypted",
    "keyedSecureCard",
    "merchantDetails",
    "payconexTransactionData",
    "paymentMethod",
    "paymentTypeTerminalConfiguration",
    "pinDetails",
    "posDevice",
    "protectedMethod",
    "receiptFieldsVO",
    "refund",
    "refundBaseMethod",
    "refundMethod",
    "refundReferenced",
    "refundUnreferenced",
    "response",
    "reversal",
    "revokedCaCertificatesType",
    "sale",
    "secureCard",
    "secureCardMethod",
    "secureCardRegisterRestResponse",
    "secureCardRemoveRestResponse",
    "secureCardRestResponse",
    "serviceError",
    "settingCreateType",
    "settingCreateType3",
    "settingDeleteType",
    "settingDeleteType4",
    "settingUpdateType",
    "settingUpdateType5",
    "standardKey",
    "standardRequest",
    "tax",
    "taxUId",
    "taxesType",
    "terminalAPIKey",
    "terminalConfiguration",
    "terminalTax",
    "terminalTaxesType",
    "terminalTip",
    "terminalTipsType",
    "terminalUpdate",
    "terminalUpdateResponse",
    "tip",
    "tipAdjustment",
    "tipUId",
    "tokenMethod",
    "trackData",
    "trackDataContactless",
    "transaction",
    "transactionList",
    "transactionReport",
    "transactionResponse",
    "transactionSummary",
    "transactionSurcharge",
    "transactionUpdate",
    "validationError",
    "validationErrorsType",
    "voucher"
]
